/******************************************************************************
* Copyright (C) 2021-2022, Advanced Micro Devices, Inc. All rights reserved.
*******************************************************************************/

/*! @file libflame_interface.hh
 *  libflame_interface.hh defines all the Libflame CPP templated public
 *  interfaces.
 *  */
#ifndef LIBFLAME_INTERFACE_HH
#define LIBFLAME_INTERFACE_HH

#include "libflame.hh"

namespace libflame {

/*! @brief Cholesky factorization of a real symmetric positive definite matrix a
    *
    * @details
    * \b Purpose:
    * \verbatim
        Cholesky factorization of a real symmetric positive definite matrix a.
        The factorization has the form
            A = U**T * U,  if uplo = 'U', or
            A = L * L**T,  if uplo = 'L',
        where U is an upper triangular matrix and L is lower triangular.

        This is the block version of the algorithm, calling Level 3 BLAS.
    \endverbatim

    * @param[in] uplo
              uplo is char*. \n
              uplo specifies output format \n
              = 'U': Output is upper triangular factorization of A \n
              = 'L': Output is lower triangular factorization of A \n
    * @param[in] n
              n is int*. \n
              The order of the matrix a. n >= 0 \n
    * @param[in,out] a
              a is REAL/DOUBLE PRECISION/COMPLEX/COMPLEX*16 array, dimension (lda,n). \n
              On entry, the symmetric matrix a.  If uplo = 'U', the leading 
              n-by-n upper triangular part of a contains the upper
              triangular part of the matrix a, and the strictly lower
              triangular part of a is not referenced.  If uplo = 'L', the
              leading n-by-n lower triangular part of a contains the lower
              triangular part of the matrix a, and the strictly upper
              triangular part of a is not referenced. \n
              On exit, if info = 0, the factor U or L from the Cholesky
              factorization A = U**T*U or A = L*L**T. \n
    * @param[in] lda
              lda is int*. \n
              The leading dimension of the matrix a, lda >= max(1,n) \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit \n
              < 0:  if INFO = -i, the i-th argument had an illegal value \n
              > 0:  if INFO = i, the leading minor of order i is not
                    positive definite, and the factorization could not be
                    completed. \n

    * @return INTEGER Return value of the function.
    *  */
template<typename T>
integer potrf(char* uplo, integer* n, T* a, integer* lda, integer* info)
{
  return potrf(uplo, n, a, lda, info);
}

/*! @brief Cholesky factorization of a real symmetric
    *         positive definite matrix a
    *
    * @details
    * \b Purpose:
    * \verbatim
        Cholesky factorization of a real symmetric positive definite matrix a
        The factorization has the form
            A = U**T * U,  if uplo = 'U', or
            A = L * L**T,  if uplo = 'L',
        where U is an upper triangular matrix and L is lower triangular.

        This is the unblocked version of the algorithm, calling Level 2 BLAS.
    \endverbatim

    * @param[in] uplo
              uplo is char* \n
              uplo specifies output format \n
              = 'U': Output is upper triangular factorization of A \n
              = 'L': Output is lower triangular factorization of A \n
    * @param[in] n
              n is integer* \n
              The order of the matrix a. n >= 0 \n
    * @param[in,out] a
              a is REAL/DOUBLE PRECISION/COMPLEX/COMPLEX*16 array, dimension (lda,n) \n
              On entry, the symmetric matrix a.  If uplo = 'U', the leading
              n-by-n upper triangular part of a contains the upper
              triangular part of the matrix a, and the strictly lower
              triangular part of a is not referenced.  If uplo = 'L', the
              leading n-by-n lower triangular part of a contains the lower
              triangular part of the matrix a, and the strictly upper
              triangular part of a is not referenced. \n
              On exit, if info = 0, the factor U or L from the Cholesky
              factorization A = U**T *U  or A = L*L**T. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the matrix a, lda >= max(1,n) \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0: successful exit \n
              < 0: if INFO = -k, the k-th argument had an illegal value \n
              > 0: if INFO = k, the leading minor of order k is not
                   positive definite, and the factorization could not be
                   completed. \n

    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer potf2(char* uplo, integer* n, T* a, integer* lda, integer* info)
{
  return potf2(uplo, n, a, lda, info);
}

/*! @brief LU factorization of a general m-by-n matrix a
    *   using partial pivoting with row interchanges.
    *
    *  @details
    * \b Purpose:
    * \verbatim
        LU factorization of a general m-by-n matrix a using partial pivoting with row interchanges.
        The factorization has the form
            A = P * L * U
        where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower
        trapezoidal if M >  , and U is upper triangular (upper trapezoidal if M < N).

        This is the right-looking Level 3 BLAS version of the algorithm.
    \endverbatim

    * @param[in] m
              m is integer* \n
              The number of rows of the matrix a.  m >= 0. \n
    * @param[in] n
              n is integer* \n
              The number of columns of the matrix a.  n >= 0. \n
    * @param[in,out] a
              a is REAL/DOUBLE PRECISION/COMPLEX/COMPLEX*16 array, dimension (lda,n) \n
              On entry, the m-by-n matrix to be factored. \n
              On exit, the factors L and U from the factorization
              A = P*L*U; the unit diagonal elements of L are not stored. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the matrix a, lda >= max(1,m) \n
    * @param[out] ipiv
              ipiv is integer array, dimension (min(m,n)) \n
              The pivot indices; for 1 <= i <= min(m,n), row i of the
              matrix was interchanged with row ipiv(i). \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit \n
              < 0:  if INFO = -i, the i-th argument had an illegal value \n
              > 0:  if INFO = i, U(i,i) is exactly zero. The factorization
                    has been completed, but the factor U is exactly
                    singular, and division by zero will occur if it is used
                    to solve a system of equations. \n

    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer getrf(integer* m, integer* n, T* a, integer* lda, integer* ipiv, integer* info)
{
  return getrf(m, n, a, lda, ipiv, info);
}

/*! @brief LU factorization of a general m-by-n matrix a
    *   using partial pivoting with row interchanges.
    *
    * @details
    * \b Purpose:
    * \verbatim
        LU factorization of a general m-by-n matrix a using partial pivoting with row interchanges.
        The factorization has the form
            A = P * L * U
        where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower
        trapezoidal if M > N), and U is upper triangular (upper trapezoidal if M < N).

        This is the right-looking Level 2 BLAS version of the algorithm.
    \endverbatim

    * @param[in] m
              m is integer* \n
              The number of rows of the matrix a.  m >= 0. \n
    * @param[in] n
              n is integer* \n
              The number of columns of the matrix a.  n >= 0. \n
    * @param[in,out] a
              a is REAL/DOUBLE PRECISION/COMPLEX/COMPLEX*16 array, dimension (lda,n) \n
              On entry, the m-by-n matrix to be factored. \n
              On exit, the factors L and U from the factorization
              A = P*L*U; the unit diagonal elements of L are not stored. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the matrix a, lda >= max(1,m) \n
    * @param[out] ipiv
              ipiv is integer array, dimension (min(m,n)) \n
              ipiv is integer array, dimension (min(m,n)) \n
              The pivot indices; for 1 <= i <= min(m,n), row i of the
              matrix was interchanged with row ipiv(i). \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit \n
              < 0:  if INFO = -i, the i-th argument had an illegal value \n
              > 0:  if INFO = i, U(i,i) is exactly zero. The factorization
                    has been completed, but the factor U is exactly
                    singular, and division by zero will occur if it is used
                    to solve a system of equations. \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer getf2(integer* m, integer* n, T* a, integer* lda, integer* ipiv, integer* info)
{
  return getf2(m, n, a, lda, ipiv, info);
}

/*! @brief QR factorization of a real m-by-n matrix a
    *
    * @details
    * \b Purpose:
    * \verbatim
        QR factorization of a real m-by-n matrix a
        The factorization has the form
            A = Q * R
    \endverbatim

    * @param[in] m
              m is integer* \n
              The number of rows of the matrix a.  m >= 0. \n
    * @param[in] n
              n is integer* \n
              The number of columns of the matrix a.  n >= 0. \n
    * @param[in,out] a
              a is float/double/COMPLEX/COMPLEX*16 array, dimension (lda,n) \n
              On entry, the m-by-n matrix to be factored. \n
              On exit, the elements on and above the diagonal of the array
              contain the min(m,n)-by-n upper trapezoidal matrix R (R is
              upper triangular if m >= n); the elements below the diagonal,
              with the array tau, represent the orthogonal matrix Q as a
              product of min(m,n) elementary reflectors (see Further
              Details). \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the matrix a, lda >= max(1,m) \n
    * @param[out] tau
              tau is float/double/COMPLEX/COMPLEX*16 array, dimension (min(m,n)) \n
              The scalar factors of the elementary reflectors (see Further
              Details). \n
              *
              * \n
              * **Further Details**
              * \verbatim
                      The matrix Q is represented as a product of elementary reflectors
                      Q = H(1) H(2) . . . H(k), where k = min(m,n).

                      Each H(i) has the form
                      H(i) = I - tau * V * V**T

                      where, tau is a real scalar, and V is a real vector with V(1:i-1) = 0 and V(i) = 1;
                      V(i+1:M) is stored on exit in A(i+1:M,i), and tau in tau(i).
              \endverbatim
    * @param[out]	WORK	
              WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
              On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
    * @param[in]	LWORK	
              LWORK is INTEGER \n
              The dimension of the array WORK.  LWORK >= max(1,N).
              For optimum performance LWORK >= N*NB, where NB is
              the optimal blocksize. \n

              If LWORK = -1, then a workspace query is assumed; the routine
              only calculates the optimal size of the WORK array, returns
              this value as the first entry of the WORK array, and no error
              message related to LWORK is issued by XERBLA. \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit \n
              < 0:  if INFO = -i, the i-th argument had an illegal value \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer geqrf(integer* m, integer* n, T* a, integer* lda, T* tau, T* work, integer* lwork, integer* info)
{
  return geqrf(m, n, a, lda, tau, work, lwork, info);
}

/*! @brief QR factorization of a real m-by-n matrix a
    *
    * @details
    * \b Purpose:
    * \verbatim
        QR factorization of a real m-by-n matrix a
        The factorization has the form
            A = Q * R
    \endverbatim

    * @param[in] m
              m is integer* \n
              The number of rows of the matrix a.  m >= 0. \n
    * @param[in] n
              n is integer* \n
              The number of columns of the matrix a.  n >= 0. \n
    * @param[in,out] a
              a is float/double/COMPLEX/COMPLEX*16 array, dimension (lda,n) \n
              On entry, the m-by-n matrix to be factored. \n
              On exit, the elements on and above the diagonal of the array
              contain the min(m,n)-by-n upper trapezoidal matrix R (R is
              upper triangular if m >= n); the elements below the diagonal,
              with the array tau, represent the orthogonal matrix Q as a
              product of elementary reflectors (see Further Details). \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the matrix a, lda >= max(1,m) \n
    * @param[out] tau
              tau is float/double/COMPLEX/COMPLEX*16 array, dimension (min(m,n)) \n
              The scalar factors of the elementary reflectors (see Further
              Details). \n
              *
              * \n
              * **Further Details**
              * \verbatim
                      The matrix Q is represented as a product of elementary reflectors
                      Q = H(1) H(2) . . . H(k), where k = min(m,n).

                      Each H(i) has the form
                      H(i) = I - tau * V * V**T

                      where, tau is a real scalar, and V is a real vector with V(1:i-1) = 0 and V(i) = 1;
                      V(i+1:M) is stored on exit in A(i+1:M,i), and tau in tau(i).
              \endverbatim
    * @param[out]	WORK	
              WORK is COMPLEX array, dimension (N) \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0: successful exit \n
              < 0: if INFO = -i, the i-th argument had an illegal value \n

    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer geqr2(integer* m, integer* n, T* a, integer* lda, T* tau, T* work, integer* info)
{
  return geqr2(m, n, a, lda, tau, work, info);
}

/*! @brief QR factorization of a real m-by-n matrix a
    *   This routine is deprecated and has been
    *   replaced by routine SGEQP3.
    *

    * @details
    * \b Purpose:
    * \verbatim
        QR factorization with column pivoting of a real m-by-n matrix a.
        This routine is deprecated and has been replaced by routine SGEQP3.
        The factorization has the form:
            A*P = Q*R.
    \endverbatim

    * @param[in] m
              m is integer* \n
              The number of rows of the matrix a.  m >= 0. \n
    * @param[in] n
              n is integer* \n
              The number of columns of the matrix a.  n >= 0. \n
    * @param[in,out] a
              a is float/double array, dimension (lda,n) \n
              On entry, the m-by-n matrix a. \n
              On exit, the upper triangle of the array contains the
              min(m,n)-by-n upper triangular matrix R; the elements
              below the diagonal, together with the array tau,
              represent the orthogonal matrix Q as a product of
              min(m,n) elementary reflectors. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the matrix a, lda >= max(1,m) \n
    * @param[in,out] jpvt
              jpvt is integer array, dimension (n) \n
              On entry, if jpvt(i) .ne. 0, the i-th column of A is permuted
              to the front of A*P (a leading column); if jpvt(i) = 0,
              the i-th column of A is a free column. \n
              On exit, if jpvt(i) = k, then the i-th column of A*P
              was the k-th column of A. \n
    * @param[out] tau
              tau is float/double array, dimension (min(m,n)) \n
              The scalar factors of the elementary reflectors.
              *
              * \n
              * **Further Details**
              * \verbatim
                      The matrix Q is represented as a product of elementary reflectors

                      Q = H(1) H(2) . . . H(n)

                      Each H(i) has the form

                      H = I - tau * V * V**T

                      where tau is a real scalar, and V is a real vector with V(1:i-1) = 0 and V(i) = 1;
                      V(i+1:m) is stored on exit in A(i+1:m,i).

                      The matrix P is represented in jpvt as follows:
                      If jpvt(j) = i,
                      then the jth column of P is the ith canonical unit vector.

                      Partial column norm updating strategy modified by
                      Z. Drmac and Z. Bujanovic, Dept. of Mathematics,
                      University of Zagreb, Croatia.
                      -- April 2011 --
                      For more details see LAPACK Working Note 176.
              \endverbatim
    * @param[out]	WORK	
              WORK is COMPLEX array, dimension (N) \n
    * @param[out]	RWORK	
              RWORK is REAL array, dimension (2*N) \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit \n
              < 0:  if INFO = -i, the i-th argument had an illegal value \n
    
    * @return INTEGER Return value of the function.
    *  */
template<typename T>
integer geqpf(integer* m, integer* n, T* a, integer* lda, integer* jpvt, T* tau, T* work, integer* info)
{
  return geqpf(m, n, a, lda, jpvt, tau, work, info);
}

template<typename T, typename Ta>
integer geqpf(integer* m, integer* n, T* a, integer* lda, integer* jpvt, T* tau, T* work, Ta* rwork, integer* info)
{
  return geqpf(m, n, a, lda, jpvt, tau, work, rwork, info);
}

/*! @brief QR factorization of a real m-by-n matrix a
    *
    * @details
    * \b Purpose:
    * \verbatim
        QR factorization with column pivoting of a real m-by-n matrix a:
            A*P = Q*R
        using Level 3 BLAS.
    \endverbatim

    * @param[in] m
              m is integer* \n
              The number of rows of the matrix a.  m >= 0. \n
    * @param[in] n
              n is integer* \n
              The number of columns of the matrix a.  n >= 0. \n
    * @param[in,out] a
              a is float/double array, dimension (lda,n) \n
              On entry, the m-by-n matrix a. \n
              On exit, the upper triangle of the array contains the
              min(m,n)-by-n upper triangular matrix R; the elements
              below the diagonal, together with the array tau,
              represent the orthogonal matrix Q as a product of
              min(m,n) elementary reflectors. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the matrix a, lda >= max(1,m) \n
    * @param[in,out] jpvt
              jpvt is integer array, dimension (n) \n
              On entry, if jpvt(J).ne.0, the J-th column of A is permuted
              to the front of A*P (a leading column); if jpvt(J) = 0,
              the J-th column of A is a free column. \n
              On exit, if jpvt(J) = K, then the J-th column of A*P
              was the K-th column of A. \n
    * @param[out] tau
              tau is float/double array, dimension (min(m,n)) \n
              The scalar factors of the elementary reflectors.
              *
              * \n
              * **Further Details**
              * \verbatim
                      The matrix Q is represented as a product of elementary reflectors

                      Q = H(1) H(2) . . . H(k), where k = min(m,n).

                      Each H(i) has the form

                      H = I - tau * V * V**T

                      where tau is a real scalar, and V is a real/complex vector with V(1:i-1) = 0 and V(i) = 1;
                      V(i+1:M) is stored on exit in A(i+1:M,i), and tau in tau(i)
              \endverbatim
    * @param[out]	WORK	
              WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
              On exit, if INFO=0, WORK(1) returns the optimal LWORK. \n
    * @param[in]	LWORK	
              LWORK is INTEGER \n
              The dimension of the array WORK. LWORK >= N+1.
              For optimal performance LWORK >= ( N+1 )*NB, where NB
              is the optimal blocksize. \n
 \n
              If LWORK = -1, then a workspace query is assumed; the routine
              only calculates the optimal size of the WORK array, returns
              this value as the first entry of the WORK array, and no error
              message related to LWORK is issued by XERBLA. \n
    * @param[out]	RWORK	
              RWORK is REAL array, dimension (2*N) \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0: successful exit. \n
              < 0: if INFO = -i, the i-th argument had an illegal value. \n
    
    * @return INTEGER Return value of the function.
    *  */
template<typename T>
integer geqp3(integer* m, integer* n, T* a, integer* lda, integer* jpvt, T* tau, T* work, integer* lwork, integer* info)
{
  return geqp3(m, n, a, lda, jpvt, tau, work, lwork, info);
}
template<typename T, typename Ta>
integer geqp3(integer* m, integer* n, T* a, integer* lda, integer* jpvt, T* tau, T* work, integer* lwork, Ta* rwork, integer* info)
{
  return geqp3(m, n, a, lda, jpvt, tau, work, lwork, rwork, info);
}

/*! @brief LQ factorization of a real m-by-n matrix a
    *
    * @details
    * \b Purpose:
    * \verbatim
        LQ factorization of a real m-by-n matrix a
        The factorization has the form
            A = L * Q
    \endverbatim

    * @param[in] m
              m is integer* \n
              The number of rows of the matrix a.  m >= 0. \n
    * @param[in] n
              n is integer* \n
              The number of columns of the matrix a.  n >= 0. \n
    * @param[in,out] a
              a is float/double/COMPLEX/COMPLEX*16 array, dimension (lda,n) \n
              On entry, the m-by-n matrix. \n
              On exit, the elements on and below the diagonal of the array
              contain the m-by-min(m,n) lower trapezoidal matrix L (L is
              lower triangular if m <= n); the elements above the diagonal,
              with the array tau, represent the orthogonal matrix Q as a
              product of elementary reflectors (see Further Details). \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the matrix a, lda >= max(1,m) \n
    * @param[out] tau
              tau is float/double/COMPLEX/COMPLEX*16 array, dimension (min(m,n)) \n
              The scalar factors of the elementary reflectors (see Further Details).
              *
              * \n
              * **Further Details**
              * \verbatim
                      The matrix Q is represented as a product of elementary reflectors
                      Q = H(k) . . . H(2) H(1), where k = min(m,n).

                      Each H(i) has the form

                      H(i) = I - tau * V * V**T

                      where tau is a real scalar, and V is a real vector with V(1:i-1) = 0 and V(i) = 1;
                      V(i+1:N) is stored on exit in A(i,i+1:N), and tau in tau(i).
              \endverbatim
    * @param[out]	WORK	
              WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
              On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
    * @param[in]	LWORK	
              LWORK is INTEGER \n
              The dimension of the array WORK.  LWORK >= max(1,M).
              For optimum performance LWORK >= M*NB, where NB is the
              optimal blocksize. \n
 \n
              If LWORK = -1, then a workspace query is assumed; the routine
              only calculates the optimal size of the WORK array, returns
              this value as the first entry of the WORK array, and no error
              message related to LWORK is issued by XERBLA. \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit \n
              < 0:  if INFO = -i, the i-th argument had an illegal value \n
    
    * @return INTEGER Return value of the function.
    *  */
template<typename T>
integer gelqf(integer* m, integer* n, T* a, integer* lda, T* tau, T* work, integer* lwork, integer* info)
{
  return gelqf(m, n, a, lda, tau, work, lwork, info);
}

/*! @brief LQ factorization of a real m-by-n matrix a
    *
    * @details
    * \b Purpose:
    * \verbatim
        LQ factorization of a real m-by-n matrix a
        The factorization has the form
        A = Q * R
    \endverbatim

    * @param[in] m
              m is integer* \n
              The number of rows of the matrix a.  m >= 0. \n
    * @param[in] n
              n is integer* \n
              The number of columns of the matrix a.  n >= 0. \n
    * @param[in,out] a
              a is float/double/COMPLEX/COMPLEX*16 array, dimension (lda,n) \n
              On entry, the m-by-n matrix. \n
              On exit, the elements on and below the diagonal of the array
              contain the m by min(m,n) lower trapezoidal matrix L (L is
              lower triangular if m <= n); the elements above the diagonal,
              with the array tau, represent the orthogonal matrix Q as a
              product of elementary reflectors (see Further Details). \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the matrix a, lda >= max(1,m) \n
    * @param[out] tau
              tau is float/double/COMPLEX/COMPLEX*16 array, dimension (min(m,n)) \n
              The scalar factors of the elementary reflectors (see Further
              Details).
              *
              * \n
              * **Further Details**
              * \verbatim
                      The matrix Q is represented as a product of elementary reflectors
                      Q = H(k) . . . H(2) H(1), where k = min(m,n).

                      Each H(i) has the form
                      H(i) = I - tau * V * V**T

                      where tau is a real scalar, and V is a real vector with V(1:i-1) = 0 and V(i) = 1;
                      V(i+1:N) is stored on exit in A(i,i+1:N), and tau in tau(i).
              \endverbatim
    * @param[out]	WORK	
              WORK is COMPLEX array, dimension (M) \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0: successful exit \n
              < 0: if INFO = -i, the i-th argument had an illegal value \n

    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer gelq2(integer* m, integer* n, T* a, integer* lda, T* tau, T* work, integer* info)
{
  return gelq2(m, n, a, lda, tau, work, info);
}

/*! @brief The minimum-norm solution to a real linear least squares problem
    *
    * @details
    * \b Purpose:
    * \verbatim
        Computation of the minimum-norm solution to a real linear least squares problem:
        minimize 2-norm(| B - A*X |)
        using the singular value decomposition (SVD) of A. A is an m-by-n matrix which may be
        rank-deficient.

        Several right hand side vectors B and solution vectors X can be handled in a single call;
        they are stored as the columns of the m-by-nrhs  right hand side matrix b and the n-by-nrhs
        solution matrix X.

        The problem is solved in three steps:
        (1) Reduce the coefficient matrix a to bidiagonal form with Householder transformations,
        reducing the original problem into a "bidiagonal least squares problem" (BLS)
        (2) Solve the BLS using a divide and conquer approach.
        (3) Apply back all the Householder transformations to solve the original least squares
        problem.

        The effective rank of A is determined by treating as zero those singular values which are
        less than rcond times the largest singular value.

        The divide and conquer algorithm makes very mild assumptions about floating point
        arithmetic. It will work on machines with a guard digit in add/subtract, or on those
        binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP,
        Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without
        guard digits, but we know of none.
    \endverbatim

    * @param[in] m
              m is integer* \n
              The number of rows of the matrix a.  m >= 0. \n
    * @param[in] n
              n is integer* \n
              The number of columns of the matrix a.  n >= 0. \n
    * @param[in] nrhs
              nrhs is integer* \n
              The number of right hand sides, i.e., the number of columns
              of the matrices b and X. nrhs >= 0. \n
    * @param[in,out] a
              a is float/double array, dimension (lda,n) \n
              On entry, the m-by-n matrix. \n
              On exit, A has been destroyed. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the matrix a, lda >= max(1,m) \n
    * @param[in,out] b
              b is float/double array, dimension (ldb,nrhs) \n
              On entry, the m-by-n matrix. \n
              On exit, b is overwritten by the n-by-nrhs solution
              matrix X.  If m >= n and rank = n, the residual
              sum-of-squares for the solution in the i-th column is given
              by the sum of squares of elements n+1:m in that column. \n
    * @param[in] ldb
              ldb is integer* \n
              The leading dimension of the matrix b, ldb >= max(1,max(m,n)). \n
    * @param[out] s
              s is float/double array, dimension (min(m,n)) \n
              The singular values of A in decreasing order.
              The condition number of A in the 2-norm = S(1)/S(min(m,n)). \n
    * @param[in] rcond
              rcond is float/double* \n
              rcond is used to determine the effective rank of a.
              Singular values S(i) <= rcond*S(1) are treated as zero.
              If rcond < 0, machine precision is used instead. \n
    * @param[out] rank
              rank is integer* \n
              The effective rank of a, i.e., the number of singular values
              which are greater than rcond*S(1). \n
    * @param[out]	WORK	
              WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
              On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
    * @param[in]	LWORK	
              LWORK is INTEGER \n
              The dimension of the array WORK. LWORK must be at least 1. \n
              The exact minimum amount of workspace needed depends on M,
              N and NRHS. As long as LWORK is at least \n
                  2 * N + N * NRHS \n
              if M is greater than or equal to N or \n
                  2 * M + M * NRHS \n
              if M is less than N, the code will execute correctly. \n
              For good performance, LWORK should generally be larger. \n
 \n
              If LWORK = -1, then a workspace query is assumed; the routine
              only calculates the optimal size of the array WORK and the
              minimum sizes of the arrays RWORK and IWORK, and returns
              these values as the first entries of the WORK, RWORK and
              IWORK arrays, and no error message related to LWORK is issued
              by XERBLA. \n
    * @param[out]	RWORK	
              RWORK is REAL array, dimension (MAX(1,LRWORK)) \n
              LRWORK >= \n
                 10*N + 2*N*SMLSIZ + 8*N*NLVL + 3*SMLSIZ*NRHS + \n
                 MAX( (SMLSIZ+1)**2, N*(1+NRHS) + 2*NRHS ) \n
              if M is greater than or equal to N or \n
                 10*M + 2*M*SMLSIZ + 8*M*NLVL + 3*SMLSIZ*NRHS + \n
                 MAX( (SMLSIZ+1)**2, N*(1+NRHS) + 2*NRHS ) \n
              if M is less than N, the code will execute correctly. \n
              SMLSIZ is returned by ILAENV and is equal to the maximum
              size of the subproblems at the bottom of the computation
              tree (usually about 25), and
                 NLVL = MAX( 0, INT( LOG_2( MIN( M,N )/(SMLSIZ+1) ) ) + 1 ) \n
              On exit, if INFO = 0, RWORK(1) returns the minimum LRWORK. \n
    * @param[out]	IWORK	
              IWORK is INTEGER array, dimension (MAX(1,LIWORK)) \n
              LIWORK >= max(1, 3*MINMN*NLVL + 11*MINMN),
              where MINMN = MIN( M,N ). \n
              On exit, if INFO = 0, IWORK(1) returns the minimum LIWORK. \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0: successful exit \n
              < 0: if INFO = -i, the i-th argument had an illegal value. \n
              > 0:  the algorithm for computing the SVD failed to converge;
                    if INFO = i, i off-diagonal elements of an intermediate
                    bidiagonal form did not converge to zero. \n

    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer gelsd(integer* m, integer* n, integer* nrhs, T* a, integer* lda, T* b, integer* ldb, T* s, T* rcond, integer* rank, T* work, integer* lwork, integer* iwork, integer* info)
{
  return gelsd(m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lwork, iwork, info);
}
template< typename T, typename Ta >
integer gelsd(integer* m, integer* n, integer* nrhs, T* a, integer* lda, T* b, integer* ldb, Ta* s, Ta* rcond, integer* rank, T* work, integer* lwork, Ta* rwork, integer* iwork, integer* info)
{
  return gelsd(m,  n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lwork, rwork, iwork, info);
}

/*! @brief The minimum-norm solution to a real linear least squares problem
    *
    * @details
    * \b Purpose:
    * \verbatim
        Computation of the minimum-norm solution to a real linear least squares problem:
        minimize 2-norm(| B - A*X |)
        using the singular value decomposition (SVD) of A. A is an m-by-n matrix which may be
        rank-deficient.

        Several right hand side vectors B and solution vectors X can be handled in a single call;
        they are stored as the columns of the m-by-nrhs  right hand side matrix b and the n-by-nrhs
        solution matrix X.

        The effective rank of A is determined by treating as zero those singular values which are
        less than rcond times the largest singular value.
    \endverbatim

    * @param[in] m
              m is integer* \n
              The number of rows of the matrix a.  m >= 0. \n
    * @param[in] n
              n is integer* \n
              The number of columns of the matrix a.  n >= 0. \n
    * @param[in] nrhs
              nrhs is integer* \n
              The number of right hand sides, i.e., the number of columns
              of the matrices b and X. nrhs >= 0. \n
    * @param[in,out] a
              a is float/double array, dimension (lda,n) \n
              On entry, the m-by-n matrix. \n
              On exit, the first min(m,n) rows of A are overwritten with
              its right singular vectors, stored rowwise. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the matrix a, lda >= max(1,m) \n
    * @param[in,out] b
              b is float/double array, dimension (ldb,nrhs) \n
              On entry, the m-by-nrhs  right hand side matrix b. \n
              On exit, b is overwritten by the n-by-nrhs solution
              matrix X.  If m >= n and rank = n, the residual
              sum-of-squares for the solution in the i-th column is given
              by the sum of squares of elements n+1:m in that column. \n
    * @param[in] ldb
              ldb is integer* \n
              The leading dimension of the matrix b, ldb >= max(1,max(m,n)). \n
    * @param[out] s
              s is float/double array, dimension (min(m,n)) \n
              The singular values of A in decreasing order.
              The condition number of A in the 2-norm = S(1)/S(min(m,n)). \n
    * @param[in] rcond
              rcond is float/double* \n
              rcond is used to determine the effective rank of a.
              Singular values S(i) <= rcond*S(1) are treated as zero. \n
              If rcond < 0, machine precision is used instead. \n
    * @param[out] rank
              rank is integer* \n
              The effective rank of a, i.e., the number of singular values
              which are greater than rcond*S(1). \n
    * @param[out]	WORK	
              WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
              On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
    * @param[in]	LWORK	
              LWORK is INTEGER \n
              The dimension of the array WORK. LWORK >= 1, and also: \n
              LWORK >=  2*min(M,N) + max(M,N,NRHS) \n
              For good performance, LWORK should generally be larger. \n
 \n
              If LWORK = -1, then a workspace query is assumed; the routine
              only calculates the optimal size of the WORK array, returns
              this value as the first entry of the WORK array, and no error
              message related to LWORK is issued by XERBLA. \n
    * @param[out]	RWORK	
              RWORK is REAL array, dimension (5*min(M,N)) \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit \n
              < 0:  if INFO = -i, the i-th argument had an illegal value. \n
              > 0:  the algorithm for computing the SVD failed to converge;
                    if INFO = i, i off-diagonal elements of an intermediate
                    bidiagonal form did not converge to zero. \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer gelss(integer* m, integer* n, integer* nrhs, T* a, integer* lda, T* b, integer* ldb, T*  s, T* rcond, integer* rank, T* work, integer* lwork, integer* info)
{
  return gelss(m, n, nrhs, a, lda, b,ldb, s, rcond, rank, work, lwork, info);
}
template< typename T, typename Ta >
integer gelss(integer* m, integer* n, integer* nrhs, T* a, integer* lda, T* b, integer* ldb, Ta*  s, Ta*  rcond, integer* rank, T* work, integer* lwork, Ta* rwork, integer* info)
{
  return gelss(m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lwork, rwork, info);
}

/*! @brief Product UUH or LHL, where U and L are upper or lower triangular matrices (blocked algorithm).
    *
    * @details
    * \b Purpose:
    * \verbatim
        Product UUH or LHL, where U and L are upper or lower triangular matrices (blocked algorithm).
        Computation of the product U * U**T or L**T * L, where the triangular factor U or L is
        stored in the upper or lower triangular part of the array a.

        If uplo = 'U' or 'u' then the upper triangle of the result is stored, overwriting the factor U in A.
        If uplo = 'L' or 'l' then the lower triangle of the result is stored, overwriting the factor L in A.

        This is the blocked form of the algorithm, calling Level 3 BLAS.
    \endverbatim

    * @param[in] uplo
              uplo is char* \n
              Specifies whether the triangular factor stored in the array a
              is upper or lower triangular: \n
              = 'U':  Upper triangular \n
              = 'L':  Lower triangular \n
    * @param[in] n
              n is integer* \n
              The order of the triangular factor U or L.  n >= 0. \n
    * @param[in,out] a
              a is float/double/COMPLEX/COMPLEX*16 array, dimension (lda,n) \n
              On entry, the triangular factor U or L. \n
              On exit, if uplo = 'U', the upper triangle of a is
              overwritten with the upper triangle of the product U * U**T; \n
              if uplo = 'L', the lower triangle of a is overwritten with
              the lower triangle of the product L**T * L. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the matrix a, lda >= max(1,n) \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0: successful exit \n
              < 0: if INFO = -k, the k-th argument had an illegal value \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer lauum(char* uplo, integer* n, T* a, integer* lda, integer* info)
{
  return lauum(uplo, n, a, lda, info);
}

/*! @brief Product UUH or LHL, where U and L are upper or lower triangular matrices (unblocked algorithm).
    *
    * @details
    * \b Purpose:
    * \verbatim
        Product UUH or LHL, where U and L are upper or lower triangular matrices (unblocked algorithm).
        Computation of the product U * U**T or L**T * L, where the triangular factor U or L is
        stored in the upper or lower triangular part of the array a.

        If uplo = 'U' or 'u' then the upper triangle of the result is stored, overwriting the factor U in A.
        If uplo = 'L' or 'l' then the lower triangle of the result is stored, overwriting the factor L in A.

        This is the unblocked form of the algorithm, calling Level 2 BLAS.
    \endverbatim

    * @param[in] uplo
              uplo is char* \n
              Specifies whether the triangular factor stored in the array a
              is upper or lower triangular: \n
              = 'U':  Upper triangular \n
              = 'L':  Lower triangular \n
    * @param[in] n
              n is integer* \n
              The order of the triangular factor U or L.  n >= 0. \n
    * @param[in,out] a
              a is float/double/COMPLEX/COMPLEX*16 array, dimension (lda,n) \n
              On entry, the triangular factor U or L. \n
              On exit, if uplo = 'U', the Upper triangle of a is
              overwritten with the upper triangle of the product U * U**T; \n
              if uplo = 'L', the lower triangle of a is overwritten with
              the lower triangle of the product L**T * L. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the matrix a, lda >= max(1,n) \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0: successful exit \n
              < 0: if INFO = -k, the k-th argument had an illegal value \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer lauu2(char* uplo, integer* n, T* a, integer* lda, integer* info)
{
  return lauu2(uplo, n, a, lda, info);
}

/*! @brief Inverse of a real symmetric positive definite matrix.
    *
    * @details
    * \b Purpose:
    * \verbatim
        Computation of the inverse of a real symmetric positive definite matrix a using the
        Cholesky factorization A = U**T*U or A = L*L**T computed by SPOTRF.
    \endverbatim

    * @param[in] uplo
              uplo is char* \n
              = 'U':  Upper triangle of a is stored; \n
              = 'L':  Lower triangle of a is stored. \n
    * @param[in] n
              n is integer*  \n
              The order of the matrix a.  n >= 0. \n
    * @param[in,out] a
              a is float/double/COMPLEX/COMPLEX*16 array, dimension (lda,n) \n
              On entry, the triangular factor U or L from the Cholesky
              factorization A = U**T*U or A = L*L**T, as computed by
              SPOTRF. \n
              On exit, the upper or lower triangle of the (symmetric)
              inverse of A, overwriting the input factor U or L. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the matrix a, lda >= max(1,n) \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit \n
              < 0:  if INFO = -i, the i-th argument had an illegal value \n
              > 0:  if INFO = i, the (i,i) element of the factor U or L is
                    zero, and the inverse could not be computed. \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer potri(char* uplo, integer* n, T* buff_A, integer*  ldim_A, integer* info)
{
  return potri(uplo, n, buff_A, ldim_A, info);
}

/*! @brief Inverse of a real upper or lower triangular matrix.
    *
    * @details
    * \b Purpose:
    * \verbatim
        Computation of inverse of a real upper or lower triangular matrix

        This is the Level 3 BLAS version of the algorithm.
    \endverbatim

    * @param[in] uplo
              uplo is char* \n
              = 'U':  A is upper triangular; \n
              = 'L':  A is lower triangular. \n
    * @param[in] diag
              diag is char* \n
              = 'N':  A is non-unit triangular; \n
              = 'U':  A is unit triangular. \n
    * @param[in] n
              n is integer*  \n
              The order of the matrix a.  n >= 0. \n
    * @param[in,out] a
              a is float/double/COMPLEX/COMPLEX*16 array, dimension (lda,n) \n
              On entry, the triangular matrix a.  If uplo = 'U', the
              leading n-by-n upper triangular part of the array a contains
              the upper triangular matrix, and the strictly lower
              triangular part of a is not referenced.  If uplo = 'L', the
              leading n-by-n lower triangular part of the array a contains
              the lower triangular matrix, and the strictly upper
              triangular part of a is not referenced.  If diag = 'U', the
              diagonal elements of a are also not referenced and are
              assumed to be 1. \n
              On exit, the (triangular) inverse of the original matrix, in
              the same storage format. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the matrix a, lda >= max(1,n) \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0: successful exit \n
              < 0: if INFO = -i, the i-th argument had an illegal value \n
              > 0: if INFO = i, A(i,i) is exactly zero.  The triangular
                   matrix is singular and its inverse can not be computed. \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer trtri(char* uplo, char* diag, integer* n, T* a, integer* lda, integer* info)
{
  return trtri(uplo, diag, n, a, lda, info);
}

/*! @brief Inverse of a triangular matrix (unblocked algorithm).
    *
    * @details
    * \b Purpose:
    * \verbatim
        Computation of inverse of a real upper or lower triangular matrix (unblocked algorithm)

        This is the Level 2 BLAS version of the algorithm.
    \endverbatim

    * @param[in] uplo
              uplo is char* \n
              = 'U':  A is upper triangular; \n
              = 'L':  A is lower triangular. \n
    * @param[in] diag
              diag is char* \n
              = 'N':  A is non-unit triangular; \n
              = 'U':  A is unit triangular. \n
    * @param[in] n
              n is integer* \n
              The order of the matrix a.  n >= 0. \n
    * @param[in,out] a
              a is float/double/COMPLEX/COMPLEX*16 array, dimension (lda,n) \n
              On entry, the triangular matrix a.  If uplo = 'U', the
              leading n by n upper triangular part of the array a contains
              the upper triangular matrix, and the strictly lower
              triangular part of a is not referenced.  If uplo = 'L', the
              leading n by n lower triangular part of the array a contains
              the lower triangular matrix, and the strictly upper
              triangular part of a is not referenced.  If diag = 'U', the
              diagonal elements of a are also not referenced and are
              assumed to be 1. \n
              On exit, the (triangular) inverse of the original matrix, in
              the same storage format. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the matrix a, lda >= max(1,n) \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0: successful exit \n
              < 0: if INFO = -k, the k-th argument had an illegal value \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer trti2(char* uplo, char* diag, integer* n, T* a, integer* lda, integer* info)
{
  return trti2(uplo, diag, n, a, lda, info);
}

/*! @brief Solving Sylvester matrix equation
    *
    * @details
    * \b Purpose:
    * \verbatim
        Solution for real Sylvester matrix equation:
            op(A)*X + X*op(B) = scale*C or
            op(A)*X - X*op(B) = scale*C,

        where op(A) = A or A**T, and  a and b are both upper quasi- triangular.
        A is M-by-M and B is n-by-n; the right hand side C and the solution X are m-by-n;
        and scale is an output scale factor, set <= 1 to avoid overflow in X.

        a and b must be in Schur canonical form (as returned by SHSEQR), that is, block upper
        triangular with 1-by-1 and 2-by-2 diagonal blocks; each 2-by-2 diagonal block has its
        diagonal elements equal and its off-diagonal elements of opposite sign.
    \endverbatim

    * @param[in] transa
              transa is char* \n
              Specifies the option op(A): \n
              = 'N': op(A) = A (No transpose) \n
              = 'T': op(A) = A**T (Transpose) \n
              = 'C': op(A) = A**H (Conjugate transpose = Transpose) \n
    * @param[in] transb
              transb is char* \n
              Specifies the option op(B): \n
              = 'N': op(B) = B (No transpose) \n
              = 'T': op(B) = B**T (Transpose) \n
              = 'C': op(B) = B**H (Conjugate transpose = Transpose) \n
    * @param[in] isgn
              isgn is integer* \n
              Specifies the sign in the equation: \n
              = +1: solve op(A)*X + X*op(B) = scale*C \n
              = -1: solve op(A)*X - X*op(B) = scale*C \n
    * @param[in] m
              m is integer* \n
              The order of the matrix a, and the number of rows in the
              matrices X and C. m >= 0. \n
    * @param[in] n
              n is integer* \n
              The order of the matrix b, and the number of columns in the
              matrices X and C. n >= 0. \n
    * @param[in] a
              a is float/double array, dimension (lda,m) \n
              The upper quasi-triangular matrix a, in Schur canonical form. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the array a. lda >= max(1,m). \n
    * @param[in] b
              b is float/double array, dimension (ldb,n) \n
              The upper quasi-triangular matrix b, in Schur canonical form. \n
    * @param[in] ldb
              ldb is integer* \n
              The leading dimension of the array b. ldb >= max(1,n). \n
    * @param[in,out] c
              c is float/double array, dimension (ldc,n) \n
              On entry, the m-by-n right hand side matrix c. \n
              On exit, c is overwritten by the solution matrix X. \n
    * @param[in] ldc
              ldc is integer* \n
              The leading dimension of the array c. ldc >= max(1,m) \n
    * @param[out] scale
              scale is float/double* \n
              The scale factor, scale, set <= 1 to avoid overflow in X \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0: successful exit \n
              < 0: if INFO = -i, the i-th argument had an illegal value \n
              = 1: A and B have common or very close eigenvalues; perturbed
                   values were used to solve the equation (but the matrices
                   A and B are unchanged). \n

    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer trsyl(char* transa, char* transb, integer* isgn, integer* m, integer* n, T* a, integer* lda, T* b, integer* ldb, T* c, integer* ldc, T* scale, integer* info)
{
  return trsyl(transa, transb, isgn, m, n, a, lda, b, ldb, c, ldc, scale, info);
}
template< typename T, typename Ta >
integer trsyl(char* transa, char* transb, integer* isgn, integer* m, integer* n, T* a, integer* lda, T* b, integer* ldb, T* c, integer* ldc, Ta* scale, integer* info)
{
  return trsyl(transa, transb, isgn, m, n, a, lda, b, ldb, c, ldc, scale, info);
}

/*! @brief Reduction to upper Hessenberg form
    *
    * @details
    * \b Purpose:
    * \verbatim
    Reduction of a real general matrix a to upper Hessenberg form H by an orthogonal
    similarity transformation:
    Q**T * A * Q = H .
    \endverbatim

    * @param[in] n
              n is integer* \n
              The order of the matrix a.  n >= 0. \n
    * @param[in] ilo
              ilo is integer* \n
    * @param[in] ihi
              ihi is integer* \n
              It is assumed that A is already upper triangular in rows
              and columns 1:ilo-1 and ihi+1:n. \n
              ilo and ihi are normally set by a previous call to SGEBAL;
              otherwise they should be set to 1 and N respectively. See Further Details. \n
              1 <= ilo <= ihi <= N, if N > 0; ilo=1 and ihi=0, if N=0. \n
    * @param[in,out] a
              a is float/double/COMPLEX/COMPLEX*16 array, dimension (lda,n) \n
              On entry, the n-by-n general matrix to be reduced. \n
              On exit, the upper triangle and the first subdiagonal of A
              are overwritten with the upper Hessenberg matrix H, and the
              elements below the first subdiagonal, with the array tau,
              represent the orthogonal matrix Q as a product of elementary
              reflectors. See Further Details. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the array a.  lda >= max(1,n). \n
    * @param[out] tau
              tau is float/double/COMPLEX/COMPLEX*16 array, dimension (n-1) \n
              The scalar factors of the elementary reflectors (see Further
              Details). Elements 1:ilo-1 and ihi:N-1 of tau are set to
              zero.
              *
              * \n
              * **Further Details**
              * \verbatim
                      The matrix Q is represented as a product of (ihi-ilo) elementary reflectors

                      Q = H(ilo) H(ilo+1) . . . H(ihi-1).

                      Each H(i) has the form

                      H(i) = I - tau * V * V**T

                      where tau is a real scalar, and V is a real vector with V(1:i) = 0, V(i+1) = 1 and
                      V(ihi+1:n) = 0; V(i+2:ihi) is stored on exit in A(i+2:ihi,i), and tau in tau(i).

                      The contents of A are illustrated by the following example, with n = 7, ilo = 2 and ihi = 6:
                      on entry,   on exit,

                      ( a   a   a   a   a   a   a) (  a   a   h   h   h   h   a)
                      (  a   a   a   a   a   a)    (   a   h   h   h   h   a)
                      (  a   a   a   a   a   a)    (   h   h   h   h   h   h)
                      (  a   a   a   a   a   a)    (   v2  h   h   h   h   h)
                      (  a   a   a   a   a   a)    (   v2  v3  h   h   h   h)
                      (  a   a   a   a   a   a)    (   v2  v3  v4  h   h   h)
                      ( a) (  a)
                      where,
                      a denotes an element of the original matrix a,
                      h denotes a modified element of the upper Hessenberg matrix H,
                      vi denotes an element of the vector defining H(i).
              \endverbatim
    * @param[out]	WORK	
              WORK is COMPLEX array, dimension (LWORK) \n
              On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
    * @param[in]	LWORK	
              LWORK is INTEGER \n
              The length of the array WORK.  LWORK >= max(1,N). \n
              For good performance, LWORK should generally be larger. \n
 \n
              If LWORK = -1, then a workspace query is assumed; the routine
              only calculates the optimal size of the WORK array, returns
              this value as the first entry of the WORK array, and no error
              message related to LWORK is issued by XERBLA. \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit \n
              < 0:  if INFO = -i, the i-th argument had an illegal value. \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer gehrd(integer* n, integer* ilo, integer* ihi, T* a, integer* lda, T* tau, T* work, integer* lwork, integer* info)
{
  return gehrd(n, ilo, ihi, a, lda, tau, work, lwork, info);
}

/*! @brief Reduction to upper Hessenberg form using an unblocked algorithm
    *
    * @details
    * \b Purpose:
    * \verbatim
        Reduction of a real general matrix a to upper Hessenberg form H by an orthogonal
        similarity transformation:
        Q**T * A * Q = H .
    \endverbatim

    * @param[in] n
              n is integer* \n
              The order of the matrix a.  n >= 0. \n
    * @param[in] ilo
              ilo is integer* \n
    * @param[in] ihi
              ihi is integer* \n
              It is assumed that A is already upper triangular in rows
              and columns 1:ilo-1 and ihi+1:n. \n
              ilo and ihi are normally set by a previous call to SGEBAL;
              otherwise they should be set to 1 and N respectively. See Further Details. \n
              1 <= ilo <= ihi <= max(1,n). \n
    * @param[in,out] a
              a is float/double/COMPLEX/COMPLEX*16 array, dimension (lda,n) \n
              On entry, the n-by-n general matrix to be reduced. \n
              On exit, the upper triangle and the first subdiagonal of A
              are overwritten with the upper Hessenberg matrix H, and the
              elements below the first subdiagonal, with the array tau,
              represent the orthogonal matrix Q as a product of elementary
              reflectors. See Further Details. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the array a.  lda >= max(1,n). \n
    * @param[out] tau
              tau is float/double/COMPLEX/COMPLEX*16 array, dimension (n-1) \n
              The scalar factors of the elementary reflectors (see Further
              Details).
              *
              * \n
              * **Further Details**
              * \verbatim
                      The matrix Q is represented as a product of (ihi-ilo) elementary reflectors

                      Q = H(ilo) H(ilo+1) . . . H(ihi-1).

                      Each H(i) has the form

                      H(i) = I - tau * V * V**T

                      where tau is a real scalar, and V is a real vector with V(1:i) = 0, V(i+1) = 1 and
                      V(ihi+1:n) = 0; V(i+2:ihi) is stored on exit in A(i+2:ihi,i), and tau in tau(i).

                      The contents of A are illustrated by the following example, with n = 7, ilo = 2 and ihi = 6:
                      on entry,   on exit,

                      ( a   a   a   a   a   a   a) (  a   a   h   h   h   h   a)
                      (  a   a   a   a   a   a) (   a   h   h   h   h   a)
                      (  a   a   a   a   a   a) (   h   h   h   h   h   h)
                      (  a   a   a   a   a   a) (   v2  h   h   h   h   h)
                      (  a   a   a   a   a   a) (   v2  v3  h   h   h   h)
                      (  a   a   a   a   a   a) (   v2  v3  v4  h   h   h)
                      ( a) (  a)
                      where,
                      a denotes an element of the original matrix a,
                      h denotes a modified element of the upper Hessenberg matrix H,
                      vi denotes an element of the vector defining H(i).
              \endverbatim
    * @param[out]	WORK	
              WORK is COMPLEX array, dimension (N) \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit \n
              < 0:  if INFO = -i, the i-th argument had an illegal value. \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer gehd2(integer* n, integer* ilo, integer* ihi, T* a, integer* lda, T* tau, T* work, integer* info)
{
  return gehd2(n, ilo, ihi, a, lda, tau, work, info);
}

/*! @brief Reduction of a real symmetric matrix a to real symmetric tridiagonal form
    *
    * @details
    * \b Purpose:
    * \verbatim
        Reduction of a real symmetric matrix a to real symmetric tridiagonal form T by an
        orthogonal similarity transformation:
            Q**T * A * Q = T.
    \endverbatim

    * @param[in] uplo
              uplo is char* \n
              = 'U':  Upper triangle of a is stored; \n
              = 'L':  Lower triangle of a is stored. \n
    * @param[in] n
              n is integer* \n
              The order of the matrix a.  n >= 0. \n
    * @param[in,out] a
              a is float/double array, dimension (lda,n) \n
              On entry, the symmetric matrix a. \n
              If uplo = 'U', the leading
              n-by-n upper triangular part of a contains the upper
              triangular part of the matrix a, and the strictly lower
              triangular part of a is not referenced. \n
              If uplo = 'L', the leading n-by-n lower triangular part of a contains the lower
              triangular part of the matrix a, and the strictly upper
              triangular part of a is not referenced. \n
              On exit, if uplo = 'U', the diagonal and first superdiagonal
              of A are overwritten by the corresponding elements of the
              tridiagonal matrix T, and the elements above the first
              superdiagonal, with the array tau, represent the orthogonal
              matrix Q as a product of elementary reflectors; \n
              if uplo = 'L', the diagonal and first subdiagonal of A are over-
              written by the corresponding elements of the tridiagonal
              matrix T, and the elements below the first subdiagonal, with
              the array tau, represent the orthogonal matrix Q as a product
              of elementary reflectors. See Further Details. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the array a.  lda >= max(1,n). \n
    * @param[out] d
              d is float/double array, dimension (n) \n
              The diagonal elements of the tridiagonal matrix T:
              D(i) = A(i,i). \n
    * @param[out] e
              e is float/double array, dimension (n-1) \n
              The off-diagonal elements of the tridiagonal matrix T: \n
              E(i) = A(i,i+1) if uplo = 'U', E(i) = A(i+1,i) if uplo = 'L'. \n
    * @param[out] tau
              tau is float/double array, dimension (n-1) \n
              The scalar factors of the elementary reflectors (see Further
              Details).
              *
              * \n
              * **Further Details**
              * \verbatim
                      If uplo = 'U', the matrix Q is represented as a product of elementary reflectors

                      Q = H(n-1) . . . H(2) H(1).

                      Each H(i) has the form

                      H(i) = I - tau * V * V**T

                      where tau is a real scalar, and V is a real vector with V(i+1:n) = 0 and V(i) = 1;
                      V(1:i-1) is stored on exit in A(1:i-1,i+1), and tau in tau(i).

                      If uplo = 'L', the matrix Q is represented as a product of elementary reflectors

                      Q = H(1) H(2) . . . H(n-1).

                      Each H(i) has the form

                      H(i) = I - tau * V * V**T

                      where tau is a real scalar, and V is a real vector with V(1:i) = 0 and V(i+1) = 1;
                      V(i+2:n) is stored on exit in A(i+2:n,i), and tau in tau(i).

                      The contents of A on exit are illustrated by the following examples with n = 5:

                      if uplo = 'U':  if uplo = 'L':

                      (  d   e   v2  v3  v4)  (  d  )
                      (   d   e   v3  v4)  (  e   d )
                      ( d   e   v4)  (  v1  e   d)
                      (  d   e )  (  v1  v2  e   d  )
                      (   d )  (  v1  v2  v3  e   d )

                      where d and e denote diagonal and off-diagonal elements of T, and vi denotes an element
                      of the vector defining H(i).
              \endverbatim
    * @param[out]	WORK	
              WORK is REAL array, dimension (MAX(1,LWORK)) \n
              On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
    * @param[in]	LWORK	
              LWORK is INTEGER \n
              The dimension of the array WORK.  LWORK >= 1. \n
              For optimum performance LWORK >= N*NB, where NB is the
              optimal blocksize. \n

              If LWORK = -1, then a workspace query is assumed; the routine
              only calculates the optimal size of the WORK array, returns
              this value as the first entry of the WORK array, and no error
              message related to LWORK is issued by XERBLA. \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit \n
              < 0:  if INFO = -i, the i-th argument had an illegal value \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer sytrd(char* uplo, integer* n, T* a, integer* lda, T*  d, T*  e, T* tau, T* work, integer* lwork, integer* info)
{
  return sytrd(uplo, n, a, lda, d, e, tau, work, lwork, info);
}

/*! @brief Reduction of a complex Hermitian matrix a to real symmetric tridiagonal form
    *
    * @details
    * \b Purpose:
    * \verbatim
    Reduction of a complex Hermitian matrix a to real symmetric tridiagonal form T by a
    unitary similarity transformation:
        Q**H * A * Q = T.
    \endverbatim

    * @param[in] uplo
              uplo is char* \n
              = 'U':  Upper triangle of a is stored; \n
              = 'L':  Lower triangle of a is stored. \n
    * @param[in] n
              n is integer* \n
              The order of the matrix a.  n >= 0. \n
    * @param[in,out] a
              a is COMPLEX/COMPLEX*16 array, dimension (lda,n) \n
              On entry, the symmetric matrix a. \n
              If uplo = 'U', the leading
              n-by-n upper triangular part of a contains the upper
              triangular part of the matrix a, and the strictly lower
              triangular part of a is not referenced. \n
              If uplo = 'L', the leading n-by-n lower triangular part of a contains the lower
              triangular part of the matrix a, and the strictly upper
              triangular part of a is not referenced. \n
              On exit, if uplo = 'U', the diagonal and first superdiagonal
              of A are overwritten by the corresponding elements of the
              tridiagonal matrix T, and the elements above the first
              superdiagonal, with the array tau, represent the orthogonal
              matrix Q as a product of elementary reflectors; \n
              if uplo = 'L', the diagonal and first subdiagonal of A are over-
              written by the corresponding elements of the tridiagonal
              matrix T, and the elements below the first subdiagonal, with
              the array tau, represent the orthogonal matrix Q as a product
              of elementary reflectors. See Further Details. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the array a.  lda >= max(1,n). \n
    * @param[out] d
              d is float/double array, dimension (n) \n
              The diagonal elements of the tridiagonal matrix T:
              D(i) = A(i,i). \n
    * @param[out] e
              e is float/double array, dimension (n-1) \n
              The off-diagonal elements of the tridiagonal matrix T: \n
              E(i) = A(i,i+1) if uplo = 'U', E(i) = A(i+1,i) if uplo = 'L'. \n
    * @param[out] tau
              tau is COMPLEX/COMPLEX*16 array, dimension (n-1) \n
              The scalar factors of the elementary reflectors (see Further
              Details).
              *
              * \n
              * **Further Details**
              * \verbatim
                      If uplo = 'U', the matrix Q is represented as a product of elementary reflectors

                      Q = H(n-1) . . . H(2) H(1).

                      Each H(i) has the form

                      H(i) = I - tau * V * V**H

                      where tau is a complex scalar, and V is a complex vector with V(i+1:n) = 0 and V(i) = 1;
                      V(1:i-1) is stored on exit in A(1:i-1,i+1), and tau in tau(i).

                      If uplo = 'L', the matrix Q is represented as a product of elementary reflectors

                      Q = H(1) H(2) . . . H(n-1).

                      Each H(i) has the form

                      H(i) = I - tau * V * V**H

                      where tau is a complex scalar, and V is a complex vector with V(1:i) = 0 and V(i+1) = 1;
                      V(i+2:n) is stored on exit in A(i+2:n,i), and tau in tau(i).

                      The contents of A on exit are illustrated by the following examples with n = 5:

                      if uplo = 'U':  if uplo = 'L':

                      (  d   e   v2  v3  v4)  (  d  )
                      (   d   e   v3  v4)  (  e   d )
                      ( d   e   v4)  (  v1  e   d)
                      (  d   e )  (  v1  v2  e   d  )
                      (   d )  (  v1  v2  v3  e   d )

                      where d and e denote diagonal and off-diagonal elements of T, and vi denotes an element
                      of the vector defining H(i).
              \endverbatim
    * @param[out]	WORK	
              WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
              On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
    * @param[in]	LWORK	
              LWORK is INTEGER \n
              The dimension of the array WORK.  LWORK >= 1.
              For optimum performance LWORK >= N*NB, where NB is the
              optimal blocksize. \n

              If LWORK = -1, then a workspace query is assumed; the routine
              only calculates the optimal size of the WORK array, returns
              this value as the first entry of the WORK array, and no error
              message related to LWORK is issued by XERBLA. \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit \n
              < 0:  if INFO = -i, the i-th argument had an illegal value \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T, typename Ta >
integer hetrd(char* uplo, integer* n, T* a, integer* lda, Ta*  d, Ta*  e, T* tau, T* work, integer* lwork, integer* info)
{
  return hetrd(uplo, n, a, lda, d, e, tau, work, lwork, info);
}
/*! @brief Reduction of a real symmetric matrix a to real symmetric tridiagonal form (unblocked algorithm)
    *
    * @details
    * \b Purpose:
    * \verbatim
        Reduction of a real symmetric matrix a to real symmetric tridiagonal form T by an orthogonal
        similarity transformation(unblocked algorithm):
            Q**T * A * Q = T.
    \endverbatim

    * @param[in] uplo
              uplo is char* \n
              = 'U':  Upper triangle of a is stored; \n
              = 'L':  Lower triangle of a is stored. \n
    * @param[in] n
              n is integer* \n
              The order of the matrix a.  n >= 0. \n
    * @param[in,out] a
              a is float/double array, dimension (lda,n) \n
              On entry, the symmetric matrix a. \n
              If uplo = 'U', the leading
              n-by-n upper triangular part of a contains the upper
              triangular part of the matrix a, and the strictly lower
              triangular part of a is not referenced. \n
              If uplo = 'L', the leading n-by-n lower triangular part of a contains the lower
              triangular part of the matrix a, and the strictly upper
              triangular part of a is not referenced. \n
              On exit, if uplo = 'U', the diagonal and first superdiagonal
              of A are overwritten by the corresponding elements of the
              tridiagonal matrix T, and the elements above the first
              superdiagonal, with the array tau, represent the orthogonal
              matrix Q as a product of elementary reflectors; \n
              if uplo = 'L', the diagonal and first subdiagonal of A are over-
              written by the corresponding elements of the tridiagonal
              matrix T, and the elements below the first subdiagonal, with
              the array tau, represent the orthogonal matrix Q as a product
              of elementary reflectors. See Further Details. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the array a.  lda >= max(1,n). \n
    * @param[out] d
              d is float/double array, dimension (n) \n
              The diagonal elements of the tridiagonal matrix T:
              D(i) = A(i,i). \n
    * @param[out] e
              e is float/double array, dimension (n-1) \n
              The off-diagonal elements of the tridiagonal matrix T: \n
              E(i) = A(i,i+1) if uplo = 'U', E(i) = A(i+1,i) if uplo = 'L'. \n
    * @param[out] tau
              tau is COMPLEX/COMPLEX*16 array, dimension (n-1) \n
              The scalar factors of the elementary reflectors (see Further
              Details).
              *
              * \n
              * **Further Details**
              * \verbatim
                      If uplo = 'U', the matrix Q is represented as a product of elementary reflectors

                      Q = H(n-1) . . . H(2) H(1).

                      Each H(i) has the form

                      H(i) = I - tau * V * V**T

                      where tau is a real scalar, and V is a real vector with V(i+1:n) = 0 and V(i) = 1;
                      V(1:i-1) is stored on exit in A(1:i-1,i+1), and tau in tau(i).

                      If uplo = 'L', the matrix Q is represented as a product of elementary reflectors

                      Q = H(1) H(2) . . . H(n-1).

                      Each H(i) has the form

                      H(i) = I - tau * V * V**T

                      where tau is a real scalar, and V is a real vector with V(1:i) = 0 and V(i+1) = 1;
                      V(i+2:n) is stored on exit in A(i+2:n,i), and tau in tau(i).

                      The contents of A on exit are illustrated by the following examples with n = 5:

                      if uplo = 'U':  if uplo = 'L':

                      (  d   e   v2  v3  v4)  (  d  )
                      (   d   e   v3  v4)  (  e   d )
                      ( d   e   v4)  (  v1  e   d)
                      (  d   e )  (  v1  v2  e   d  )
                      (   d )  (  v1  v2  v3  e   d )

                      where d and e denote diagonal and off-diagonal elements of T, and vi denotes an element
                      of the vector defining H(i).
              \endverbatim
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit \n
              < 0:  if INFO = -i, the i-th argument had an illegal value. \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer sytd2(char* uplo, integer* n, T* a, integer* lda, T*  d, T*  e, T* tau, integer* info)
{
  return sytd2(uplo, n, a, lda, d, e, tau, info);
}

/*! @brief Reduction of a Hermitian matrix a to real symmetric tridiagonal form (unblocked algorithm)
    *
    * @details
    * \b Purpose:
    * \verbatim
        Reduction of a Hermitian matrix a to real symmetric tridiagonal form T by an unitary
        similarity transformation(unblocked algorithm):
            Q**T * A * Q = T.
    \endverbatim

    * @param[in] uplo
              uplo is char* \n
              = 'U':  Upper triangle of a is stored; \n
              = 'L':  Lower triangle of a is stored. \n
    * @param[in] n
              n is integer* \n
              The order of the matrix a.  n >= 0. \n
    * @param[in,out] a
              a is COMPLEX/COMPLEX*16 array, dimension (lda,n) \n
              On entry, the symmetric matrix a. \n
              If uplo = 'U', the leading
              n-by-n upper triangular part of a contains the upper
              triangular part of the matrix a, and the strictly lower
              triangular part of a is not referenced. \n
              If uplo = 'L', the leading n-by-n lower triangular part of a contains the lower
              triangular part of the matrix a, and the strictly upper
              triangular part of a is not referenced. \n
              On exit, if uplo = 'U', the diagonal and first superdiagonal
              of A are overwritten by the corresponding elements of the
              tridiagonal matrix T, and the elements above the first
              superdiagonal, with the array tau, represent the orthogonal
              matrix Q as a product of elementary reflectors; \n
              if uplo = 'L', the diagonal and first subdiagonal of A are over-
              written by the corresponding elements of the tridiagonal
              matrix T, and the elements below the first subdiagonal, with
              the array tau, represent the orthogonal matrix Q as a product
              of elementary reflectors. See Further Details. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the array a.  lda >= max(1,n). \n
    * @param[out] d
              d is float/double array, dimension (n) \n
              The diagonal elements of the tridiagonal matrix T:
              D(i) = A(i,i).
    * @param[out] e
              e is float/double array, dimension (n-1) \n
              The off-diagonal elements of the tridiagonal matrix T: \n
              E(i) = A(i,i+1) if uplo = 'U', E(i) = A(i+1,i) if uplo = 'L'. \n
    * @param[out] tau
              tau is COMPLEX/COMPLEX*16 array, dimension (n-1) \n
              The scalar factors of the elementary reflectors (see Further
              Details).
              *
              * \n
              * **Further Details**
              * \verbatim
                      If uplo = 'U', the matrix Q is represented as a product of elementary reflectors

                          Q = H(n-1) . . . H(2) H(1).

                      Each H(i) has the form

                          H(i) = I - tau * V * V**H

                      where tau is a complex scalar, and V is a complex vector with V(i+1:n) = 0 and V(i) = 1;
                      V(1:i-1) is stored on exit in A(1:i-1,i+1), and tau in tau(i).

                      If uplo = 'L', the matrix Q is represented as a product of elementary reflectors

                          Q = H(1) H(2) . . . H(n-1).

                      Each H(i) has the form

                          H(i) = I - tau * V * V**H

                      where tau is a complex scalar, and V is a complex complex vector with V(1:i) = 0 and V(i+1) = 1;
                      V(i+2:n) is stored on exit in A(i+2:n,i), and tau in tau(i).

                      The contents of A on exit are illustrated by the following examples with n = 5:

                      if uplo = 'U':                       if uplo = 'L':

                          (  d   e   v2  v3  v4)              (  d                 )
                          (      d   e   v3  v4)              (  e   d             )
                          (          d   e   v4)              (  v1  e   d         )
                          (              d   e )              (  v1  v2  e   d     )
                          (                  d )              (  v1  v2  v3  e   d )

                      where d and e denote diagonal and off-diagonal elements of T, and vi denotes an element
                      of the vector defining H(i).
              \endverbatim
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit \n
              < 0:  if INFO = -i, the i-th argument had an illegal value. \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T, typename Ta >
integer hetd2(char* uplo, integer* n, T* a, integer* lda, Ta*  d, Ta*  e, T* tau, integer* info)
{
  return hetd2(uplo, n, a, lda, d, e, tau, info);
}

/*! @brief Reduction to bidiagonal form
    *
    * @details
    * \b Purpose:
    * \verbatim
        Reduction of a general real m-by-n matrix a to upper or lower bidiagonal form B by an
        orthogonal transformation: Q**T * A * P = B.

        If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal.
    \endverbatim

    * @param[in] m
              m is integer* \n
              The number of rows in the matrix a.  m >= 0. \n
    * @param[in] n
              n is integer* \n
              The number of columns in the matrix a.  n >= 0. \n
    * @param[in,out] a
              a is float/double array, dimension (lda,n) \n
              On entry, the m-by-n general matrix to be reduced. \n
              On exit, \n
              if m >= n, the diagonal and the first superdiagonal are
              overwritten with the upper bidiagonal matrix b; the
              elements below the diagonal, with the array tauq, represent
              the orthogonal matrix Q as a product of elementary
              reflectors, and the elements above the first superdiagonal,
              with the array taup, represent the orthogonal matrix P as
              a product of elementary reflectors; \n
              if m < n, the diagonal and the first subdiagonal are
              overwritten with the lower bidiagonal matrix b; the
              elements below the first subdiagonal, with the array tauq,
              represent the orthogonal matrix Q as a product of
              elementary reflectors, and the elements above the diagonal,
              with the array taup, represent the orthogonal matrix P as
              a product of elementary reflectors. \n
              See Further Details. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the array a.  lda >= max(1,m). \n
    * @param[out] d
              d is float/double array, dimension (min(m,n)) \n
              The diagonal elements of the bidiagonal matrix b:
              D(i) = A(i,i).
    * @param[out] e
              e is float/double array, dimension (min(m,n)-1) \n
              The off-diagonal elements of the bidiagonal matrix b: \n
              if m >= n, E(i) = A(i,i+1) for i = 1,2,...,n-1; \n
              if m < n, E(i) = A(i+1,i) for i = 1,2,...,m-1. \n
    * @param[out] tauq
              tauq is float/double array, dimension (min(m,n)) \n
              The scalar factors of the elementary reflectors which
              represent the orthogonal matrix Q. \n
              See Further Details.
    * @param[out] taup
              taup is float/double array, dimension (min(m,n)) \n
              The scalar factors of the elementary reflectors which
              represent the orthogonal matrix P. \n
              See Further Details.
              *
              * \n
              * **Further Details**
              * \verbatim
                      The matrices Q and P are represented as products of elementary reflectors:

                      If m >= n,

                      Q = H(1) H(2) . . . H(n)  and  P = G(1) G(2) . . . G(n-1)

                      Each H(i) and G(i) has the form:

                      H(i) = I - tauq * V * V**T  and G(i) = I - taup * u * u**T

                      where tauq and taup are real scalars, and V and u are real vectors;
                      V(1:i-1) = 0, V(i) = 1, and V(i+1:m) is stored on exit in A(i+1:m,i);
                      u(1:i) = 0, u(i+1) = 1, and u(i+2:n) is stored on exit in A(i,i+2:n);
                      tauq is stored in tauq(i) and taup in taup(i).

                      If m < n,

                      Q = H(1) H(2) . . . H(m-1)  and  P = G(1) G(2) . . . G(m)

                      Each H(i) and G(i) has the form:

                      H(i) = I - tauq * V * V**T  and G(i) = I - taup * u * u**T

                      where tauq and taup are real scalars, and V and u are real vectors;
                      V(1:i) = 0, V(i+1) = 1, and V(i+2:m) is stored on exit in A(i+2:m,i);
                      u(1:i-1) = 0, u(i) = 1, and u(i+1:n) is stored on exit in A(i,i+1:n);
                      tauq is stored in tauq(i) and taup in taup(i).

                      The contents of A on exit are illustrated by the following examples:

                      m = 6 and n = 5 (m > n): m = 5 and n = 6 (m < n):

                      (  d   e   u1  u1  u1)  (  d   u1  u1  u1  u1  u1)
                      (  v1  d   e   u2  u2)  (  e   d   u2  u2  u2  u2)
                      (  v1  v2  d   e   u3)  (  v1  e   d   u3  u3  u3)
                      (  v1  v2  v3  d   e )  (  v1  v2  e   d   u4  u4)
                      (  v1  v2  v3  v4  d )  (  v1  v2  v3  e   d   u5)
                      (  v1  v2  v3  v4  v5)

                      where d and e denote diagonal and off-diagonal elements of B, vi denotes an element
                      of the vector defining H(i), and ui an element of the vector defining G(i).
              \endverbatim
    * @param[out]	WORK	
              WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
              On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
    * @param[in]	LWORK	
              LWORK is INTEGER \n
              The length of the array WORK.  LWORK >= max(1,M,N). \n
              For optimum performance LWORK >= (M+N)*NB, where NB
              is the optimal blocksize. \n

              If LWORK = -1, then a workspace query is assumed; the routine
              only calculates the optimal size of the WORK array, returns
              this value as the first entry of the WORK array, and no error
              message related to LWORK is issued by XERBLA. \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit. \n
              < 0:  if INFO = -i, the i-th argument had an illegal value. \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer gebrd(integer* m, integer* n, T* a, integer* lda, T*  d, T*  e, T* tauq, T* taup, T* work, integer* lwork, integer* info)
{
  return gebrd(m, n, a, lda, d, e, tauq, taup, work, lwork, info);
}
template< typename T, typename Ta >
integer gebrd(integer* m, integer* n, T* a, integer* lda, Ta* d, Ta* e, T* tauq, T* taup, T* work, integer* lwork, integer* info)
{
  return gebrd(m, n, a, lda, d, e, tauq, taup, work, lwork, info);
}

/*! @brief Reduction to bidiagonal form (unblocked algorithm)
    *
    * @details
    * \b Purpose:
    * \verbatim
        Reduction of a general real m-by-n matrix a to upper or lower bidiagonal form B by an
        orthogonal transformation: Q**T * A * P = B.

        If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal.
    \endverbatim

    * @param[in] m
              m is integer* \n
              The number of rows in the matrix a.  m >= 0. \n
    * @param[in] n
              n is integer* \n
              The number of columns in the matrix a.  n >= 0. \n
    * @param[in,out] a
              a is float/double array, dimension (lda,n) \n
              On entry, the m-by-n general matrix to be reduced. \n
              On exit, \n
              if m >= n, the diagonal and the first superdiagonal are
              overwritten with the upper bidiagonal matrix b; the
              elements below the diagonal, with the array tauq, represent
              the orthogonal matrix Q as a product of elementary
              reflectors, and the elements above the first superdiagonal,
              with the array taup, represent the orthogonal matrix P as
              a product of elementary reflectors; \n
              if m < n, the diagonal and the first subdiagonal are
              overwritten with the lower bidiagonal matrix b; the
              elements below the first subdiagonal, with the array tauq,
              represent the orthogonal matrix Q as a product of
              elementary reflectors, and the elements above the diagonal,
              with the array taup, represent the orthogonal matrix P as
              a product of elementary reflectors. \n
              See Further Details. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the array a.  lda >= max(1,m). \n
    * @param[out] d
              d is float/double array, dimension (min(m,n)) \n
              The diagonal elements of the bidiagonal matrix b: \n
              D(i) = A(i,i).
    * @param[out] e
              e is float/double array, dimension (min(m,n)-1) \n
              The off-diagonal elements of the bidiagonal matrix b: \n
              if m >= n, E(i) = A(i,i+1) for i = 1,2,...,n-1; \n
              if m < n, E(i) = A(i+1,i) for i = 1,2,...,m-1.
    * @param[out] tauq
              tauq is float/double array, dimension (min(m,n)) \n
              The scalar factors of the elementary reflectors which
              represent the orthogonal matrix Q.
              See Further Details. \n
    * @param[out] taup
              taup is float/double array, dimension (min(m,n)) \n
              The scalar factors of the elementary reflectors which
              represent the orthogonal matrix P. \n
              See Further Details.
              *
              * \n
              * **Further Details**
              * \verbatim
                      The matrices Q and P are represented as products of elementary reflectors:

                      If m >= n,

                      Q = H(1) H(2) . . . H(n)  and  P = G(1) G(2) . . . G(n-1)

                      Each H(i) and G(i) has the form:

                      H(i) = I - tauq * V * V**T  and G(i) = I - taup * u * u**T

                      where tauq and taup are real scalars, and V and u are real vectors;
                      V(1:i-1) = 0, V(i) = 1, and V(i+1:m) is stored on exit in A(i+1:m,i);
                      u(1:i) = 0, u(i+1) = 1, and u(i+2:n) is stored on exit in A(i,i+2:n);
                      tauq is stored in tauq(i) and taup in taup(i).

                      If m < n,

                      Q = H(1) H(2) . . . H(m-1)  and  P = G(1) G(2) . . . G(m)

                      Each H(i) and G(i) has the form:

                      H(i) = I - tauq * V * V**T  and G(i) = I - taup * u * u**T

                      where tauq and taup are real scalars, and V and u are real vectors;
                      V(1:i) = 0, V(i+1) = 1, and V(i+2:m) is stored on exit in A(i+2:m,i);
                      u(1:i-1) = 0, u(i) = 1, and u(i+1:n) is stored on exit in A(i,i+1:n);
                      tauq is stored in tauq(i) and taup in taup(i).

                      The contents of A on exit are illustrated by the following examples:

                      m = 6 and n = 5 (m > n): m = 5 and n = 6 (m < n):

                      (  d   e   u1  u1  u1)  (  d   u1  u1  u1  u1  u1)
                      (  v1  d   e   u2  u2)  (  e   d   u2  u2  u2  u2)
                      (  v1  v2  d   e   u3)  (  v1  e   d   u3  u3  u3)
                      (  v1  v2  v3  d   e )  (  v1  v2  e   d   u4  u4)
                      (  v1  v2  v3  v4  d )  (  v1  v2  v3  e   d   u5)
                      (  v1  v2  v3  v4  v5)

                      where d and e denote diagonal and off-diagonal elements of B, vi denotes an element of
                      the vector defining H(i), and ui an element of the vector defining G(i).
              \endverbatim
    * @param[out]	WORK	
              WORK is COMPLEX array, dimension (max(M,N)) \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0: successful exit \n
              < 0: if INFO = -i, the i-th argument had an illegal value. \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer gebd2(integer* m, integer* n, T* a, integer* lda, T*  d, T*  e, T* tauq, T* taup, T* work, integer* info)
{
  return gebd2(m, n, a, lda, d, e, tauq, taup, work, info);
}
template< typename T, typename Ta >
integer gebd2(integer* m, integer* n, T* a, integer* lda, Ta*  d, Ta*  e, T* tauq, T* taup, T* work, integer* info)
{
  return gebd2(m, n, a,lda, d, e, tauq, taup, work, info);
}

/*! @brief Reduction of a real symmetric-definite generalized eigenproblem to standard form
    *
    * @details
    * \b Purpose:
    * \verbatim
        Reduction of a real symmetric-definite generalized eigenproblem to standard form.

        If itype = 1, the problem is A*X = lambda*B*X,
        and A is overwritten by inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T)

        If itype = 2 or 3, the problem is A*B*X = lambda*X or
        B*A*X = lambda*X, and A is overwritten by U*A*U**T or L**T*A*L.

        B must have been previously factorized as U**T*U or L*L**T by SPOTRF.
    \endverbatim

    * @param[in] itype
              itype is integer* \n
              = 1: compute inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T); \n
              = 2 or 3: compute U*A*U**T or L**T*A*L. \n
    * @param[in] uplo
              uplo is char* \n
              = 'U':  Upper triangle of a is stored and b is factored as
              U**T*U; \n
              = 'L':  Lower triangle of a is stored and b is factored as
              L*L**T. \n
    * @param[in] n
              n is integer* \n
              The order of the matrices a and b.  n >= 0. \n
    * @param[in,out] a
              a is float/double array, dimension (lda,n) \n
              On entry, the symmetric matrix a.  If uplo = 'U', the leading
              n-by-n upper triangular part of a contains the upper
              triangular part of the matrix a, and the strictly lower
              triangular part of a is not referenced.  If uplo = 'L', the
              leading n-by-n lower triangular part of a contains the lower
              triangular part of the matrix a, and the strictly upper
              triangular part of a is not referenced. \n
              On exit, if info = 0, the transformed matrix, stored in the
              same format as a. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the array a.  lda >= max(1,n). \n
    * @param[in] b
              b is float/double array, dimension (ldb,n) \n
              The triangular factor from the Cholesky factorization of b,
              as returned by SPOTRF. \n
    * @param[in] ldb
              ldb is integer* \n
              The leading dimension of the array b.  ldb >= max(1,n). \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit \n
              < 0:  if INFO = -i, the i-th argument had an illegal value \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer sygst(integer* itype, char* uplo, integer* n, T* a, integer* lda, T* b, integer* ldb, integer* info)
{
  return sygst(itype, uplo, n, a, lda, b, ldb, info);
}

/*! @brief Reduction of a complex Hermitian-definite generalized eigenproblem to standard form
    *
    * @details
    * \b Purpose:
    * \verbatim
        Reduction of a real symmetric-definite generalized eigenproblem to standard form.

        If itype = 1, the problem is A*X = lambda*B*X,
        and A is overwritten by inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H)

        If itype = 2 or 3, the problem is A*B*X = lambda*X or
        B*A*X = lambda*X, and A is overwritten by U*A*U**H or L**H*A*L.

        B must have been previously factorized as U**H*U or L*L**H by SPOTRF.
    \endverbatim

    * @param[in] itype
              itype is integer* \n
              = 1: compute inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H); \n
              = 2 or 3: compute U*A*U**H or L**H*A*L. \n
    * @param[in] uplo
              uplo is char* \n
              = 'U':  Upper triangle of a is stored and b is factored as
              U**H*U; \n
              = 'L':  Lower triangle of a is stored and b is factored as
              L*L**H. \n
    * @param[in] n
              n is integer* \n
              The order of the matrices a and b.  n >= 0. \n
    * @param[in,out] a
              a is COMPLEX/COMPLEX*16 array, dimension (lda,n) \n
              On entry, the symmetric matrix a.  If uplo = 'U', the leading
              n-by-n upper triangular part of a contains the upper
              triangular part of the matrix a, and the strictly lower
              triangular part of a is not referenced.  If uplo = 'L', the
              leading n-by-n lower triangular part of a contains the lower
              triangular part of the matrix a, and the strictly upper
              triangular part of a is not referenced. \n
              On exit, if info = 0, the transformed matrix, stored in the
              same format as a.
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the array a.  lda >= max(1,n). \n
    * @param[in] b
              b is COMPLEX/COMPLEX*16 array, dimension (ldb,n) \n
              The triangular factor from the Cholesky factorization of b,
              as returned by SPOTRF. \n
    * @param[in] ldb
              ldb is integer* \n
              The leading dimension of the array b.  ldb >= max(1,n). \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit \n
              < 0:  if INFO = -i, the i-th argument had an illegal value \n

    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer hegst(integer* itype, char* uplo, integer* n, T* a, integer* lda, T* b, integer* ldb, integer* info)
{
  return hegst(itype, uplo, n, a, lda, b, ldb, info);
}

/*! @brief Reduction of a symmetric-definite generalized eigenproblem to standard form (unblocked algorithm)
    *
    * @details
    * \b Purpose:
    * \verbatim
        Reduction of a real symmetric definite generalized eigenproblem to standard form, using the
        factorization results obtained from spotrf (unblocked algorithm).
        If itype = 1, the problem is A*X = lambda*B*X,
        and A is overwritten by inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T)

        If itype = 2 or 3, the problem is A*B*X = lambda*X or
        B*A*X = lambda*X, and A is overwritten by U*A*U**T or L**T *A*L.

        B must have been previously factorized as U**T *U or L*L**T by SPOTRF.
    \endverbatim

    * @param[in] itype
              itype is integer* \n
              = 1: compute inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T); \n
              = 2 or 3: compute U*A*U**T or L**T *A*L. \n
    * @param[in] uplo
              uplo is char* \n
              Specifies whether the upper or lower triangular part of the
              symmetric matrix a is stored, and how b has been factorized. \n
              = 'U':  Upper triangular \n
              = 'L':  Lower triangular \n
    * @param[in] n
              n is integer* \n
              The order of the matrices a and b.  n >= 0. \n
    * @param[in,out] a
              a is float/doublearray, dimension (lda,n) \n
              On entry, the symmetric matrix a.  If uplo = 'U', the leading
              n by n upper triangular part of a contains the upper
              triangular part of the matrix a, and the strictly lower
              triangular part of a is not referenced.  If uplo = 'L', the
              leading n by n lower triangular part of a contains the lower
              triangular part of the matrix a, and the strictly upper
              triangular part of a is not referenced. \n
              On exit, if info = 0, the transformed matrix, stored in the
              same format as a. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the array a.  lda >= max(1,n). \n
    * @param[in] b
              b is float/double array, dimension (ldb,n) \n
              The triangular factor from the Cholesky factorization of b,
              as returned by SPOTRF. \n
    * @param[in] ldb
              ldb is integer* \n
              The leading dimension of the array b.  ldb >= max(1,n). \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit. \n
              < 0:  if INFO = -i, the i-th argument had an illegal value. \n

    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer sygs2(integer* itype, char* uplo, integer* n, T* a, integer* lda, T* b, integer* ldb, integer* info)
{
  return sygs2(itype, uplo, n, a, lda, b, ldb, info);
}

/*! @brief Reduction of a Hermitian-definite generalized eigenproblem to standard form (unblocked algorithm)
    *
    * @details
    * \b Purpose:
    * \verbatim
        Reduction of a Hermitian definite generalized eigenproblem to standard form, using the
        factorization results obtained from cpotrf (unblocked algorithm).
        If itype = 1, the problem is A*X = lambda*B*X,
        and A is overwritten by inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H)

        If itype = 2 or 3, the problem is A*B*X = lambda*X or
        B*A*X = lambda*X, and A is overwritten by U*A*U**H or L**H *A*L.

        B must have been previously factorized as U**H *U or L*L**H by CPOTRF.
    \endverbatim

    * @param[in] itype
              itype is integer* \n
              = 1: compute inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H); \n
              = 2 or 3: compute U*A*U**H or L**H *A*L. \n
    * @param[in] uplo
              uplo is char* \n
              Specifies whether the upper or lower triangular part of the
              Hermitian matrix a is stored, and how b has been factorized. \n
              = 'U':  Upper triangular \n
              = 'L':  Lower triangular \n
    * @param[in] n
              n is integer* \n
              The order of the matrices a and b.  n >= 0. \n
    * @param[in,out] a
              a is COMPLEX/COMPLEX*16 array, dimension (lda,n) \n
              On entry, the symmetric matrix a.  If uplo = 'U', the leading
              n by n upper triangular part of a contains the upper
              triangular part of the matrix a, and the strictly lower
              triangular part of a is not referenced.  If uplo = 'L', the
              leading n by n lower triangular part of a contains the lower
              triangular part of the matrix a, and the strictly upper
              triangular part of a is not referenced. \n
              On exit, if info = 0, the transformed matrix, stored in the
              same format as a. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the array a.  lda >= max(1,n). \n
    * @param[in] b
              b is COMPLEX/COMPLEX*16 array, dimension (ldb,n) \n
              The triangular factor from the Cholesky factorization of b,
              as returned by CPOTRF. \n
    * @param[in] ldb
              ldb is integer* \n
              The leading dimension of the array b.  ldb >= max(1,n). \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit. \n
              < 0:  if INFO = -i, the i-th argument had an illegal value. \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer hegs2(integer* itype, char* uplo, integer* n, T* a, integer* lda, T* b, integer* ldb, integer* info)
{
  return hegs2(itype, uplo, n, a, lda, b, ldb, info);
}

/*! @brief Triangular factor of a block reflector
    *
    * @details
    * \b Purpose:
    * \verbatim
        Formation of the triangular factor T of a real block reflector H of order n, which is
        defined as a product of k elementary reflectors.

        If direct = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;

        If direct = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.

        If storev = 'C', the vector which defines the elementary reflector H(i) is stored in the
        i-th column of the array V, and

        H  =  I - V * T * V**T

        If storev = 'R', the vector which defines the elementary reflector H(i) is stored in the
        i-th row of the array V, and

        H  =  I - V**T * T * V
    \endverbatim

    * @param[in] direct
              direct is char* \n
              Specifies the order in which the elementary reflectors are
              multiplied to form the block reflector: \n
              = 'F': H = H(1) H(2) . . . H(k) (Forward) \n
              = 'B': H = H(k) . . . H(2) H(1) (Backward) \n
    * @param[in] storev
              storev is char* \n
              Specifies how the vectors which define the elementary
              reflectors are stored (see also Further Details): \n
              = 'C': columnwise \n
              = 'R': rowwise \n
    * @param[in] n
              n is integer* \n
              The order of the block reflector H. n >= 0. \n
    * @param[in] k
              k is integer* \n
              The order of the triangular factor T (= the number of
              elementary reflectors). K >= 1. \n
    * @param[in] v
              v is float/double/COMPLEX/COMPLEX*16 array, dimension \n
              (ldv,k) if storev = 'C' \n
              (ldv,k) if storev = 'R' \n
              The matrix v. See further details. \n
    * @param[in] ldv
              ldv is integer* \n
              The leading dimension of the array V. \n
              If storev = 'C', ldv >= max(1,n); if storev = 'R', ldv >= k. \n
    * @param[in] tau
              tau is float/double/COMPLEX/COMPLEX*16 array, dimension (k) \n
              tau(i) must contain the scalar factor of the elementary
              reflector H(i). \n
    * @param[out] t
              t is float/double/COMPLEX/COMPLEX*16 array, dimension (ldt,k) \n
              The k by k triangular factor T of the block reflector. \n
              If direct = 'F', T is upper triangular; if direct = 'B', T is
              lower triangular. The rest of the array is not used. \n
    * @param[in] ldt
              ldt is integer* \n
              The leading dimension of the array T. ldt >= k.
              *
              * \n
              * **Further Details**
              * \verbatim
                      The shape of the matrix V and the storage of the vectors which define the H(i) is best
                      illustrated by the following example with n = 5 and k = 3. The elements equal to 1
                      are not stored.

                      direct = 'F' and storev = 'C':   direct = 'F' and storev = 'R':

                      V = (  1)  V = (  1 v1 v1 v1 v1)
                      ( v1  1)   (  1 v2 v2 v2)
                      ( v1 v2  1)   (  1 v3 v3)
                      ( v1 v2 v3)
                      ( v1 v2 v3)

                      direct = 'B' and storev = 'C':   direct = 'B' and storev = 'R':

                      V = ( v1 v2 v3)  V = ( v1 v1  1)
                      ( v1 v2 v3)   ( v2 v2 v2  1)
                      (  1 v2 v3)   ( v3 v3 v3 v3  1)
                      (  1 v3)
                      (  1)
              \endverbatim
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer larft(char* direct, char* storev, integer* n, integer* k, T* v, integer* ldv, T* tau, T* t, integer* ldt)
{
  return larft(direct, storev, n, k, v, ldv, tau, t, ldt);
}

/*! @brief Generation of an elementary reflector (Householder matrix)
    *
    * @details
    * \b Purpose:
    * \verbatim
        Generation of a real elementary reflector (Householder matrix) H of order n, such that

        H * ( alpha) = ( beta),   H**T * H = I.
        (   X  )   (   0 )

        where alpha and beta are scalars, and X is an (n-1)-element real vector.
        H is represented in the form

        H = I - tau * ( 1) * ( 1 v**T) ,
        ( v)

        where tau is a real scalar and v is a real (n-1)-element vector.

        If the elements of X are all zero, then tau = 0 and H is taken to be the unit matrix.

        Otherwise  1 <= tau <= 2.
    \endverbatim

    * @param[in] n
              n is integer* \n
              The order of the elementary reflector. \n
    * @param[in,out] alpha
              alpha is float/double/COMPLEX/COMPLEX*16* \n
              On entry, the value alpha. \n
              On exit, it is overwritten with the value beta. \n
    * @param[in,out] x
              x is float/double/COMPLEX/COMPLEX*16 array, dimension (1+(N-2)*abs(incx)) \n
              On entry, the vector x. \n
              On exit, it is overwritten with the vector v. \n
    * @param[in] incx
              incx is integer* \n
              The increment between elements of X. incx > 0. \n
    * @param[out] tau
              tau is float/double/COMPLEX/COMPLEX*16* \n
              The value tau. \n

    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer larfg(integer* n, T* alpha, T* x, integer* incx, T* tau)
{
  return larfg(n, alpha, x, incx, tau);
}

/*! @brief Generation of an elementary reflector (Householder matrix) with non-negative beta
    *
    * @details
    * \b Purpose:
    * \verbatim
        Generation of a real elementary reflector H (Householder matrix) with non-negative beta
        of order n, such that

        H * ( alpha) = ( beta),   H**T * H = I.
        (   x  )   (   0 )

        where alpha and beta are scalars, beta is non-negative, and x is an (n-1)-element real vector.
        H is represented in the form

        H = I - tau * ( 1) * ( 1 v**T) ,
        ( v)

        where tau is a real scalar and v is a real (n-1)-element vector.

        If the elements of x are all zero, then tau = 0 and H is taken to be the unit matrix.
    \endverbatim

    * @param[in] n
              n is integer* \n
              The order of the elementary reflector. \n
    * @param[in,out] alpha
              alpha is float/double/COMPLEX/COMPLEX*16* \n
              On entry, the value alpha. \n
              On exit, it is overwritten with the value beta. \n
    * @param[in,out] x
              x is float/double/COMPLEX/COMPLEX*16 array, dimension (1+(N-2)*abs(incx)) \n
              On entry, the vector x. \n
              On exit, it is overwritten with the vector v. \n
    * @param[in] incx
              incx is integer* \n
              The increment between elements of X. incx > 0. \n
    * @param[out] tau
              tau is float/double/COMPLEX/COMPLEX*16* \n
              The value tau. \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer larfgp(integer* n, T* alpha, T* x, integer* incx, T* tau)
{
  return larfgp(n, alpha, x, incx, tau);
}

/*! @brief Form Q from QR factorization
    *
    * @details
    * \b Purpose:
    * \verbatim
        Generation of an m-by-n real matrix Q with orthonormal columns, which is defined as the
        first N columns of a product of K elementary reflectors of order M

        Q  =  H(1) H(2) . . . H(k)

        as returned by SGEQRF.
    \endverbatim
    
    * @param[in] m
              m is integer* \n
              The number of rows of the matrix Q. m >= 0. \n
    * @param[in] n
              n is integer* \n
              The number of columns of the matrix Q. m >= n >= 0. \n
    * @param[in] k
              k is integer* \n
              The number of elementary reflectors whose product defines the
              matrix Q. n >= k >= 0. \n
    * @param[in,out] a
              a is float/double array, dimension (lda,n) \n
              On entry, the i-th column must contain the vector which
              defines the elementary reflector H(i), for i = 1,2,...,k, as
              returned by SGEQRF in the first k columns of its array
              argument a. \n
              On exit, the m-by-n matrix Q. \n
    * @param[in] lda
              lda is integer* \n
              The first dimension of the array a. lda >= max(1,m). \n
    * @param[in] tau
              tau is float/double array, dimension (k) \n
              tau(i) must contain the scalar factor of the elementary
              reflector H(i), as returned by SGEQRF. \n
    * @param[out]	WORK	
              WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK)) \n
              On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
    * @param[in]	LWORK	
              LWORK is INTEGER \n
              The dimension of the array WORK. LWORK >= max(1,N).
              For optimum performance LWORK >= N*NB, where NB is the
              optimal blocksize. \n
 \n
              If LWORK = -1, then a workspace query is assumed; the routine
              only calculates the optimal size of the WORK array, returns
              this value as the first entry of the WORK array, and no error
              message related to LWORK is issued by XERBLA. \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit \n
              < 0:  if INFO = -i, the i-th argument has an illegal value \n

    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer orgqr(integer* m, integer* n, integer* k, T* a, integer* lda, T* tau, T* work, integer* lwork, integer* info)
{
  return orgqr(m, n, k,  a, lda, tau, work, lwork, info);
}

/*! @brief Form Q from QR factorization
    *
    * @details
    * \b Purpose:
    * \verbatim
        Generation of an m-by-n complex matrix Q with orthonormal columns, which is defined as the
        first N columns of a product of K elementary reflectors of order M

        Q  =  H(1) H(2) . . . H(k)

        as returned by SGEQRF.
    \endverbatim

    * @param[in] m
              m is integer* \n
              The number of rows of the matrix Q. m >= 0. \n
    * @param[in] n
              n is integer* \n
              The number of columns of the matrix Q. m >= n >= 0. \n
    * @param[in] k
              k is integer* \n
              The number of elementary reflectors whose product defines the
              matrix Q. n >= k >= 0. \n
    * @param[in,out] a
              a is COMPLEX/COMPLEX*16 array, dimension (lda,n) \n
              On entry, the i-th column must contain the vector which
              defines the elementary reflector H(i), for i = 1,2,...,k, as
              returned by CGEQRF in the first k columns of its array
              argument a. \n
              On exit, the m-by-n matrix Q. \n
    * @param[in] lda
              lda is integer* \n
              The first dimension of the array a. lda >= max(1,m). \n
    * @param[in] tau
              tau is COMPLEX/COMPLEX*16 array, dimension (k) \n
              tau(i) must contain the scalar factor of the elementary
              reflector H(i), as returned by SGEQRF. \n
    * @param[out]	WORK	
              WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
              On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
    * @param[in]	LWORK	
              LWORK is INTEGER \n
              The dimension of the array WORK. LWORK >= max(1,N).
              For optimum performance LWORK >= N*NB, where NB is the
              optimal blocksize. \n
 \n
              If LWORK = -1, then a workspace query is assumed; the routine
              only calculates the optimal size of the WORK array, returns
              this value as the first entry of the WORK array, and no error
              message related to LWORK is issued by XERBLA. \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit \n
              < 0:  if INFO = -i, the i-th argument has an illegal value \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer ungqr(integer* m, integer* n, integer* k, T* a, integer* lda, T* tau, T* work, integer* lwork, integer* info)
{
  return ungqr(m, n, k, a, lda, tau, work, lwork, info);
}

/*! @brief Apply Q or Q' from QR factorization
    *
    * @details
    * \b Purpose:
    * \verbatim
        Apply Q or Q' from QR factorization
        Overwrite the general real m-by-n matrix c with

        side = 'L'  side = 'R'
        trans = 'N':   Q * C C * Q
        trans = 'T':   Q**T * C C * Q**T

        where Q is a real orthogonal matrix defined as the product of k elementary reflectors

        Q = H(1) H(2) . . . H(k)

        as returned by SGEQRF. Q is of order M if side = 'L' and of order N if side = 'R'.
    \endverbatim

    * @param[in] side
              side is char* \n
              = 'L': apply Q or Q**T from the Left; \n
              = 'R': apply Q or Q**T from the Right. \n
    * @param[in] trans
              trans is char* \n
              = 'N':  No transpose, apply Q; \n
              = 'T':  Transpose, apply Q**T. \n
    * @param[in] m
              m is integer* \n
              The number of rows of the matrix c. m >= 0. \n
    * @param[in] n
              n is integer* \n
              The number of columns of the matrix c. n >= 0. \n
    * @param[in] k
              k is integer* \n
              The number of elementary reflectors whose product defines
              the matrix Q. \n
              If side = 'L', m >= k >= 0; \n
              if side = 'R', n >= k >= 0. \n
    * @param[in] a
              a is float/double array, dimension (lda,k) \n
              The i-th column must contain the vector which defines the
              elementary reflector H(i), for i = 1,2,...,k, as returned by
              SGEQRF in the first k columns of its array argument a. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the array a. \n
              If side = 'L', lda >= max(1,m); \n
              if side = 'R', lda >= max(1,n). \n
    * @param[in] tau
              tau is float/double array, dimension (k) \n
              tau(i) must contain the scalar factor of the elementary
              reflector H(i), as returned by SGEQRF. \n
    * @param[in,out] c
              c is float/double array, dimension (ldc,n) \n
              On entry, the m-by-n matrix c. \n
              On exit, c is overwritten by Q*C or Q**T*C or C*Q**T or C*Q. \n
    * @param[in] ldc
              ldc is integer* \n
              The leading dimension of the array c. ldc >= max(1,m). \n
    * @param[out]	WORK	
              WORK is REAL array, dimension (MAX(1,LWORK)) \n
              On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
    * @param[in]	LWORK	
              LWORK is INTEGER \n
              The dimension of the array WORK. \n
              If SIDE = 'L', LWORK >= max(1,N); \n
              if SIDE = 'R', LWORK >= max(1,M). \n
              For good performance, LWORK should generally be larger. \n
 \n
              If LWORK = -1, then a workspace query is assumed; the routine
              only calculates the optimal size of the WORK array, returns
              this value as the first entry of the WORK array, and no error
              message related to LWORK is issued by XERBLA. \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit \n
              < 0:  if INFO = -i, the i-th argument had an illegal value \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer ormqr(char* side, char* trans, integer* m, integer* n, integer* k, T* a, integer* lda, T* tau, T* c, integer* ldc, T* work, integer* lwork, integer* info)
{
  return ormqr(side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork, info);
}

/*! @brief Apply Q or Q' from QR factorization
    *
    * @details
    * \b Purpose:
    * \verbatim
        Apply Q or Q' from QR factorization
        Overwrite the general complex m-by-n matrix c with

        side = 'L'  side = 'R'
        trans = 'N':   Q * C C * Q
        trans = 'H':   Q**H * C C * Q**H

        where Q is a complex unitary matrix defined as the product of k elementary reflectors

        Q = H(1) H(2) . . . H(k)

        as returned by CGEQRF. Q is of order M if side = 'L' and of order N if side = 'R'.
    \endverbatim

    * @param[in] side
              side is char* \n
              = 'L': apply Q or Q**H from the Left; \n
              = 'R': apply Q or Q**H from the Right. \n
    * @param[in] trans
              trans is char* \n
              = 'N':  No transpose, apply Q; \n
              = 'H':  Transpose, apply Q**H. \n
    * @param[in] m
              m is integer* \n
              The number of rows of the matrix c. m >= 0. \n
    * @param[in] n
              n is integer* \n
              The number of columns of the matrix c. n >= 0. \n
    * @param[in] k
              k is integer* \n
              The number of elementary reflectors whose product defines
              the matrix Q. \n
              If side = 'L', m >= k >= 0; \n
              if side = 'R', n >= k >= 0. \n
    * @param[in] a
              a is COMPLEX/COMPLEX*16 array, dimension (lda,k) \n
              The i-th column must contain the vector which defines the
              elementary reflector H(i), for i = 1,2,...,k, as returned by
              CGEQRF in the first k columns of its array argument a. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the array a. \n
              If side = 'L', lda >= max(1,m); \n
              if side = 'R', lda >= max(1,n). \n
    * @param[in] tau
              tau is COMPLEX/COMPLEX*16 array, dimension (k) \n
              tau(i) must contain the scalar factor of the elementary
              reflector H(i), as returned by SGEQRF. \n
    * @param[in,out] c
              c is COMPLEX/COMPLEX*16 array, dimension (ldc,n) \n
              On entry, the m-by-n matrix c. \n
              On exit, c is overwritten by Q*C or Q**H*C or C*Q**H or C*Q. \n
    * @param[in] ldc
              ldc is integer* \n
              The leading dimension of the array c. ldc >= max(1,m). \n
    * @param[out]	WORK	
              WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
              On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
    * @param[in]	LWORK	
              LWORK is INTEGER \n
              The dimension of the array WORK. \n
              If SIDE = 'L', LWORK >= max(1,N); \n
              if SIDE = 'R', LWORK >= max(1,M). \n
              For good performance, LWORK should generally be larger. \n
 \n
              If LWORK = -1, then a workspace query is assumed; the routine
              only calculates the optimal size of the WORK array, returns
              this value as the first entry of the WORK array, and no error
              message related to LWORK is issued by XERBLA. \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit \n
              < 0:  if INFO = -i, the i-th argument had an illegal value \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer unmqr(char* side, char* trans, integer* m, integer* n, integer* k, T* a, integer* lda, T* tau, T* c, integer* ldc, T* work, integer* lwork, integer* info)
{
  return unmqr(side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork, info);
}

/*! @brief Multiply a general matrix by the orthogonal matrix from a QR factorization
    *   determined by sgeqrf (unblocked algorithm).
    *
    * @details
    * \b Purpose:
    * \verbatim
        Multiply a general matrix by the orthogonal matrix from a QR factorization determined by
        sgeqrf (unblocked algorithm).
        Overwrite the general real m by n matrix c with

        Q * C  if side = 'L' and trans = 'N', or

        Q**T* C  if side = 'L' and trans = 'T', or

        C * Q  if side = 'R' and trans = 'N', or

        C * Q**T if side = 'R' and trans = 'T',

        where Q is a real orthogonal matrix defined as the product of k elementary reflectors

        Q = H(1) H(2) . . . H(k)

        as returned by SGEQRF. Q is of order m if side = 'L' and of order n if side = 'R'.
    \endverbatim

    * @param[in] side
              side is char* \n
              = 'L': apply Q or Q**T from the Left; \n
              = 'R': apply Q or Q**T from the Right. \n
    * @param[in] trans
              trans is char* \n
              = 'N':  No transpose, apply Q; \n
              = 'T':  Transpose, apply Q**T. \n
    * @param[in] m
              m is integer* \n
              The number of rows of the matrix c. m >= 0. \n
    * @param[in] n
              n is integer* \n
              The number of columns of the matrix c. n >= 0. \n
    * @param[in] k
              k is integer* \n
              The number of elementary reflectors whose product defines
              the matrix Q. \n
              If side = 'L', m >= k >= 0; \n
              if side = 'R', n >= k >= 0. \n
    * @param[in] a
              a is float/double array, dimension (lda,k) \n
              The i-th column must contain the vector which defines the
              elementary reflector H(i), for i = 1,2,...,k, as returned by
              SGEQRF in the first k columns of its array argument a. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the array a. \n
              If side = 'L', lda >= max(1,m); \n
              if side = 'R', lda >= max(1,n). \n
    * @param[in] tau
              tau is float/double array, dimension (k) \n
              tau(i) must contain the scalar factor of the elementary
              reflector H(i), as returned by SGEQRF. \n
    * @param[in,out] c
              c is float/double array, dimension (ldc,n) \n
              On entry, the m-by-n matrix c. \n
              On exit, c is overwritten by Q*C or Q**T*C or C*Q**T or C*Q. \n
    * @param[in] ldc
              ldc is integer* \n
              The leading dimension of the array c. ldc >= max(1,m). \n
    * @param[out]	WORK	
              WORK is REAL array, dimension \n
                                       (N) if SIDE = 'L', \n
                                       (M) if SIDE = 'R' \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0: successful exit \n
              < 0: if INFO = -i, the i-th argument had an illegal value \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer orm2r(char* side, char* trans, integer* m, integer* n, integer* k, T* a, integer* lda, T* tau, T* c, integer* ldc, T* work, integer* info)
{
  return orm2r(side, trans, m, n, k, a, lda, tau, c, ldc, work, info);
}

/*! @brief Multiply a general matrix by the orthogonal matrix from a QR factorization
    *   determined by sgeqrf (unblocked algorithm).
    *
    * @details
    * \b Purpose:
    * \verbatim
        Multiply a general matrix by the orthogonal matrix from a QR factorization determined by
        sgeqrf (unblocked algorithm).
        Overwrite the general complex m by n matrix c with

        Q * C  if side = 'L' and trans = 'N', or

        Q**H* C  if side = 'L' and trans = 'C', or

        C * Q  if side = 'R' and trans = 'N', or

        C * Q**H if side = 'R' and trans = 'C',

        where Q is a complex unitary matrix defined as the product of k elementary reflectors

        Q = H(1) H(2) . . . H(k)

        as returned by SGEQRF. Q is of order m if side = 'L' and of order n if side = 'R'.
    \endverbatim

    * @param[in] side
              side is char* \n
              = 'L': apply Q or Q**H from the Left; \n
              = 'R': apply Q or Q**H from the Right. \n
    * @param[in] trans
              trans is char* \n
              = 'N':  No transpose, apply Q; \n
              = 'C':  Transpose, apply Q**H. \n
    * @param[in] m
              m is integer* \n
              The number of rows of the matrix c. m >= 0. \n
    * @param[in] n
              n is integer* \n
              The number of columns of the matrix c. n >= 0. \n
    * @param[in] k
              k is integer* \n
              The number of elementary reflectors whose product defines
              the matrix Q. \n
              If side = 'L', m >= k >= 0; \n
              if side = 'R', n >= k >= 0. \n
    * @param[in] a
              a is COMPLEX/COMPLEX*16 array, dimension (lda,k) \n
              The i-th column must contain the vector which defines the
              elementary reflector H(i), for i = 1,2,...,k, as returned by
              CGEQRF in the first k columns of its array argument a. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the array a. \n
              If side = 'L', lda >= max(1,m); \n
              if side = 'R', lda >= max(1,n). \n
    * @param[in] tau
              tau is COMPLEX/COMPLEX*16 array, dimension (k) \n
              tau(i) must contain the scalar factor of the elementary
              reflector H(i), as returned by CGEQRF. \n
    * @param[in,out] c
              c is COMPLEX/COMPLEX*16 array, dimension (ldc,n) \n
              On entry, the m-by-n matrix c. \n
              On exit, c is overwritten by Q*C or Q**H*C or C*Q**H or C*Q. \n
    * @param[in] ldc
              ldc is integer* \n
              The leading dimension of the array c. ldc >= max(1,m). \n
    * @param[out]	WORK	
              WORK is COMPLEX array, dimension \n
                                       (N) if SIDE = 'L', \n
                                       (M) if SIDE = 'R' \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0: successful exit \n
              < 0: if INFO = -i, the i-th argument had an illegal value \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer unm2r(char* side, char* trans, integer* m, integer* n, integer* k, T* a, integer* lda, T* tau, T* c, integer* ldc, T* work, integer* info)
{
  return unm2r(side, trans, m, n, k, a, lda, tau, c, ldc, work, info);
}

/*! @brief Form Q from LQ factorization
    *
    * @details
    * \b Purpose:
    * \verbatim
        Generate an m-by-n real matrix Q with orthonormal rows, which is defined as the first M
        rows of a product of K elementary reflectors of order N

        Q  =  H(k) . . . H(2) H(1)

        as returned by SGELQF.
    \endverbatim

    * @param[in] m
              m is integer* \n
              The number of rows of the matrix Q. m >= 0. \n
    * @param[in] n
              n is integer* \n
              The number of columns of the matrix Q. n >= m. \n
    * @param[in] k
              k is integer* \n
              The number of elementary reflectors whose product defines the
              matrix Q. m >= k >= 0. \n
    * @param[in,out] a
              a is float/doublearray, dimension (lda,n) \n
              On entry, the i-th row must contain the vector which defines
              the elementary reflector H(i), for i = 1,2,...,k, as returned
              by SGELQF in the first k rows of its array argument a.
              On exit, the m-by-n matrix Q. \n
    * @param[in] lda
              lda is integer* \n
              The first dimension of the array a. lda >= max(1,m). \n
    * @param[in] tau
              tau is float/double array, dimension (k) \n
              tau(i) must contain the scalar factor of the elementary
              reflector H(i), as returned by SGELQF. \n
    * @param[out]	WORK	
              WORK is REAL array, dimension (MAX(1,LWORK)) \n
              On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
    * @param[in]	LWORK	
              LWORK is INTEGER \n
              The dimension of the array WORK. LWORK >= max(1,M).
              For optimum performance LWORK >= M*NB, where NB is
              the optimal blocksize. \n
 \n
              If LWORK = -1, then a workspace query is assumed; the routine
              only calculates the optimal size of the WORK array, returns
              this value as the first entry of the WORK array, and no error
              message related to LWORK is issued by XERBLA. \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit \n
              < 0:  if INFO = -i, the i-th argument has an illegal value \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer orglq(integer* m, integer* n, integer* k, T* a, integer* lda, T* tau, T* work, integer* lwork, integer* info)
{
  return orglq(m, n, k, a, lda, tau, work, lwork, info);
}

/*! @brief Form Q from LQ factorization
    *
    * @details
    * \b Purpose:
    * \verbatim
        Generate an m-by-n complex matrix Q with orthonormal rows, which is defined as the first
        M rows of a product of K elementary reflectors of order N

        Q  =  H(k) . . . H(2) H(1)

        as returned by CGELQF.
    \endverbatim

    * @param[in] m
              m is integer* \n
              The number of rows of the matrix Q. m >= 0. \n
    * @param[in] n
              n is integer* \n
              The number of columns of the matrix Q. n >= m. \n
    * @param[in] k
              k is integer* \n
              The number of elementary reflectors whose product defines the
              matrix Q. m >= k >= 0. \n
    * @param[in,out] a
              a is COMPLEX/COMPLEX*16 array, dimension (lda,n) \n
              On entry, the i-th row must contain the vector which defines
              the elementary reflector H(i), for i = 1,2,...,k, as returned
              by CGELQF in the first k rows of its array argument a. \n
              On exit, the m-by-n matrix Q. \n
    * @param[in] lda
              lda is integer* \n
              The first dimension of the array a. lda >= max(1,m). \n
    * @param[in] tau
              tau is COMPLEX/COMPLEX*16 array, dimension (k) \n
              tau(i) must contain the scalar factor of the elementary
              reflector H(i), as returned by CGELQF. \n
    * @param[out]	WORK	
              WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
              On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
    * @param[in]	LWORK	
              LWORK is INTEGER \n
              The dimension of the array WORK. LWORK >= max(1,M).
              For optimum performance LWORK >= M*NB, where NB is
              the optimal blocksize. \n
 \n
              If LWORK = -1, then a workspace query is assumed; the routine
              only calculates the optimal size of the WORK array, returns
              this value as the first entry of the WORK array, and no error
              message related to LWORK is issued by XERBLA. \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit; \n
              < 0:  if INFO = -i, the i-th argument has an illegal value \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer unglq(integer* m, integer* n, integer* k, T* a, integer* lda, T* tau, T* work, integer* lwork, integer* info)
{
  return unglq(m, n, k, a, lda, tau, work, lwork, info);
}

/*! @brief Apply Q or Q' from LQ factorization
    *
    * @details
    * \b Purpose:
    * \verbatim
        Apply Q or Q' from LQ factorization. Overwrite the general real m-by-n matrix c with

        side = 'L'  side = 'R'
        trans = 'N':   Q * C C * Q
        trans = 'T':   Q**T * C C * Q**T

        where Q is a real orthogonal matrix defined as the product of k elementary reflectors

        Q = H(k) . . . H(2) H(1)

        as returned by SGELQF. Q is of order M if side = 'L' and of order N if side = 'R'.
    \endverbatim

    * @param[in] side
              side is char* \n
              = 'L': apply Q or Q**T from the Left; \n
              = 'R': apply Q or Q**T from the Right. \n
    * @param[in] trans
              trans is char* \n
              = 'N':  No transpose, apply Q; \n
              = 'T':  Transpose, apply Q**T. \n
    * @param[in] m
              m is integer* \n
              The number of rows of the matrix c. m >= 0. \n
    * @param[in] n
              n is integer* \n
              The number of columns of the matrix c. n >= 0. \n
    * @param[in] k
              k is integer* \n
              The number of elementary reflectors whose product defines
              the matrix Q. \n
              If side = 'L', m >= k >= 0; \n
              if side = 'R', n >= k >= 0. \n
    * @param[in] a
              a is float/double/ array, dimension \n
              (lda,m) if side = 'L', \n
              (lda,n) if side = 'R' \n
              The i-th row must contain the vector which defines the
              elementary reflector H(i), for i = 1,2,...,k, as returned by
              SGELQF in the first k rows of its array argument a. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the array a. lda >= max(1,k). \n
    * @param[in] tau
              tau is float/double array, dimension (k) \n
              tau(i) must contain the scalar factor of the elementary
              reflector H(i), as returned by SGELQF. \n
    * @param[in,out] c
              c is float/double array, dimension (ldc,n) \n
              On entry, the m-by-n matrix c. \n
              On exit, c is overwritten by Q*C or Q**T*C or C*Q**T or C*Q. \n
    * @param[in] ldc
              ldc is integer* \n
              The leading dimension of the array c. ldc >= max(1,m). \n
    * @param[out]	WORK	
              WORK is REAL array, dimension (MAX(1,LWORK)) \n
              On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
    * @param[in]	LWORK	
              LWORK is INTEGER \n
              The dimension of the array WORK. \n
              If SIDE = 'L', LWORK >= max(1,N); \n
              if SIDE = 'R', LWORK >= max(1,M). \n
              For good performance, LWORK should generally be larger. \n
 \n
              If LWORK = -1, then a workspace query is assumed; the routine
              only calculates the optimal size of the WORK array, returns
              this value as the first entry of the WORK array, and no error
              message related to LWORK is issued by XERBLA. \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit \n
              < 0:  if INFO = -i, the i-th argument had an illegal value \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer ormlq(char* side, char* trans, integer* m, integer* n, integer* k, T* a, integer* lda, T* tau, T* c, integer* ldc, T* work, integer* lwork, integer* info)
{
  return ormlq(side, trans,  m, n, k, a, lda, tau, c, ldc, work, lwork, info);
}

/*! @brief Apply Q or Q' from LQ factorization
    *
    * @details
    * \b Purpose:
    * \verbatim
        Apply Q or Q' from LQ factorization. Overwrite the general complex m-by-n matrix c with

        side = 'L'  side = 'R'
        trans = 'N':   Q * C C * Q
        trans = 'C':   Q**H * C C * Q**H

        where Q is a complex unitary matrix defined as the product of k elementary reflectors

        Q = H(k)**H . . . H(2)**H H(1)**H

        as returned by CGELQF. Q is of order M if side = 'L' and of order N if side = 'R'.
    \endverbatim

    * @param[in] side
              side is char* \n
              = 'L': apply Q or Q**H from the Left; \n
              = 'R': apply Q or Q**H from the Right. \n
    * @param[in] trans
              trans is char* \n
              = 'N':  No transpose, apply Q; \n
              = 'C':  Conjugate transpose, apply Q**H. \n
    * @param[in] m
              m is integer* \n
              The number of rows of the matrix c. m >= 0. \n
    * @param[in] n
              n is integer* \n
              The number of columns of the matrix c. n >= 0. \n
    * @param[in] k
              k is integer* \n
              The number of elementary reflectors whose product defines
              the matrix Q. \n
              If side = 'L', m >= k >= 0; \n
              if side = 'R', n >= k >= 0. \n
    * @param[in] a
              a is COMPLEX/COMPLEX*16 array, dimension \n
              (lda,m) if side = 'L', \n
              (lda,n) if side = 'R' \n
              The i-th row must contain the vector which defines the
              elementary reflector H(i), for i = 1,2,...,k, as returned by
              CGELQF in the first k rows of its array argument a. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the array a. lda >= max(1,k). \n
    * @param[in] tau
              tau is COMPLEX/COMPLEX*16 array, dimension (k) \n
              tau(i) must contain the scalar factor of the elementary
              reflector H(i), as returned by CGELQF. \n
    * @param[in,out] c
              c is COMPLEX/COMPLEX*16 array, dimension (ldc,n) \n
              On entry, the m-by-n matrix c. \n
              On exit, c is overwritten by Q*C or Q**T*C or C*Q**T or C*Q. \n
    * @param[in] ldc
              ldc is integer* \n
              The leading dimension of the array c. ldc >= max(1,m). \n
    * @param[out]	WORK	
              WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
              On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
    * @param[in]	LWORK	
              LWORK is INTEGER \n
              The dimension of the array WORK. \n
              If SIDE = 'L', LWORK >= max(1,N); \n
              if SIDE = 'R', LWORK >= max(1,M). \n
              For good performance, LWORK should generally be larger. \n
 \n
              If LWORK = -1, then a workspace query is assumed; the routine
              only calculates the optimal size of the WORK array, returns
              this value as the first entry of the WORK array, and no error
              message related to LWORK is issued by XERBLA. \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit \n
              < 0:  if INFO = -i, the i-th argument had an illegal value \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer unmlq(char* side, char* trans, integer* m, integer* n, integer* k, T* a, integer* lda, T* tau, T* c, integer* ldc, T* work, integer* lwork, integer* info)
{
  return unmlq(side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork, info);
}

/*! @brief Apply Q or Q' from LQ factorization
    *
    * @details
    * \b Purpose:
    * \verbatim
        Apply Q or Q' from LQ factorization. Overwrite the general real m-by-n matrix c with

        Q * C  if side = 'L' and trans = 'N', or

        Q**T* C  if side = 'L' and trans = 'T', or

        C * Q  if side = 'R' and trans = 'N', or

        C * Q**T if side = 'R' and trans = 'T',

        where Q is a real orthogonal matrix defined as the product of k elementary reflectors

        Q = H(k) . . . H(2) H(1)

        as returned by SGELQF. Q is of order m if side = 'L' and of order n
    \endverbatim

    * @param[in] side
              side is char* \n
              = 'L': apply Q or Q**T from the Left; \n
              = 'R': apply Q or Q**T from the Right. \n
    * @param[in] trans
              trans is char* \n
              = 'N':  No transpose, apply Q; \n
              = 'T':  Transpose, apply Q**T. \n
    * @param[in] m
              m is integer* \n
              The number of rows of the matrix c. m >= 0. \n
    * @param[in] n
              n is integer* \n
              The number of columns of the matrix c. n >= 0. \n
    * @param[in] k
              k is integer* \n
              The number of elementary reflectors whose product defines
              the matrix Q. \n
              If side = 'L', m >= k >= 0; \n
              if side = 'R', n >= k >= 0. \n
    * @param[in] a
              a is float/double array, dimension \n
              (lda,m) if side = 'L', \n
              (lda,n) if side = 'R' \n
              The i-th row must contain the vector which defines the
              elementary reflector H(i), for i = 1,2,...,k, as returned by
              SGELQF in the first k rows of its array argument a. \n
              a is modified by the routine but restored on exit. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the array a. lda >= max(1,k). \n
    * @param[in] tau
              tau is float/double array, dimension (k) \n
              tau(i) must contain the scalar factor of the elementary
              reflector H(i), as returned by SGELQF. \n
    * @param[in,out] c
              c is float/double array, dimension (ldc,n) \n
              On entry, the m-by-n matrix c. \n
              On exit, c is overwritten by Q*C or Q**T*C or C*Q**T or C*Q. \n
    * @param[in] ldc
              ldc is integer* \n
              The leading dimension of the array c. ldc >= max(1,m). \n
    * @param[out]	WORK	
              WORK is REAL array, dimension \n
                                       (N) if SIDE = 'L', \n
                                       (M) if SIDE = 'R' \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0: successful exit \n
              < 0: if INFO = -i, the i-th argument had an illegal value \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer orml2(char* side, char* trans, integer* m, integer* n, integer* k, T* a, integer* lda, T* tau, T* c, integer* ldc, T* work, integer* info)
{
  return orml2(side, trans, m, n, k, a, lda, tau, c, ldc, work, info);
}

/*! @brief Apply Q or Q' from LQ factorization
    *
    * @details
    * \b Purpose:
    * \verbatim
        Apply Q or Q' from LQ factorization. Overwrite the general complex m-by-n matrix c with

        Q * C  if side = 'L' and trans = 'N', or

        Q**H* C  if side = 'L' and trans = 'C', or

        C * Q  if side = 'R' and trans = 'N', or

        C * Q**H if side = 'R' and trans = 'C',

        where Q is a complex unitary matrix defined as the product of k elementary reflectors

        Q = H(k)**H . . . H(2)**H H(1)**H

        as returned by CGELQF. Q is of order m if side = 'L' and of order n
    \endverbatim

    * @param[in] side
              side is char* \n
              = 'L': apply Q or Q**T from the Left; \n
              = 'R': apply Q or Q**T from the Right. \n
    * @param[in] trans
              trans is char* \n
              = 'N':  No transpose, apply Q; \n
              = 'T':  Transpose, apply Q**T. \n
    * @param[in] m
              m is integer* \n
              The number of rows of the matrix c. m >= 0. \n
    * @param[in] n
              n is integer* \n
              The number of columns of the matrix c. n >= 0. \n
    * @param[in] k
              k is integer* \n
              The number of elementary reflectors whose product defines
              the matrix Q. \n
              If side = 'L', m >= k >= 0; \n
              if side = 'R', n >= k >= 0. \n
    * @param[in] a
              a is COMPLEX/COMPLEX*16 array, dimension \n
              (lda,m) if side = 'L', \n
              (lda,n) if side = 'R' \n
              The i-th row must contain the vector which defines the
              elementary reflector H(i), for i = 1,2,...,k, as returned by
              CGELQF in the first k rows of its array argument a. \n
              a is modified by the routine but restored on exit. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the array a. lda >= max(1,k). \n
    * @param[in] tau
              tau is COMPLEX/COMPLEX*16 array, dimension (k) \n
              tau(i) must contain the scalar factor of the elementary
              reflector H(i), as returned by CGELQF. \n
    * @param[in,out] c
              c is COMPLEX/COMPLEX*16 array, dimension (ldc,n) \n
              On entry, the m-by-n matrix c. \n
              On exit, c is overwritten by Q*C or Q**H*C or C*Q**H or C*Q. \n
    * @param[in] ldc
              ldc is integer* \n
              The leading dimension of the array c. ldc >= max(1,m). \n
    * @param[out]	WORK	
              WORK is COMPLEX array, dimension \n
                                       (N) if SIDE = 'L', \n
                                       (M) if SIDE = 'R' \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0: successful exit \n
              < 0: if INFO = -i, the i-th argument had an illegal value \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer unml2(char* side, char* trans, integer* m, integer* n, integer* k, T* a, integer* lda, T* tau, T* c, integer* ldc, T* work, integer* info)
{
  return unml2(side, trans, m, n, k, a, lda, tau, c, ldc, work, info);
}

/*! @brief Form Q from tridiagonal reduction
    *
    * @details
    * \b Purpose:
    * \verbatim
    Form Q from tridiagonal reduction. Generate a real orthogonal matrix Q which is defined as
    the product of n-1 elementary reflectors of order M, as returned by SSYTRD:

        if uplo = 'U', Q = H(n-1) . . . H(2) H(1),

        if uplo = 'L', Q = H(1) H(2) . . . H(n-1).
    \endverbatim

    * @param[in] uplo
              uplo is char* \n
              = 'U': Upper triangle of a contains elementary reflectors
              from SSYTRD; \n
              = 'L': Lower triangle of a contains elementary reflectors
              from SSYTRD. \n
    * @param[in] m
              m is integer* \n
              The order of the matrix Q. m >= 0. \n
    * @param[in,out] a
              a is float/double array, dimension (lda,m) \n
              On entry, the vectors which define the elementary reflectors,
              as returned by SSYTRD. \n
              On exit, the m-by-m orthogonal matrix Q. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the array a. lda >= max(1,m). \n
    * @param[in] tau
              tau is float/double array, dimension (m-1) \n
              tau(i) must contain the scalar factor of the elementary
              reflector H(i), as returned by SSYTRD. \n
    * @param[out]	WORK	
              WORK is REAL array, dimension (MAX(1,LWORK)) \n
              On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
    * @param[in]	LWORK	
              LWORK is INTEGER \n
              The dimension of the array WORK. LWORK >= max(1,N-1). \n
              For optimum performance LWORK >= (N-1)*NB, where NB is
              the optimal blocksize. \n
 \n
              If LWORK = -1, then a workspace query is assumed; the routine
              only calculates the optimal size of the WORK array, returns
              this value as the first entry of the WORK array, and no error
              message related to LWORK is issued by XERBLA. \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit \n
              < 0:  if INFO = -i, the i-th argument had an illegal value \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer orgtr(char* uplo, integer* m, T* a, integer* lda, T* tau, T* work, integer* lwork, integer* info)
{
  return orgtr(uplo, m, a, lda, tau, work, lwork, info);
}

/*! @brief Form Q from tridiagonal reduction
    *
    * @details
    * \b Purpose:
    * \verbatim
    Form Q from tridiagonal reduction. Generate a complex unitary matrix Q which is defined as
    the product of n-1 elementary reflectors of order M, as returned by CHETRD:

        if uplo = 'U', Q = H(n-1) . . . H(2) H(1),

        if uplo = 'L', Q = H(1) H(2) . . . H(n-1).
    \endverbatim

    * @param[in] uplo
              uplo is char* \n
              = 'U': Upper triangle of a contains elementary reflectors
              from CHETRD; \n
              = 'L': Lower triangle of a contains elementary reflectors
              from CHETRD. \n
    * @param[in] m
              m is integer* \n
              The order of the matrix Q. m >= 0. \n
    * @param[in,out] a
              a is COMPLEX/COMPLEX*16 array, dimension (lda,m) \n
              On entry, the vectors which define the elementary reflectors,
              as returned by CHETRD. \n
              On exit, the m-by-m orthogonal matrix Q. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the array a. lda >= max(1,m). \n
    * @param[in] tau
              tau is COMPLEX/COMPLEX*16 array, dimension (m-1) \n
              tau(i) must contain the scalar factor of the elementary
              reflector H(i), as returned by CHETRD. \n
    * @param[out]	WORK	
              WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
              On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
    * @param[in]	LWORK	
              LWORK is INTEGER \n
              The dimension of the array WORK. LWORK >= N-1. \n
              For optimum performance LWORK >= (N-1)*NB, where NB is
              the optimal blocksize. \n
 \n
              If LWORK = -1, then a workspace query is assumed; the routine
              only calculates the optimal size of the WORK array, returns
              this value as the first entry of the WORK array, and no error
              message related to LWORK is issued by XERBLA. \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit \n
              < 0:  if INFO = -i, the i-th argument had an illegal value \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer ungtr(char* uplo, integer* m, T* a, integer* lda, T* tau, T* work, integer* lwork, integer* info)
{
  return ungtr(uplo, m, a, lda, tau, work, lwork, info);
}

/*! @brief Apply Q or Q' from tridiagonal reduction
    *
    * @details
    * \b Purpose:
    * \verbatim
        Apply Q or Q' from tridiagonal reduction. Overwrite the general real m-by-n matrix c with

        side = 'L'  side = 'R'
        trans = 'N':   Q * C C * Q
        trans = 'T':   Q**T * C C * Q**T

        where Q is a real orthogonal matrix of order nq, with nq = m if side = 'L' and nq = n if
        side = 'R'. Q is defined as the product of nq-1 elementary reflectors, as returned by SSYTRD:

        if uplo = 'U', Q = H(nq-1) . . . H(2) H(1);

        if uplo = 'L', Q = H(1) H(2) . . . H(nq-1).
    \endverbatim

    * @param[in] side
              side is char* \n
              = 'L': apply Q or Q**T from the Left; \n
              = 'R': apply Q or Q**T from the Right. \n
    * @param[in] uplo
              uplo is char* \n
              = 'U': Upper triangle of a contains elementary reflectors
              from SSYTRD; \n
              = 'L': Lower triangle of a contains elementary reflectors
              from SSYTRD. \n
    * @param[in] trans
              trans is char* \n
              = 'N':  No transpose, apply Q; \n
              = 'T':  Transpose, apply Q**T. \n
    * @param[in] m
              m is integer* \n
              The number of rows of the matrix c. m >= 0. \n
    * @param[in] n
              n is integer* \n
              The number of columns of the matrix c. n >= 0. \n
    * @param[in] a
              a is float/double array, dimension \n
              (lda,m) if side = 'L' \n
              (lda,n) if side = 'R' \n
              The vectors which define the elementary reflectors, as
              returned by SSYTRD. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the array a. \n
              lda >= max(1,m) if side = 'L'; lda >= max(1,n) if side = 'R'. \n
    * @param[in] tau
              tau is float/double array, dimension \n
              (m-1) if side = 'L' \n
              (n-1) if side = 'R' \n
              tau(i) must contain the scalar factor of the elementary
              reflector H(i), as returned by SSYTRD. \n
    * @param[in,out] c
              c is float/double array, dimension (ldc,n) \n
              On entry, the m-by-n matrix c. \n
              On exit, c is overwritten by Q*C or Q**T*C or C*Q**T or C*Q. \n
    * @param[in] ldc
              ldc is integer* \n
              The leading dimension of the array c. ldc >= max(1,m). \n
    * @param[out]	WORK	
              WORK is REAL array, dimension (MAX(1,LWORK)) \n
              On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
    * @param[in]	LWORK	
              LWORK is INTEGER \n
              The dimension of the array WORK. \n
              If SIDE = 'L', LWORK >= max(1,N); \n
              if SIDE = 'R', LWORK >= max(1,M). \n
              For optimum performance LWORK >= N*NB if SIDE = 'L', and
              LWORK >= M*NB if SIDE = 'R', where NB is the optimal
              blocksize. \n
 \n
              If LWORK = -1, then a workspace query is assumed; the routine
              only calculates the optimal size of the WORK array, returns
              this value as the first entry of the WORK array, and no error
              message related to LWORK is issued by XERBLA. \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit \n
              < 0:  if INFO = -i, the i-th argument had an illegal value \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer ormtr(char* side, char* uplo, char* trans, integer* m, integer* n, T* a, integer* lda, T* tau, T* c, integer* ldc, T* work, integer* lwork, integer* info)
{
  return ormtr(side, uplo, trans, m, n, a, lda, tau, c, ldc, work, lwork, info);
}

/*! @brief Apply Q or Q' from tridiagonal reduction
    *
    * @details
    * \b Purpose:
    * \verbatim
        Apply Q or Q' from tridiagonal reduction. Overwrite the general complex m-by-n matrix c with

            side = 'L'  side = 'R'
            trans = 'N':   Q * C C * Q
            trans = 'C':   Q**H * C C * Q**H

        where Q is a complex unitary matrix of order nq, with nq = m if side = 'L' and nq = n if
        side = 'R'. Q is defined as the product of nq-1 elementary reflectors, as returned by CHETRD:

            if uplo = 'U', Q = H(nq-1) . . . H(2) H(1);

            if uplo = 'L', Q = H(1) H(2) . . . H(nq-1).
    \endverbatim

    * @param[in] side
              side is char* \n
              = 'L': apply Q or Q**H from the Left; \n
              = 'R': apply Q or Q**H from the Right. \n
    * @param[in] uplo
              uplo is char* \n
              = 'U': Upper triangle of a contains elementary reflectors
              from CHETRD; \n
              = 'L': Lower triangle of a contains elementary reflectors
              from CHETRD. \n
    * @param[in] trans
              trans is char* \n
              = 'N':  No transpose, apply Q; \n
              = 'C':  Transpose, apply Q**C. \n
    * @param[in] m
              m is integer* \n
              The number of rows of the matrix c. m >= 0. \n
    * @param[in] n
              n is integer* \n
              The number of columns of the matrix c. n >= 0. \n
    * @param[in] a
              a is COMPLEX/COMPLEX*16 array, dimension \n
              (lda,m) if side = 'L' \n
              (lda,n) if side = 'R' \n
              The vectors which define the elementary reflectors, as
              returned by CHETRD. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the array a. \n
              lda >= max(1,m) if side = 'L'; lda >= max(1,n) if side = 'R'. \n
    * @param[in] tau
              tau is COMPLEX/COMPLEX*16 array, dimension \n
              (m-1) if side = 'L' \n
              (n-1) if side = 'R' \n
              tau(i) must contain the scalar factor of the elementary
              reflector H(i), as returned by CHETRD. \n
    * @param[in,out] c
              c is COMPLEX/COMPLEX*16 array, dimension (ldc,n) \n
              On entry, the m-by-n matrix c. \n
              On exit, c is overwritten by Q*C or Q**H*C or C*Q**H or C*Q. \n
    * @param[in] ldc
              ldc is integer* \n
              The leading dimension of the array c. ldc >= max(1,m). \n
    * @param[out]	WORK	
              WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
              On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
    * @param[in]	LWORK	
              LWORK is INTEGER \n
              The dimension of the array WORK. \n
              If SIDE = 'L', LWORK >= max(1,N); \n
              if SIDE = 'R', LWORK >= max(1,M). \n
              For optimum performance LWORK >= N*NB if SIDE = 'L', and
              LWORK >=M*NB if SIDE = 'R', where NB is the optimal
              blocksize. \n
 \n
              If LWORK = -1, then a workspace query is assumed; the routine
              only calculates the optimal size of the WORK array, returns
              this value as the first entry of the WORK array, and no error
              message related to LWORK is issued by XERBLA. \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit \n
              < 0:  if INFO = -i, the i-th argument had an illegal value \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer unmtr(char* side, char* uplo, char* trans, integer* m, integer* n, T* a, integer* lda, T* tau, T* c, integer* ldc, T* work, integer* lwork, integer* info)
{
  return unmtr(side, uplo, trans, m, n, a, lda, tau, c, ldc, work, lwork, info);
}

/*! @brief Form Q from bidiagonal reduction
    *
    * @details
    * \b Purpose:
    * \verbatim
        Generate one of the real orthogonal matrices Q or P**T determined by SGEBRD when reducing
        a real matrix a to bidiagonal form: A = Q * B * P**T.  Q and P**T are defined as products
        of elementary reflectors H(i) or G(i) respectively.

        If vect = 'Q', A is assumed to have been an M-by-K matrix, and Q is of order M:
        if m >= k, Q = H(1) H(2) . . . H(k) and SORGBR returns the first n columns of Q,
        where m >= n >= k;
        if m < k, Q = H(1) H(2) . . . H(m-1) and SORGBR returns Q as an M-by-M matrix.

        If vect = 'P', A is assumed to have been a K-by-N matrix, and P**T is of order N:
        if k < n, P**T = G(k) . . . G(2) G(1) and SORGBR returns the first m rows of P**T,
        where n >= m >= k;
        if k >= n, P**T = G(n-1) . . . G(2) G(1) and SORGBR returns P**T as an n-by-n matrix.
    \endverbatim

    * @param[in] vect
              vect is char* \n
              Specifies whether the matrix Q or the matrix P**T is
              required, as defined in the transformation applied by SGEBRD:
              = 'Q':  generate Q; \n
              = 'P':  generate P**T. \n
    * @param[in] m
              m is integer* \n
              The number of rows of the matrix Q or P**T to be returned.
              m >= 0. \n
    * @param[in] n
              n is integer* \n
              The number of columns of the matrix Q or P**T to be returned.
              n >= 0. \n
              If vect = 'Q', m >= n >= min(m,k); \n
              if vect = 'P', n >= m >= min(n,k). \n
    * @param[in] k
              k is integer* \n
              If vect = 'Q', the number of columns in the original M-by-K
              matrix reduced by SGEBRD. \n
              If vect = 'P', the number of rows in the original K-by-N
              matrix reduced by SGEBRD. \n
              k >= 0. \n
    * @param[in,out] a
              a is float/double array, dimension (lda,n) \n
              On entry, the vectors which define the elementary reflectors,
              as returned by SGEBRD. \n
              On exit, the m-by-n matrix Q or P**T. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the array a. lda >= max(1,m). \n
    * @param[in] tau
              tau is float/double array, dimension \n
              (min(m,k)) if vect = 'Q' \n
              (min(n,k)) if vect = 'P' \n
              tau(i) must contain the scalar factor of the elementary
              reflector H(i) or G(i), which determines Q or P**T, as
              returned by SGEBRD in its array argument tauq or taup. \n
    * @param[out]	WORK	
              WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK)) \n
              On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
    * @param[in]	LWORK	
              LWORK is INTEGER \n
              The dimension of the array WORK. LWORK >= max(1,min(M,N)).
              For optimum performance LWORK >= min(M,N)*NB, where NB
              is the optimal blocksize. \n
 \n
              If LWORK = -1, then a workspace query is assumed; the routine
              only calculates the optimal size of the WORK array, returns
              this value as the first entry of the WORK array, and no error
              message related to LWORK is issued by XERBLA. \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit \n
              < 0:  if INFO = -i, the i-th argument had an illegal value \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer orgbr(char* vect, integer* m, integer* n, integer* k, T* a, integer* lda, T* tau, T* work, integer* lwork, integer* info)
{
  return orgbr(vect, m, n, k, a, lda, tau, work, lwork, info);
}

/*! @brief Form Q from bidiagonal reduction
    *
    * @details
    * \b Purpose:
    * \verbatim
        Generate one of the complex unitary matrices Q or P**H determined by CGEBRD when reducing
        a complex matrix a to bidiagonal form: A = Q * B * P**H.  Q and P**H are defined as
        products of elementary reflectors H(i) or G(i) respectively.

        If vect = 'Q', A is assumed to have been an M-by-K matrix, and Q is of order M:
        if m >= k, Q = H(1) H(2) . . . H(k) and CUNGBR returns the first n columns of Q,
        where m >= n >= k;
        if m < k, Q = H(1) H(2) . . . H(m-1) and CUNGBR returns Q as an M-by-M matrix.

        If vect = 'P', A is assumed to have been a K-by-N matrix, and P**H is of order N:
        if k < n, P**H = G(k) . . . G(2) G(1) and CUNGBR returns the first m rows of P**H,
        where n >= m >= k;
        if k >= n, P**H = G(n-1) . . . G(2) G(1) and CUNGBR returns P**H as an n-by-n matrix.
    \endverbatim

    * @param[in] vect
              vect is char* \n
              Specifies whether the matrix Q or the matrix P**H is
              required, as defined in the transformation applied by CGEBRD: \n
              = 'Q':  generate Q; \n
              = 'P':  generate P**H. \n
    * @param[in] m
              m is integer* \n
              The number of rows of the matrix Q or P**H to be returned. \n
              m >= 0.
    * @param[in] n
              n is integer* \n
              The number of columns of the matrix Q or P**H to be returned. \n
              n >= 0. \n
              If vect = 'Q', m >= n >= min(m,k); \n
              if vect = 'P', n >= m >= min(n,k). \n
    * @param[in] k
              k is integer* \n
              If vect = 'Q', the number of columns in the original M-by-K
              matrix reduced by CGEBRD. \n
              If vect = 'P', the number of rows in the original K-by-N
              matrix reduced by CGEBRD. \n
              k >= 0.
    * @param[in,out] a
              a is COMPLEX/COMPLEX*16 array, dimension (lda,n) \n
              On entry, the vectors which define the elementary reflectors,
              as returned by CGEBRD. \n
              On exit, the m-by-n matrix Q or P**H. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the array a. lda >= max(1,m).
    * @param[in] tau
              tau is COMPLEX/COMPLEX*16 array, dimension \n
              (min(m,k)) if vect = 'Q' \n
              (min(n,k)) if vect = 'P' \n
              tau(i) must contain the scalar factor of the elementary
              reflector H(i) or G(i), which determines Q or P**H, as
              returned by CGEBRD in its array argument tauq or taup. \n
    * @param[out]	WORK	
              WORK is COMPLEX*16 array, dimension (MAX(1,LWORK)) \n
              On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
    * @param[in]	LWORK	
              LWORK is INTEGER \n
              The dimension of the array WORK. LWORK >= max(1,min(M,N)).
              For optimum performance LWORK >= min(M,N)*NB, where NB
              is the optimal blocksize. \n
 \n
              If LWORK = -1, then a workspace query is assumed; the routine
              only calculates the optimal size of the WORK array, returns
              this value as the first entry of the WORK array, and no error
              message related to LWORK is issued by XERBLA. \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit \n
              < 0:  if INFO = -i, the i-th argument had an illegal value \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer ungbr(char* vect, integer* m, integer* n, integer* k, T* a, integer* lda, T* tau, T* work, integer* lwork, integer* info)
{
  return ungbr(vect, m, n, k, a, lda, tau, work, lwork, info);
}

/*! @brief Apply Q or Q' from bidiagonal reduction
    *
    * @details
    * \b Purpose:
    * \verbatim
        If vect = 'Q', SORMBR overwrites the general real m-by-n matrix c with
            side = 'L'  side = 'R'
            trans = 'N':   Q * C C * Q
            trans = 'T':   Q**T * C C * Q**T

        If vect = 'P', SORMBR overwrites the general real m-by-n matrix c with
            side = 'L'  side = 'R'
            trans = 'N':   P * C C * P
            trans = 'T':   P**T * C C * P**T

        Here Q and P**T are the orthogonal matrices determined by SGEBRD when reducing a real
        matrix a to bidiagonal form: A = Q * B * P**T. Q and P**T are defined as products of
        elementary reflectors H(i) and G(i) respectively.

        Let nq = m if side = 'L' and nq = n if side = 'R'. Thus nq is the order of the orthogonal
        matrix Q or P**T that is applied.

        If vect = 'Q', A is assumed to have been an NQ-by-K matrix:
            if nq >= k, Q = H(1) H(2) . . . H(k);
            if nq < k, Q = H(1) H(2) . . . H(nq-1).

        If vect = 'P', A is assumed to have been a K-by-NQ matrix:
            if k < nq, P = G(1) G(2) . . . G(k);
            if k >= nq, P = G(1) G(2) . . . G(nq-1).
    \endverbatim

    * @param[in] vect
              vect is char* \n
              = 'Q': apply Q or Q**T; \n
              = 'P': apply P or P**T. \n
    * @param[in] side
              side is char* \n
              = 'L': apply Q, Q**T, P or P**T from the Left; \n
              = 'R': apply Q, Q**T, P or P**T from the Right. \n
    * @param[in] trans
              trans is char* \n
              = 'N':  No transpose, apply Q  or P; \n
              = 'T':  Transpose, apply Q**T or P**T. \n
    * @param[in] m
              m is integer* \n
              The number of rows of the matrix c. m >= 0. \n
    * @param[in] n
              n is integer* \n
              The number of columns of the matrix c. n >= 0. \n
    * @param[in] k
              k is integer* \n
              If vect = 'Q', the number of columns in the original
              matrix reduced by SGEBRD. \n
              If vect = 'P', the number of rows in the original
              matrix reduced by SGEBRD. \n
              k >= 0. \n
    * @param[in] a
              a is float/double array, dimension \n
              (lda,min(nq,k)) if vect = 'Q' \n
              (lda,nq)  if vect = 'P' \n
              The vectors which define the elementary reflectors H(i) and
              G(i), whose products determine the matrices Q and P, as
              returned by SGEBRD. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the array a. \n
              If vect = 'Q', lda >= max(1,nq); \n
              if vect = 'P', lda >= max(1,min(nq,k)). \n
    * @param[in] tau
              tau is float/double array, dimension (min(nq,k)) \n
              tau(i) must contain the scalar factor of the elementary
              reflector H(i) or G(i) which determines Q or P, as returned
              by SGEBRD in the array argument tauq or taup. \n
    * @param[in,out] c
              c is float/double array, dimension (ldc,n) \n
              On entry, the m-by-n matrix c. \n
              On exit, c is overwritten by Q*C or Q**T*C or C*Q**T or C*Q
              or P*C or P**T*C or C*P or C*P**T. \n
    * @param[in] ldc
              ldc is integer* \n
              The leading dimension of the array c. ldc >= max(1,m). \n
    * @param[out]	WORK	
              WORK is REAL array, dimension (MAX(1,LWORK)) \n
              On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
    * @param[in]	LWORK	
              LWORK is INTEGER \n
              The dimension of the array WORK. \n
              If SIDE = 'L', LWORK >= max(1,N); \n
              if SIDE = 'R', LWORK >= max(1,M). \n
              For optimum performance LWORK >= N*NB if SIDE = 'L', and
              LWORK >= M*NB if SIDE = 'R', where NB is the optimal
              blocksize. \n
 \n
              If LWORK = -1, then a workspace query is assumed; the routine
              only calculates the optimal size of the WORK array, returns
              this value as the first entry of the WORK array, and no error
              message related to LWORK is issued by XERBLA. \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit \n
              < 0:  if INFO = -i, the i-th argument had an illegal value \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer ormbr(char* vect, char* side, char* trans, integer* m, integer* n, integer* k, T* a, integer* lda, T* tau, T* c, integer* ldc, T* work, integer* lwork, integer* info)
{
  return ormbr(vect, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork, info);
}

/*! @brief Apply Q or Q' from bidiagonal reduction
    *
    * @details
    * \b Purpose:
    * \verbatim
        If vect = 'Q', CUNMBR overwrites the general complex m-by-n matrix c with
        side = 'L'  side = 'R'
            trans = 'N':   Q * C C * Q
            trans = 'C':   Q**H * C C * Q**H

        If vect = 'P', CUNMBR overwrites the general complex m-by-n matrix c with
        side = 'L'  side = 'R'
            trans = 'N':   P * C C * P
            trans = 'C':   P**H * C C * P**H

        Here Q and P**H are the orthogonal matrices determined by CGEBRD when reducing a complex
        matrix a to bidiagonal form: A = Q * B * P**H. Q and P**H are defined as products of
        elementary reflectors H(i) and G(i) respectively.

        Let nq = m if side = 'L' and nq = n if side = 'R'. Thus nq is the order of the orthogonal
        matrix Q or P**H that is applied.

        If vect = 'Q', A is assumed to have been an NQ-by-K matrix:
            if nq >= k, Q = H(1) H(2) . . . H(k);
            if nq < k, Q = H(1) H(2) . . . H(nq-1).

        If vect = 'P', A is assumed to have been a K-by-NQ matrix:
            if k < nq, P = G(1) G(2) . . . G(k);
            if k >= nq, P = G(1) G(2) . . . G(nq-1).
    \endverbatim

    * @param[in] vect
              vect is char* \n
              = 'Q': apply Q or Q**H; \n
              = 'P': apply P or P**H. \n
    * @param[in] side
              side is char* \n
              = 'L': apply Q, Q**H, P or P**H from the Left; \n
              = 'R': apply Q, Q**H, P or P**H from the Right. \n
    * @param[in] trans
              trans is char* \n
              = 'N':  No transpose, apply Q  or P; \n
              = 'C':  Transpose, apply Q**H or P**H. \n
    * @param[in] m
              m is integer* \n
              The number of rows of the matrix c. m >= 0. \n
    * @param[in] n
              n is integer* \n
              The number of columns of the matrix c. n >= 0. \n
    * @param[in] k
              k is integer* \n
              If vect = 'Q', the number of columns in the original
              matrix reduced by CGEBRD. \n
              If vect = 'P', the number of rows in the original
              matrix reduced by CGEBRD. \n
              k >= 0. \n
    * @param[in] a
              a is COMPLEX/COMPLEX*16 array, dimension \n
              (lda,min(nq,k)) if vect = 'Q' \n
              (lda,nq)  if vect = 'P' \n
              The vectors which define the elementary reflectors H(i) and
              G(i), whose products determine the matrices Q and P, as
              returned by CGEBRD. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the array a. \n
              If vect = 'Q', lda >= max(1,nq); \n
              if vect = 'P', lda >= max(1,min(nq,k)). \n
    * @param[in] tau
              tau is COMPLEX/COMPLEX*16 array, dimension (min(nq,k)) \n
              tau(i) must contain the scalar factor of the elementary
              reflector H(i) or G(i) which determines Q or P, as returned
              by CGEBRD in the array argument tauq or taup. \n
    * @param[in,out] c
              c is COMPLEX/COMPLEX*16 array, dimension (ldc,n) \n
              On entry, the m-by-n matrix c. \n
              On exit, c is overwritten by Q*C or Q**H*C or C*Q**H or C*Q
              or P*C or P**H*C or C*P or C*P**H. \n
    * @param[in] ldc
              ldc is integer* \n
              The leading dimension of the array c. ldc >= max(1,m). \n
    * @param[out]	WORK	
              WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
              On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
    * @param[in]	LWORK	
              LWORK is INTEGER \n
              The dimension of the array WORK. \n
              If SIDE = 'L', LWORK >= max(1,N); \n
              if SIDE = 'R', LWORK >= max(1,M); \n
              if N = 0 or M = 0, LWORK >= 1. \n
              For optimum performance LWORK >= max(1,N*NB) if SIDE = 'L',
              and LWORK >= max(1,M*NB) if SIDE = 'R', where NB is the
              optimal blocksize. (NB = 0 if M = 0 or N = 0.) \n
 \n
              If LWORK = -1, then a workspace query is assumed; the routine
              only calculates the optimal size of the WORK array, returns
              this value as the first entry of the WORK array, and no error
              message related to LWORK is issued by XERBLA. \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit \n
              < 0:  if INFO = -i, the i-th argument had an illegal value \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer unmbr(char* vect, char* side, char* trans, integer* m, integer* n, integer* k, T* a, integer* lda, T* tau, T* c, integer* ldc, T* work, integer* lwork, integer* info)
{
  return unmbr( vect, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork, info);
}

/*! @brief Tridiagonal QR algorithm
    *
    * @details
    * \b Purpose:
    * \verbatim
        Computation of all eigenvalues and, optionally, eigenvectors of a symmetric tridiagonal
        matrix using the implicit QL or QR method. The eigenvectors of a full or band symmetric
        matrix can also be found if SSYTRD or SSPTRD or SSBTRD has been used to reduce this matrix
        to tridiagonal form.
    \endverbatim

    * @param[in] jobz
              jobz is char* \n
              = 'N':  Compute eigenvalues only. \n
              = 'V':  Compute eigenvalues and eigenvectors of the original
              symmetric matrix.  On entry, Z must contain the
              orthogonal matrix used to reduce the original matrix
              to tridiagonal form. \n
              = 'I':  Compute eigenvalues and eigenvectors of the
              tridiagonal matrix.  Z is initialized to the identity
              matrix. \n
    * @param[in] n
              n is integer* \n
              The order of the matrix.  n >= 0. \n
    * @param[in,out] d
              d is float/double array, dimension (n) \n
              On entry, the diagonal elements of the tridiagonal matrix. \n
              On exit, if info = 0, the eigenvalues in ascending order. \n
    * @param[in,out] e
              e is float/double array, dimension (n-1) \n
              On entry, the (n-1) subdiagonal elements of the tridiagonal
              matrix. \n
              On exit, E has been destroyed. \n
    * @param[in,out] z
              z is float/double array, dimension (ldz, n) \n
              On entry, if  jobz = 'V', then Z contains the orthogonal
              matrix used in the reduction to tridiagonal form. \n
              On exit, if info = 0, then if  jobz = 'V', Z contains the
              orthonormal eigenvectors of the original symmetric matrix,
              and if jobz = 'I', Z contains the orthonormal eigenvectors
              of the symmetric tridiagonal matrix. \n
              If jobz = 'N', then Z is not referenced. \n
    * @param[in] ldz
              ldz is integer* \n
              The leading dimension of the array Z.  ldz >= 1, and if
              eigenvectors are desired, then  ldz >= max(1,n). \n
    * @param[out]	WORK	
              WORK is REAL array, dimension (max(1,2*N-2)) \n
              If COMPZ = 'N', then WORK is not referenced. \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit \n
              < 0:  if INFO = -i, the i-th argument had an illegal value \n
              > 0:  the algorithm has failed to find all the eigenvalues in
                    a total of 30*N iterations; if INFO = i, then i
                    elements of E have not converged to zero; on exit, D
                    and E contain the elements of a symmetric tridiagonal
                    matrix which is unitarily similar to the original
                    matrix. \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer steqr(char* compz, integer* n, T* d, T* e, T* z, integer* ldz, T* work, integer* info)
{
  return steqr(compz, n, d, e, z, ldz, work, info);
}
template< typename T, typename Ta >
integer steqr(char* compz, integer* n, Ta* d, Ta* e, T* z, integer* ldz, Ta* work, integer* info)
{
  return steqr(compz, n, d, e, z, ldz, work, info);
}

/*! @brief Tridiagonal divide-and-conquer algorithm
    *
    * @details
    * \b Purpose:
    * \verbatim
        Computation of all eigenvalues and, optionally, eigenvectors of a symmetric tridiagonal
        matrix using the divide and conquer method. The eigenvectors of a full or band real
        symmetric matrix can also be found if SSYTRD or SSPTRD or SSBTRD has been used to reduce
        this matrix to tridiagonal form.

        This code makes very mild assumptions about floating point arithmetic. It will work on
        machines with a guard digit in add/subtract, or on those binary machines without guard
        digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could
        conceivably fail on hexadecimal or decimal machines without guard digits, but we know of
        none.  See SLAED3 for details.
    \endverbatim

    * @param[in] compz
              compz is char* \n
              = 'N':  Compute eigenvalues only. \n
              = 'I':  Compute eigenvectors of tridiagonal matrix also. \n
              = 'V':  Compute eigenvectors of original dense symmetric
              matrix also.  On entry, Z contains the orthogonal
              matrix used to reduce the original matrix to
              tridiagonal form. \n
    * @param[in] n
              n is integer* \n
              The dimension of the symmetric tridiagonal matrix.  n >= 0. \n
    * @param[in,out] d
              d is float/double array, dimension (n) \n
              On entry, the diagonal elements of the tridiagonal matrix. \n
              On exit, if info = 0, the eigenvalues in ascending order. \n
    * @param[in,out] e
              e is float/double array, dimension (n-1) \n
              On entry, the subdiagonal elements of the tridiagonal matrix. \n
              On exit, E has been destroyed. \n
    * @param[in,out] z
              z is float/double array, dimension (ldz,n) \n
              On entry, if compz = 'V', then Z contains the orthogonal
              matrix used in the reduction to tridiagonal form. \n
              On exit, if info = 0, then if compz = 'V', Z contains the
              orthonormal eigenvectors of the original symmetric matrix,
              and if compz = 'I', Z contains the orthonormal eigenvectors
              of the symmetric tridiagonal matrix. \n
              If  compz = 'N', then Z is not referenced. \n
    * @param[in] ldz
              ldz is integer* \n
              The leading dimension of the array Z.  ldz >= 1. \n
              If eigenvectors are desired, then ldz >= max(1,n). \n
    * @param[out]	WORK	
              WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
              On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
    * @param[in]	LWORK	
              LWORK is INTEGER \n
              The dimension of the array WORK. \n
              If COMPZ = 'N' or 'I', or N <= 1, LWORK must be at least 1. \n
              If COMPZ = 'V' and N > 1, LWORK must be at least N*N. \n
              Note that for COMPZ = 'V', then if N is less than or
              equal to the minimum divide size, usually 25, then LWORK need
              only be 1. \n
 \n
              If LWORK = -1, then a workspace query is assumed; the routine
              only calculates the optimal sizes of the WORK, RWORK and
              IWORK arrays, returns these values as the first entries of
              the WORK, RWORK and IWORK arrays, and no error message
              related to LWORK or LRWORK or LIWORK is issued by XERBLA. \n
    * @param[out]	RWORK	
              RWORK is REAL array, dimension (MAX(1,LRWORK)) \n
              On exit, if INFO = 0, RWORK(1) returns the optimal LRWORK. \n
    * @param[in]	LRWORK	
              LRWORK is INTEGER \n
              The dimension of the array RWORK. \n
              If COMPZ = 'N' or N <= 1, LRWORK must be at least 1. \n
              If COMPZ = 'V' and N > 1, LRWORK must be at least \n
                             1 + 3*N + 2*N*lg N + 4*N**2 , \n
                             where lg( N ) = smallest integer k such \n
                             that 2**k >= N. \n
              If COMPZ = 'I' and N > 1, LRWORK must be at least
                             1 + 4*N + 2*N**2 . \n
              Note that for COMPZ = 'I' or 'V', then if N is less than or
              equal to the minimum divide size, usually 25, then LRWORK
              need only be max(1,2*(N-1)). \n
 \n
              If LRWORK = -1, then a workspace query is assumed; the
              routine only calculates the optimal sizes of the WORK, RWORK
              and IWORK arrays, returns these values as the first entries
              of the WORK, RWORK and IWORK arrays, and no error message
              related to LWORK or LRWORK or LIWORK is issued by XERBLA. \n
    * @param[out]	IWORK	
              IWORK is INTEGER array, dimension (MAX(1,LIWORK)) \n
              On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK. \n
    * @param[in]	LIWORK	
              LIWORK is INTEGER \n
              The dimension of the array IWORK. \n
              If COMPZ = 'N' or N <= 1, LIWORK must be at least 1. \n
              If COMPZ = 'V' or N > 1,  LIWORK must be at least
                                        6 + 6*N + 5*N*lg N. \n
              If COMPZ = 'I' or N > 1,  LIWORK must be at least
                                        3 + 5*N . \n
              Note that for COMPZ = 'I' or 'V', then if N is less than or
              equal to the minimum divide size, usually 25, then LIWORK
              need only be 1. \n
 \n
              If LIWORK = -1, then a workspace query is assumed; the
              routine only calculates the optimal sizes of the WORK, RWORK
              and IWORK arrays, returns these values as the first entries
              of the WORK, RWORK and IWORK arrays, and no error message
              related to LWORK or LRWORK or LIWORK is issued by XERBLA. \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit. \n
              < 0:  if INFO = -i, the i-th argument had an illegal value. \n
              > 0:  The algorithm failed to compute an eigenvalue while
                    working on the submatrix lying in rows and columns
                    INFO/(N+1) through mod(INFO,N+1). \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer stedc(char* compz, integer* n, T* d, T* e, T* z, integer* ldz, T* work, integer* lwork, integer* iwork, integer* liwork, integer* info)
{
  return stedc(compz, n, d, e, z, ldz, work, lwork, iwork, liwork, info);
}
template< typename T, typename Ta >
integer stedc(char* compz, integer* n, Ta* d, Ta* e, T* z, integer* ldz, T* work, integer* lwork, Ta* rwork, integer* lrwork, integer* iwork, integer* liwork, integer* info)
{
  return stedc(compz, n, d, e, z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info);
}

/*! @brief Tridiagonal MRRR algorithm
    *
    * @details
    * \b Purpose:
    * \verbatim
        Tridiagonal MRRR algorithm.
        Computation of selected eigenvalues and, optionally, eigenvectors of a real symmetric
        tridiagonal matrix T. Any such unreduced matrix has a well defined set of pairwise
        different real eigenvalues, the corresponding real eigenvectors are pairwise orthogonal.

        The spectrum may be computed either completely or partially by specifying either an
        interval (vl,vu] or a range of indices il:iu for the desired eigenvalues.

        Depending on the number of desired eigenvalues, these are computed either by bisection or
        the dqds algorithm. Numerically orthogonal eigenvectors are computed by the use of various
        suitable L D L^T factorizations near clusters of close eigenvalues (referred to as RRRs,
        Relatively Robust Representations). An informal sketch of the algorithm follows.

        For each unreduced block (submatrix) of T,
        (a) Compute T - sigma I  = L D L^T, so that L and D
        define all the wanted eigenvalues to high relative accuracy.
        This means that small relative changes in the entries of D and L
        cause only small relative changes in the eigenvalues and
        eigenvectors. The standard (unfactored) representation of the
        tridiagonal matrix T does not have this property in general.
        (b) Compute the eigenvalues to suitable accuracy.
        If the eigenvectors are desired, the algorithm attains full
        accuracy of the computed eigenvalues only right before
        the corresponding vectors have to be computed, see steps c) and d).
        (c) For each cluster of close eigenvalues, select a new
        shift close to the cluster, find a new factorization, and refine
        the shifted eigenvalues to suitable accuracy.
        (d) For each eigenvalue with a large enough relative separation compute
        the corresponding eigenvector by forming a rank revealing twisted
        factorization. Go back to (c) for any clusters that remain.

        For more details, see:
        - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations to compute
        orthogonal eigenvectors of symmetric tridiagonal matrices," Linear Algebra and its
        Applications, 387(1), pp. 1-28, August 2004.
        - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and Relative Gaps,"
        SIAM Journal on Matrix Analysis and Applications, Vol. 25,   2004.
        Also LAPACK Working Note 154.
        - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric tridiagonal
        eigenvalue/eigenvector problem", Computer Science Division Technical Report No.
        UCB/CSD-97-971, UC Berkeley, May 1997.

        Further Details
        1.SSTEMR works only on machines which follow IEEE-754 floating-point standard in their
        handling of infinities and NaNs. This permits the use of efficient inner loops avoiding a
        check for zero divisors.
    \endverbatim

    * @param[in] jobz
              jobz is char* \n
              = 'N':  Compute eigenvalues only; \n
              = 'V':  Compute eigenvalues and eigenvectors. \n
    * @param[in] range
              range is char* \n
              = 'A': all eigenvalues will be found. \n
              = 'V': all eigenvalues in the half-open interval (vl,vu]
              will be found. \n
              = 'I': the il-th through iu-th eigenvalues will be found. \n
    * @param[in] n
              n is integer* \n
              The order of the matrix.  n >= 0. \n
    * @param[in,out] d
              d is float/double array, dimension (n) \n
              On entry, the N diagonal elements of the tridiagonal matrix
              T. \n
              On exit, D is overwritten. \n
    * @param[in,out] e
              e is float/double array, dimension (n) \n
              On entry, the (n-1) subdiagonal elements of the tridiagonal
              matrix T in elements 1 to n-1 of E. E(n) need not be set on
              input, but is used internally as workspace. \n
              On exit, E is overwritten. \n
    * @param[in] vl
              vl is integer* \n
              If range='V', the lower bound of the interval to
              be searched for eigenvalues. vl < vu. \n
              Not referenced if range = 'A' or 'I'. \n
    * @param[in] vu
              vu is T* \n
              If range='V', the upper bound of the interval to
              be searched for eigenvalues. vl < vu. \n
              Not referenced if range = 'A' or 'I'. \n
    * @param[in] il
              il is integer* \n
              If range='I', the index of the
              smallest eigenvalue to be returned. \n
              1 <= il <= iu <= N, if N > 0. \n
              Not referenced if range = 'A' or 'V'. \n
    * @param[in] iu
              iu is integer* \n
              If range='I', the index of the
              largest eigenvalue to be returned. \n
              1 <= il <= iu <= N, if N > 0. \n
              Not referenced if range = 'A' or 'V'. \n
    * @param[out] m
              m is integer* \n
              The total number of eigenvalues found.  0 <= M <= N. \n
              If range = 'A', M = N, and if range = 'I', M = iu-il+1. \n
    * @param[out] w
              w is float/double array, dimension (n) \n
              The first M elements contain the selected eigenvalues in
              ascending order. \n
    * @param[out] z
              z is float/double array, dimension (ldz, max(1,m)) \n
              If jobz = 'V', and if info = 0, then the first M columns of Z
              contain the orthonormal eigenvectors of the matrix T
              corresponding to the selected eigenvalues, with the i-th
              column of Z holding the eigenvector associated with W(i).
              If jobz = 'N', then Z is not referenced. \n
              Note: the user must ensure that at least max(1,m) columns are
              supplied in the array Z; if range = 'V', the exact value of M
              is not known in advance and can be computed with a workspace
              query by setting nzc = -1, see below. \n
    * @param[in] ldz
              ldz is integer* \n
              The leading dimension of the array Z.  ldz >= 1, and if
              jobz = 'V', then ldz >= max(1,n). \n
    * @param[in] nzc
              nzc is integer* \n
              The number of eigenvectors to be held in the array Z. \n
              If range = 'A', then nzc >= max(1,n). \n
              If range = 'V', then nzc >= the number of eigenvalues in (vl,vu]. \n
              If range = 'I', then nzc >= iu-il+1. \n
              If nzc = -1, then a workspace query is assumed; the
              routine calculates the number of columns of the array Z that
              are needed to hold the eigenvectors. \n
              This value is returned as the first entry of the Z array, and
              no error message related to nzc is issued by XERBLA. \n
    * @param[out] isuppz
              isuppz is integer array, dimension ( 2*max(1,m)) \n
              The support of the eigenvectors in Z, i.e., the indices
              indicating the nonzero elements in Z. The i-th computed eigenvector
              is nonzero only in elements isuppz( 2*i-1) through
              isuppz( 2*i). This is relevant in the case when the matrix
              is split. isuppz is only accessed when jobz is 'V' and N > 0. \n
    * @param[in,out] tryrac
              tryrac is LOGICAL \n
              If tryrac.EQ..TRUE., indicates that the code should check whether
              the tridiagonal matrix defines its eigenvalues to high relative
              accuracy.  If so, the code uses relative-accuracy preserving
              algorithms that might be (a bit) slower depending on the matrix.
              If the matrix does not define its eigenvalues to high relative
              accuracy, the code can uses possibly faster algorithms. \n
              If tryrac.EQ..FALSE., the code is not required to guarantee
              relatively accurate eigenvalues and can use the fastest possible
              techniques. \n
              On exit, a .TRUE. tryrac will be set to .FALSE. if the matrix
              does not define its eigenvalues to high relative accuracy. \n
    * @param[out]	WORK	
              WORK is REAL array, dimension (LWORK) \n
              On exit, if INFO = 0, WORK(1) returns the optimal
              (and minimal) LWORK. \n
    * @param[in]	LWORK	
              LWORK is INTEGER \n
              The dimension of the array WORK. LWORK >= max(1,18*N) \n
              if JOBZ = 'V', and LWORK >= max(1,12*N) if JOBZ = 'N'. \n
              If LWORK = -1, then a workspace query is assumed; the routine
              only calculates the optimal size of the WORK array, returns
              this value as the first entry of the WORK array, and no error
              message related to LWORK is issued by XERBLA. \n
    * @param[out]	IWORK	
              IWORK is INTEGER array, dimension (LIWORK) \n
              On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK. \n
    * @param[in]	LIWORK	
              LIWORK is INTEGER \n
              The dimension of the array IWORK.  LIWORK >= max(1,10*N)
              if the eigenvectors are desired, and LIWORK >= max(1,8*N)
              if only the eigenvalues are to be computed. \n
              If LIWORK = -1, then a workspace query is assumed; the
              routine only calculates the optimal size of the IWORK array,
              returns this value as the first entry of the IWORK array, and
              no error message related to LIWORK is issued by XERBLA. \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              On exit, INFO \n
              = 0:  successful exit \n
              < 0:  if INFO = -i, the i-th argument had an illegal value \n
              > 0:  if INFO = 1X, internal error in SLARRE, \n
                    if INFO = 2X, internal error in CLARRV. \n
                    Here, the digit X = ABS( IINFO ) < 10, where IINFO is
                    the nonzero error code returned by SLARRE or
                    CLARRV, respectively. \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer stemr(char* jobz, char* range, integer* n, T*  d, T*  e, T* vl, T* vu, integer* il, integer* iu, integer* m, T*  w, T* z, integer* ldz, integer* nzc, integer* isuppz, integer* tryrac, T* work, integer* lwork, integer* iwork, integer* liwork, integer* info)
{
  return stemr(jobz, range, n, d, e, vl, vu, il, iu, m, w, z, ldz, nzc, isuppz, tryrac, work, lwork, iwork, liwork, info);
}
template< typename T, typename Ta >
integer stemr(char* jobz, char* range, integer* n, Ta*  d, Ta*  e, Ta* vl, Ta* vu, integer* il, integer* iu, integer* m, Ta*  w, T* z, integer* ldz, integer* nzc, integer* isuppz, integer* tryrac, Ta* work, integer* lwork, integer* iwork, integer* liwork, integer* info)
{
  return stemr(jobz, range, n, d, e, vl, vu, il, iu, m, w, z, ldz, nzc, isuppz, tryrac, work, lwork, iwork, liwork, info);
}

/*! @brief Eigenvalue decomposition (QR algorithm)
    *
    * @details
    * \b Purpose:
    * \verbatim
        Eigenvalue decomposition (QR algorithm).
        Computation of all eigenvalues and, optionally, eigenvectors of a real symmetric matrix a.
    \endverbatim

    * @param[in] jobz
              jobz is char* \n
              = 'N':  Compute eigenvalues only; \n
              = 'V':  Compute eigenvalues and eigenvectors. \n
    * @param[in] uplo
              uplo is char* \n
              = 'U':  Upper triangle of a is stored; \n
              = 'L':  Lower triangle of a is stored. \n
    * @param[in] n
              n is integer* \n
              The order of the matrix a.  n >= 0. \n
    * @param[in,out] a
              a is float/double array, dimension (lda, n) \n
              On entry, the symmetric matrix a.  If uplo = 'U', the
              leading n-by-n upper triangular part of a contains the
              upper triangular part of the matrix a.  If uplo = 'L',
              the leading n-by-n lower triangular part of a contains
              the lower triangular part of the matrix a. \n
              On exit, if jobz = 'V', then if info = 0, A contains the
              orthonormal eigenvectors of the matrix a. \n
              If jobz = 'N', then on exit the lower triangle (if uplo='L')
              or the upper triangle (if uplo='U') of A, including the
              diagonal, is destroyed. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the array a.  lda >= max(1,n). \n
    * @param[out] w
              w is float/double array, dimension (n) \n
              If info = 0, the eigenvalues in ascending order. \n
    * @param[out]	WORK	
              WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK)) \n
              On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
    * @param[in]	LWORK	
              LWORK is INTEGER \n
              The length of the array WORK.  LWORK >= max(1,3*N-1). \n
              For optimal efficiency, LWORK >= (NB+2)*N,
              where NB is the blocksize for DSYTRD returned by ILAENV. \n

              If LWORK = -1, then a workspace query is assumed; the routine
              only calculates the optimal size of the WORK array, returns
              this value as the first entry of the WORK array, and no error
              message related to LWORK is issued by XERBLA. \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit \n
              < 0:  if INFO = -i, the i-th argument had an illegal value \n
              > 0:  if INFO = i, the algorithm failed to converge; i
                    off-diagonal elements of an intermediate tridiagonal
                    form did not converge to zero. \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer syev(char* jobz, char* uplo, integer* n, T* a, integer* lda, T*  w, T* work, integer* lwork, integer* info)
{
  return syev(jobz, uplo, n, a, lda, w, work, lwork, info);
}

/*! @brief SYR performs the symmetric rank-1 update of a complex symmetric matrix

 * @details
 * \b Purpose:
    \verbatim 
     SYR   performs the symmetric rank 1 operation

        A := alpha*x*x**H + A,

     where alpha is a complex scalar, x is an n element vector and A is an
     n by n symmetric matrix.
    \endverbatim  

 * @param[in] UPLO
           UPLO is CHARACTER*1 \n
           On entry, UPLO specifies whether the upper or lower
           triangular part of the array A is to be referenced as
           follows: \n

              UPLO = 'U' or 'u'   Only the upper triangular part of A
                                  is to be referenced. \n

              UPLO = 'L' or 'l'   Only the lower triangular part of A
                                  is to be referenced. \n
           Unchanged on exit. \n
 * @param[in] N
           N is INTEGER \n
           On entry, N specifies the order of the matrix A.
           N must be at least zero. \n
           Unchanged on exit. \n
 * @param[in] ALPHA
           ALPHA is COMPLEX \n
           On entry, ALPHA specifies the scalar alpha.
           Unchanged on exit. \n
 * @param[in] X
           X is COMPLEX array, dimension at least
           ( 1 + ( N - 1)*abs( INCX)). \n
           Before entry, the incremented array X must contain the N-
           element vector x. \n
           Unchanged on exit. \n
 * @param[in] INCX
           INCX is INTEGER \n
           On entry, INCX specifies the increment for the elements of
           X. INCX must not be zero. \n
           Unchanged on exit. \n
 * @param[in,out] A
           A is COMPLEX array, dimension ( LDA, N) \n
           Before entry, with  UPLO = 'U' or 'u', the leading n by n
           upper triangular part of the array A must contain the upper
           triangular part of the symmetric matrix and the strictly
           lower triangular part of A is not referenced. On exit, the
           upper triangular part of the array A is overwritten by the
           upper triangular part of the updated matrix. \n
           Before entry, with UPLO = 'L' or 'l', the leading n by n
           lower triangular part of the array A must contain the lower
           triangular part of the symmetric matrix and the strictly
           upper triangular part of A is not referenced. On exit, the
           lower triangular part of the array A is overwritten by the
           lower triangular part of the updated matrix. \n
 * @param[in] LDA
           LDA is INTEGER \n
           On entry, LDA specifies the first dimension of A as declared
           in the calling (sub) program. LDA must be at least
           max( 1, N).
           Unchanged on exit. \n
  
 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer syr(char* uplo, integer* n, T alpha,  T* x, integer* incx, T* a, integer* lda)
{
  return syr(uplo, n, alpha, x, incx, a, lda);
}

/*! @brief Eigenvalue decomposition (QR algorithm)
    *
    * @details
    * \b Purpose:
    * \verbatim
        Eigenvalue decomposition (QR algorithm)
        Computation of all eigenvalues and, optionally, eigenvectors of a complex Hermitian matrix a.
    \endverbatim

    * @param[in] jobz
              jobz is char* \n
              = 'N':  Compute eigenvalues only; \n
              = 'V':  Compute eigenvalues and eigenvectors. \n
    * @param[in] uplo
              uplo is char* \n
              = 'U':  Upper triangle of a is stored; \n
              = 'L':  Lower triangle of a is stored. \n
    * @param[in] n
              n is integer* \n
              The order of the matrix a.  n >= 0. \n
    * @param[in,out] a
              a is COMPLEX/COMPLEX*16 array, dimension (lda, n) \n
              On entry, the Hermitian matrix a.  If uplo = 'U', the
              leading n-by-n upper triangular part of a contains the
              upper triangular part of the matrix a.  If uplo = 'L',
              the leading n-by-n lower triangular part of a contains
              the lower triangular part of the matrix a. \n
              On exit, if jobz = 'V', then if info = 0, A contains the
              orthonormal eigenvectors of the matrix a. \n
              If jobz = 'N', then on exit the lower triangle (if uplo='L')
              or the upper triangle (if uplo='U') of A, including the
              diagonal, is destroyed. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the array a.  lda >= max(1,n). \n
    * @param[out] w
              w is float/double array, dimension (n) \n
              If info = 0, the eigenvalues in ascending order. \n
    * @param[out]	WORK	
              WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
              On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
    * @param[in]	LWORK	
              LWORK is INTEGER \n
              The length of the array WORK.  LWORK >= max(1,2*N-1). \n
              For optimal efficiency, LWORK >= (NB+1)*N,
              where NB is the blocksize for CHETRD returned by ILAENV. \n
 \n
              If LWORK = -1, then a workspace query is assumed; the routine
              only calculates the optimal size of the WORK array, returns
              this value as the first entry of the WORK array, and no error
              message related to LWORK is issued by XERBLA. \n
    * @param[out]	RWORK	
              RWORK is REAL array, dimension (max(1, 3*N-2)) \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit \n
              < 0:  if INFO = -i, the i-th argument had an illegal value \n
              > 0:  if INFO = i, the algorithm failed to converge; i
                    off-diagonal elements of an intermediate tridiagonal
                    form did not converge to zero. \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T, typename Ta >
integer heev(char* jobz, char* uplo, integer* n, T* a, integer* lda, Ta*  w, T* work, integer* lwork, Ta* rwork, integer* info)
{
  return heev(jobz, uplo, n, a, lda, w, work, lwork, rwork, info);
}

/*! @brief Eigenvalue decomposition (divide-and-conquer)
    *
    * @details
    * \b Purpose:
    * \verbatim
        Computation of the eigenvalues and, optionally, the left and/or right eigenvectors for SY
        matrices. SSYEVD computes all eigenvalues and, optionally, eigenvectors of a real
        symmetric matrix a. If eigenvectors are desired, it uses a divide and conquer algorithm.

        The divide and conquer algorithm makes very mild assumptions about floating point
        arithmetic. It will work on machines with a guard digit in add/subtract, or on those
        binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray
        C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without
        guard digits, but we know of none.

        Because of large use of BLAS of level 3, SSYEVD needs N**2 more workspace than SSYEVX.
    \endverbatim

    * @param[in] jobz
              jobz is char* \n
              = 'N':  Compute eigenvalues only; \n
              = 'V':  Compute eigenvalues and eigenvectors. \n
    * @param[in] uplo
              uplo is char* \n
              = 'U':  Upper triangle of a is stored; \n
              = 'L':  Lower triangle of a is stored. \n
    * @param[in] n
              n is integer* \n
              The order of the matrix a.  n >= 0. \n
    * @param[in,out] a
              a is float/double array, dimension (lda, n) \n
              On entry, the symmetric matrix a.  If uplo = 'U', the
              leading n-by-n upper triangular part of a contains the
              upper triangular part of the matrix a.  If uplo = 'L',
              the leading n-by-n lower triangular part of a contains
              the lower triangular part of the matrix a. \n
              On exit, if jobz = 'V', then if info = 0, A contains the
              orthonormal eigenvectors of the matrix a. \n
              If jobz = 'N', then on exit the lower triangle (if uplo='L')
              or the upper triangle (if uplo='U') of A, including the
              diagonal, is destroyed. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the array a.  lda >= max(1,n). \n
    * @param[out] w
              w is float/double array, dimension (n) \n
              If info = 0, the eigenvalues in ascending order. \n
    * @param[out]	WORK	
              WORK is DOUBLE PRECISION array,
                                             dimension (LWORK) \n
              On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
    * @param[in]	LWORK	
              LWORK is INTEGER \n
              The dimension of the array WORK. \n
              If N <= 1,               LWORK must be at least 1. \n
              If JOBZ = 'N' and N > 1, LWORK must be at least 2*N+1. \n
              If JOBZ = 'V' and N > 1, LWORK must be at least
                                                    1 + 6*N + 2*N**2. \n
 \n
              If LWORK = -1, then a workspace query is assumed; the routine
              only calculates the optimal sizes of the WORK and IWORK
              arrays, returns these values as the first entries of the WORK
              and IWORK arrays, and no error message related to LWORK or
              LIWORK is issued by XERBLA. \n
    * @param[out]	IWORK	
              IWORK is INTEGER array, dimension (MAX(1,LIWORK)) \n
              On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK. \n
    * @param[in]	LIWORK	
              LIWORK is INTEGER \n
              The dimension of the array IWORK. \n
              If N <= 1,                LIWORK must be at least 1. \n
              If JOBZ  = 'N' and N > 1, LIWORK must be at least 1. \n
              If JOBZ  = 'V' and N > 1, LIWORK must be at least 3 + 5*N. \n
 \n
              If LIWORK = -1, then a workspace query is assumed; the
              routine only calculates the optimal sizes of the WORK and
              IWORK arrays, returns these values as the first entries of
              the WORK and IWORK arrays, and no error message related to
              LWORK or LIWORK is issued by XERBLA. \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit \n
              < 0:  if INFO = -i, the i-th argument had an illegal value \n
              > 0:  if INFO = i and JOBZ = 'N', then the algorithm failed
                    to converge; i off-diagonal elements of an intermediate
                    tridiagonal form did not converge to zero;
                    if INFO = i and JOBZ = 'V', then the algorithm failed
                    to compute an eigenvalue while working on the submatrix
                    lying in rows and columns INFO/(N+1) through
                    mod(INFO,N+1). \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer syevd(char* jobz, char* uplo, integer* n, T* a, integer* lda, T*  w, T* work, integer* lwork, integer* iwork, integer* liwork, integer* info)
{
  return syevd(jobz, uplo, n, a, lda, w, work, lwork, iwork, liwork, info);
}

/*! @brief Eigenvalue decomposition (divide-and-conquer)
    *
    * @details
    * \b Purpose:
    * \verbatim
        Eigenvalue decomposition (divide-and-conquer).
        Computation of the eigenvalues and, optionally, the left and/or right eigenvectors for
        HE matrices

        CHEEVD computes all eigenvalues and, optionally, eigenvectors of a complex Hermitian
        matrix a.  If eigenvectors are desired, it uses a divide and conquer algorithm.

        The divide and conquer algorithm makes very mild assumptions about floating point
        arithmetic. It will work on machines with a guard digit in add/subtract, or on those
        binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray
        C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without
        guard digits, but we know of none.
    \endverbatim

    * @param[in] jobz
              jobz is char* \n
              = 'N':  Compute eigenvalues only; \n
              = 'V':  Compute eigenvalues and eigenvectors. \n
    * @param[in] uplo
              uplo is char* \n
              = 'U':  Upper triangle of a is stored; \n
              = 'L':  Lower triangle of a is stored. \n
    * @param[in] n
              n is integer* \n
              The order of the matrix a.  n >= 0. \n
    * @param[in,out] a
              a is COMPLEX/COMPLEX*16 array, dimension (lda, n) \n
              On entry, the Hermitian matrix a.  If uplo = 'U', the
              leading n-by-n upper triangular part of a contains the
              upper triangular part of the matrix a.  If uplo = 'L',
              the leading n-by-n lower triangular part of a contains
              the lower triangular part of the matrix a. \n
              On exit, if jobz = 'V', then if info = 0, A contains the
              orthonormal eigenvectors of the matrix a. \n
              If jobz = 'N', then on exit the lower triangle (if uplo='L')
              or the upper triangle (if uplo='U') of A, including the
              diagonal, is destroyed. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the array a.  lda >= max(1,n). \n
    * @param[out] w
              w is float/double array, dimension (n) \n
              If info = 0, the eigenvalues in ascending order. \n
    * @param[out]	WORK	
              WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
              On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
    * @param[in]	LWORK	
              LWORK is INTEGER \n
              The length of the array WORK. \n
              If N <= 1,                LWORK must be at least 1. \n
              If JOBZ  = 'N' and N > 1, LWORK must be at least N + 1. \n
              If JOBZ  = 'V' and N > 1, LWORK must be at least 2*N + N**2. \n
 \n
              If LWORK = -1, then a workspace query is assumed; the routine
              only calculates the optimal sizes of the WORK, RWORK and
              IWORK arrays, returns these values as the first entries of
              the WORK, RWORK and IWORK arrays, and no error message
              related to LWORK or LRWORK or LIWORK is issued by XERBLA. \n
    * @param[out]	RWORK	
              RWORK is REAL array,
                                             dimension (LRWORK) \n
              On exit, if INFO = 0, RWORK(1) returns the optimal LRWORK. \n
    * @param[in]	LRWORK	
              LRWORK is INTEGER \n
              The dimension of the array RWORK. \n
              If N <= 1,                LRWORK must be at least 1. \n
              If JOBZ  = 'N' and N > 1, LRWORK must be at least N. \n
              If JOBZ  = 'V' and N > 1, LRWORK must be at least
                             1 + 5*N + 2*N**2. \n
 \n
              If LRWORK = -1, then a workspace query is assumed; the
              routine only calculates the optimal sizes of the WORK, RWORK
              and IWORK arrays, returns these values as the first entries
              of the WORK, RWORK and IWORK arrays, and no error message
              related to LWORK or LRWORK or LIWORK is issued by XERBLA. \n
    * @param[out]	IWORK	
              IWORK is INTEGER array, dimension (MAX(1,LIWORK)) \n
              On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK. \n
    * @param[in]	LIWORK	
              LIWORK is INTEGER \n
              The dimension of the array IWORK. \n
              If N <= 1,                LIWORK must be at least 1. \n
              If JOBZ  = 'N' and N > 1, LIWORK must be at least 1. \n
              If JOBZ  = 'V' and N > 1, LIWORK must be at least 3 + 5*N. \n
 \n
              If LIWORK = -1, then a workspace query is assumed; the
              routine only calculates the optimal sizes of the WORK, RWORK
              and IWORK arrays, returns these values as the first entries
              of the WORK, RWORK and IWORK arrays, and no error message
              related to LWORK or LRWORK or LIWORK is issued by XERBLA. \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit \n
              < 0:  if INFO = -i, the i-th argument had an illegal value \n
              > 0:  if INFO = i and JOBZ = 'N', then the algorithm failed
                    to converge; i off-diagonal elements of an intermediate
                    tridiagonal form did not converge to zero;
                    if INFO = i and JOBZ = 'V', then the algorithm failed
                    to compute an eigenvalue while working on the submatrix
                    lying in rows and columns INFO/(N+1) through
                    mod(INFO,N+1). \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T, typename Ta >
integer heevd(char* jobz, char* uplo, integer* n, T* a, integer* lda, Ta* w, T* work, integer* lwork, Ta* rwork, integer* lrwork, integer* iwork, integer* liwork, integer* info)
{
  return heevd(jobz, uplo, n, a, lda, w, work, lwork, rwork, lrwork, iwork, liwork, info);
}

/*! @brief Hermitian eigenvalue decomposition (MRRR)
    *
    * @details
    * \b Purpose:
    * \verbatim
        Computation of eigenvalues and, optionally, the left and/or right eigenvectors for HE
        matrices. CHEEVR computes selected eigenvalues and, optionally, eigenvectors of a complex
        Hermitian matrix a. Eigenvalues and eigenvectors can be selected by specifying either a
        range of values or a range of indices for the desired eigenvalues.

        CHEEVR first reduces the matrix a to tridiagonal form T with a call to CHETRD.  Then,
        whenever possible, CHEEVR calls CSTEMR to compute the eigenspectrum using Relatively
        Robust Representations. CSTEMR computes eigenvalues by the dqds algorithm, while
        orthogonal eigenvectors are computed from various "good" L D L^T representations (also
        known as Relatively Robust Representations). Gram-Schmidt orthogonalization is avoided as
        far as possible. More specifically, the various steps of the algorithm are as follows.

        For each unreduced block (submatrix) of T,
        (a) Compute T - sigma I  = L D L^T, so that L and D
        define all the wanted eigenvalues to high relative accuracy.
        This means that small relative changes in the entries of D and L
        cause only small relative changes in the eigenvalues and
        eigenvectors. The standard (unfactored) representation of the
        tridiagonal matrix T does not have this property in general.
        (b) Compute the eigenvalues to suitable accuracy.
        If the eigenvectors are desired, the algorithm attains full
        accuracy of the computed eigenvalues only right before
        the corresponding vectors have to be computed, see steps c) and d).
        (c) For each cluster of close eigenvalues, select a new
        shift close to the cluster, find a new factorization, and refine
        the shifted eigenvalues to suitable accuracy.
        (d) For each eigenvalue with a large enough relative separation compute
        the corresponding eigenvector by forming a rank revealing twisted
        factorization. Go back to (c) for any clusters that remain.

        The desired accuracy of the output can be specified by the input parameter abstol.

        For more details, see DSTEMR's documentation and:
        - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations to compute
        orthogonal eigenvectors of symmetric tridiagonal matrices," Linear Algebra and its
        Applications, 387(1), pp. 1-28, August 2004.
        - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and   Relative Gaps,"
        SIAM Journal on Matrix Analysis and Applications, Vol. 25,   2004.
        Also LAPACK Working Note 154.
        - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric tridiagonal
        eigenvalue/eigenvector problem",   Computer Science Division Technical Report No.
        UCB/CSD-97-971, UC Berkeley, May 1997.


        Note 1 : CHEEVR calls CSTEMR when the full spectrum is requested on machines which conform
        to the ieee-754 floating point standard. CHEEVR calls SSTEBZ and CSTEIN on non-ieee
        machines and when partial spectrum requests are made.

        Normal execution of CSTEMR may create NaNs and infinities and hence may abort due to a
        floating point exception in environments which do not handle NaNs and infinities in the
        ieee standard default manner.
    \endverbatim

    * @param[in] jobz
              jobz is char* \n
              = 'N':  Compute eigenvalues only; \n
              = 'V':  Compute eigenvalues and eigenvectors. \n
    * @param[in] range
              range is char* \n
              = 'A': all eigenvalues will be found. \n
              = 'V': all eigenvalues in the half-open interval (vl,vu]
              will be found. \n
              = 'I': the il-th through iu-th eigenvalues will be found. \n
              For range = 'V' or 'I' and iu - il < N - 1, SSTEBZ and
              CSTEIN are called \n
    * @param[in] uplo
              uplo is char* \n
              = 'U':  Upper triangle of a is stored; \n
              = 'L':  Lower triangle of a is stored. \n
    * @param[in] n
              n is integer* \n
              The order of the matrix a.  n >= 0. \n
    * @param[in,out] a
              a is COMPLEX/COMPLEX*16 array, dimension (lda, n) \n
              On entry, the Hermitian matrix a.  If uplo = 'U', the
              leading n-by-n upper triangular part of a contains the
              upper triangular part of the matrix a.  If uplo = 'L',
              the leading n-by-n lower triangular part of a contains
              the lower triangular part of the matrix a. \n
              On exit, the lower triangle (if uplo='L') or the upper
              triangle (if uplo='U') of A, including the diagonal, is
              destroyed. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the array a.  lda >= max(1,n). \n
    * @param[in] vl
              vl is float/double* \n
              If range='V', the lower bound of the interval to
              be searched for eigenvalues. vl < vu. \n
              Not referenced if range = 'A' or 'I'. \n
    * @param[in] vu
              vu is float/double* \n
              If range='V', the upper bound of the interval to
              be searched for eigenvalues. vl < vu. \n
              Not referenced if range = 'A' or 'I'. \n
    * @param[in] il
              il is integer* \n
              If range='I', the index of the
              smallest eigenvalue to be returned. \n
              1 <= il <= iu <= N, if N > 0; il = 1 and iu = 0 if N = 0. \n
              Not referenced if range = 'A' or 'V'. \n
    * @param[in] iu
              iu is integer* \n
              If range='I', the index of the
              largest eigenvalue to be returned. \n
              1 <= il <= iu <= N, if N > 0; il = 1 and iu = 0 if N = 0. \n
              Not referenced if range = 'A' or 'V'. \n
    * @param[in] abstol
              abstol is float\double array \n
              The absolute error tolerance for the eigenvalues.
              An approximate eigenvalue is accepted as converged
              when it is determined to lie in an interval [a,b]
              of width less than or equal to \n \n
              abstol + EPS *   max( |a|,|b|) , \n \n
              where EPS is the machine precision.  If abstol is less than
              or equal to zero, then  EPS*|T|  will be used in its place,
              where |T| is the 1-norm of the tridiagonal matrix obtained
              by reducing A to tridiagonal form. \n \n
              See "Computing Small Singular Values of Bidiagonal Matrices
              with Guaranteed High Relative Accuracy," by Demmel and
              Kahan, LAPACK Working Note #3. \n \n
              If high relative accuracy is important, set abstol to
              SLAMCH( 'Safe minimum').  Doing so will guarantee that
              eigenvalues are computed to high relative accuracy when
              possible in future releases.  The current code does not
              make any guarantees about high relative accuracy, but
              furutre releases will. See J. Barlow and J. Demmel,
              "Computing Accurate Eigensystems of Scaled Diagonally
              Dominant Matrices", LAPACK Working Note #7, for a discussion
              of which matrices define their eigenvalues to high relative
              accuracy. \n
    * @param[out] m
              m is integer* \n
              The total number of eigenvalues found.  0 <= M <= N. \n
              If range = 'A', M = N, and if range = 'I', M = iu-il+1. \n
    * @param[out] w
              w is float/double array, dimension (n) \n
              The first M elements contain the selected eigenvalues in
              ascending order. \n
    * @param[out] z
              z is COMPLEX/COMPLEX*16 array, dimension (ldz, max(1,m)) \n
              If jobz = 'V', then if info = 0, the first M columns of Z
              contain the orthonormal eigenvectors of the matrix a
              corresponding to the selected eigenvalues, with the i-th
              column of Z holding the eigenvector associated with W(i). \n
              If jobz = 'N', then Z is not referenced. \n
              Note: the user must ensure that at least max(1,m) columns are
              supplied in the array Z; if range = 'V', the exact value of M
              is not known in advance and an upper bound must be used. \n
    * @param[in] ldz
              ldz is integer* \n
              The leading dimension of the array Z.  ldz >= 1, and if
              jobz = 'V', ldz >= max(1,n). \n
    * @param[out] isuppz
              isuppz is integer array, dimension ( 2*max(1,m)) \n
              The support of the eigenvectors in Z, i.e., the indices
              indicating the nonzero elements in Z. The i-th eigenvector
              is nonzero only in elements isuppz( 2*i-1) through
              isuppz( 2*i). This is an output of CSTEMR (tridiagonal
              matrix). The support of the eigenvectors of A is typically
              1:N because of the unitary transformations applied by CUNMTR.
              Implemented only for range = 'A' or 'I' and iu - il = N - 1 \n
    * @param[out]	WORK	
              WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
              On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
    * @param[in]	LWORK	
              LWORK is INTEGER \n
              The length of the array WORK.  LWORK >= max(1,2*N). \n
              For optimal efficiency, LWORK >= (NB+1)*N,
              where NB is the max of the blocksize for CHETRD and for
              CUNMTR as returned by ILAENV. \n
 \n
              If LWORK = -1, then a workspace query is assumed; the routine
              only calculates the optimal sizes of the WORK, RWORK and
              IWORK arrays, returns these values as the first entries of
              the WORK, RWORK and IWORK arrays, and no error message
              related to LWORK or LRWORK or LIWORK is issued by XERBLA. \n
    * @param[out]	RWORK	
              RWORK is REAL array, dimension (MAX(1,LRWORK)) \n
              On exit, if INFO = 0, RWORK(1) returns the optimal
              (and minimal) LRWORK. \n
    * @param[in]	LRWORK	
              LRWORK is INTEGER \n
              The length of the array RWORK.  LRWORK >= max(1,24*N). \n
 \n
              If LRWORK = -1, then a workspace query is assumed; the
              routine only calculates the optimal sizes of the WORK, RWORK
              and IWORK arrays, returns these values as the first entries
              of the WORK, RWORK and IWORK arrays, and no error message
              related to LWORK or LRWORK or LIWORK is issued by XERBLA. \n
    * @param[out]	IWORK	
              IWORK is INTEGER array, dimension (MAX(1,LIWORK)) \n
              On exit, if INFO = 0, IWORK(1) returns the optimal
              (and minimal) LIWORK. \n
    * @param[in]	LIWORK	
              LIWORK is INTEGER \n
              The dimension of the array IWORK.  LIWORK >= max(1,10*N). \n
 \n
              If LIWORK = -1, then a workspace query is assumed; the
              routine only calculates the optimal sizes of the WORK, RWORK
              and IWORK arrays, returns these values as the first entries
              of the WORK, RWORK and IWORK arrays, and no error message
              related to LWORK or LRWORK or LIWORK is issued by XERBLA. \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit \n
              < 0:  if INFO = -i, the i-th argument had an illegal value \n
              > 0:  Internal error \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T, typename Ta >
integer heevr(char* jobz, char* range, char* uplo, integer* n, T* a, integer* lda, Ta*  vl, Ta*  vu, integer* il, integer* iu, Ta*  abstol, integer* m, Ta* w, T* z, integer* ldz, integer* isuppz, T* work, integer* lwork, Ta* rwork, integer* lrwork, integer* iwork, integer* liwork, integer* info)
{
  return heevr(jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, rwork, lrwork, iwork, liwork, info);
}

/*! @brief Hermitian eigenvalue decomposition (MRRR)
    *

    * @details
    * \b Purpose:
    * \verbatim
        Hermitian eigenvalue decomposition (MRRR).
        Computation of eigenvalues and, optionally, the left and/or right eigenvectors for SY
        matrices

        SSYEVR computes selected eigenvalues and, optionally, eigenvectors of a real symmetric
        matrix a. Eigenvalues and eigenvectors can be selected by specifying either a range of
        values or a range of indices for the desired eigenvalues.

        SSYEVR first reduces the matrix a to tridiagonal form T with a call to SSYTRD.  Then,
        whenever possible, SSYEVR calls SSTEMR to compute the eigenspectrum using Relatively
        Robust Representations. SSTEMR computes eigenvalues by the dqds algorithm, while orthogonal
        eigenvectors are computed from various "good" L D L^T representations (also known as
        Relatively Robust Representations). Gram-Schmidt orthogonalization is avoided as far as
        possible. More specifically, the various steps of the algorithm are as follows.

        For each unreduced block (submatrix) of T,
        (a) Compute T - sigma I  = L D L^T, so that L and D
        define all the wanted eigenvalues to high relative accuracy.
        This means that small relative changes in the entries of D and L
        cause only small relative changes in the eigenvalues and
        eigenvectors. The standard (unfactored) representation of the
        tridiagonal matrix T does not have this property in general.
        (b) Compute the eigenvalues to suitable accuracy.
        If the eigenvectors are desired, the algorithm attains full
        accuracy of the computed eigenvalues only right before
        the corresponding vectors have to be computed, see steps c) and d).
        (c) For each cluster of close eigenvalues, select a new
        shift close to the cluster, find a new factorization, and refine
        the shifted eigenvalues to suitable accuracy.
        (d) For each eigenvalue with a large enough relative separation compute
        the corresponding eigenvector by forming a rank revealing twisted
        factorization. Go back to (c) for any clusters that remain.

        The desired accuracy of the output can be specified by the input parameter abstol.

        For more details, see SSTEMR's documentation and:
        - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations to compute
        orthogonal eigenvectors of symmetric tridiagonal matrices," Linear Algebra and its
        Applications, 387(1), pp. 1-28, August 2004.
        - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and   Relative Gaps,"
        SIAM Journal on Matrix Analysis and Applications, Vol. 25,   2004.
        Also LAPACK Working Note 154.
        - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric tridiagonal
        eigenvalue/eigenvector problem",   Computer Science Division Technical Report No.
        UCB/CSD-97-971, UC Berkeley, May 1997.


        Note 1 : SSYEVR calls SSTEMR when the full spectrum is requested on machines which conform
        to the ieee-754 floating point standard. SSYEVR calls SSTEBZ and SSTEIN on non-ieee
        machines and when partial spectrum requests are made.

        Normal execution of SSTEMR may create NaNs and infinities and hence may abort due to a
        floating point exception in environments which do not handle NaNs and infinities in the
        ieee standard default manner.
    \endverbatim

    * @param[in] jobz
              jobz is char* \n
              = 'N':  Compute eigenvalues only; \n
              = 'V':  Compute eigenvalues and eigenvectors. \n
    * @param[in] range
              range is char* \n
              = 'A': all eigenvalues will be found. \n
              = 'V': all eigenvalues in the half-open interval (vl,vu]
              will be found. \n
              = 'I': the il-th through iu-th eigenvalues will be found. \n
              For range = 'V' or 'I' and iu - il < N - 1, SSTEBZ and
              SSTEIN are called \n
    * @param[in] uplo
              uplo is char* \n
              = 'U':  Upper triangle of a is stored; \n
              = 'L':  Lower triangle of a is stored. \n
    * @param[in] n
              n is integer* \n
              The order of the matrix a.  n >= 0. \n
    * @param[in,out] a
              a is float/double array, dimension (lda, n) \n
              On entry, the symmetric matrix a.  If uplo = 'U', the
              leading n-by-n upper triangular part of a contains the
              upper triangular part of the matrix a.  If uplo = 'L',
              the leading n-by-n lower triangular part of a contains
              the lower triangular part of the matrix a. \n
              On exit, the lower triangle (if uplo='L') or the upper
              triangle (if uplo='U') of A, including the diagonal, is
              destroyed. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the array a.  lda >= max(1,n). \n
    * @param[in] vl
              vl is float/double* \n
              If range='V', the lower bound of the interval to
              be searched for eigenvalues. vl < vu. \n
              Not referenced if range = 'A' or 'I'. \n
    * @param[in] vu
              vu is float/double* \n
              If range='V', the upper bound of the interval to
              be searched for eigenvalues. vl < vu. \n
              Not referenced if range = 'A' or 'I'. \n
    * @param[in] il
              il is integer* \n
              If range='I', the index of the
              smallest eigenvalue to be returned. \n
              1 <= il <= iu <= N, if N > 0; il = 1 and iu = 0 if N = 0. \n
              Not referenced if range = 'A' or 'V'. \n
    * @param[in] iu
              iu is integer* \n
              If range='I', the index of the
              largest eigenvalue to be returned. \n
              1 <= il <= iu <= N, if N > 0; il = 1 and iu = 0 if N = 0. \n
              Not referenced if range = 'A' or 'V'. \n
    * @param[in] abstol
              abstol is float/double* \n
              The absolute error tolerance for the eigenvalues. \n
              An approximate eigenvalue is accepted as converged
              when it is determined to lie in an interval [a,b]
              of width less than or equal to \n \n
              abstol + EPS *   max( |a|,|b|) , \n \n
              where EPS is the machine precision.  If abstol is less than
              or equal to zero, then  EPS*|T|  will be used in its place,
              where |T| is the 1-norm of the tridiagonal matrix obtained
              by reducing A to tridiagonal form. \n \n
              See "Computing Small Singular Values of Bidiagonal Matrices
              with Guaranteed High Relative Accuracy," by Demmel and
              Kahan, LAPACK Working Note #3. \n \n
              If high relative accuracy is important, set abstol to
              SLAMCH( 'Safe minimum').  Doing so will guarantee that
              eigenvalues are computed to high relative accuracy when
              possible in future releases.  The current code does not
              make any guarantees about high relative accuracy, but
              future releases will. See J. Barlow and J. Demmel,
              "Computing Accurate Eigensystems of Scaled Diagonally
              Dominant Matrices", LAPACK Working Note #7, for a discussion
              of which matrices define their eigenvalues to high relative
              accuracy. \n
    * @param[out] m
              m is integer* \n
              The total number of eigenvalues found.  0 <= m <= n. \n
              If range = 'A', m = n, and if range = 'I', m = iu-il+1. \n
    * @param[out] w
              w is float/double/COMPLEX/COMPLEX*16 array, dimension (n) \n
              The first m elements contain the selected eigenvalues in
              ascending order. \n
    * @param[out] z
              z is float/double array, dimension (ldz, max(1,m)) \n
              If jobz = 'V', then if info = 0, the first M columns of Z
              contain the orthonormal eigenvectors of the matrix a
              corresponding to the selected eigenvalues, with the i-th
              column of Z holding the eigenvector associated with W(i). \n
              If jobz = 'N', then Z is not referenced. \n
              Note: the user must ensure that at least max(1,m) columns are
              supplied in the array Z; if range = 'V', the exact value of m
              is not known in advance and an upper bound must be used.
              Supplying n columns is always safe. \n
    * @param[in] ldz
              ldz is integer* \n
              The leading dimension of the array Z.  ldz >= 1, and if
              jobz = 'V', ldz >= max(1,n). \n
    * @param[out] isuppz
              isuppz is integer array, dimension ( 2*max(1,m)) \n
              The support of the eigenvectors in Z, i.e., the indices
              indicating the nonzero elements in Z. The i-th eigenvector
              is nonzero only in elements isuppz( 2*i-1) through
              isuppz( 2*i). This is an output of SSTEMR (tridiagonal
              matrix). The support of the eigenvectors of A is typically
              1:N because of the orthogonal transformations applied by SORMTR. \n
              Implemented only for range = 'A' or 'I' and iu - il = N - 1 \n
    * @param[out]	WORK	
              WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK)) \n
              On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
    * @param[in]	LWORK	
              LWORK is INTEGER \n
              The dimension of the array WORK.  LWORK >= max(1,26*N).
              For optimal efficiency, LWORK >= (NB+6)*N,
              where NB is the max of the blocksize for DSYTRD and DORMTR
              returned by ILAENV. \n
 \n
              If LWORK = -1, then a workspace query is assumed; the routine
              only calculates the optimal size of the WORK array, returns
              this value as the first entry of the WORK array, and no error
              message related to LWORK is issued by XERBLA. \n
    * @param[out]	IWORK	
              IWORK is INTEGER array, dimension (MAX(1,LIWORK)) \n
              On exit, if INFO = 0, IWORK(1) returns the optimal LWORK. \n
    * @param[in]	LIWORK	
              LIWORK is INTEGER \n
              The dimension of the array IWORK.  LIWORK >= max(1,10*N). \n
 \n
              If LIWORK = -1, then a workspace query is assumed; the
              routine only calculates the optimal size of the IWORK array,
              returns this value as the first entry of the IWORK array, and
              no error message related to LIWORK is issued by XERBLA. \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit \n
              < 0:  if INFO = -i, the i-th argument had an illegal value \n
              > 0:  Internal error \n

    * @return INTEGER Return value of the function.
    *  */
template<typename T>
integer syevr(char* jobz, char* range, char* uplo, integer* n, T* a, integer* lda, T* vl, T* vu, integer* il, integer* iu, T* abstol, integer* m, T*  w, T* z, integer* ldz, integer* isuppz, T* work, integer* lwork, integer* iwork, integer* liwork, integer* info)
{
  return syevr(jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork, info);
}

/*! @brief Bidiagonal QR algorithm
    *
    * @details
    * \b Purpose:
    * \verbatim
        Bidiagonal QR algorithm.
        Computation of singular values and, optionally, the right and/or left singular vectors
        from the singular value decomposition (SVD) of a real n-by-n (upper or lower) bidiagonal
        matrix b using the implicit zero-shift QR algorithm.  The SVD of B has the form

        B = Q * S * P**T

        where S is the diagonal matrix of singular values, Q is an orthogonal matrix of left
        singular vectors, and P is an orthogonal matrix of right singular vectors.  If left
        singular vectors are requested, this subroutine actually returns U*Q instead of Q, and,
        if right singular vectors are requested, this subroutine returns P**T*vt instead of P**T,
        for given real input matrices U and vt.  When U and vt are the orthogonal matrices that
        reduce a general matrix a to bidiagonal form:

        A = U*B*vt, as computed by SGEBRD, then

        A = (U*Q) * S * (P**T*vt)

        is the SVD of A.  Optionally, the subroutine may also compute Q**T*C for a given real input matrix c.

        See,
        "Computing Small Singular Values of Bidiagonal Matrices With Guaranteed High Relative
        Accuracy," by J. Demmel and W. Kahan, LAPACK Working Note #3 (or SIAM J. Sci. Statist.
        Comput. vol. 11, no. 5, pp. 873-912, Sept 1990) and
        "Accurate singular values and differential qd algorithms," by B. Parlett and V. Fernando,
        Technical Report CPAM-554, Mathematics Department, University of California at Berkeley,
        July 1992 for a detailed description of the algorithm.
    \endverbatim

    * @param[in] uplo
              uplo is char* \n
              = 'U':  B is upper bidiagonal; \n
              = 'L':  B is lower bidiagonal. \n
    * @param[in] n
              n is integer* \n
              The order of the matrix B.  n >= 0. \n
    * @param[in] ncvt
              ncvt is integer* \n
              The number of columns of the matrix vt. ncvt >= 0. \n
    * @param[in] nru
              nru is integer* \n
              The number of rows of the matrix u. nru >= 0. \n
    * @param[in] ncc
              ncc is integer* \n
              The number of columns of the matrix c. ncc >= 0. \n
    * @param[in,out] d
              d is float/double array, dimension (n) \n
              On entry, the n diagonal elements of the bidiagonal matrix b. \n
              On exit, if info=0, the singular values of B in decreasing
              order. \n
    * @param[in,out] e
              e is float/double array, dimension (n-1) \n
              On entry, the N-1 offdiagonal elements of the bidiagonal
              matrix b. \n
              On exit, if info = 0, E is destroyed; if info > 0, D and E
              will contain the diagonal and superdiagonal elements of a
              bidiagonal matrix orthogonally equivalent to the one given
              as input. \n
    * @param[in,out] vt
              vt is float/double array, dimension (ldvt, ncvt) \n
              On entry, an n-by-ncvt matrix vt. \n
              On exit, vt is overwritten by P**T * vt. \n
              Not referenced if ncvt = 0. \n
    * @param[in] ldvt
              ldvt is integer* \n
              The leading dimension of the array vt. \n
              ldvt >= max(1,n) if ncvt > 0; ldvt >= 1 if ncvt = 0. \n
    * @param[in,out] u
              u is float/double array, dimension (ldu, n) \n
              On entry, an nru-by-n matrix U. \n
              On exit, U is overwritten by U * Q. \n
              Not referenced if nru = 0. \n
    * @param[in] ldu
              ldu is integer* \n
              The leading dimension of the array u.  ldu >= max(1,nru). \n
    * @param[in,out] c
              c is float/doublearray, dimension (ldc, ncc) \n
              On entry, an n-by-ncc matrix c. \n
              On exit, c is overwritten by Q**T * C. \n
              Not referenced if ncc = 0. \n
    * @param[in] ldc
              ldc is integer* \n
              The leading dimension of the array c. \n
              ldc >= max(1,n) if ncc > 0; ldc >=1 if ncc = 0. \n
              * \par
              * \verbatim
                  Internal Parameters:
                  ====================
                  TOLMUL  T*, default = max(10,min(100,EPS**(-1/8)))
                  TOLMUL controls the convergence criterion of the QR loop.
                  If it is positive, TOLMUL*EPS is the desired relative
                  precision in the computed singular values.
                  If it is negative, abs(TOLMUL*EPS*sigma_max) is the
                  desired absolute accuracy in the computed singular
                  values (corresponds to relative accuracy
                  abs(TOLMUL*EPS) in the largest singular value.
                  abs(TOLMUL) should be between 1 and 1/EPS, and preferably
                  between 10 (for fast convergence) and .1/EPS
                  (for there to be some accuracy in the results).
                  Default is to lose at either one eighth or 2 of the
                  available decimal digits in each computed singular value
                  (whichever is smaller).

                  MAXITR  integer*, default = 6
                  MAXITR controls the maximum number of passes of the
                  algorithm through its inner loop. The algorithms stops
                  (and so fails to converge) if the number of passes
                  through the inner loop exceeds MAXITR*N**2.
              \endverbatim
    * @param[out]	WORK	
              WORK is REAL array, dimension (4*N) \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit \n
              < 0:  If INFO = -i, the i-th argument had an illegal value \n
              > 0:
                 if NCVT = NRU = NCC = 0, \n
                    = 1, a split was marked by a positive value in E \n
                    = 2, current block of Z not diagonalized after 30*N \n
                         iterations (in inner while loop) \n
                    = 3, termination criterion of outer while loop not met
                         (program created more than N unreduced blocks) \n
                 else NCVT = NRU = NCC = 0, \n
                       the algorithm did not converge; D and E contain the
                       elements of a bidiagonal matrix which is orthogonally
                       similar to the input matrix B;  if INFO = i, i
                       elements of E have not converged to zero. \n
    
    * @return INTEGER Return value of the function.
    *  */
template<typename T>
integer bdsqr(char* uplo, integer* n, integer* ncvt, integer* nru, integer* ncc, T* d, T* e, T* vt, integer* ldvt, T* u, integer* ldu, T* c, integer* ldc, T* rwork, integer* info)
{
  return  bdsqr(uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc, rwork, info);
}
template<typename T, typename Ta>
integer bdsqr(char* uplo, integer* n, integer* ncvt, integer* nru, integer* ncc, Ta* d, Ta* e, T* vt, integer* ldvt, T* u, integer* ldu, T* c, integer* ldc, Ta* rwork, integer* info)
{
  return bdsqr(uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc, rwork, info);
}

/*! @brief BDSDC Bidiagonal divide-and-conquer algorithm
    *
    * @details
    * \b Purpose:
    * \verbatim
        Computation of singular value decomposition (SVD) of a real n-by-n (upper or lower)
        bidiagonal matrix
        B:  B = U * S * vt,
        using a divide and conquer method, where S is a diagonal matrix with non-negative diagonal
        elements (the singular values of B), and U and vt are orthogonal matrices of left and
        right singular vectors, respectively. SBDSDC can be used to compute all singular values,
        and optionally, singular vectors or singular vectors in compact form.

        This code makes very mild assumptions about floating point arithmetic. It will work on
        machines with a guard digit in add/subtract, or on those binary machines without guard
        digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could
        conceivably fail on hexadecimal or decimal machines without guard digits, but we know of
        none.  See SLASD3 for details.

        The code currently calls SLASDQ if singular values only are desired. However, it can be
        slightly modified to compute singular values using the divide and conquer method.
    \endverbatim

    * @param[in] uplo
              uplo is char* \n
              = 'U':  B is upper bidiagonal. \n
              = 'L':  B is lower bidiagonal. \n
    * @param[in] compq
              compq is char* \n
              Specifies whether singular vectors are to be computed
              as follows: \n
              = 'N':  Compute singular values only; \n
              = 'P':  Compute singular values and compute singular
              vectors in compact form; \n
              = 'I':  Compute singular values and singular vectors. \n
    * @param[in] n
              n is integer* \n
              The order of the matrix B.  n >= 0. \n
    * @param[in,out] d
              d is float/double array, dimension (n) \n
              On entry, the n diagonal elements of the bidiagonal matrix b. \n
              On exit, if info=0, the singular values of B. \n
    * @param[in,out] e
              e is float/double array, dimension (n-1) \n
              On entry, the elements of E contain the offdiagonal
              elements of the bidiagonal matrix whose SVD is desired. \n
              On exit, E has been destroyed. \n
    * @param[out] u
              U is float/double array, dimension (ldu,n) \n
              If  compq = 'I', then: \n
              On exit, if info = 0, U contains the left singular vectors
              of the bidiagonal matrix. \n
              For other values of compq, U is not referenced. \n
    * @param[in] ldu
              ldu is integer* \n
              The leading dimension of the array U.  ldu >= 1. \n
              If singular vectors are desired, then ldu >= max( 1, n ). \n
    * @param[out] vt
              vt is float/double array, dimension (ldvt,n) \n
              If  compq = 'I', then: \n
              On exit, if info = 0, vt**T contains the right singular
              vectors of the bidiagonal matrix. \n
              For other values of compq, vt is not referenced. \n
    * @param[in] ldvt
              ldvt is integer* \n
              The leading dimension of the array vt.  ldvt >= 1. \n
              If singular vectors are desired, then ldvt >= max( 1, n ). \n
    * @param[out] q
              q is float/double array, dimension (LDQ) \n
              If  compq = 'P', then: \n
              On exit, if info = 0, Q and iq contain the left
              and right singular vectors in a compact form,
              requiring O(N log N) space instead of 2*n**2. \n
              In particular, Q contains all the float data in
              LDQ >= N*(11 + 2*SMLSIZ + 8*INT(LOG_2(N/(SMLSIZ+1))))
              words of memory, where SMLSIZ is returned by ILAENV and
              is equal to the maximum size of the subproblems at the
              bottom of the computation tree (usually about 25). \n
              For other values of compq, Q is not referenced. \n
    * @param[out] iq
              iq is integer array, dimension (LDIQ) \n
              If  compq = 'P', then: \n
              On exit, if info = 0, Q and iq contain the left
              and right singular vectors in a compact form,
              requiring O(N log N) space instead of 2*n**2. \n
              In particular, iq contains all integer data in
              LDIQ >= N*(3 + 3*INT(LOG_2(N/(SMLSIZ+1))))
              words of memory, where SMLSIZ is returned by ILAENV and
              is equal to the maximum size of the subproblems at the
              bottom of the computation tree (usually about 25). \n
              For other values of compq, iq is not referenced. \n
    * @param[out]	WORK	
              WORK is REAL array, dimension (MAX(1,LWORK)) \n
              If COMPQ = 'N' then LWORK >= (4 * N). \n
              If COMPQ = 'P' then LWORK >= (6 * N). \n
              If COMPQ = 'I' then LWORK >= (3 * N**2 + 4 * N). \n
    * @param[out]	IWORK	
              IWORK is INTEGER array, dimension (8*N) \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit. \n
              < 0:  if INFO = -i, the i-th argument had an illegal value. \n
              > 0:  The algorithm failed to compute a singular value.
                    The update process of divide and conquer failed. \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer bdsdc(char* uplo, char* compq, integer* n, T*  d, T*  e, T*  u, integer* ldu, T*  vt, integer* ldvt, T*  q, T* iq, T* work, integer* iwork, integer* info)
{
  return bdsdc(uplo, compq, n, d, e, u, ldu, vt, ldvt, q, iq, work, iwork, info);
}

/*! @brief BDSVDX computes the singular value decomposition (SVD) of a real  \n
     N-by-N (upper or lower) bidiagonal matrix B
 * @details
 * \b Purpose:
    \verbatim 
     BDSVDX computes the singular value decomposition (SVD) of a real
     N-by-N (upper or lower) bidiagonal matrix B, B = U * S * VT,
     where S is a diagonal matrix with non-negative diagonal elements
     (the singular values of B), and U and VT are orthogonal matrices
     of left and right singular vectors, respectively.

     Given an upper bidiagonal B with diagonal D = [ d_1 d_2 ... d_N ]
     and superdiagonal E = [ e_1 e_2 ... e_N-1 ], SBDSVDX computes the
     singular value decompositon of B through the eigenvalues and
     eigenvectors of the N*2-by-N*2 tridiagonal matrix

           |  0  d_1                |
           | d_1  0  e_1            |
     TGK = |     e_1  0  d_2        |
           |         d_2  .   .     |
           |              .   .   . |

     If (s,u,v) is a singular triplet of B with ||u|| = ||v|| = 1, then
     (+/-s,q), ||q|| = 1, are eigenpairs of TGK, with q = P * ( u' +/-v') /
     sqrt(2) = ( v_1 u_1 v_2 u_2 ... v_n u_n) / sqrt(2), and
     P = [ e_{n+1} e_{1} e_{n+2} e_{2} ... ].

     Given a TGK matrix, one can either a) compute -s,-v and change signs
     so that the singular values (and corresponding vectors) are already in
     descending order (as in SGESVD/SGESDD) or b) compute s,v and reorder
     the values (and corresponding vectors). SBDSVDX implements a) by
     calling SSTEVX (bisection plus inverse iteration, to be replaced
     with a version of the Multiple Relative Robust Representation
     algorithm. (See P. Willems and B. Lang, A framework for the MR^3
     algorithm: theory and implementation, SIAM J. Sci. Comput.,
     35:740-766, 2013.)
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  B is upper bidiagonal; \n
          = 'L':  B is lower bidiagonal. \n
 * @param[in] JOBZ
          JOBZ is CHARACTER*1 \n
          = 'N':  Compute singular values only; \n
          = 'V':  Compute singular values and singular vectors. \n
 * @param[in] RANGE
          RANGE is CHARACTER*1 \n
          = 'A': all singular values will be found. \n
          = 'V': all singular values in the half-open interval [VL,VU)
                 will be found. \n
          = 'I': the IL-th through IU-th singular values will be found. \n
 * @param[in] N
          N is INTEGER \n
          The order of the bidiagonal matrix.  N >= 0. \n
 * @param[in] D
          D is REAL array, dimension (N) \n
          The n diagonal elements of the bidiagonal matrix B. \n
 * @param[in] E
          E is REAL array, dimension (max(1,N-1)) \n
          The (n-1) superdiagonal elements of the bidiagonal matrix
          B in elements 1 to N-1. \n
 * @param[in] VL
         VL is REAL \n
          If RANGE='V', the lower bound of the interval to
          be searched for singular values. VU > VL.
          Not referenced if RANGE = 'A' or 'I'. \n
 * @param[in] VU
          VU is REAL \n
          If RANGE='V', the upper bound of the interval to
          be searched for singular values. VU > VL.
          Not referenced if RANGE = 'A' or 'I'. \n
 * @param[in] IL
          IL is INTEGER \n
          If RANGE='I', the index of the
          smallest singular value to be returned.
          1 <= IL <= IU <= min(M,N), if min(M,N) > 0.
          Not referenced if RANGE = 'A' or 'V'. \n
 * @param[in] IU
          IU is INTEGER
          If RANGE='I', the index of the
          largest singular value to be returned. \n
          1 <= IL <= IU <= min(M,N), if min(M,N) > 0. \n
          Not referenced if RANGE = 'A' or 'V'.
 * @param[out] NS
          NS is INTEGER \n
          The total number of singular values found.  0 <= NS <= N.
          If RANGE = 'A', NS = N, and if RANGE = 'I', NS = IU-IL+1. \n
 * @param[out] S
          S is REAL array, dimension (N) \n
          The first NS elements contain the selected singular values in
          ascending order. \n
 * @param[out] Z 
          Z is REAL array, dimension (2*N,K) \n
          If JOBZ = 'V', then if INFO = 0 the first NS columns of Z
          contain the singular vectors of the matrix B corresponding to
          the selected singular values, with U in rows 1 to N and V
          in rows N+1 to N*2, i.e. \n
          Z = [ U ] \n
              [ V ] \n
          If JOBZ = 'N', then Z is not referenced. \n
          Note: The user must ensure that at least K = NS+1 columns are
          supplied in the array Z; if RANGE = 'V', the exact value of
          NS is not known in advance and an upper bound must be used. \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of the array Z. LDZ >= 1, and if
          JOBZ = 'V', LDZ >= max(2,N*2). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (14*N) \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (12*N) \n
          If JOBZ = 'V', then if INFO = 0, the first NS elements of
          IWORK are zero. If INFO > 0, then IWORK contains the indices
          of the eigenvectors that failed to converge in DSTEVX. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, then i eigenvectors failed to converge
                   in SSTEVX. The indices of the eigenvectors
                   (as returned by SSTEVX) are stored in the
                   array IWORK. \n
                if INFO = N*2 + 1, an internal error occurred. \n
 
 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer bdsvdx(char* uplo, char* jobz, char* range, integer* n, T* d, T* e, T vl, T vu, integer* il, integer* iu, integer* ns, T* s, T* z, integer* ldz, T* work, integer* iwork, integer* info)
{
  return bdsvdx(uplo, jobz, range, n, d, e, vl, vu, il, iu, ns, s, z, ldz, work, iwork, info);
}

/*! @brief DISNA computes the reciprocal condition numbers for the eigenvectors \n
     of a real symmetric or complex Hermitian matrix 
 * @details
 * \b Purpose:
    \verbatim 
     DISNA computes the reciprocal condition numbers for the eigenvectors
     of a real symmetric or complex Hermitian matrix or for the left or
     right singular vectors of a general m-by-n matrix. The reciprocal
     condition number is the 'gap' between the corresponding eigenvalue or
     singular value and the nearest other one.

     The bound on the error, measured by angle in radians, in the I-th
     computed vector is given by

            SLAMCH( 'E') * ( ANORM / SEP( I))

     where ANORM = 2-norm(A) = max( abs( D(j))).  SEP(I) is not allowed
     to be smaller than SLAMCH( 'E')*ANORM in order to limit the size of
     the error bound.

     SDISNA may also be used to compute error bounds for eigenvectors of
     the generalized symmetric definite eigenproblem.
    \endverbatim  

 * @param[in] JOB
          JOB is CHARACTER*1 \n
          Specifies for which problem the reciprocal condition numbers
          should be computed: \n
          = 'E':  the eigenvectors of a symmetric/Hermitian matrix; \n
          = 'L':  the left singular vectors of a general matrix; \n
          = 'R':  the right singular vectors of a general matrix. \n
 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix. M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          If JOB = 'L' or 'R', the number of columns of the matrix,
          in which case N >= 0. Ignored if JOB = 'E'. \n
 * @param[in] D
          D is REAL array, dimension (M) if JOB = 'E'
                              dimension (min(M,N)) if JOB = 'L' or 'R' \n
          The eigenvalues (if JOB = 'E') or singular values (if JOB =
          'L' or 'R') of the matrix, in either increasing or decreasing
          order. If singular values, they must be non-negative. \n
 * @param[out] SEP
          SEP is REAL array, dimension (M) if JOB = 'E'
                               dimension (min(M,N)) if JOB = 'L' or 'R' \n
          The reciprocal condition numbers of the vectors. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n
 
 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer disna(char* job, integer* m, integer* n, T* d, T* sep, integer* info)
{
  return disna(job, m, n, d, sep, info);
}

/*! @brief SLAG2D converts a single precision matrix to a double precision matrix

 * @details
 * \b Purpose:
    \verbatim 
     SLAG2D converts a SINGLE PRECISION matrix, SA, to a DOUBLE
     PRECISION matrix, A.

     Note that while it is possible to overflow while converting
     from double to single, it is not possible to overflow when
     converting from single to double.

     This is an auxiliary routine so there is no argument checking.
    \endverbatim  

 * @param[in] M
          M is INTEGER \n
          The number of lines of the matrix A.  M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A.  N >= 0. \n
 * @param[in] SA
          SA is REAL array, dimension (LDSA,N) \n
          On entry, the M-by-N coefficient matrix SA. \n
 * @param[in] LDSA
          LDSA is INTEGER \n
          The leading dimension of the array SA.  LDSA >= max(1,M). \n
 * @param[out] A
          A is DOUBLE PRECISION array, dimension (LDA,N) \n
          On exit, the M-by-N coefficient matrix A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,M). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
 
 * @return INTEGER Return value of the function.
 * */
integer lag2d(integer* m, integer* n, float* sa, integer* ldsa, double* a, integer* lda, integer* info)
{
  return slag2d(m, n, sa, ldsa, a, lda, info);
}

/*! @brief DLAG2S converts a double precision matrix to a single precision matrix

 * @details
 * \b Purpose:
    \verbatim 
    DLAG2S converts a DOUBLE PRECISION matrix, SA, to a SINGLE
    PRECISION matrix, A.

    RMAX is the overflow for the SINGLE PRECISION arithmetic
    DLAG2S checks that all the entries of A are between -RMAX and
    RMAX. If not the conversion is aborted and a flag is raised.

    This is an auxiliary routine so there is no argument checking.
    \endverbatim 

 * @param[in] M
          M is INTEGER \n
          The number of lines of the matrix A.  M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A.  N >= 0. \n
 * @param[in] A
          A is DOUBLE PRECISION array, dimension (LDA,N) \n
          On entry, the M-by-N coefficient matrix A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,M). \n
 * @param[out] SA
          SA is REAL array, dimension (LDSA,N) \n
          On exit, if INFO=0, the M-by-N coefficient matrix SA; if
          INFO>0, the content of SA is unspecified. \n
 * @param[in] LDSA
          LDSA is INTEGER \n
          The leading dimension of the array SA.  LDSA >= max(1,M). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit. \n
          = 1:  an entry of the matrix A is greater than the SINGLE
                PRECISION overflow threshold, in this case, the content
                of SA in exit is unspecified. \n
 
 * @return INTEGER Return value of the function.
 * */
integer lag2s(integer*m, integer* n, double* a, integer* lda, float* sa, integer *ldsa, integer* info)
{
  return dlag2s(m, n, a, lda, sa, ldsa, info);
}

/*! @brief CLAG2Z converts a complex single precision matrix to a complex double precision matrix

 * @details
 * \b Purpose:
    \verbatim 
     CLAG2Z converts a COMPLEX matrix, SA, to a COMPLEX*16 matrix, A

     Note that while it is possible to overflow while converting
     from double to single, it is not possible to overflow when
     converting from single to double.

     This is an auxiliary routine so there is no argument checking.
    \endverbatim  

 * @param[in] M
          M is INTEGER \n
          The number of lines of the matrix A.  M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A.  N >= 0. \n
 * @param[in] SA
          SA is COMPLEX array, dimension (LDSA,N) \n
          On entry, the M-by-N coefficient matrix SA. \n
 * @param[in] LDSA
          LDSA is INTEGER \n
          The leading dimension of the array SA.  LDSA >= max(1,M). \n
 * @param[out] A
          A is COMPLEX*16 array, dimension (LDA,N) \n
          On exit, the M-by-N coefficient matrix A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,M). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
 
 * @return INTEGER Return value of the function.
 * */
integer lag2z(integer*m, integer* n, scomplex* sa, integer*ldsa, dcomplex* a, integer* lda, integer* info)
{
  return clag2z(m, n, sa, ldsa, a, lda, info);
}

/*! @brief ZLAG2C converts a complex double precision matrix to a complex single precision matrix.

 * @details
 * \b Purpose:
    \verbatim 
    ZLAG2C converts a COMPLEX*16 matrix, SA, to a COMPLEX matrix, A

    RMAX is the overflow for the SINGLE PRECISION arithmetic
    ZLAG2C checks that all the entries of A are between -RMAX and
    RMAX. If not the conversion is aborted and a flag is raised.

    This is an auxiliary routine so there is no argument checking.
    \endverbatim 

 * @param[in] M
          M is INTEGER \n
          The number of lines of the matrix A.  M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A.  N >= 0. \n
 * @param[in] A
          A is COMPLEX*16 array, dimension (LDA,N) \n
          On entry, the M-by-N coefficient matrix A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,M). \n
 * @param[out] SA
          SA is COMPLEX array, dimension (LDSA,N) \n
          On exit, if INFO=0, the M-by-N coefficient matrix SA; if
          INFO>0, the content of SA is unspecified. \n
 * @param[in] LDSA
          LDSA is INTEGER \n
          The leading dimension of the array SA.  LDSA >= max(1,M). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit. \n
          = 1:  an entry of the matrix A is greater than the SINGLE
                PRECISION overflow threshold, in this case, the content
                of SA in exit is unspecified. \n
 
 * @return INTEGER Return value of the function.
 * */
integer lag2c(integer*m, integer* n, dcomplex* a, integer*lda, scomplex* sa, integer* ldsa, integer* info)
{
  return zlag2c(m, n, a, lda, sa, ldsa, info);
}

/*! @brief LAMCH determines single precision machine parameters

 * @details
 * \b Purpose:
    \verbatim 
     LAMCH determines single precision machine parameters.
    \endverbatim   

  * @param[in] CMACH
           CMACH is CHARACTER*1 \n
           Specifies the value to be returned by SLAMCH: \n
           = 'E' or 'e',   SLAMCH := eps \n
           = 'S' or 's ,   SLAMCH := sfmin \n
           = 'B' or 'b',   SLAMCH := base \n
           = 'P' or 'p',   SLAMCH := eps*base \n
           = 'N' or 'n',   SLAMCH := t \n
           = 'R' or 'r',   SLAMCH := rnd \n
           = 'M' or 'm',   SLAMCH := emin \n
           = 'U' or 'u',   SLAMCH := rmin \n
           = 'L' or 'l',   SLAMCH := emax \n
           = 'O' or 'o',   SLAMCH := rmax \n
           where \n
           eps   = relative machine precision \n
           sfmin = safe minimum, such that 1/sfmin does not overflow \n
           base  = base of the machine \n
           prec  = eps*base \n
           t     = number of (base) digits in the mantissa \n
           rnd   = 1.0 when rounding occurs in addition, 0.0 otherwise \n
           emin  = minimum exponent before (gradual) underflow \n
           rmin  = underflow threshold - base**(emin-1) \n
           emax  = largest exponent before overflow \n
           rmax  = overflow threshold  - (base**emax)*(1-eps) \n

* @return T Template based return value of the function.
 * */
float slamch(char* cmach, integer cmach_len)
{
  return fla_slamch(cmach, cmach_len);
}
double dlamch(char* cmach, integer cmach_len)
{
  return fla_dlamch(cmach, cmach_len);
}

/*! @brief LAPY2 returns sqrt(x2+y2)

 * @details
 * \b Purpose:
    \verbatim 
    LAPY2 returns sqrt(x**2+y**2), taking care not to cause unnecessary
    overflow.
    \endverbatim 

 * @param[in] X
          X is REAL \n
 * @param[in] Y
          Y is REAL \n
          X and Y specify the values x and y. \n

* @return T Template based return value of the function.
 * */
template< typename T >
T lapy2(T* x, T* y)
{
  return lapy2(x, y);
}

/*! @brief LAPY3 returns sqrt(x2+y2+z2)

 * @details
 * \b Purpose:
    \verbatim 
     LAPY3 returns sqrt(x**2+y**2+z**2), taking care not to cause
     unnecessary overflow.
    \endverbatim  

 * @param[in] X
          X is REAL \n
 * @param[in] Y
          Y is REAL \n
 * @param[in] Z
          Z is REAL \n
          X, Y and Z specify the values x, y and z. \n
 
 * @return T Template based return value of the function.
 * */
template< typename T >
T lapy3(T* x, T* y, T* z)
{
  return lapy3(x, y, z);
}

/*! @brief LARTGP generates a plane rotation so that the diagonal is nonnegative

 * @details
 * \b Purpose:
    \verbatim 
     LARTGP generates a plane rotation so that

        [  CS  SN  ]  .  [ F ]  =  [ R ]   where CS**2 + SN**2 = 1.
        [ -SN  CS  ]     [ G ]     [ 0 ]

     This is a slower, more accurate version of the Level 1 BLAS routine SROTG,
     with the following other differences:
        F and G are unchanged on return.
        If G=0, then CS=(+/-)1 and SN=0.
        If F=0 and (G .ne. 0), then CS=0 and SN=(+/-)1.

     The sign is chosen so that R >= 0.
    \endverbatim  

 * @param[in] F
          F is REAL \n
          The first component of vector to be rotated. \n
 * @param[in] G
          G is REAL \n
          The second component of vector to be rotated. \n
 * @param[out] CS
          CS is REAL \n
          The cosine of the rotation. \n
 * @param[out] SN
          SN is REAL \n
          The sine of the rotation. \n
 * @param[out] R
          R is REAL \n
          The nonzero component of the rotated vector. \n

  This version has a few statements commented out for thread safety
  (machine parameters are computed on each entry). 10 feb 03, SJH. \n

 * @return T Template based return value of the function.
 * */
template<typename T>
T lartgp(T* f, T* g, T* cs, T* sn, T* r)
{
  return lartgp(f, g, cs, sn, r);
}

/*! @brief General matrix singular value decomposition (QR algorithm)
   *
   * @details
   * \b Purpose:
     \verbatim
     Computation of singular value decomposition (SVD) of a real m-by-n matrix a, optionally
     computing the left and/or right singular vectors. The SVD is written

     A = U * SIGMA * transpose(V)

     where SIGMA is an m-by-n matrix which is zero except for its min(m,n) diagonal elements,
     U is an M-by-M orthogonal matrix, and V is an n-by-n orthogonal matrix.  The diagonal
     elements of SIGMA are the singular values of A; they are real and non-negative, and are
     returned in descending order. The first min(m,n) columns of U and V are the left and right
     singular vectors of A.

     Note that the routine returns V**T, not V.
    \endverbatim

    * @param[in] jobu
              jobu is char* \n
              Specifies options for computing all or part of the matrix U: \n
              = 'A':  all M columns of U are returned in array U: \n
              = 'S':  the first min(m,n) columns of U (the left singular
              vectors) are returned in the array U; \n
              = 'O':  the first min(m,n) columns of U (the left singular
              vectors) are overwritten on the array a; \n
              = 'N':  no columns of U (no left singular vectors) are
              computed. \n
    * @param[in] jobv
              jobv is char* \n
              Specifies options for computing all or part of the matrix
              V**T: \n
              = 'A':  all N rows of V**T are returned in the array vt; \n
              = 'S':  the first min(m,n) rows of V**T (the right singular
              vectors) are returned in the array vt; \n
              = 'O':  the first min(m,n) rows of V**T (the right singular
              vectors) are overwritten on the array a; \n
              = 'N':  no rows of V**T (no right singular vectors) are
              computed. \n \n
              jobv and jobu cannot both be 'O'. \n
    * @param[in] m
              m is integer* \n
              The number of rows of the input matrix a.  m >= 0. \n
    * @param[in] n
              n is integer* \n
              The number of columns of the input matrix a.  n >= 0. \n
    * @param[in,out] a
              a is float/double array, dimension (lda,n) \n
              On entry, the m-by-n matrix a. \n
              On exit, \n
              if jobu = 'O',  A is overwritten with the first min(m,n)
              columns of U (the left singular vectors,
              stored columnwise); \n
              if jobv = 'O', A is overwritten with the first min(m,n)
              rows of V**T (the right singular vectors,
              stored rowwise); \n
              if jobu .ne. 'O' and jobv .ne. 'O', the contents of A
              are destroyed. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the array a.  lda >= max(1,m). \n
    * @param[out] s
              s is float/double array, dimension (min(m,n)) \n
              The singular values of A, sorted so that S(i) >= S(i+1). \n
    * @param[out] u
              U is float/double array, dimension (ldu,UCOL) \n
              (ldu,M) if jobu = 'A' or (ldu,min(m,n)) if jobu = 'S'. \n
              If jobu = 'A', U contains the m-by-m orthogonal matrix U; \n
              if jobu = 'S', U contains the first min(m,n) columns of U
              (the left singular vectors, stored columnwise); \n
              if jobu = 'N' or 'O', U is not referenced. \n
    * @param[in] ldu
              ldu is integer* \n
              The leading dimension of the array U.  ldu >= 1; if
              jobu = 'S' or 'A', ldu >= M. \n
    * @param[out] vt
              vt is float/double array, dimension (ldvt,N) \n
              If jobv = 'A', vt contains the n-by-n orthogonal matrix
              V**T; \n
              if jobv = 'S', vt contains the first min(m,n) rows of
              V**T (the right singular vectors, stored rowwise); \n
              if jobv = 'N' or 'O', vt is not referenced. \n
    * @param[in] ldvt
              ldvt is integer* \n
              The leading dimension of the array vt.  ldvt >= 1; if
              jobv = 'A', ldvt >= N; if jobv = 'S', ldvt >= min(m,n). \n
    * @param[out] superb
              superb is float/double array, dimension (min(m,n)) \n
              Backup of data from working array. \n
    * @param[out]	WORK	
              WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
              On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
    * @param[in]	LWORK	
              LWORK is INTEGER \n
              The dimension of the array WORK. \n
              LWORK >=  MAX(1,2*MIN(M,N)+MAX(M,N)). \n
              For good performance, LWORK should generally be larger. \n
 \n
              If LWORK = -1, then a workspace query is assumed; the routine
              only calculates the optimal size of the WORK array, returns
              this value as the first entry of the WORK array, and no error
              message related to LWORK is issued by XERBLA. \n
    * @param[out]	RWORK	
              RWORK is REAL array, dimension (5*min(M,N)) \n
              On exit, if INFO > 0, RWORK(1:MIN(M,N)-1) contains the
              unconverged superdiagonal elements of an upper bidiagonal
              matrix B whose diagonal is in S (not necessarily sorted).
              B satisfies A = U * B * VT, so it has the same singular
              values as A, and singular vectors related by U and VT. \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit. \n
              < 0:  if INFO = -i, the i-th argument had an illegal value. \n
              > 0:  if CBDSQR did not converge, INFO specifies how many
                    superdiagonals of an intermediate bidiagonal form B
                    did not converge to zero. See the description of RWORK
                    above for details. \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer gesvd(char* jobu, char* jobv, integer* m, integer* n, T* a, integer* lda, T*  s, T* u, integer* ldu, T* vt, integer* ldvt, T* work, integer* lwork, integer* info)
{
  return gesvd(jobu, jobv, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, info);
}
template< typename T, typename Ta >
integer gesvd(char* jobu, char* jobv, integer* m, integer* n, T* a, integer* lda, Ta*  s, T* u, integer* ldu, T* vt, integer* ldvt, T* work, integer* lwork, Ta* rwork, integer* info)
{
  return gesvd(jobu, jobv, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, rwork, info);
}

/*! @brief General matrix singular value decomposition (divide-and-conquer)
  * @details
  * \b Purpose:
    \verbatim
    Computation of singular value decomposition (SVD) of a real m-by-n matrix a, optionally
    computing the left and right singular vectors.  If singular vectors are desired, it uses a
    divide-and-conquer algorithm.

    The SVD is written

    A = U * SIGMA * transpose(V)

    where SIGMA is an m-by-n matrix which is zero except for its min(m,n) diagonal elements,
    U is an M-by-M orthogonal matrix, and V is an n-by-n orthogonal matrix.  The diagonal
    elements of SIGMA are the singular values of A; they are real and non-negative, and are
    returned in descending order.  The first min(m,n) columns of U and V are the left and right
    singular vectors of A.

    Note that the routine returns vt = V**T, not V.

    The divide and conquer algorithm makes very mild assumptions about floating point
    arithmetic. It will work on machines with a guard digit in add/subtract, or on those
    binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray
    C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without
    guard digits, but we know of none.
   \endverbatim

    * @param[in] jobz
              jobz is char* \n
              Specifies options for computing all or part of the matrix U: \n
              = 'A':  all M columns of U and all N rows of V**T are
              returned in the arrays U and vt; \n
              = 'S':  the first min(m,n) columns of U and the first
              min(m,n) rows of V**T are returned in the arrays U
              and vt; \n
              = 'O':  If m >= n, the first N columns of U are overwritten
              on the array a and all rows of V**T are returned in
              the array vt; \n
              otherwise, all columns of U are returned in the
              array U and the first M rows of V**T are overwritten
              in the array a; \n
              = 'N':  no columns of U or rows of V**T are computed. \n
    * @param[in] m
              m is integer* \n
              The number of rows of the input matrix a.  m >= 0. \n
    * @param[in] n
              n is integer* \n
              The number of columns of the input matrix a.  n >= 0. \n
    * @param[in,out] a
              a is float/double array, dimension (lda,n) \n
              On entry, the m-by-n matrix a. \n
              On exit, \n
              if jobz = 'O',  A is overwritten with the first N columns
              of U (the left singular vectors, stored
              columnwise) if m >= n;
              A is overwritten with the first M rows
              of V**T (the right singular vectors, stored
              rowwise) otherwise. \n
              if jobz .ne. 'O', the contents of A are destroyed. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the array a.  lda >= max(1,m). \n
    * @param[out] s
              s is float/double array, dimension (min(m,n)) \n
              The singular values of A, sorted so that S(i) >= S(i+1). \n
    * @param[out] u
              U is float/double array, dimension (ldu,UCOL) \n
              UCOL = m if jobz = 'A' or jobz = 'O' and M < N; \n
              UCOL = min(m,n) if jobz = 'S'. \n
              If jobz = 'A' or jobz = 'O' and m < m, U contains the m-by-m
              orthogonal matrix U; \n
              if jobz = 'S', U contains the first min(m,n) columns of U
              (the left singular vectors, stored columnwise); \n
              if jobz = 'O' and m >= n, or jobz = 'N', U is not referenced. \n
    * @param[in] ldu
              ldu is integer* \n
              The leading dimension of the array U.  ldu >= 1; if
              jobz = 'S' or 'A' or jobz = 'O' and m < n, ldu >= m. \n
    * @param[out] vt
              vt is float/double array, dimension (ldvt,n) \n
              If jobz = 'A' or jobz = 'O' and m >= n, vt contains the
              n-by-n orthogonal matrix V**T; \n
              if jobz = 'S', vt contains the first min(m,n) rows of
              V**T (the right singular vectors, stored rowwise); \n
              if jobz = 'O' and M < N, or jobz = 'N', vt is not referenced. \n
    * @param[in] ldvt
              ldvt is integer* \n
              The leading dimension of the array vt.  ldvt >= 1; \n
              if jobz = 'A' or jobz = 'O' and m >= n, ldvt >= n; \n
              if jobz = 'S', ldvt >= min(m,n). \n
    * @param[out]	WORK	
              WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
              On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
    * @param[in]	LWORK	
              LWORK is INTEGER \n
              The dimension of the array WORK. LWORK >= 1. \n
              If LWORK = -1, a workspace query is assumed.  The optimal
              size for the WORK array is calculated and stored in WORK(1),
              and no other work except argument checking is performed. \n
 \n
              Let mx = max(M,N) and mn = min(M,N). \n
              If JOBZ = 'N', LWORK >= 2*mn + mx. \n
              If JOBZ = 'O', LWORK >= 2*mn*mn + 2*mn + mx. \n
              If JOBZ = 'S', LWORK >=   mn*mn + 3*mn. \n
              If JOBZ = 'A', LWORK >=   mn*mn + 2*mn + mx. \n
              These are not tight minimums in all cases; see comments inside code.
              For good performance, LWORK should generally be larger;
              a query is recommended. \n
    * @param[out]	RWORK	
              RWORK is REAL array, dimension (MAX(1,LRWORK)) \n
              Let mx = max(M,N) and mn = min(M,N). \n
              If JOBZ = 'N',    LRWORK >= 5*mn (LAPACK <= 3.6 needs 7*mn); \n
              else if mx >> mn, LRWORK >= 5*mn*mn + 5*mn; \n
              else              LRWORK >= max( 5*mn*mn + 5*mn,
                                               2*mx*mn + 2*mn*mn + mn ). \n
    * @param[out]	IWORK	
              IWORK is INTEGER array, dimension (8*min(M,N)) \n
    * @param[out]	INFO	
              INFO is INTEGER \n
              = 0:  successful exit. \n
              < 0:  if INFO = -i, the i-th argument had an illegal value. \n
              > 0:  The updating process of SBDSDC did not converge. \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer gesdd(char* jobz, integer* m, integer* n, T* a, integer* lda, T*  s, T* u, integer* ldu, T* vt, integer* ldvt, T* work, integer* lwork, integer* iwork, integer* info)
{
  return gesdd(jobz, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, iwork, info);
}
template< typename T, typename Ta >
integer gesdd(char* jobz, integer* m, integer* n, T* a, integer* lda, Ta*  s, T* u, integer* ldu, T* vt, integer* ldvt, T* work, integer* lwork, Ta* rwork, integer* iwork, integer* info)
{
  return gesdd(jobz, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, rwork, iwork, info);
}

/*! @brief Swap rows

  * @details
  * \b Purpose:
    \verbatim
     Perform a series of row interchanges on the matrix a.
     One row interchange is initiated for each of rows k1 through k2 of A.
    \endverbatim

    * @param[in] n
              n is integer* \n
              The number of columns of the matrix a. \n
    * @param[in,out] a
              a is float/double/COMPLEX/COMPLEX*16 array, dimension (lda,n) \n
              On entry, the matrix of column dimension n to which the row
              interchanges will be applied. \n
              On exit, the permuted matrix. \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the array a. \n
    * @param[in] k1
              k1 is integer* \n
              The first element of ipiv for which a row interchange will
              be done. \n
    * @param[in] k2
              k2 is integer* \n
              (k2-k1+1) is the number of elements of ipiv for which a row
              interchange will be done. \n
    * @param[in] ipiv
              ipiv is integer array, dimension (k1+(k2-k1)*abs(incx)) \n
              The vector of pivot indices. Only the elements in positions
              k1 through k1+(k2-k1)*abs(incx) of ipiv are accessed. \n
              ipiv(k1+(K-k1)*abs(incx)) = L implies rows K and L are to be
              interchanged. \n
    * @param[in] incx
              incx is integer* \n
              The increment between successive values of ipiv. If incx
              is negative, the pivots are applied in reverse order. \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer laswp(integer* n, T* a, integer* lda, integer* k1, integer* k2, integer* ipiv, integer* incx)
{
  return laswp(n, a, lda, k1, k2, ipiv, incx);
}

/*! @brief Initialize the off-diagonal elements and the diagonal elements of a matrix to given values
    *
    * @details
    * \b Purpose:
    * \verbatim
      Initialize an m-by-n matrix a to beta on the diagonal and alpha on the offdiagonals.
      \endverbatim

    * @param[in] uplo
              uplo is char* \n
              Specifies the part of the matrix a to be set. \n
              = 'U':   Upper triangular part is set; the strictly lower
              triangular part of a is not changed. \n
              = 'L':   Lower triangular part is set; the strictly upper
              triangular part of a is not changed. \n
              Otherwise:  All of the matrix a is set. \n
    * @param[in] m
              m is integer* \n
              The number of rows of the matrix a.  m >= 0. \n
    * @param[in] n
              n is integer* \n
              The number of columns of the matrix a.  n >= 0. \n
    * @param[in] alpha
              alpha is float/double/COMPLEX/COMPLEX*16* \n
              The constant to which the offdiagonal elements are to be set. \n
    * @param[in] beta
              beta is float/double/COMPLEX/COMPLEX*16* \n
              The constant to which the diagonal elements are to be set. \n
    * @param[out] a
              a is float/double/COMPLEX/COMPLEX*16 array, dimension (lda,n) \n
              On exit, the leading m-by-n submatrix of A is set as follows: \n \n
              if uplo = 'U', A(i,j) = alpha, 1<=i<=j-1, 1<=j<=n, \n
              if uplo = 'L', A(i,j) = alpha, j+1<=i<=m, 1<=j<=n, \n
              otherwise,  A(i,j) = alpha, 1<=i<=m, 1<=j<=n, i.ne.j, \n \n
              and, for all uplo, A(i,i) = beta, 1<=i<=min(m,n). \n
    * @param[in] lda
              lda is integer* \n
              The leading dimension of the array a.  lda >= max(1,m). \n
    
    * @return INTEGER Return value of the function.
    *  */
template< typename T >
integer laset(char* uplo, integer* m, integer* n, T* alpha, T* beta, T* a, integer* lda)
{
  return laset(uplo, m, n, alpha, beta, a, lda);
}

/*! @brief Bidiagonal block cs decomposition of orthogonal/unitary matrix
   
    @details
    \b Purpose:
    \verbatim
    bbcsd() is inline function to call respective LAPACK API using templates.
    Where T can be REAL or DOUBLE PRECISION.
    
    X is M-by-M, its top-left block is P-by-Q, and Q must be no larger
    than P, M-P, or M-Q.
    BBCSD computes the CS decomposition of an orthogonal matrix in
    bidiagonal-block form,

       [ B11 | B12 0  0 ]
       [  0  |  0 -I  0 ]
    X = [----------------]
       [ B21 | B22 0  0 ]
       [  0  |  0  0  I ]

                                 [  C | -S  0  0 ]
                     [ U1 |    ] [  0 |  0 -I  0 ] [ V1 |    ]**T
                   = [---------] [---------------] [---------]   .
                     [    | U2 ] [  S |  C  0  0 ] [    | V2 ]
                                 [  0 |  0  0  I ]

    X is M-by-M, its top-left block is P-by-Q, and Q must be no larger
    than P, M-P, or M-Q. (If Q is not the smallest index, then X must be
    transposed and/or permuted. This can be done in constant time using
    the TRANS and SIGNS options. See SORCSD for details.)

    The bidiagonal matrices B11, B12, B21, and B22 are represented
    implicitly by angles THETA(1:Q) and PHI(1:Q-1).

    The orthogonal matrices U1, U2, V1T, and V2T are input/output.
    The input matrices are pre- or post-multiplied by the appropriate
    singular vector matrices.
	  
    Real reference:
    http://www.netlib.org/lapack/explore-html/d1/df5/group__real_o_t_h_e_rcomputational_ga95bdd6e44aed23173e9a0c93c32dad78.html#ga95bdd6e44aed23173e9a0c93c32dad78
    Double reference:
    http://www.netlib.org/lapack/explore-html/da/dba/group__double_o_t_h_e_rcomputational_ga27a367582a76c7b48a8bf3eed068e216.html#ga27a367582a76c7b48a8bf3eed068e216
    Complex reference:
	  http://www.netlib.org/lapack/explore-html/d3/db9/group__complex_o_t_h_e_rcomputational_gaa78ee3c0b2912f780622143726a5299e.html#gaa78ee3c0b2912f780622143726a5299e
	  Complex double reference:
	  http://www.netlib.org/lapack/explore-html/d0/da6/group__complex16_o_t_h_e_rcomputational_gab100b320bf854584daf3579ff6d96485.html#gab100b320bf854584daf3579ff6d96485
	  \endverbatim

 * @param[in]	JOBU1	
          JOBU1 is CHARACTER \n
          = 'Y':      U1 is updated; \n
          otherwise:  U1 is not updated. \n
 * @param[in]	JOBU2	
          JOBU2 is CHARACTER \n
          = 'Y':      U2 is updated; \n
          otherwise:  U2 is not updated. \n
 * @param[in]	JOBV1T	
          JOBV1T is CHARACTER \n
          = 'Y':      V1T is updated; \n
          otherwise:  V1T is not updated. \n
 * @param[in]	JOBV2T	
          JOBV2T is CHARACTER \n
          = 'Y':      V2T is updated; \n
          otherwise:  V2T is not updated. \n
 * @param[in]	TRANS	
          TRANS is CHARACTER \n
          = 'T':      X, U1, U2, V1T, and V2T are stored in row-major
                      order; \n
          otherwise:  X, U1, U2, V1T, and V2T are stored in column-
                      major order. \n
 * @param[in]	M	
          M is INTEGER \n
          The number of rows and columns in X, the orthogonal matrix in
          bidiagonal-block form. \n
 * @param[in]	P	
          P is INTEGER \n
          The number of rows in the top-left block of X. 0 <= P <= M. \n
 * @param[in]	Q	
          Q is INTEGER \n
          The number of columns in the top-left block of X.
          0 <= Q <= MIN(P,M-P,M-Q). \n
 * @param[in,out]	THETA	
          THETA is REAL or DOUBLE PRECISION array, dimension (Q) \n
          On entry, the angles THETA(1),...,THETA(Q) that, along with
          PHI(1), ...,PHI(Q-1), define the matrix in bidiagonal-block
          form. On exit, the angles whose cosines and sines define the
          diagonal blocks in the CS decomposition. \n
 * @param[in,out]	PHI	
          PHI is REAL or DOUBLE PRECISION array, dimension (Q-1) \n
          The angles PHI(1),...,PHI(Q-1) that, along with THETA(1),...,
          THETA(Q), define the matrix in bidiagonal-block form. \n
 * @param[in,out]	U1	
          U1 is REAL or DOUBLE PRECISION or COMPLEX or COMPLEX*16 array, dimension (LDU1,P) \n
          On entry, a P-by-P matrix. On exit, U1 is postmultiplied
          by the left singular vector matrix common to [ B11 ; 0 ] and
          [ B12 0 0 ; 0 -I 0 0 ]. \n
 * @param[in]	LDU1	
          LDU1 is INTEGER \n
          The leading dimension of the array U1, LDU1 >= MAX(1,P). \n
 * @param[in,out]	U2	
          U2 is REAL or DOUBLE PRECISION or COMPLEX or COMPLEX*16 array, dimension (LDU2,M-P) \n
          On entry, an (M-P)-by-(M-P) matrix. On exit, U2 is
          postmultiplied by the left singular vector matrix common to
          [ B21 ; 0 ] and [ B22 0 0 ; 0 0 I ]. \n
 * @param[in]	LDU2	
          LDU2 is INTEGER \n
          The leading dimension of the array U2, LDU2 >= MAX(1,M-P). \n
 * @param[in,out]	V1T	
          V1T is REAL or DOUBLE PRECISION or COMPLEX or COMPLEX*16 array, dimension (LDV1T,Q) \n
          On entry, a Q-by-Q matrix. On exit, V1T is premultiplied
          by the transpose of the right singular vector
          matrix common to [ B11 ; 0 ] and [ B21 ; 0 ]. \n
 * @param[in]	LDV1T	
          LDV1T is INTEGER \n
          The leading dimension of the array V1T, LDV1T >= MAX(1,Q). \n
 * @param[in,out]	V2T	
          V2T is REAL or DOUBLE PRECISION or COMPLEX or COMPLEX*16 array, dimension (LDV2T,M-Q) \n
          On entry, an (M-Q)-by-(M-Q) matrix. On exit, V2T is
          premultiplied by the transpose of the right
          singular vector matrix common to [ B12 0 0 ; 0 -I 0 ] and
          [ B22 0 0 ; 0 0 I ]. \n
 * @param[in]	LDV2T	
          LDV2T is INTEGER \n
          The leading dimension of the array V2T, LDV2T >= MAX(1,M-Q). \n
 * @param[out]	B11D	
          B11D is REAL or DOUBLE PRECISION array, dimension (Q) \n
          When SBBCSD converges, B11D contains the cosines of THETA(1),
          ..., THETA(Q). If SBBCSD fails to converge, then B11D
          contains the diagonal of the partially reduced top-left
          block. \n
 * @param[out]	B11E	
          B11E is REAL or DOUBLE PRECISION array, dimension (Q-1) \n
          When SBBCSD converges, B11E contains zeros. If SBBCSD fails
          to converge, then B11E contains the superdiagonal of the
          partially reduced top-left block. \n
 * @param[out]	B12D	
          B12D is REAL or DOUBLE PRECISION array, dimension (Q) \n
          When SBBCSD converges, B12D contains the negative sines of
          THETA(1), ..., THETA(Q). If SBBCSD fails to converge, then
          B12D contains the diagonal of the partially reduced top-right
          block. \n
 * @param[out]	B12E	
          B12E is REAL or DOUBLE PRECISION array, dimension (Q-1) \n
          When SBBCSD converges, B12E contains zeros. If SBBCSD fails
          to converge, then B12E contains the subdiagonal of the
          partially reduced top-right block. \n
 * @param[out]	B21D	
          B21D is REAL or DOUBLE PRECISION array, dimension (Q) \n
          When SBBCSD converges, B21D contains the negative sines of
          THETA(1), ..., THETA(Q). If SBBCSD fails to converge, then
          B21D contains the diagonal of the partially reduced bottom-left
          block. \n
 * @param[out]	B21E	
          B21E is REAL or DOUBLE PRECISION array, dimension (Q-1) \n
          When SBBCSD converges, B21E contains zeros. If SBBCSD fails
          to converge, then B21E contains the subdiagonal of the
          partially reduced bottom-left block. \n
 * @param[out]	B22D	
          B22D is REAL or DOUBLE PRECISION array, dimension (Q) \n
          When SBBCSD converges, B22D contains the negative sines of
          THETA(1), ..., THETA(Q). If SBBCSD fails to converge, then
          B22D contains the diagonal of the partially reduced bottom-right
          block. \n
 * @param[out]	B22E	
          B22E is REAL or DOUBLE PRECISION array, dimension (Q-1) \n
          When SBBCSD converges, B22E contains zeros. If SBBCSD fails
          to converge, then B22E contains the subdiagonal of the
          partially reduced bottom-right block. \n
 * @param[out]	WORK	
          WORK is REAL or DOUBLE PRECISION array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK. LWORK >= MAX(1,8*Q). \n
 \n
          If LWORK = -1, then a workspace query is assumed; the
          routine only calculates the optimal size of the WORK array,
          returns this value as the first entry of the work array, and
          no error message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n
          > 0:  if SBBCSD did not converge, INFO specifies the number
                of nonzero entries in PHI, and B11D, B11E, etc.,
                contain the partially reduced matrix. \n

 * @return INTEGER Return value of the function.
 * */
template<typename T>
integer bbcsd(char* jobu1, char* jobu2, char* jobv1t, char* jobv2t, char* trans,
      integer* m, integer* p, integer* q, T* theta, T* phi, T* u1,
      integer* ldu1, T* u2, integer* ldu2, T* v1t, integer* ldv1t, T* v2t,
      integer* ldv2t, T* b11d, T* b11e, T* b12d, T* b12e, T* b21d, T* b21e,
      T* b22d, T* b22e, T* work, integer *lwork, integer* info)
{
  return bbcsd(jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, u1,
            ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d, b12e,
            b21d, b21e, b22d, b22e, work, lwork, info);
}

template<typename T, typename Ta>
integer bbcsd(char* jobu1, char* jobu2, char* jobv1t, char* jobv2t, char* trans,
      integer* m, integer* p, integer* q, Ta* theta, Ta* phi, T* u1,
      integer* ldu1, T* u2, integer* ldu2, T* v1t, integer* ldv1t, T* v2t,
      integer* ldv2t, Ta* b11d, Ta* b11e, Ta* b12d, Ta* b12e, Ta* b21d,
      Ta* b21e, Ta* b22d, Ta* b22e, Ta* rwork, integer* lrwork, integer *info)
{
    return bbcsd(jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, u1,
            ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d, b12e,
            b21d, b21e, b22d, b22e, rwork, lrwork, info);
}

/*! @brief Reduces a general band matrix to bidiagonal form
 *
 * @details
 * \b Purpose :

   \verbatim
    GBBRD reduces a real general m-by-n band matrix A to upper
     bidiagonal form B by an orthogonal transformation: Q**T * A * P = B.

     The routine computes B, and optionally forms Q or P**T, or computes
    Q**T*C for a given matrix C.
    \endverbatim

 * @param[in] VECT
          VECT is CHARACTER*1 \n
          Specifies whether or not the matrices Q and P**T are to be
          formed. \n
          = 'N': do not form Q or P**T; \n
          = 'Q': form Q only; \n
          = 'P': form P**T only; \n
          = 'B': form both. \n
 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A.  N >= 0. \n
 * @param[in] NCC
          NCC is INTEGER \n
          The number of columns of the matrix C.  NCC >= 0. \n
 * @param[in] KL
          KL is INTEGER \n
          The number of subdiagonals of the matrix A. KL >= 0. \n
 * @param[in] KU
          KU is INTEGER \n
          The number of superdiagonals of the matrix A. KU >= 0. \n
 * @param[in,out] AB
          AB is REAL array, dimension (LDAB,N) \n
          On entry, the m-by-n band matrix A, stored in rows 1 to
          KL+KU+1. The j-th column of A is stored in the j-th column of
          the array AB as follows: \n
          AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl).
          On exit, A is overwritten by values generated during the
          reduction. \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          The leading dimension of the array A. LDAB >= KL+KU+1. \n
 * @param[out] D
          D is REAL array, dimension (min(M,N)) \n
          The diagonal elements of the bidiagonal matrix B. \n
 * @param[out] E
          E is REAL array, dimension (min(M,N)-1) \n
          The superdiagonal elements of the bidiagonal matrix B. \n
 * @param[out] Q
          Q is REAL array, dimension (LDQ,M) \n
          If VECT = 'Q' or 'B', the m-by-m orthogonal matrix Q. \n
          If VECT = 'N' or 'P', the array Q is not referenced. \n
 * @param[in] LDQ
          LDQ is INTEGER \n
          The leading dimension of the array Q. \n
          LDQ >= max(1,M) if VECT = 'Q' or 'B'; LDQ >= 1 otherwise. \n
 * @param[out] PT
          PT is REAL array, dimension (LDPT,N) \n
          If VECT = 'P' or 'B', the n-by-n orthogonal matrix P'. \n
          If VECT = 'N' or 'Q', the array PT is not referenced. \n
 * @param[in] LDPT
          LDPT is INTEGER \n
          The leading dimension of the array PT. \n
          LDPT >= max(1,N) if VECT = 'P' or 'B'; LDPT >= 1 otherwise. \n
 * @param[in,out] C
          C is REAL array, dimension (LDC,NCC)
          On entry, an m-by-ncc matrix C. \n
          On exit, C is overwritten by Q**T*C. \n
          C is not referenced if NCC = 0. \n
 * @param[in] LDC
          LDC is INTEGER \n
          The leading dimension of the array C. \n
          LDC >= max(1,M) if NCC > 0; LDC >= 1 if NCC = 0. \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (max(M,N)) \n
 * @param[out]	RWORK	
          RWORK is REAL array, dimension (max(M,N)) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n

 * @return INTEGER Return value of the function.
* */
template< typename T >
integer gbbrd(char* vect, integer* m, integer* n, integer* ncc, integer* kl, integer* ku, T* ab, integer* ldab, T* d, T* e, T* q, integer* ldq, T* pt, integer* ldpt, T* c, integer* ldc, T* work, integer* info)
{
  return gbbrd( vect, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc, work, info);
}
template< typename T, typename Ta >
integer gbbrd(char* vect, integer* m, integer* n, integer* ncc, integer* kl, integer* ku, T* ab, integer* ldab, Ta* d, Ta* e, T* q, integer* ldq, T* pt, integer* ldpt, T* c, integer* ldc, T* work, Ta* rwork, integer* info)
{
  return gbbrd( vect, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc, work, rwork, info);
}

/*! @brief estimates the reciprocal of the condition number of a real general band matrix A, in either the 1-norm or the infinity-norm,
 *
 * @details
 * \b Purpose :
   \verbatim
    GBCON estimates the reciprocal of the condition number of a real
    general band matrix A, in either the 1-norm or the infinity-norm,
    using the LU factorization computed by SGBTRF.

    An estimate is obtained for norm(inv(A)), and the reciprocal of the
    condition number is computed as
      RCOND = 1 / ( norm(A) * norm(inv(A))).
 \endverbatim

 * @param[in] NORM
          NORM is CHARACTER*1 \n
          Specifies whether the 1-norm condition number or the
          infinity-norm condition number is required: \n
          = '1' or 'O':  1-norm; \n
          = 'I':         Infinity-norm. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] KL
          KL is INTEGER \n
          The number of subdiagonals within the band of A.  KL >= 0. \n
 * @param[in] KU
          KU is INTEGER \n
          The number of superdiagonals within the band of A.  KU >= 0. \n
 * @param[in] AB
          AB is REAL array, dimension (LDAB,N) \n
          Details of the LU factorization of the band matrix A, as
          computed by SGBTRF.  U is stored as an upper triangular band
          matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
          the multipliers used during the factorization are stored in
          rows KL+KU+2 to 2*KL+KU+1. \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1. \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          The pivot indices; for 1 <= i <= N, row i of the matrix was
          interchanged with row IPIV(i). \n
 * @param[in] ANORM
          ANORM is REAL \n
          If NORM = '1' or 'O', the 1-norm of the original matrix A. \n
          If NORM = 'I', the infinity-norm of the original matrix A. \n
 * @param[out] RCOND
          RCOND is REAL \n
          The reciprocal of the condition number of the matrix A,
          computed as RCOND = 1/(norm(A) * norm(inv(A))). \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (2*N) \n
 * @param[out]	RWORK	
          RWORK is REAL array, dimension (N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
* */
template< typename T >
integer gbcon(char* norm, integer* n, integer* kl, integer* ku,  T* ab, integer* ldab, integer* ipiv, T* anorm, T* rcond, T* work, integer* iwork, integer* info)
{
  return gbcon(norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond, work, iwork, info);
}
template< typename T, typename Ta >
integer gbcon(char* norm, integer* n, integer* kl, integer* ku,  T* ab, integer* ldab,  integer* ipiv, Ta* anorm, Ta* rcond, T* work, Ta* rwork, integer* info)
{
  return gbcon(norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond, work, rwork, info);
}

/*! @brief Computes row and column scalings intended to equilibrate  band matrix and reduce its condition number
 *
 * @details
 * \b Purpose:
 * \verbatim
    GBEQU computes row and column scalings intended to equilibrate an
    M-by-N band matrix A and reduce its condition number.
   \endverbatim

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A.  N >= 0. \n
 * @param[in] KL
          KL is INTEGER \n
          The number of subdiagonals within the band of A.  KL >= 0. \n
 * @param[in] KU
          KU is INTEGER \n
          The number of superdiagonals within the band of A.  KU >= 0. \n
 * @param[in] AB
          AB is REAL array, dimension (LDAB,N) \n
          The band matrix A, stored in rows 1 to KL+KU+1.  The j-th
          column of A is stored in the j-th column of the array AB as
          follows: \n
          AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl). \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          The leading dimension of the array AB.  LDAB >= KL+KU+1. \n
 * @param[out] R
          R is REAL array, dimension (M) \n
          If INFO = 0, or INFO > M, R contains the row scale factors
          for A. \n
 * @param[out] C
          C is REAL array, dimension (N) \n
          If INFO = 0, C contains the column scale factors for A. \n
 * @param[out] ROWCND
          ROWCND is REAL \n
          If INFO = 0 or INFO > M, ROWCND contains the ratio of the
          smallest R(i) to the largest R(i).  If ROWCND >= 0.1 and
          AMAX is neither too large nor too small, it is not worth
          scaling by R. \n
 * @param[out] COLCND
          COLCND is REAL \n
          If INFO = 0, COLCND contains the ratio of the smallest
          C(i) to the largest C(i).  If COLCND >= 0.1, it is not
          worth scaling by C. \n
 * @param[out] AMAX
          AMAX is REAL \n
          Absolute value of largest matrix element.  If AMAX is very
          close to overflow or very close to underflow, the matrix
          should be scaled. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, and i is \n
                <= M:  the i-th row of A is exactly zero \n
                >  M:  the (i-M)-th column of A is exactly zero \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer gbequ(integer* m, integer* n, integer* kl, integer* ku,  T* ab, integer* ldab, T* r, T* c, T* rowcnd, T* colcnd, T* amax, integer* info)
{
  return gbequ(m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax, info);
}
template< typename T, typename Ta >
integer gbequ(integer* m, integer* n, integer* kl, integer* ku,  T* ab, integer* ldab, Ta* r, Ta* c, Ta* rowcnd, Ta* colcnd, Ta* amax, integer* info)
{
  return gbequ(m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax, info);
}

/*! @brief Computes row and column scalings intended to equilibrate band matrix and reduce its condition number(scaling factor:power of radix)
 *
 * @details
 * \b Purpose:
 * \verbatim
    GBEQUB computes row and column scalings intended to equilibrate an
    M-by-N matrix A and reduce its condition number.  R returns the row
    scale factors and C the column scale factors, chosen to try to make
    the largest element in each row and column of the matrix B with
    elements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most
    the radix.

    R(i) and C(j) are restricted to be a power of the radix between
    SMLNUM = smallest safe number and BIGNUM = largest safe number.  Use
    of these scaling factors is not guaranteed to reduce the condition
    number of A but works well in practice.

    This routine differs from SGEEQU by restricting the scaling factors
    to a power of the radix.  Barring over- and underflow, scaling by
    these factors introduces no additional rounding errors.  However, the
    scaled entries' magnitudes are no longer approximately 1 but lie
    between sqrt(radix) and 1/sqrt(radix).
   \endverbatim

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A.  N >= 0. \n
 * @param[in] KL
          KL is INTEGER \n
          The number of subdiagonals within the band of A.  KL >= 0. \n
 * @param[in] KU
          KU is INTEGER \n
          The number of superdiagonals within the band of A.  KU >= 0. \n
 * @param[in] AB
          AB is REAL array, dimension (LDAB,N) \n
          The band matrix A, stored in rows 1 to KL+KU+1.  The j-th
          column of A is stored in the j-th column of the array AB as
          follows: \n
          AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl). \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          The leading dimension of the array AB.  LDAB >= KL+KU+1. \n
 * @param[out] R
          R is REAL array, dimension (M) \n
          If INFO = 0, or INFO > M, R contains the row scale factors
          for A. \n
 * @param[out] C
          C is REAL array, dimension (N) \n
          If INFO = 0, C contains the column scale factors for A. \n
 * @param[out] ROWCND
          ROWCND is REAL \n
          If INFO = 0 or INFO > M, ROWCND contains the ratio of the
          smallest R(i) to the largest R(i).  If ROWCND >= 0.1 and
          AMAX is neither too large nor too small, it is not worth
          scaling by R. \n
 * @param[out] COLCND
          COLCND is REAL \n
          If INFO = 0, COLCND contains the ratio of the smallest
          C(i) to the largest C(i).  If COLCND >= 0.1, it is not
          worth scaling by C. \n
 * @param[out] AMAX
          AMAX is REAL \n
          Absolute value of largest matrix element.  If AMAX is very
          close to overflow or very close to underflow, the matrix
          should be scaled. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i,  and i is \n
                <= M:  the i-th row of A is exactly zero \n
                >  M:  the (i-M)-th column of A is exactly zero \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer gbequb(integer* m, integer* n, integer* kl, integer* ku, T* ab, integer* ldab, T* r, T* c, T* rowcnd, T* colcnd, T* amax, integer* info)
{
  return gbequb(m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax, info);
}
template< typename T, typename Ta >
integer gbequb(integer* m, integer* n, integer* kl, integer* ku, T* ab, integer* ldab, Ta* r, Ta* c, Ta* rowcnd, Ta* colcnd, Ta* amax, integer* info)
{
  return gbequb(m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax, info);
}

/*! @brief Improves computed solution to banded matrix and provides error bounds and backward estimates
*
* @details

* \b Purpose:
  \verbatim
    GBRFS improves the computed solution to a system of linear
    equations when the coefficient matrix is banded, and provides
    error bounds and backward error estimates for the solution.
  \endverbatim

 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          Specifies the form of the system of equations: \n
          = 'N':  A * X = B     (No transpose) \n
          = 'T':  A**T * X = B  (Transpose) \n
          = 'C':  A**H * X = B  (Conjugate transpose = Transpose) \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] KL
          KL is INTEGER \n
          The number of subdiagonals within the band of A.  KL >= 0. \n
 * @param[in] KU
          KU is INTEGER \n
          The number of superdiagonals within the band of A.  KU >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns \n
          of the matrices B and X.  NRHS >= 0. \n
 * @param[in] AB
          AB is REAL array, dimension (LDAB,N) \n
          The original band matrix A, stored in rows 1 to KL+KU+1. \n
          The j-th column of A is stored in the j-th column of the
          array AB as follows: \n
          AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(n,j+kl). \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          The leading dimension of the array AB.  LDAB >= KL+KU+1. \n
 * @param[in] AFB
          AFB is REAL array, dimension (LDAFB,N) \n
          Details of the LU factorization of the band matrix A, as
          computed by SGBTRF.  U is stored as an upper triangular band
          matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
          the multipliers used during the factorization are stored in
          rows KL+KU+2 to 2*KL+KU+1. \n
 * @param[in] LDAFB
          LDAFB is INTEGER \n
          The leading dimension of the array AFB.  LDAFB >= 2*KL*KU+1. \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          The pivot indices from SGBTRF; for 1<=i<=N, row i of the
          matrix was interchanged with row IPIV(i). \n
 * @param[in] B
          B is REAL array, dimension (LDB,NRHS) \n
          The right hand side matrix B. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[in,out] X
          X is REAL array, dimension (LDX,NRHS) \n
          On entry, the solution matrix X, as computed by SGBTRS.
          On exit, the improved solution matrix X. \n
 * @param[in] LDX
          LDX is INTEGER \n
          The leading dimension of the array X.  LDX >= max(1,N). \n
 * @param[out] FERR
          FERR is REAL array, dimension (NRHS) \n
          The estimated forward error bound for each solution vector
          X(j) (the j-th column of the solution matrix X). \n
          If XTRUE is the true solution corresponding to X(j), FERR(j)
          is an estimated upper bound for the magnitude of the largest
          element in (X(j) - XTRUE) divided by the magnitude of the
          largest element in X(j).  The estimate is as reliable as
          the estimate for RCOND, and is almost always a slight
          overestimate of the true error. \n
 * @param[out] BERR
          BERR is REAL array, dimension (NRHS) \n
          The componentwise relative backward error of each solution
          vector X(j) (i.e., the smallest relative change in
          any element of A or B that makes X(j) an exact solution). \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (2*N) \n
 * @param[out]	RWORK	
          RWORK is REAL array, dimension (N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer gbrfs(char* trans, integer* n, integer* kl, integer* ku, integer* nrhs,  T* ab, integer* ldab,  T* afb, integer* ldafb,  integer* ipiv,  T* b, integer* ldb, T* x, integer* ldx, T* ferr, T* berr, T* work, integer* iwork, integer* info)
{
  return gbrfs( trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb,  ipiv, b, ldb, x, ldx, ferr, berr, work, iwork, info);
}
template< typename T , typename Ta >
integer gbrfs(char* trans, integer* n, integer* kl, integer* ku, integer* nrhs,  T* ab, integer* ldab,  T* afb, integer* ldafb,  integer* ipiv,  T* b, integer* ldb, T* x, integer* ldx, Ta* ferr, Ta* berr, T* work, Ta* rwork, integer* info)
{
  return gbrfs( trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb,  ipiv, b, ldb, x, ldx, ferr, berr, work, rwork, info);
}

/*! @brief Improves computed solution to banded matrix and provides backward estimates,component wise and normwise error bound
 *
 *  @details
 *  \b Purpose:
 *  \verbatim
    Improves computed solution to banded matrix and provides backward estimates,component wise and normwise error bounds
    \endverbatim

 * @param[in] TRANS
        TRANS is CHARACTER*1 \n
        Specifies the form of the system of equations: \n
          = 'N':  A * X = B     (No transpose) \n
          = 'T':  A**T * X = B  (Transpose) \n
          = 'C':  A**H * X = B  (Conjugate transpose = Transpose) \n
 * @param[in] EQUED
        EQUED is CHARACTER*1 \n
        Specifies the form of equilibration that was done to A
        before calling this routine. This is needed to compute
        the solution and error bounds correctly. \n
           = 'N':  No equilibration \n
           = 'R':  Row equilibration, i.e., A has been premultiplied by
                   diag(R). \n
           = 'C':  Column equilibration, i.e., A has been postmultiplied
                   by diag(C). \n
           = 'B':  Both row and column equilibration, i.e., A has been
                   replaced by diag(R) * A * diag(C).
                   The right hand side B has been changed accordingly. \n
 * @param[in] N
        N is INTEGER \n
        The order of the matrix A.  N >= 0. \n
 * @param[in] KL
        KL is INTEGER  \n
        The number of subdiagonals within the band of A.  KL >= 0. \n
 * @param[in] KU
        KU is INTEGER \n
        The number of superdiagonals within the band of A.  KU >= 0. \n
 * @param[in] NRHS
        NRHS is INTEGER \n
        The number of right hand sides, i.e., the number of columns
        of the matrices B and X.  NRHS >= 0. \n
 * @param[in] AB
        AB is REAL array, dimension (LDAB,N) \n
        The original band matrix A, stored in rows 1 to KL+KU+1. \n
        The j-th column of A is stored in the j-th column of the
        array AB as follows: \n
        AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(n,j+kl). \n
 * @param[in] LDAB
        LDAB is INTEGER \n
        The leading dimension of the array AB.  LDAB >= KL+KU+1. \n
 * @param[in] AFB
        AFB is REAL array, dimension (LDAFB,N) \n
        Details of the LU factorization of the band matrix A, as
        computed by DGBTRF.  U is stored as an upper triangular band
        matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
        the multipliers used during the factorization are stored in
        rows KL+KU+2 to 2*KL+KU+1. \n
 * @param[in] LDAFB
        LDAFB is INTEGER \n
        The leading dimension of the array AFB.  LDAFB >= 2*KL*KU+1. \n
 * @param[in] IPIV
        IPIV is INTEGER \n array, dimension (N) \n
        The pivot indices from SGETRF; for 1<=i<=N, row i of the
        matrix was interchanged with row IPIV(i). \n
 * @param[in,out] R
        R is REAL array, dimension (N) \n
        The row scale factors for A.  If EQUED = 'R' or 'B', A is
        multiplied on the left by diag(R); if EQUED = 'N' or 'C', R
        is not accessed.  R is an input argument if FACT = 'F';
        otherwise, R is an output argument.  If FACT = 'F' and
        EQUED = 'R' or 'B', each element of R must be positive. \n
        If R is output, each element of R is a power of the radix.
        If R is input, each element of R should be a power of the radix
        to ensure a reliable solution and error estimates. Scaling by
        powers of the radix does not cause rounding errors unless the
        result underflows or overflows. Rounding errors during scaling
        lead to refining with a matrix that is not equivalent to the
        input matrix, producing error estimates that may not be
        reliable. \n
 * @param[in,out] C
        C is REAL array, dimension (N) \n
        The column scale factors for A.  If EQUED = 'C' or 'B', A is
        multiplied on the right by diag(C); if EQUED = 'N' or 'R', C
        is not accessed.  C is an input argument if FACT = 'F';
        otherwise, C is an output argument.  If FACT = 'F' and
        EQUED = 'C' or 'B', each element of C must be positive. \n
        If C is output, each element of C is a power of the radix. \n
        If C is input, each element of C should be a power of the radix
        to ensure a reliable solution and error estimates. Scaling by
        powers of the radix does not cause rounding errors unless the
        result underflows or overflows. Rounding errors during scaling
        lead to refining with a matrix that is not equivalent to the
        input matrix, producing error estimates that may not be
        reliable. \n
 * @param[in] B
        B is REAL array, dimension (LDB,NRHS) \n
        The right hand side matrix B. \n
 * @param[in] LDB
        LDB is INTEGER \n
        The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[in,out] X
        X is REAL array, dimension (LDX,NRHS) \n
        On entry, the solution matrix X, as computed by SGETRS. \n
        On exit, the improved solution matrix X. \n
 * @param[in] LDX
        LDX is INTEGER \n
        The leading dimension of the array X.  LDX >= max(1,N). \n
 * @param[out] RCOND
        RCOND is REAL \n
        Reciprocal scaled condition number. This is an estimate of the
        reciprocal Skeel condition number of the matrix A after
        equilibration (if done).  If this is less than the machine
        precision (in particular, if it is zero), the matrix is singular
        to working precision.  Note that the error may still be small even
        if this number is very small and the matrix appears ill-
        conditioned. \n
 * @param[out] BERR
        BERR is REAL array, dimension (NRHS) \n
        Componentwise relative backward error. This is the
        componentwise relative backward error of each solution vector X(j)
        (i.e., the smallest relative change in any element of A or B that
        makes X(j) an exact solution). \n
 * @param[in] N_ERR_BNDS
        N_ERR_BNDS is INTEGER \n
        Number of error bounds to return for each right hand side
        and each type (normwise or componentwise).  See ERR_BNDS_NORM and
        ERR_BNDS_COMP below. \n
 * @param[out] ERR_BNDS_NORM
        ERR_BNDS_NORM is REAL array, dimension (NRHS, N_ERR_BNDS) \n
        For each right-hand side, this array contains information about
        various error bounds and condition numbers corresponding to the
        normwise relative error, which is defined as follows: \n
 \n
        Normwise relative error in the ith solution vector: \n
               max_j (abs(XTRUE(j,i) - X(j,i))) \n
              ------------------------------ \n
                    max_j abs(X(j,i)) \n
 \n
        The array is indexed by the type of error information as described
        below. There currently are up to three pieces of information
        returned. \n
 \n
        The first index in ERR_BNDS_NORM(i,:) corresponds to the ith
        right-hand side. \n
 \n
        The second index in ERR_BNDS_NORM(:,err) contains the following
        three fields: \n
        err = 1 "Trust/don't trust" boolean. Trust the answer if the
                reciprocal condition number is less than the threshold
                sqrt(n) * slamch('Epsilon'). \n
 \n
        err = 2 "Guaranteed" error bound: The estimated forward error,
                almost certainly within a factor of 10 of the true error
                so long as the next entry is greater than the threshold
                sqrt(n) * slamch('Epsilon'). This error bound should only
                be trusted if the previous boolean is true. \n
 \n
        err = 3  Reciprocal condition number: Estimated normwise
                reciprocal condition number.  Compared with the threshold
                sqrt(n) * slamch('Epsilon') to determine if the error
                estimate is "guaranteed". These reciprocal condition
                numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
                appropriately scaled matrix Z.
                Let Z = S*A, where S scales each row by a power of the
                radix so all absolute row sums of Z are approximately 1. \n
 * @param[out] ERR_BNDS_COMP
        ERR_BNDS_COMP is REAL array, dimension (NRHS, N_ERR_BNDS) \n
        For each right-hand side, this array contains information about
        various error bounds and condition numbers corresponding to the
        componentwise relative error, which is defined as follows: \n
 \n
        Componentwise relative error in the ith solution vector: \n
                      abs(XTRUE(j,i) - X(j,i)) \n
               max_j ---------------------- \n
                           abs(X(j,i)) \n
 \n
        The array is indexed by the right-hand side i (on which the
        componentwise relative error depends), and the type of error
        information as described below. There currently are up to three
        pieces of information returned for each right-hand side. If
        componentwise accuracy is not requested (PARAMS(3) = 0.0), then
        ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS < 3, then at most
        the first (:,N_ERR_BNDS) entries are returned. \n
 \n
        The first index in ERR_BNDS_COMP(i,:) corresponds to the ith
        right-hand side. \n
 \n
        The second index in ERR_BNDS_COMP(:,err) contains the following
        three fields: \n
        err = 1 "Trust/don't trust" boolean. Trust the answer if the
                reciprocal condition number is less than the threshold
                sqrt(n) * slamch('Epsilon'). \n
 \n
        err = 2 "Guaranteed" error bound: The estimated forward error,
                almost certainly within a factor of 10 of the true error
                so long as the next entry is greater than the threshold
                sqrt(n) * slamch('Epsilon'). This error bound should only
                be trusted if the previous boolean is true. \n
 \n
        err = 3  Reciprocal condition number: Estimated componentwise
                reciprocal condition number.  Compared with the threshold
                sqrt(n) * slamch('Epsilon') to determine if the error
                estimate is "guaranteed". These reciprocal condition
                numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
                appropriately scaled matrix Z.
                Let Z = S*(A*diag(x)), where x is the solution for the
                current right-hand side and S scales each row of
                A*diag(x) by a power of the radix so all absolute row
                sums of Z are approximately 1. \n
 \n
        See Lapack Working Note 165 for further details and extra
        cautions. \n
 * @param[in] NPARAMS
        NPARAMS is INTEGER \n
        Specifies the number of parameters set in PARAMS.  If <= 0, the
        PARAMS array is never referenced and default values are used. \n
 * @param[in,out] PARAMS
        PARAMS is REAL array, dimension NPARAMS \n
        Specifies algorithm parameters.  If an entry is < 0.0, then
        that entry will be filled with default value used for that
        parameter.  Only positions up to NPARAMS are accessed; defaults
        are used for higher-numbered parameters. \n
 \n
        PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative
            refinement or not. \n
         Default: 1.0 \n
            = 0.0:  No refinement is performed, and no error bounds are
                    computed. \n
            = 1.0:  Use the double-precision refinement algorithm,
                    possibly with doubled-single computations if the
                    compilation environment does not support DOUBLE
                    PRECISION. \n
              (other values are reserved for future use) \n
 \n
        PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual
            computations allowed for refinement. \n
         Default: 10 \n
         Aggressive: Set to 100 to permit convergence using approximate
                     factorizations or factorizations other than LU. If
                     the factorization uses a technique other than
                     Gaussian elimination, the guarantees in
                     err_bnds_norm and err_bnds_comp may no longer be
                     trustworthy. \n
 \n
        PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code
            will attempt to find a solution with small componentwise
            relative error in the double-precision algorithm.  Positive
            is true, 0.0 is false. \n
         Default: 1.0 (attempt componentwise convergence) \n
 * @param[out]	WORK	
        WORK is COMPLEX array, dimension (2*N) \n
 * @param[out]	RWORK	
        RWORK is REAL array, dimension (2*N) \n
 * @param[out]	INFO	
        INFO is INTEGER \n
        = 0:  Successful exit. The solution to every right-hand side is
         guaranteed. \n
        < 0:  If INFO = -i, the i-th argument had an illegal value \n
        > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization
         has been completed, but the factor U is exactly singular, so
         the solution and error bounds could not be computed. RCOND = 0
         is returned. \n
        = N+J: The solution corresponding to the Jth right-hand side is
         not guaranteed. The solutions corresponding to other right-
         hand sides K with K > J may not be guaranteed as well, but
         only the first such right-hand side is reported. If a small
         componentwise error is not requested (PARAMS(3) = 0.0) then
         the Jth right-hand side is the first with a normwise error
         bound that is not guaranteed (the smallest J such
         that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)
         the Jth right-hand side is the first with either a normwise or
         componentwise error bound that is not guaranteed (the smallest
         J such that either ERR_BNDS_NORM(J,1) = 0.0 or
         ERR_BNDS_COMP(J,1) = 0.0). See the definition of
         ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information
         about all of the right-hand sides check ERR_BNDS_NORM or
         ERR_BNDS_COMP. \n
* */
template< typename T >
integer gbrfsx(char* trans, char* equed, integer* n, integer* kl, integer* ku, integer* nrhs, T* ab, integer* ldab, T* afb, integer* ldafb, integer* ipiv, T* r, T* c, T* b, integer* ldb, T* x, integer* ldx, T* rcond, T* berr, integer* n_err_bnds, T* err_bnds_norm, T* err_bnds_comp, integer* nparams, T* params, T* work, integer* iwork, integer* info)
{
  return gbrfsx(trans, equed, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info);
}
template< typename T , typename Ta >
integer gbrfsx(char* trans, char* equed, integer* n, integer* kl, integer* ku, integer* nrhs,  T* ab, integer* ldab,  T* afb, integer* ldafb,  integer* ipiv,  Ta* r,  Ta* c,  T* b, integer* ldb, T* x, integer* ldx, Ta* rcond, Ta* berr, integer* n_err_bnds, Ta* err_bnds_norm, Ta* err_bnds_comp, integer* nparams, Ta* params, T* work, Ta* rwork, integer* info)
{
  return gbrfsx(trans, equed, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info);
}

/*! @brief  GBSV computes the solution to system of linear equations A * X = B for GB matrices
*
* @details
* \b Purpose:
* \verbatim
  GBSV computes the solution to a real system of linear equations
  A * X = B, where A is a band matrix of order N with KL subdiagonals
  and KU superdiagonals, and X and B are N-by-NRHS matrices.
  \endverbatim

 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] KL
          KL is INTEGER \n
          The number of subdiagonals within the band of A.  KL >= 0. \n
 * @param[in] KU
          KU is INTEGER \n
          The number of superdiagonals within the band of A.  KU >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in,out] AB
          AB is REAL array, dimension (LDAB,N) \n
          On entry, the matrix A in band storage, in rows KL+1 to
          2*KL+KU+1; rows 1 to KL of the array need not be set.
          The j-th column of A is stored in the j-th column of the
          array AB as follows: \n
          AB(KL+KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+KL) \n
          On exit, details of the factorization: U is stored as an
          upper triangular band matrix with KL+KU superdiagonals in
          rows 1 to KL+KU+1, and the multipliers used during the
          factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
          See below for further details. \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1. \n
 * @param[out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          The pivot indices that define the permutation matrix P;
          row i of the matrix was interchanged with row IPIV(i). \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,NRHS) \n
          On entry, the N-by-NRHS right hand side matrix B. \n
          On exit, if INFO = 0, the N-by-NRHS solution matrix X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization
                has been completed, but the factor U is exactly
                singular, and the solution has not been computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer gbsv(integer* n, integer* kl, integer* ku, integer* nrhs, T* ab, integer* ldab, integer* ipiv, T* b, integer* ldb, integer* info)
{
  return gbsv(n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb, info);
}

/*! @brief It computes the solution to system of linear equations A * X = B for GB matrices along with error bounds
*
*  @details
* \b Purpose:
  \verbatim
   GBSVX uses the LU factorization to compute the solution to a real
   system of linear equations A * X = B, A**T * X = B, or A**H * X = B,
   where A is a band matrix of order N with KL subdiagonals and KU
   superdiagonals, and X and B are N-by-NRHS matrices.

   Error bounds on the solution and a condition estimate are also
   provided.
   \endverbatim

 * @param[in] FACT
          FACT is CHARACTER*1 \n
          Specifies whether or not the factored form of the matrix A is
          supplied on entry, and if not, whether the matrix A should be
          equilibrated before it is factored. \n
          = 'F':  On entry, AFB and IPIV contain the factored form of
                  A.  If EQUED is not 'N', the matrix A has been
                  equilibrated with scaling factors given by R and C.
                  AB, AFB, and IPIV are not modified. \n
          = 'N':  The matrix A will be copied to AFB and factored. \n
          = 'E':  The matrix A will be equilibrated if necessary, then
                  copied to AFB and factored. \n
 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          Specifies the form of the system of equations. \n
          = 'N':  A * X = B     (No transpose) \n
          = 'T':  A**T * X = B  (Transpose) \n
          = 'C':  A**H * X = B  (Transpose) \n
 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] KL
          KL is INTEGER \n
          The number of subdiagonals within the band of A.  KL >= 0. \n
 * @param[in] KU
          KU is INTEGER \n
          The number of superdiagonals within the band of A.  KU >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrices B and X.  NRHS >= 0. \n
 * @param[in,out] AB
          AB is REAL array, dimension (LDAB,N) \n
          On entry, the matrix A in band storage, in rows 1 to KL+KU+1.
          The j-th column of A is stored in the j-th column of the
          array AB as follows: \n
          AB(KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+kl) \n
 \n
          If FACT = 'F' and EQUED is not 'N', then A must have been
          equilibrated by the scaling factors in R and/or C.  AB is not
          modified if FACT = 'F' or 'N', or if FACT = 'E' and
          EQUED = 'N' on exit. \n
 \n
          On exit, if EQUED .ne. 'N', A is scaled as follows: \n
          EQUED = 'R':  A := diag(R) * A \n
          EQUED = 'C':  A := A * diag(C) \n
          EQUED = 'B':  A := diag(R) * A * diag(C). \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          The leading dimension of the array AB.  LDAB >= KL+KU+1. \n
 * @param[in,out] AFB
          AFB is REAL array, dimension (LDAFB,N) \n
          If FACT = 'F', then AFB is an input argument and on entry
          contains details of the LU factorization of the band matrix
          A, as computed by SGBTRF.  U is stored as an upper triangular
          band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1,
          and the multipliers used during the factorization are stored
          in rows KL+KU+2 to 2*KL+KU+1.  If EQUED .ne. 'N', then AFB is
          the factored form of the equilibrated matrix A. \n
 \n
          If FACT = 'N', then AFB is an output argument and on exit
          returns details of the LU factorization of A. \n
 \n
          If FACT = 'E', then AFB is an output argument and on exit
          returns details of the LU factorization of the equilibrated
          matrix A (see the description of AB for the form of the
          equilibrated matrix). \n
 * @param[in] LDAFB
          LDAFB is INTEGER \n
          The leading dimension of the array AFB.  LDAFB >= 2*KL+KU+1. \n
 * @param[in,out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          If FACT = 'F', then IPIV is an input argument and on entry
          contains the pivot indices from the factorization A = L*U
          as computed by SGBTRF; row i of the matrix was interchanged
          with row IPIV(i). \n
 \n
          If FACT = 'N', then IPIV is an output argument and on exit
          contains the pivot indices from the factorization A = L*U
          of the original matrix A. \n
 \n
          If FACT = 'E', then IPIV is an output argument and on exit
          contains the pivot indices from the factorization A = L*U
          of the equilibrated matrix A. \n
 * @param[in,out] EQUED
          EQUED is CHARACTER*1 \n
          Specifies the form of equilibration that was done. \n
          = 'N':  No equilibration (always true if FACT = 'N'). \n
          = 'R':  Row equilibration, i.e., A has been premultiplied by
                  diag(R). \n
          = 'C':  Column equilibration, i.e., A has been postmultiplied
                  by diag(C). \n
          = 'B':  Both row and column equilibration, i.e., A has been
                  replaced by diag(R) * A * diag(C). \n
          EQUED is an input argument if FACT = 'F'; otherwise, it is an
          output argument. \n
 * @param[in,out] R
          R is REAL array, dimension (N) \n
          The row scale factors for A.  If EQUED = 'R' or 'B', A is
          multiplied on the left by diag(R); if EQUED = 'N' or 'C', R
          is not accessed.  R is an input argument if FACT = 'F';
          otherwise, R is an output argument.  If FACT = 'F' and
          EQUED = 'R' or 'B', each element of R must be positive. \n
 * @param[in,out] C
          C is REAL array, dimension (N) \n
          The column scale factors for A.  If EQUED = 'C' or 'B', A is
          multiplied on the right by diag(C); if EQUED = 'N' or 'R', C
          is not accessed.  C is an input argument if FACT = 'F';
          otherwise, C is an output argument.  If FACT = 'F' and
          EQUED = 'C' or 'B', each element of C must be positive. \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,NRHS) \n
          On entry, the right hand side matrix B. \n
          On exit, \n
          if EQUED = 'N', B is not modified; \n
          if TRANS = 'N' and EQUED = 'R' or 'B', B is overwritten by
          diag(R)*B; \n
          if TRANS = 'T' or 'C' and EQUED = 'C' or 'B', B is
          overwritten by diag(C)*B. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out] X
          X is REAL array, dimension (LDX,NRHS) \n
          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X
          to the original system of equations.  Note that A and B are
          modified on exit if EQUED .ne. 'N', and the solution to the
          equilibrated system is inv(diag(C))*X if TRANS = 'N' and
          EQUED = 'C' or 'B', or inv(diag(R))*X if TRANS = 'T' or 'C'
          and EQUED = 'R' or 'B'. \n
 * @param[in] LDX
          LDX is INTEGER \n
          The leading dimension of the array X.  LDX >= max(1,N). \n
 * @param[out] RCOND
          RCOND is REAL \n
          The estimate of the reciprocal condition number of the matrix
          A after equilibration (if done). If RCOND is less than the
          machine precision (in particular, if RCOND = 0), the matrix
          is singular to working precision.  This condition is
          indicated by a return code of INFO > 0. \n
 * @param[out] FERR
          FERR is REAL array, dimension (NRHS) \n
          The estimated forward error bound for each solution vector
          X(j) (the j-th column of the solution matrix X).
          If XTRUE is the true solution corresponding to X(j), FERR(j)
          is an estimated upper bound for the magnitude of the largest
          element in (X(j) - XTRUE) divided by the magnitude of the
          largest element in X(j).  The estimate is as reliable as
          the estimate for RCOND, and is almost always a slight
          overestimate of the true error. \n
 * @param[out] BERR
          BERR is REAL array, dimension (NRHS) \n
          The componentwise relative backward error of each solution
          vector X(j) (i.e., the smallest relative change in
          any element of A or B that makes X(j) an exact solution). \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (2*N) \n
 * @param[out]	RWORK	
          RWORK is REAL array, dimension (N) \n
          On exit, RWORK(1) contains the reciprocal pivot growth
          factor norm(A)/norm(U). The "max absolute element" norm is
          used. If RWORK(1) is much less than 1, then the stability
          of the LU factorization of the (equilibrated) matrix A
          could be poor. This also means that the solution X, condition
          estimator RCOND, and forward error bound FERR could be
          unreliable. If factorization fails with 0<INFO<=N, then
          RWORK(1) contains the reciprocal pivot growth factor for the
          leading INFO columns of A. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, and i is \n
                <= N:  U(i,i) is exactly zero.  The factorization
                       has been completed, but the factor U is exactly
                       singular, so the solution and error bounds
                       could not be computed. RCOND = 0 is returned. \n
                = N+1: U is nonsingular, but RCOND is less than machine
                       precision, meaning that the matrix is singular
                       to working precision.  Nevertheless, the
                       solution and error bounds are computed because
                       there are a number of situations where the
                       computed solution can be more accurate than the
                       value of RCOND would suggest. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer gbsvx(char* fact, char* trans, integer* n, integer* kl, integer* ku, integer* nrhs, T* ab, integer* ldab, T* afb, integer* ldafb, integer* ipiv, char* equed, T* r, T* c, T* b, integer* ldb, T* x, integer* ldx, T* rcond, T* ferr, T* berr, T* work, integer* iwork, integer* info)
{
  return gbsvx(fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, iwork, info);
}
template< typename T, typename Ta >
integer gbsvx(char* fact, char* trans, integer* n, integer* kl, integer* ku, integer* nrhs, T* ab, integer* ldab, T* afb, integer* ldafb, integer* ipiv, char* equed, Ta* r, Ta* c, T* b, integer* ldb, T* x, integer* ldx, Ta* rcond, Ta* ferr, Ta* berr, T* work, Ta* rwork, integer* info)
{
  return gbsvx(fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, rwork, info);
}

/*! @brief  GBSVXX computes the solution to system of linear equations A * X = B for GB matrices
*
* @details
* \b Purpose
* \verbatim
    GBSVXX uses the LU factorization to compute the solution to a
    real system of linear equations  A * X = B,  where A is an
    N-by-N matrix and X and B are N-by-NRHS matrices.

    If requested, both normwise and maximum componentwise error bounds
    are returned. SGBSVXX will return a solution with a tiny
    guaranteed error (O(eps) where eps is the working machine
    precision) unless the matrix is very ill-conditioned, in which
    case a warning is returned. Relevant condition numbers also are
    calculated and returned.

    SGBSVXX accepts user-provided factorizations and equilibration
    factors; see the definitions of the FACT and EQUED options.
    Solving with refinement and using a factorization from a previous
    SGBSVXX call will also produce a solution with either O(eps)
    errors or warnings, but we cannot make that claim for general
    user-provided factorizations and equilibration factors if they
    differ from what SGBSVXX would itself produce.
   \endverbatim

 * @param[in] FACT
        FACT is CHARACTER*1 \n
        Specifies whether or not the factored form of the matrix A is
        supplied on entry, and if not, whether the matrix A should be
        equilibrated before it is factored. \n
         = 'F':  On entry, AF and IPIV contain the factored form of A.
                 If EQUED is not 'N', the matrix A has been
                 equilibrated with scaling factors given by R and C.
                 A, AF, and IPIV are not modified. \n
         = 'N':  The matrix A will be copied to AF and factored. \n
         = 'E':  The matrix A will be equilibrated if necessary, then
                 copied to AF and factored. \n
 * @param[in] TRANS
        TRANS is CHARACTER*1 \n
        Specifies the form of the system of equations: \n
          = 'N':  A * X = B     (No transpose) \n
          = 'T':  A**T * X = B  (Transpose) \n
          = 'C':  A**H * X = B  (Conjugate Transpose = Transpose) \n
 * @param[in] N
        N is INTEGER \n
        The number of linear equations, i.e., the order of the
        matrix A.  N >= 0. \n
 * @param[in] KL
        KL is INTEGER \n
        The number of subdiagonals within the band of A.  KL >= 0. \n
 * @param[in] KU
        KU is INTEGER \n
        The number of superdiagonals within the band of A.  KU >= 0. \n
 * @param[in] NRHS
        NRHS is INTEGER \n
        The number of right hand sides, i.e., the number of columns
        of the matrices B and X.  NRHS >= 0. \n
 * @param[in,out] AB
        AB is REAL array, dimension (LDAB,N) \n
        On entry, the matrix A in band storage, in rows 1 to KL+KU+1.
        The j-th column of A is stored in the j-th column of the
        array AB as follows: \n
        AB(KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+kl) \n
 \n
        If FACT = 'F' and EQUED is not 'N', then AB must have been
        equilibrated by the scaling factors in R and/or C.  AB is not
        modified if FACT = 'F' or 'N', or if FACT = 'E' and
        EQUED = 'N' on exit. \n
 \n
        On exit, if EQUED .ne. 'N', A is scaled as follows: \n
        EQUED = 'R':  A := diag(R) * A \n
        EQUED = 'C':  A := A * diag(C) \n
        EQUED = 'B':  A := diag(R) * A * diag(C). \n
 * @param[in] LDAB
        LDAB is INTEGER \n
        The leading dimension of the array AB.  LDAB >= KL+KU+1. \n
 * @param[in,out] AFB
        AFB is REAL array, dimension (LDAFB,N) \n
        If FACT = 'F', then AFB is an input argument and on entry
        contains details of the LU factorization of the band matrix
        A, as computed by SGBTRF.  U is stored as an upper triangular
        band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1,
        and the multipliers used during the factorization are stored
        in rows KL+KU+2 to 2*KL+KU+1.  If EQUED .ne. 'N', then AFB is
        the factored form of the equilibrated matrix A. \n
 \n
        If FACT = 'N', then AF is an output argument and on exit
        returns the factors L and U from the factorization A = P*L*U
        of the original matrix A. \n
 \n
        If FACT = 'E', then AF is an output argument and on exit
        returns the factors L and U from the factorization A = P*L*U
        of the equilibrated matrix A (see the description of A for
        the form of the equilibrated matrix). \n
 * @param[in] LDAFB
        LDAFB is INTEGER \n
        The leading dimension of the array AFB.  LDAFB >= 2*KL+KU+1. \n
 * @param[in,out] IPIV
        IPIV is INTEGER array, dimension (N) \n
        If FACT = 'F', then IPIV is an input argument and on entry
        contains the pivot indices from the factorization A = P*L*U
        as computed by SGETRF; row i of the matrix was interchanged
        with row IPIV(i). \n
 \n
        If FACT = 'N', then IPIV is an output argument and on exit
        contains the pivot indices from the factorization A = P*L*U
        of the original matrix A. \n
 \n
        If FACT = 'E', then IPIV is an output argument and on exit
        contains the pivot indices from the factorization A = P*L*U
        of the equilibrated matrix A. \n
 * @param[in,out] EQUED
        EQUED is CHARACTER*1 \n
        Specifies the form of equilibration that was done. \n
         = 'N':  No equilibration (always true if FACT = 'N'). \n
         = 'R':  Row equilibration, i.e., A has been premultiplied by
                 diag(R). \n
         = 'C':  Column equilibration, i.e., A has been postmultiplied
                 by diag(C). \n
         = 'B':  Both row and column equilibration, i.e., A has been
                 replaced by diag(R) * A * diag(C). \n
        EQUED is an input argument if FACT = 'F'; otherwise, it is an
        output argument. \n
 * @param[in,out] R
        R is REAL array, dimension (N) \n
        The row scale factors for A.  If EQUED = 'R' or 'B', A is
        multiplied on the left by diag(R); if EQUED = 'N' or 'C', R
        is not accessed.  R is an input argument if FACT = 'F';
        otherwise, R is an output argument.  If FACT = 'F' and
        EQUED = 'R' or 'B', each element of R must be positive. \n
        If R is output, each element of R is a power of the radix. \n
        If R is input, each element of R should be a power of the radix
        to ensure a reliable solution and error estimates. Scaling by
        powers of the radix does not cause rounding errors unless the
        result underflows or overflows. Rounding errors during scaling
        lead to refining with a matrix that is not equivalent to the
        input matrix, producing error estimates that may not be
        reliable. \n
 * @param[in,out] C
        C is REAL array, dimension (N) \n
        The column scale factors for A.  If EQUED = 'C' or 'B', A is
        multiplied on the right by diag(C); if EQUED = 'N' or 'R', C
        is not accessed.  C is an input argument if FACT = 'F';
        otherwise, C is an output argument.  If FACT = 'F' and
        EQUED = 'C' or 'B', each element of C must be positive. \n
        If C is output, each element of C is a power of the radix. \n
        If C is input, each element of C should be a power of the radix
        to ensure a reliable solution and error estimates. Scaling by
        powers of the radix does not cause rounding errors unless the
        result underflows or overflows. Rounding errors during scaling
        lead to refining with a matrix that is not equivalent to the
        input matrix, producing error estimates that may not be
        reliable. \n
 * @param[in,out] B
        B is REAL array, dimension (LDB,NRHS) \n
        On entry, the N-by-NRHS right hand side matrix B. \n
        On exit, \n
        if EQUED = 'N', B is not modified; \n
        if TRANS = 'N' and EQUED = 'R' or 'B', B is overwritten by
          diag(R)*B; \n
        if TRANS = 'T' or 'C' and EQUED = 'C' or 'B', B is
          overwritten by diag(C)*B. \n
 * @param[in] LDB
        LDB is INTEGER \n
        The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out] X
        X is REAL array, dimension (LDX,NRHS) \n
        If INFO = 0, the N-by-NRHS solution matrix X to the original
        system of equations.  Note that A and B are modified on exit
        if EQUED .ne. 'N', and the solution to the equilibrated system is
        inv(diag(C))*X if TRANS = 'N' and EQUED = 'C' or 'B', or
        inv(diag(R))*X if TRANS = 'T' or 'C' and EQUED = 'R' or 'B'. \n
 * @param[in] LDX
        LDX is INTEGER \n
        The leading dimension of the array X.  LDX >= max(1,N). \n
 * @param[out] RCOND
        RCOND is REAL \n
        Reciprocal scaled condition number. This is an estimate of the
        reciprocal Skeel condition number of the matrix A after
        equilibration (if done).  If this is less than the machine
        precision (in particular, if it is zero), the matrix is singular
        to working precision.  Note that the error may still be small even
        if this number is very small and the matrix appears ill-
        conditioned. \n
 * @param[out] RPVGRW
        RPVGRW is REAL \n
        Reciprocal pivot growth.  On exit, this contains the reciprocal
        pivot growth factor norm(A)/norm(U). The "max absolute element"
        norm is used.  If this is much less than 1, then the stability of
        the LU factorization of the (equilibrated) matrix A could be poor.
        This also means that the solution X, estimated condition numbers,
        and error bounds could be unreliable. If factorization fails with
        0<INFO<=N, then this contains the reciprocal pivot growth factor
        for the leading INFO columns of A.  In SGESVX, this quantity is
        returned in WORK(1). \n
 * @param[out] BERR
        BERR is REAL array, dimension (NRHS) \n
        Componentwise relative backward error.  This is the
        componentwise relative backward error of each solution vector X(j)
        (i.e., the smallest relative change in any element of A or B that
        makes X(j) an exact solution). \n
 * @param[in] N_ERR_BNDS
        N_ERR_BNDS is INTEGER \n
        Number of error bounds to return for each right hand side
        and each type (normwise or componentwise).  See ERR_BNDS_NORM and
        ERR_BNDS_COMP below. \n
 * @param[out] ERR_BNDS_NORM
        ERR_BNDS_NORM is REAL array, dimension (NRHS, N_ERR_BNDS)
        For each right-hand side, this array contains information about
        various error bounds and condition numbers corresponding to the
        normwise relative error, which is defined as follows: \n
 \n
        Normwise relative error in the ith solution vector: \n
               max_j (abs(XTRUE(j,i) - X(j,i))) \n
              ------------------------------ \n
                    max_j abs(X(j,i)) \n
 \n
        The array is indexed by the type of error information as described
        below. There currently are up to three pieces of information
        returned. \n
 \n
        The first index in ERR_BNDS_NORM(i,:) corresponds to the ith
        right-hand side. \n
 \n
        The second index in ERR_BNDS_NORM(:,err) contains the following
        three fields: \n
        err = 1 "Trust/don't trust" boolean. Trust the answer if the
                reciprocal condition number is less than the threshold
                sqrt(n) * slamch('Epsilon'). \n
 \n
        err = 2 "Guaranteed" error bound: The estimated forward error,
                almost certainly within a factor of 10 of the true error
                so long as the next entry is greater than the threshold
                sqrt(n) * slamch('Epsilon'). This error bound should only
                be trusted if the previous boolean is true. \n
 \n
        err = 3  Reciprocal condition number: Estimated normwise
                reciprocal condition number.  Compared with the threshold
                sqrt(n) * slamch('Epsilon') to determine if the error
                estimate is "guaranteed". These reciprocal condition
                numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
                appropriately scaled matrix Z.
                Let Z = S*A, where S scales each row by a power of the
                radix so all absolute row sums of Z are approximately 1. \n
 \n
        See Lapack Working Note 165 for further details and extra
        cautions. \n
 * @param[out] ERR_BNDS_COMP
        ERR_BNDS_COMP is REAL array, dimension (NRHS, N_ERR_BNDS) \n
        For each right-hand side, this array contains information about
        various error bounds and condition numbers corresponding to the
        componentwise relative error, which is defined as follows: \n
 \n
        Componentwise relative error in the ith solution vector: \n
                      abs(XTRUE(j,i) - X(j,i)) \n
               max_j ---------------------- \n
                           abs(X(j,i)) \n
 \n
        The array is indexed by the right-hand side i (on which the
        componentwise relative error depends), and the type of error
        information as described below. There currently are up to three
        pieces of information returned for each right-hand side. If
        componentwise accuracy is not requested (PARAMS(3) = 0.0), then
        ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS < 3, then at most
        the first (:,N_ERR_BNDS) entries are returned. \n
 \n
        The first index in ERR_BNDS_COMP(i,:) corresponds to the ith
        right-hand side. \n
 \n
        The second index in ERR_BNDS_COMP(:,err) contains the following
        three fields: \n
        err = 1 "Trust/don't trust" boolean. Trust the answer if the
                reciprocal condition number is less than the threshold
                sqrt(n) * slamch('Epsilon'). \n
 \n
        err = 2 "Guaranteed" error bound: The estimated forward error,
                almost certainly within a factor of 10 of the true error
                so long as the next entry is greater than the threshold
                sqrt(n) * slamch('Epsilon'). This error bound should only
                be trusted if the previous boolean is true. \n
 \n
        err = 3  Reciprocal condition number: Estimated componentwise
                reciprocal condition number.  Compared with the threshold
                sqrt(n) * slamch('Epsilon') to determine if the error
                estimate is "guaranteed". These reciprocal condition
                numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
                appropriately scaled matrix Z.
                Let Z = S*(A*diag(x)), where x is the solution for the
                current right-hand side and S scales each row of
                A*diag(x) by a power of the radix so all absolute row
                sums of Z are approximately 1. \n
 \n
        See Lapack Working Note 165 for further details and extra
        cautions. \n
 * @param[in] NPARAMS
        NPARAMS is INTEGER \n
        Specifies the number of parameters set in PARAMS.  If <= 0, the
        PARAMS array is never referenced and default values are used. \n
 * @param[in,out] PARAMS
        PARAMS is REAL array, dimension NPARAMS \n
        Specifies algorithm parameters.  If an entry is < 0.0, then
        that entry will be filled with default value used for that
        parameter.  Only positions up to NPARAMS are accessed; defaults
        are used for higher-numbered parameters. \n
 \n
        PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative
            refinement or not. \n
         Default: 1.0 \n
            = 0.0:  No refinement is performed, and no error bounds are
                    computed. \n
            = 1.0:  Use the double-precision refinement algorithm,
                    possibly with doubled-single computations if the
                    compilation environment does not support DOUBLE
                    PRECISION.
              (other values are reserved for future use) \n
 \n
        PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual
            computations allowed for refinement. \n
         Default: 10 \n
         Aggressive: Set to 100 to permit convergence using approximate
                     factorizations or factorizations other than LU. If
                     the factorization uses a technique other than
                     Gaussian elimination, the guarantees in
                     err_bnds_norm and err_bnds_comp may no longer be
                     trustworthy. \n
 \n
        PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code
            will attempt to find a solution with small componentwise
            relative error in the double-precision algorithm.  Positive
            is true, 0.0 is false. \n
         Default: 1.0 (attempt componentwise convergence) \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (2*N) \n
 * @param[out]	RWORK	
          RWORK is REAL array, dimension (2*N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  Successful exit. The solution to every right-hand side is
           guaranteed. \n
          < 0:  If INFO = -i, the i-th argument had an illegal value \n
          > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization
           has been completed, but the factor U is exactly singular, so
           the solution and error bounds could not be computed. RCOND = 0
           is returned. \n
          = N+J: The solution corresponding to the Jth right-hand side is
           not guaranteed. The solutions corresponding to other right-
           hand sides K with K > J may not be guaranteed as well, but
           only the first such right-hand side is reported. If a small
           componentwise error is not requested (PARAMS(3) = 0.0) then
           the Jth right-hand side is the first with a normwise error
           bound that is not guaranteed (the smallest J such
           that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)
           the Jth right-hand side is the first with either a normwise or
           componentwise error bound that is not guaranteed (the smallest
           J such that either ERR_BNDS_NORM(J,1) = 0.0 or
           ERR_BNDS_COMP(J,1) = 0.0). See the definition of
           ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information
           about all of the right-hand sides check ERR_BNDS_NORM or
           ERR_BNDS_COMP. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer gbsvxx(char* fact, char* trans, integer* n, integer* kl, integer* ku, integer* nrhs, T* ab, integer* ldab, T* afb, integer* ldafb, integer* ipiv, char* equed, T* r, T* c, T* b, integer* ldb, T* x, integer* ldx, T* rcond, T* rpvgrw, T* berr, integer* n_err_bnds, T* err_bnds_norm, T* err_bnds_comp, integer* nparams, T* params, T* work, integer* iwork, integer* info)
{
  return gbsvxx(fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info);
}
template< typename T, typename Ta >
integer gbsvxx(char* fact, char* trans, integer* n, integer* kl, integer* ku, integer* nrhs, T* ab, integer* ldab, T* afb, integer* ldafb, integer* ipiv, char* equed, Ta* r, Ta* c, T* b, integer* ldb, T* x, integer* ldx, Ta* rcond, Ta* rpvgrw, Ta* berr, integer* n_err_bnds, Ta* err_bnds_norm, Ta* err_bnds_comp, integer* nparams, Ta* params, T* work, Ta* rwork, integer* info)
{
  return gbsvxx(fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info);
}

/*! @brief \b GBTRF computes the LU factorization of a general band matrix using the pivot
 *  @details
 *  \b Purpose:
 *  \verbatim
    GBTRF computes an LU factorization of a real m-by-n band matrix A
    using partial pivoting with row interchanges.

    This is the blocked version of the algorithm, calling Level 3 BLAS.
    \endverbatim

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A.  N >= 0. \n
 * @param[in] KL
          KL is INTEGER \n
          The number of subdiagonals within the band of A.  KL >= 0.
 * @param[in] KU
          KU is INTEGER \n
          The number of superdiagonals within the band of A.  KU >= 0. \n
 * @param[in,out] AB
          AB is REAL array, dimension (LDAB,N) \n
          On entry, the matrix A in band storage, in rows KL+1 to
          2*KL+KU+1; rows 1 to KL of the array need not be set.
          The j-th column of A is stored in the j-th column of the
          array AB as follows: \n
          AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl) \n
 \n
          On exit, details of the factorization: U is stored as an
          upper triangular band matrix with KL+KU superdiagonals in
          rows 1 to KL+KU+1, and the multipliers used during the
          factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
          See below for further details. \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1. \n
 * @param[in] IPIV
           IPIV is INTEGER array, dimension (min(M,N)) \n
           The pivot indices; for 1 <= i <= min(M,N), row i of the
           matrix was interchanged with row IPIV(i). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n
          > 0: if INFO = +i, U(i,i) is exactly zero. The factorization
               has been completed, but the factor U is exactly
               singular, and division by zero will occur if it is used
               to solve a system of equations. \n

 * @return INTEGER Return value of the function.
  * */
template< typename T >
integer gbtrf(integer* m, integer* n, integer* kl, integer* ku, T* ab, integer* ldab, integer* ipiv, integer* info)
{
  return gbtrf(m, n, kl, ku, ab, ldab, ipiv, info);
}

/*! @brief \b GBTRS solves a system of linear equationsA * X = B  or  A**T * X = B with a general band matrix A using the LU factorization computed by GBTRF
 *  @details
    \b Purpose:
    \verbatim
    GBTRS solves a system of linear equations
    A * X = B  or  A**T * X = B
    with a general band matrix A using the LU factorization computed
    by GBTRF.
    \endverbatim
 * @param[in] TRANS
        TRANS is CHARACTER*1 \n
        Specifies the form of the system of equations. \n
        = 'N':  A * X = B  (No transpose) \n
        = 'T':  A**T* X = B  (Transpose) \n
        = 'C':  A**T* X = B  (Conjugate transpose = Transpose) \n
 * @param[in] N
        N is INTEGER \n
        The order of the matrix A.  N >= 0. \n
 * @param[in] KL
        KL is INTEGER \n
        The number of subdiagonals within the band of A.  KL >= 0. \n
 * @param[in] KU
        KU is INTEGER \n
        The number of superdiagonals within the band of A.  KU >= 0. \n
 * @param[in] NRHS
        NRHS is INTEGER \n
        The number of right hand sides, i.e., the number of columns
        of the matrix B.  NRHS >= 0. \n
 * @param[in] AB
        AB is REAL array, dimension (LDAB,N) \n
        Details of the LU factorization of the band matrix A, as
        computed by SGBTRF.  U is stored as an upper triangular band
        matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
        the multipliers used during the factorization are stored in
        rows KL+KU+2 to 2*KL+KU+1. \n
 * @param[in] LDAB
        LDAB is INTEGER \n
        The leading dimension of the array AB.  LDAB >= 2*KL+KU+1. \n
 * @param[in] IPIV
        IPIV is INTEGER \n array, dimension (N)
        The pivot indices; for 1 <= i <= N, row i of the matrix was
        interchanged with row IPIV(i). \n
 * @param[in,out] B
        B is REAL array, dimension (LDB,NRHS) \n
        On entry, the right hand side matrix B.
        On exit, the solution matrix X. \n
 * @param[in] LDB
        LDB is INTEGER \n
        The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out]	INFO	
        INFO is INTEGER \n
        = 0:  successful exit \n
        < 0:  if INFO = -i, the i-th argument had an illegal value \n

* @return INTEGER Return value of the function.
 * */
template< typename T >
integer gbtrs(char* trans, integer* n, integer* kl, integer* ku, integer* nrhs,  T* ab, integer* ldab,  integer* ipiv, T* b, integer* ldb, integer* info)
{
  return gbtrs(trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb, info);
}

/*! @brief \b GEBAK Forms right left vectors of real general matrix
 *
 * @details
    \b Purpose:
    *  =============
    \verbatim
    GEBAK forms the right or left eigenvectors of a real general matrix
    by backward transformation on the computed eigenvectors of the
    balanced matrix output by GEBAL.
    \endverbatim

 * @param[in] JOB
        JOB is CHARACTER*1 \n
        Specifies the type of backward transformation required: \n
        = 'N': do nothing, return immediately; \n
        = 'P': do backward transformation for permutation only; \n
        = 'S': do backward transformation for scaling only; \n
        = 'B': do backward transformations for both permutation and
               scaling. \n
        JOB must be the same as the argument JOB supplied to SGEBAL. \n
 * @param[in] SIDE
        SIDE is CHARACTER*1 \n
        = 'R':  V contains right eigenvectors; \n
        = 'L':  V contains left eigenvectors. \n
 * @param[in] N
        N is INTEGER \n
        The number of rows of the matrix V.  N >= 0. \n
 * @param[in] ILO
        ILO is INTEGER \n
 * @param[in] IHI
        IHI is INTEGER \n
        The integers ILO and IHI determined by SGEBAL. \n
        1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0. \n
 * @param[in] SCALE
        SCALE is REAL array, dimension (N) \n
        Details of the permutation and scaling factors, as returned
        by SGEBAL. \n
 * @param[in] M
        M is INTEGER \n
        The number of columns of the matrix V.  M >= 0. \n
 * @param[in,out] V
        V is REAL array, dimension (LDV,M) \n
        On entry, the matrix of right or left eigenvectors to be
        transformed, as returned by SHSEIN or STREVC. \n
        On exit, V is overwritten by the transformed eigenvectors. \n
 * @param[in] LDV
        LDV is INTEGER \n
        The leading dimension of the array V. LDV >= max(1,N). \n
 * @param[out]	INFO	
        INFO is INTEGER \n
        = 0:  successful exit \n
        < 0:  if INFO = -i, the i-th argument had an illegal value. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer gebak(char* job, char* side, integer* n, integer* ilo, integer* ihi,  T* scale, integer* m, T* v, integer* ldv, integer* info)
{
  return gebak(job, side, n, ilo, ihi,  scale, m, v, ldv, info);
}
template< typename T, typename Ta >
integer gebak(char* job, char* side, integer* n, integer* ilo, integer* ihi,  Ta* scale, integer* m, T* v, integer* ldv, integer* info)
{
  return gebak(job, side, n, ilo, ihi,  scale, m, v, ldv, info);
}

/*! @brief \b GEBAL It balances a real matrix
 *
 *  @details
 *  \b Purpose:
    \verbatim
    GEBAL balances a general real matrix A.  This involves, first,
    permuting A by a similarity transformation to isolate eigenvalues
    in the first 1 to ILO-1 and last IHI+1 to N elements on the
    diagonal; and second, applying a diagonal similarity transformation
    to rows and columns ILO to IHI to make the rows and columns as
    close in norm as possible.  Both steps are optional.

    Balancing may reduce the 1-norm of the matrix, and improve the
    accuracy of the computed eigenvalues and/or eigenvectors.
    \endverbatim

 * @param[in] JOB
          JOB is CHARACTER*1 \n
          Specifies the operations to be performed on A: \n
          = 'N':  none:  simply set ILO = 1, IHI = N, SCALE(I) = 1.0
                  for i = 1,...,N; \n
          = 'P':  permute only; \n
          = 'S':  scale only; \n
          = 'B':  both permute and scale. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the input matrix A. \n
          On exit,  A is overwritten by the balanced matrix.
          If JOB = 'N', A is not referenced.
          See Further Details. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] ILO
          ILO is INTEGER \n
 * @param[out] IHI
          IHI is INTEGER \n
          ILO and IHI are set to integers such that on exit
          A(i,j) = 0 if i > j and j = 1,...,ILO-1 or I = IHI+1,...,N.
          If JOB = 'N' or 'S', ILO = 1 and IHI = N. \n
 * @param[out] SCALE
          SCALE is REAL array, dimension (N) \n
          Details of the permutations and scaling factors applied to
          A.  If P(j) is the index of the row and column interchanged
          with row and column j and D(j) is the scaling factor
          applied to row and column j, then \n
          SCALE(j) = P(j)    for j = 1,...,ILO-1 \n
                   = D(j)    for j = ILO,...,IHI \n
                   = P(j)    for j = IHI+1,...,N. \n
          The order in which the interchanges are made is N to IHI+1, \n
          then 1 to ILO-1. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer gebal(char* job, integer* n, T* a, integer* lda, integer* ilo, integer* ihi, T* scale, integer* info)
{
  return gebal(job, n, a, lda, ilo, ihi, scale, info);
}
template< typename T, typename Ta >
integer gebal(char* job, integer* n, T* a, integer* lda, integer* ilo, integer* ihi, Ta* scale, integer* info)
{
  return gebal(job, n, a, lda, ilo, ihi, scale, info);
}

/*! @brief  GEEQUB - computes row and column scaling to reduce condition number of matrix
 *
 *  @details
 *  \b Purpose:
 *  \verbatim
    GEEQUB computes row and column scalings intended to equilibrate an
    M-by-N matrix A and reduce its condition number.  R returns the row
    scale factors and C the column scale factors, chosen to try to make
    the largest element in each row and column of the matrix B with
    elements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most
    the radix.

    R(i) and C(j) are restricted to be a power of the radix between
    SMLNUM = smallest safe number and BIGNUM = largest safe number.  Use
    of these scaling factors is not guaranteed to reduce the condition
    number of A but works well in practice.

    This routine differs from SGEEQU by restricting the scaling factors
    to a power of the radix.  Barring over- and underflow, scaling by
    these factors introduces no additional rounding errors.  However, the
    scaled entries' magnitudes are no longer approximately 1 but lie
    between sqrt(radix) and 1/sqrt(radix).
    \endverbatim

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A.  N >= 0. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          The M-by-N matrix whose equilibration factors are
          to be computed. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,M). \n
 * @param[out] R
          R is REAL array, dimension (M) \n
          If INFO = 0 or INFO > M, R contains the row scale factors
          for A. \n
 * @param[out] C
          C is REAL array, dimension (N) \n
          If INFO = 0,  C contains the column scale factors for A. \n
 * @param[out] ROWCND
          ROWCND is REAL \n
          If INFO = 0 or INFO > M, ROWCND contains the ratio of the
          smallest R(i) to the largest R(i).  If ROWCND >= 0.1 and
          AMAX is neither too large nor too small, it is not worth
          scaling by R. \n
 * @param[out] COLCND
          COLCND is REAL \n
          If INFO = 0, COLCND contains the ratio of the smallest
          C(i) to the largest C(i).  If COLCND >= 0.1, it is not
          worth scaling by C. \n
 * @param[out] AMAX
          AMAX is REAL \n
          Absolute value of largest matrix element.  If AMAX is very
          close to overflow or very close to underflow, the matrix
          should be scaled. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i,  and i is \n
                <= M:  the i-th row of A is exactly zero \n
                >  M:  the (i-M)-th column of A is exactly zero \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer geequb(integer* m, integer* n,  T* a, integer* lda, T* r, T* c, T* rowcnd, T* colcnd, T* amax, integer* info)
{
  return geequb(m, n,  a, lda, r, c, rowcnd, colcnd, amax, info);
}
template< typename T, typename Ta >
integer geequb(integer* m, integer* n,  T* a, integer* lda, Ta* r, Ta* c, Ta* rowcnd, Ta* colcnd, Ta* amax, integer* info)
{
  return geequb(m, n,  a, lda, r, c, rowcnd, colcnd, amax, info);
}

/*! @brief GEES computes the eigenvalues, the Schur form, and, optionally, the matrix of Schur vectors for GE matrices</b>
 *  @details
 *  \b Purpose:
 *  \verbatim
    GEES computes for an N-by-N real nonsymmetric matrix A, the
    eigenvalues, the real Schur form T, and, optionally, the matrix of
    Schur vectors Z.  This gives the Schur factorization A = Z*T*(Z**T).

    Optionally, it also orders the eigenvalues on the diagonal of the
    real Schur form so that selected eigenvalues are at the top left.
    The leading columns of Z then form an orthonormal basis for the
    invariant subspace corresponding to the selected eigenvalues.

    A matrix is in real Schur form if it is upper quasi-triangular with
    1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in the
    form
           [  a  b  ]
           [  c  a  ]

    where b*c < 0. The eigenvalues of such a block are a +- sqrt(bc).
    \endverbatim

 * @param[in] JOBVS
          JOBVS is CHARACTER*1 \n
          = 'N': Schur vectors are not computed; \n
          = 'V': Schur vectors are computed. \n
 * @param[in] SORT
          SORT is CHARACTER*1 \n
          Specifies whether or not to order the eigenvalues on the
          diagonal of the Schur form. \n
          = 'N': Eigenvalues are not ordered; \n
          = 'S': Eigenvalues are ordered (see SELECT). \n
 * @param[in] SELECT
          SELECT is a LOGICAL FUNCTION of two REAL arguments \n
          SELECT must be declared EXTERNAL in the calling subroutine.
          If SORT = 'S', SELECT is used to select eigenvalues to sort
          to the top left of the Schur form.
          If SORT = 'N', SELECT is not referenced. \n
          An eigenvalue WR(j)+sqrt(-1)*WI(j) is selected if
          SELECT(WR(j),WI(j)) is true; i.e., if either one of a complex
          conjugate pair of eigenvalues is selected, then both complex
          eigenvalues are selected. \n
          Note that a selected complex eigenvalue may no longer
          satisfy SELECT(WR(j),WI(j)) = .TRUE. after ordering, since
          ordering may change the value of complex eigenvalues
          (especially if the eigenvalue is ill-conditioned); in this
          case INFO is set to N+2 (see INFO below). \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A. N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the N-by-N matrix A. \n
          On exit, A has been overwritten by its real Schur form T. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] SDIM
          SDIM is INTEGER \n
          If SORT = 'N', SDIM = 0. \n
          If SORT = 'S', SDIM = number of eigenvalues (after sorting)
                         for which SELECT is true. (Complex conjugate
                         pairs for which SELECT is true for either
                         eigenvalue count as  - computes row and column scaling to reduce condition number of matrix \n
 * @param[out] WR/*!
          WR is REAL array, dimension (N) \n
 * @param[out] WI
          WI is REAL array, dimension (N) \n
          WR and WI contain the real and imaginary parts,
          respectively, of the computed eigenvalues in the same order
          that they appear on the diagonal of the output Schur form T.
          Complex conjugate pairs of eigenvalues will appear
          consecutively with the eigenvalue having the positive
          imaginary part first. \n
 * @param[out] VS
          VS is REAL array, dimension (LDVS,N) \n
          If JOBVS = 'V', VS contains the orthogonal matrix Z of Schur
          vectors. \n
          If JOBVS = 'N', VS is not referenced. \n
 * @param[in] LDVS
          LDVS is INTEGER \n
          The leading dimension of the array VS.  LDVS >= 1; if
          JOBVS = 'V', LDVS >= N. \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK.  LWORK >= max(1,2*N).
          For good performance, LWORK must generally be larger. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	RWORK	
          RWORK is REAL array, dimension (N) \n
 * @param[out]	BWORK	
          BWORK is LOGICAL array, dimension (N) \n
          Not referenced if SORT = 'N'. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value. \n
          > 0: if INFO = i, and i is \n
               <= N:  the QR algorithm failed to compute all the
                      eigenvalues; elements 1:ILO-1 and i+1:N of W
                      contain those eigenvalues which have converged;
                      if JOBVS = 'V', VS contains the matrix which
                      reduces A to its partially converged Schur form. \n
               = N+1: the eigenvalues could not be reordered because
                      some eigenvalues were too close to separate (the
                      problem is very ill-conditioned); \n
               = N+2: after reordering, roundoff changed values of
                      some complex eigenvalues so that leading
                      eigenvalues in the Schur form no longer satisfy
                      SELECT = .TRUE..  This could also be caused by
                      underflow due to scaling. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer gees(char* jobvs, char* sort, void* select, integer* n, T* a, integer* lda, integer* sdim, T* wr, T* wi, T* vs, integer* ldvs, T* work, integer* lwork, logical* bwork, integer* info)
{
  return gees(jobvs, sort, select, n, a, lda, sdim, wr, wi, vs, ldvs, work, lwork, bwork, info);
}
template< typename T, typename Ta >
integer gees(char* jobvs, char* sort, void* select, integer* n, T* a, integer* lda, integer* sdim, T* w, T* vs, integer* ldvs, T* work, integer* lwork, Ta* rwork, logical* bwork, integer* info)
{
  return gees(jobvs, sort, select, n, a, lda, sdim, w, vs, ldvs, work, lwork, rwork, bwork, info);
}

/*! @brief GEESX computes the eigenvalues, the Schur form, and, optionally, the matrix of Schur vectors for GE matrices
 *
 *  @details
 *  \b Purpose:
 *  \verbatim
    GEESX computes for an N-by-N real nonsymmetric matrix A, the
    eigenvalues, the real Schur form T, and, optionally, the matrix of
    Schur vectors Z.  This gives the Schur factorization A = Z*T*(Z**T).

    Optionally, it also orders the eigenvalues on the diagonal of the
    real Schur form so that selected eigenvalues are at the top left;
    computes a reciprocal condition number for the average of the
    selected eigenvalues (RCONDE); and computes a reciprocal condition
    number for the right invariant subspace corresponding to the
    selected eigenvalues (RCONDV).  The leading columns of Z form an
    orthonormal basis for this invariant subspace.

    For further explanation of the reciprocal condition numbers RCONDE
    and RCONDV, see Section 4.10 of the LAPACK Users' Guide (where
    these quantities are called s and sep respectively).

    A real matrix is in real Schur form if it is upper quasi-triangular
    with 1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in
    the form
             [  a  b  ]
             [  c  a  ]

    where b*c < 0. The eigenvalues of such a block are a +- sqrt(bc).
    \endverbatim

 * @param[in] JOBVS
          JOBVS is CHARACTER*1 \n
          = 'N': Schur vectors are not computed; \n
          = 'V': Schur vectors are computed. \n
 * @param[in] SORT
          SORT is CHARACTER*1 \n
          Specifies whether or not to order the eigenvalues on the
          diagonal of the Schur form. \n
          = 'N': Eigenvalues are not ordered; \n
          = 'S': Eigenvalues are ordered (see SELECT). \n
 * @param[in] SELECT
          SELECT is a LOGICAL FUNCTION of two REAL arguments
          SELECT must be declared EXTERNAL in the calling subroutine. \n
          If SORT = 'S', SELECT is used to select eigenvalues to sort
          to the top left of the Schur form.
          If SORT = 'N', SELECT is not referenced. \n
          An eigenvalue WR(j)+sqrt(-1)*WI(j) is selected if
          SELECT(WR(j),WI(j)) is true; i.e., if either one of a
          complex conjugate pair of eigenvalues is selected, then both
          are.  Note that a selected complex eigenvalue may no longer
          satisfy SELECT(WR(j),WI(j)) = .TRUE. after ordering, since
          ordering may change the value of complex eigenvalues
          (especially if the eigenvalue is ill-conditioned); in this
          case INFO may be set to N+3 (see INFO below). \n
 * @param[in] SENSE
          SENSE is CHARACTER*1 \n
          Determines which reciprocal condition numbers are computed. \n
          = 'N': None are computed; \n
          = 'E': Computed for average of selected eigenvalues only; \n
          = 'V': Computed for selected right invariant subspace only; \n
          = 'B': Computed for both. \n
          If SENSE = 'E', 'V' or 'B', SORT must equal 'S'. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A. N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA, N) \n
          On entry, the N-by-N matrix A. \n
          On exit, A is overwritten by its real Schur form T. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] SDIM
          SDIM is INTEGER \n
          If SORT = 'N', SDIM = 0. \n
          If SORT = 'S', SDIM = number of eigenvalues (after sorting)
                         for which SELECT is true. (Complex conjugate
                         pairs for which SELECT is true for either
                         eigenvalue count as 2.) \n
 * @param[out] WR
          WR is REAL array, dimension (N) \n
 * @param[out] WI
          WI is REAL array, dimension (N) \n
          WR and WI contain the real and imaginary parts, respectively,
          of the computed eigenvalues, in the same order that they
          appear on the diagonal of the output Schur form T.  Complex
          conjugate pairs of eigenvalues appear consecutively with the
          eigenvalue having the positive imaginary part fir - 
          computes row and column scaling to reduce condition number of matrix \n
 * @param[out] VS/*!
          VS is REAL array, dimension (LDVS,N) \n
          If JOBVS = 'V', VS contains the orthogonal matrix Z of Schur
          vectors. \n
          If JOBVS = 'N', VS is not referenced. \n
 * @param[in] LDVS
          LDVS is INTEGER \n
          The leading dimension of the array VS.  LDVS >= 1, and if
          JOBVS = 'V', LDVS >= N. \n
 * @param[out] RCONDE
          RCONDE is REAL \n
          If SENSE = 'E' or 'B', RCONDE contains the reciprocal
          condition number for the average of the selected eigenvalues.
          Not referenced if SENSE = 'N' or 'V'. \n
 * @param[out] RCONDV
          RCONDV is REAL \n
          If SENSE = 'V' or 'B', RCONDV contains the reciprocal
          condition number for the selected right invariant subspace.
          Not referenced if SENSE = 'N' or 'E'. \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK.  LWORK >= max(1,2*N). \n
          Also, if SENSE = 'E' or 'V' or 'B', LWORK >= 2*SDIM*(N-SDIM),
          where SDIM is the number of selected eigenvalues computed by
          this routine.  Note that 2*SDIM*(N-SDIM) <= N*N/2. Note also
          that an error is only returned if LWORK < max(1,2*N), but if
          SENSE = 'E' or 'V' or 'B' this may not be large enough.
          For good performance, LWORK must generally be larger. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates upper bound on the optimal size of the
          array WORK, returns this value as the first entry of the WORK
          array, and no error message related to LWORK is issued by
          XERBLA. \n
 * @param[out]	RWORK	
          RWORK is REAL array, dimension (N) \n
 * @param[out]	BWORK	
          BWORK is LOGICAL array, dimension (N) \n
          Not referenced if SORT = 'N'. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value. \n
          > 0: if INFO = i, and i is \n
             <= N: the QR algorithm failed to compute all the
                   eigenvalues; elements 1:ILO-1 and i+1:N of W
                   contain those eigenvalues which have converged; if
                   JOBVS = 'V', VS contains the transformation which
                   reduces A to its partially converged Schur form. \n
             = N+1: the eigenvalues could not be reordered because some
                   eigenvalues were too close to separate (the problem
                   is very ill-conditioned); \n
             = N+2: after reordering, roundoff changed values of some
                   complex eigenvalues so that leading eigenvalues in
                   the Schur form no longer satisfy SELECT=.TRUE.  This
                   could also be caused by underflow due to scaling. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer geesx(char* jobvs, char* sort, void* select, char* sense, integer* n, T* a, integer* lda, integer* sdim, T* wr, T* wi, T* vs, integer* ldvs, T* rconde, T* rcondv, T* work, integer* lwork, integer* iwork, integer* liwork, logical* bwork, integer* info)
{
  return geesx(jobvs, sort, select, sense, n, a, lda, sdim, wr, wi, vs, ldvs, rconde, rcondv, work, lwork, iwork, liwork, bwork, info);
}
template< typename T, typename Ta >
integer geesx(char* jobvs, char* sort, void* select, char* sense, integer* n, T* a, integer* lda, integer* sdim, T* w, T* vs, integer* ldvs, Ta* rconde, Ta* rcondv, T* work, integer* lwork, Ta* rwork, logical* bwork, integer* info)
{
  return geesx(jobvs, sort, select, sense, n, a, lda, sdim, w, vs, ldvs, rconde, rcondv, work, lwork, rwork, bwork, info);
}

/*! @brief GEEV computes the eigenvalues and, optionally, the left and/or right eigenvectors for GE matrices
*
* @details
* \b Purpose:
* \verbtatim
 GEEV computes for an N-by-N real nonsymmetric matrix A, the
 eigenvalues and, optionally, the left and/or right eigenvectors.

 The right eigenvector v(j) of A satisfies
                  A * v(j) = lambda(j) * v(j)
 where lambda(j) is its eigenvalue.
 The left eigenvector u(j) of A satisfies
               u(j)**H * A = lambda(j) * u(j)**H
 where u(j)**H denotes the conjugate-transpose of u(j).

 The computed eigenvectors are normalized to have Euclidean norm
 equal to 1 and largest component real.
  \endverbatim

 * @param[in] JOBVL
          JOBVL is CHARACTER*1 \n
          = 'N': left eigenvectors of A are not computed; \n
          = 'V': left eigenvectors of A are computed. \n
 * @param[in] JOBVR
          JOBVR is CHARACTER*1 \n
          = 'N': right eigenvectors of A are not computed; \n
          = 'V': right eigenvectors of A are computed. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A. N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the N-by-N matrix A. \n
          On exit, A has been overwritten. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] WR
          WR is REAL array, dimension (N) \n
 * @param[out] WI
          WI is REAL array, dimension (N) \n
          WR and WI contain the real and imaginary parts,
          respectively, of the computed eigenvalues.  Complex
          conjugate pairs of eigenvalues appear consecutively
          with the eigenvalue having the positive imaginary part
          first. \n
 * @param[out] VL
          VL is REAL array, dimension (LDVL,N) \n
          If JOBVL = 'V', the left eigenvectors u(j) are stored one
          after another in the columns of VL, in the same order
          as their eigenvalues. \n
          If JOBVL = 'N', VL is not referenced. \n
          If the j-th eigenvalue is real, then u(j) = VL(:,j),
          the j-th column of VL. \n
          If the j-th and (j+1)-st eigenvalues form a complex
          conjugate pair - computes row and column scaling to reduce condition number of matrixhen u(j@ = VL(:,j) + i*VL(:,j+1) and
          u(j+1) = VL(:,j) \n
 * @param[in] LDVL
          LDVL is INTEGER \n
          The leading dimension of the array VL.  LDVL >= 1; if
          JOBVL = 'V', LDVL >= N. \n
 * @param[out] VR
          VR is REAL array, dimension (LDVR,N) \n
          If JOBVR = 'V', the right eigenvectors v(j) are stored one
          after another in the columns of VR, in the same order
          as their eigenvalues. \n
          If JOBVR = 'N', VR is not referenced. \n
          If the j-th eigenvalue is real, then v(j) = VR(:,j),
          the j-th column of VR. \n
          If the j-th and (j+1)-st eigenvalues form a complex
          conjugate pair, then v(j) = VR(:,j) + i*VR(:,j+1) and
          v(j+1) = VR(:,j) - i*VR(:,j+1). \n
 * @param[in] LDVR
          LDVR is INTEGER \n
          The leading dimension of the array VR.  LDVR >= 1; if
          JOBVR = 'V', LDVR >= N. \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK.  LWORK >= max(1,2*N).
          For good performance, LWORK must generally be larger. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	RWORK	
          RWORK is REAL array, dimension (2*N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n
          > 0:  if INFO = i, the QR algorithm failed to compute all the
                eigenvalues, and no eigenvectors have been computed;
                elements i+1:N of W contain eigenvalues which have
                converged. \n

 * @return INTEGER Return value of the function.
 * */
template<typename T>
integer geev(char* jobvl, char* jobvr, integer* n, T* a, integer* lda, T* wr, T* wi, T* vl, integer* ldvl, T* vr, integer* ldvr, T* work, integer* lwork, integer* info)
{
  return geev(jobvl, jobvr, n, a, lda, wr, wi, vl, ldvl, vr, ldvr, work, lwork, info);
}
template<typename T, typename Ta>
integer geev(char* jobvl, char* jobvr, integer* n, T* a, integer* lda, T* w, T* vl, integer* ldvl, T* vr, integer* ldvr, T* work, integer* lwork, Ta* rwork, integer* info)
{
  return geev(jobvl, jobvr, n, a, lda, w, vl, ldvl, vr, ldvr, work, lwork, rwork, info);
}

/*! @brief GEEVX computes the eigenvalues and, optionally, the left and/or right eigenvectors for GE matrices(enabling conditions)
* @details
* \b Purpose:
* \verbatim
    GEEVX computes for an N-by-N real nonsymmetric matrix A, the
    eigenvalues and, optionally, the left and/or right eigenvectors.

    Optionally also, it computes a balancing transformation to improve
    the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
    SCALE, and ABNRM), reciprocal condition numbers for the eigenvalues
    (RCONDE), and reciprocal condition numbers for the right
    eigenvectors (RCONDV).

    The right eigenvector v(j) of A satisfies
                    A * v(j) = lambda(j) * v(j)
    where lambda(j) is its eigenvalue.
    The left eigenvector u(j) of A satisfies
                 u(j)**H * A = lambda(j) * u(j)**H
    where u(j)**H denotes the conjugate-transpose of u(j).

    The computed eigenvectors are normalized to have Euclidean norm
    equal to 1 and largest component real.

    Balancing a matrix means permuting the rows and columns to make it
    more nearly upper triangular, and applying a diagonal similarity
    transformation D * A * D**(-1), where D is a diagonal matrix, to
    make its rows and columns closer in norm and the condition numbers
    of its eigenvalues and eigenvectors smaller.  The computed
    reciprocal condition numbers correspond to the balanced matrix.
    Permuting rows and columns will not change the condition numbers
    (in exact arithmetic) but diagonal scaling will.  For further
    explanation of balancing, see section 4.10.2 of the LAPACK
    Users' Guide.
 \endverbatim

 * @param[in] BALANC
          BALANC is CHARACTER*1 \n
          Indicates how the input matrix should be diagonally scaled
          and/or permuted to improve the conditioning of its
          eigenvalues. \n
          = 'N': Do not diagonally scale or permute; \n
          = 'P': Perform permutations to make the matrix more nearly
                 upper triangular. Do not diagonally scale; \n
          = 'S': Diagonally scale the matrix, i.e. replace A by
                 D*A*D**(-1), where D is a diagonal matrix chosen
                 to make the rows and columns of A more equal in
                 norm. Do not permute; \n
          = 'B': Both diagonally scale and permute A. \n
 \n
          Computed reciprocal condition numbers will be for the matrix
          after balancing and/or permuting. Permuting does not change
          condition numbers (in exact arithmetic), but balancing does. \n
 * @param[in] JOBVL
          JOBVL is CHARACTER*1 \n
          = 'N': left eigenvectors of A are not computed; \n
          = 'V': left eigenvectors of A are computed. \n
          If SENSE = 'E' or 'B', JOBVL must = 'V'. \n
 * @param[in] JOBVR
          JOBVR is CHARACTER*1 \n
          = 'N': right eigenvectors of A are not computed; \n
          = 'V': right eigenvectors of A are computed. \n
          If SENSE = 'E' or 'B', JOBVR must = 'V'. \n
 * @param[in] SENSE
          SENSE is CHARACTER*1 \n
          Determines which reciprocal condition numbers are computed. \n
          = 'N': None are computed; \n
          = 'E': Computed for eigenvalues only; \n
          = 'V': Computed for right eigenvectors only; \n
          = 'B': Computed for eigenvalues and right eigenvectors. \n
 \n
          If SENSE = 'E' or 'B', both left and right eigenvectors
          must also be computed (JOBVL = 'V' and JOBVR = 'V'). \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A. N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the N-by-N matrix A. \n
          On exit, A has been overwritten.  If JOBVL = 'V' or
          JOBVR = 'V', A contains the real Schur form of the balanced
          version of the input matrix A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] WR
          WR is REAL array, dimension (N) \n
 * @param[out] WI
          WI is REAL array, dimension (N) \n
          WR and WI contain the real and imaginary parts,
          respectively, of the computed eigenvalues.  Complex
          conjugate pairs of eigenvalues will appear consecutively
          with the eigenvalue having the positive imaginary part
          first. \n
 * @param[out] VL
          VL is REAL array, dimension (LDVL,N) \n
          If JOBVL = 'V', the left eigenvectors u(j) are stored one
          after another in the columns of VL, in the same order
          as their eigenvalues. \n
          If JOBVL = 'N', VL is not referenced. \n
          If the j-th eigenvalue is real, then u(j) = VL(:,j),
          the j-th column of VL. \n
          If the j-th and (j+1)-st eigenvalues form a complex
          conjugate pair, then u(j) = VL(:,j) + i*VL(:,j+1) and
          u(j+1) = VL(:,j) - i*VL(:,j+1). \n
 * @param[in] LDVL
          LDVL is INTEGER \n
          The leading dimension of the array VL.  LDVL >= 1; if
          JOBVL = 'V', LDVL >= N. \n
 * @param[out] VR
          VR is REAL array, dimension (LDVR,N) \n
          If JOBVR = 'V', the right eigenvectors v(j) are stored one
          after another in the columns of VR, in the same order
          as their eigenvalues. \n
          If JOBVR = 'N', VR is not referenced. \n
          If the j-th eigenvalue is real, then v(j) = VR(:,j),
          the j-th column of VR. \n
          If the j-th and (j+1)-st eigenvalues form a complex
          conjugate pair, then v(j) = VR(:,j) + i*VR(:,j+1) and
          v(j+1) = VR(:,j) - i*VR(:,j+1). \n
 * @param[in] LDVR
          LDVR is INTEGER \n
          The leading dimension of the array VR.  LDVR >= 1, and if
          JOBVR = 'V', LDVR >= N. \n
 * @param[out] ILO
          ILO is INTEGER \n
 * @param[out] IHI
          IHI is INTEGER \n
          ILO and IHI are integer values determined when A was
          balanced.  The balanced A(i,j) = 0 if I > J and
          J = 1,...,ILO-1 or I = IHI+1,...,N. \n
 * @param[out] SCALE
          SCALE is REAL array, dimension (N) \n
          Details of the permutations and scaling factors applied
          when balancin - computes row and column scaling to reduce condition number of matrix.  If P@j) is the index of the row and column
          interchanged wit/*!h row and column j, and D(j) is the scaling
          factor applied to row and column j, then
          SCALE(J) = P(J),    for J = 1,...,ILO-1
                   = D(J),    for J = ILO,...,IHI
                   = P(J)     for J = IHI+1,...,N.
          The order in which the interchanges are made is N to IHI+1,
          then 1 to ILO-1. \n
 * @param[out] ABNRM
          ABNRM is REAL \n
          The one-norm of the balanced matrix (the maximum
          of the sum of absolute values of elements of any column). \n
 * @param[out] RCONDE
          RCONDE is REAL array, dimension (N) \n
          RCONDE(j) is the reciprocal condition number of the j-th
          eigenvalue. \n
 * @param[out] RCONDV
          RCONDV is REAL array, dimension (N) \n
          RCONDV(j) is the reciprocal condition number of the j-th
          right eigenvector. \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK.  If SENSE = 'N' or 'E',
          LWORK >= max(1,2*N), and if SENSE = 'V' or 'B',
          LWORK >= N*N+2*N. \n
          For good performance, LWORK must generally be larger. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	RWORK	
          RWORK is REAL array, dimension (2*N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n
          > 0:  if INFO = i, the QR algorithm failed to compute all the
                eigenvalues, and no eigenvectors or condition numbers
                have been computed; elements 1:ILO-1 and i+1:N of W
                contain eigenvalues which have converged. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer geevx(char* balanc, char* jobvl, char* jobvr, char* sense, integer* n, T* a, integer* lda, T* wr, T* wi, T* vl, integer* ldvl, T* vr, integer* ldvr, integer* ilo, integer* ihi, T* scale, T* abnrm, T* rconde, T* rcondv, T* work, integer* lwork, integer* iwork, integer* info)
{
  return geevx(balanc, jobvl, jobvr, sense, n, a, lda, wr, wi, vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, lwork, iwork, info);
}
template< typename T, typename Ta >
integer geevx(char* balanc, char* jobvl, char* jobvr, char* sense, integer* n, T* a, integer* lda, T* w, T* vl, integer* ldvl, T* vr, integer* ldvr, integer* ilo, integer* ihi, Ta* scale, Ta* abnrm, Ta* rconde, Ta* rcondv, T* work, integer* lwork, Ta* rwork, integer* info)
{
  return geevx(balanc, jobvl, jobvr, sense, n, a, lda, w, vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, lwork, rwork, info);
}

/*! @brief Computes the singular value decomposition (SVD) of a real matrix
* @details
* \b Purpose:
* \verbatim
    GEJSV computes the singular value decomposition (SVD) of a real M-by-N
    matrix [A], where M >= N. The SVD of [A] is written as

                [A] = [U] * [SIGMA] * [V]^t,

    where [SIGMA] is an N-by-N (M-by-N) matrix which is zero except for its N
    diagonal elements, [U] is an M-by-N (or M-by-M) orthonormal matrix, and
    [V] is an N-by-N orthogonal matrix. The diagonal elements of [SIGMA] are
    the singular values of [A]. The columns of [U] and [V] are the left and
    the right singular vectors of [A], respectively. The matrices [U] and [V]
    are computed and stored in the arrays U and V, respectively. The diagonal
    of [SIGMA] is computed and stored in the array SVA.
    GEJSV can sometimes compute tiny singular values and their singular vectors much
    more accurately than other SVD routines, see below under Further Details.
 \endverbatim

 * @param[in] JOBA
         JOBA is CHARACTER*1 \n
         Specifies the level of accuracy: \n
       = 'C': This option works well (high relative accuracy) if A = B * D,
              with well-conditioned B and arbitrary diagonal matrix D.
              The accuracy cannot be spoiled by COLUMN scaling. The
              accuracy of the computed output depends on the condition of
              B, and the procedure aims at the best theoretical accuracy.
              The relative error max_{i=1:N}|d sigma_i| / sigma_i is
              bounded by f(M,N)*epsilon* cond(B), independent of D.
              The input matrix is preprocessed with the QRF with column
              pivoting. This initial preprocessing and preconditioning by
              a rank revealing QR factorization is common for all values of
              JOBA. Additional actions are specified as follows: \n
       = 'E': Computation as with 'C' with an additional estimate of the
              condition number of B. It provides a realistic error bound. \n
       = 'F': If A = D1 * C * D2 with ill-conditioned diagonal scalings
              D1, D2, and well-conditioned matrix C, this option gives
              higher accuracy than the 'C' option. If the structure of the
              input matrix is not known, and relative accuracy is
              desirable, then this option is advisable. The input matrix A
              is preprocessed with QR factorization with FULL (row and
              column) pivoting. \n
       = 'G': Computation as with 'F' with an additional estimate of the
              condition number of B, where A=D*B. If A has heavily weighted
              rows, then using this condition number gives too pessimistic
              error bound. \n
       = 'A': Small singular values are the noise and the matrix is treated
              as numerically rank deficient. The error in the computed
              singular values is bounded by f(m,n)*epsilon*||A||.
              The computed SVD A = U * S * V^t restores A up to
              f(m,n)*epsilon*||A||. \n
              This gives the procedure the licence to discard (set to zero)
              all singular values below N*epsilon*||A||. \n
       = 'R': Similar as in 'A'. Rank revealing property of the initial
              QR factorization is used do reveal (using triangular factor)
              a gap sigma_{r+1} < epsilon * sigma_r in which case the
              numerical RANK is declared to be r. The SVD is computed with
              absolute error bounds, but more accurately than with 'A'. \n
 * @param[in] JOBU
         JOBU is CHARACTER*1 \n
         Specifies whether to compute the columns of U: \n
       = 'U': N columns of U are returned in the array U. \n
       = 'F': full set of M left sing. vectors is returned in the array U. \n
       = 'W': U may be used as workspace of length M*N. See the description
              of U. \n
       = 'N': U is not computed. \n
 * @param[in] JOBV
         JOBV is CHARACTER*1 \n
         Specifies whether to compute the matrix V: \n
       = 'V': N columns of V are returned in the array V; Jacobi rotations
              are not explicitly accumulated. \n
       = 'J': N columns of V are returned in the array V, but they are
              computed as the product of Jacobi rotations. This option is
              allowed only if JOBU .NE. 'N', i.e. in computing the full SVD. \n
       = 'W': V may be used as workspace of length N*N. See the description
              of V. \n
       = 'N': V is not computed. \n
 * @param[in] JOBR
         JOBR is CHARACTER*1 \n
         Specifies the RANGE for the singular values. Issues the licence to
         set to zero small positive singular values if they are outside
         specified range. If A .NE. 0 is scaled so that the largest singular
         value of c*A is around SQRT(BIG), BIG=SLAMCH('O'), then JOBR issues
         the licence to kill columns of A whose norm in c*A is less than
         SQRT(SFMIN) (for JOBR = 'R'), or less than SMALL=SFMIN/EPSLN,
         where SFMIN=SLAMCH('S'), EPSLN=SLAMCH('E'). \n
       = 'N': Do not kill small columns of c*A. This option assumes that
              BLAS and QR factorizations and triangular solvers are
              implemented to work in that range. If the condition of A
              is greater than BIG, use SGESVJ. \n
       = 'R': RESTRICTED range for sigma(c*A) is [SQRT(SFMIN), SQRT(BIG)]
              (roughly, as described above). This option is recommended.
                                             ===========================
         For computing the singular values in the FULL range [SFMIN,BIG]
         use SGESVJ. \n
 * @param[in] JOBT
         JOBT is CHARACTER*1 \n
         If the matrix is square then the procedure may determine to use
         transposed A if A^t seems to be better with respect to convergence.
         If the matrix is not square, JOBT is ignored. This is subject to
         changes in the future. \n
         The decision is based on two values of entropy over the adjoint
         orbit of A^t * A. See the descriptions of WORK(6) and WORK(7). \n
       = 'T': transpose if entropy test indicates possibly faster
         convergence of Jacobi process if A^t is taken as input. If A is
         replaced with A^t, then the row pivoting is included automatically. \n
       = 'N': do not speculate.
         This option can be used to compute only the singular values, or the
         full SVD (U, SIGMA and V). For only one set of singular vectors
         (U or V), the caller should provide both U and V, as one of the
         matrices is used as workspace if the matrix A is transposed.
         The implementer can easily remove this constraint and make the
         code more complicated. See the descriptions of U and V. \n
 * @param[in] JOBP
         JOBP is CHARACTER*1 \n
         Issues the licence to introduce structured perturbations to drown
         denormalized numbers. This licence should be active if the
         denormals are poorly implemented, causing slow computation,
         especially in cases of fast convergence (!). For details see [1,2].
         For the sake of simplicity, this perturbations are included only
         when the full SVD or only the singular values are requested. The
         implementer/user can easily add the perturbation for the cases of
         computing one set of singular vectors. \n
       = 'P': introduce perturbation \n
       = 'N': do not perturb \n
 * @param[in] M
         M is INTEGER \n
         The number of rows of the input matrix A.  M >= 0. \n
 * @param[in] N
         N is INTEGER \n
         The number of columns of the input matrix A. M >= N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the M-by-N matrix A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,M). \n
 * @param[out] SVA
          SVA is REAL array, dimension (N) \n
          On exit, \n
          - For WORK(1)/WORK(2) = ONE: The singular values of A. During the
            computation SVA contains Euclidean column norms of the
            iterated matrices in the array A. \n
          - For WORK(1) .NE. WORK(2): The singular values of A are
            (WORK(1)/WORK(2)) * SVA(1:N). This factored form is used if
            sigma_max(A) overflows or if small singular values have been
            saved from underflow by scaling the input matrix A. \n
          - If JOBR='R' then some of the singular values may be returned
            as exact zeros obtained by "set to zero" because they are
            below the numerical rank threshold or are denormalized numbers.
 * @param[out] U
          U is REAL array, dimension ( LDU, N) \n
          If JOBU = 'U', then U contains on exit the M-by-N matrix of
                         the left singular vectors. \n
          If JOBU = 'F', then U contains on exit the M-by-M matrix of
                         the left singular vectors, including an ONB
                         of the orthogonal complement of the Range(A). \n
          If JOBU = 'W'  .AND. (JOBV = 'V' .AND. JOBT = 'T' .AND. M = N),
                         then U is used as workspace if the procedure
                         replaces A with A^t. In that case, [V] is computed
                         in U as left singular vectors of A^t and then
                         copied back to the V array. This 'W' option is just
                         a reminder to the caller that in this case U is
                         reserved as workspace of length N*N. \n
          If JOBU = 'N'  U is not referenced, unless JOBT= - computes row and
                         column scaling to reduce condition number of matrix. \n
 * @param[in] LDU
          LDU is INTEGER \n
          The leading dimension of the array U,  LDU >= 1. \n
          IF  JOBU = 'U' or 'F' or 'W',  then LDU >= M. \n
 * @param[out] V
          V is REAL array, dimension ( LDV, N) \n
          If JOBV = 'V', 'J' then V contains on exit the N-by-N matrix of
                         the right singular vectors; \n
          If JOBV = 'W', AND (JOBU = 'U' AND JOBT = 'T' AND M = N),
                         then V is used as workspace if the pprocedure
                         replaces A with A^t. In that case, [U] is computed
                         in V as right singular vectors of A^t and then
                         copied back to the U array. This 'W' option is just
                         a reminder to the caller that in this case V is
                         reserved as workspace of length N*N. \n
          If JOBV = 'N'  V is not referenced, unless JOBT='T'. \n
 * @param[in] LDV
          LDV is INTEGER \n
          The leading dimension of the array V,  LDV >= 1. \n
          If JOBV = 'V' or 'J' or 'W', then LDV >= N. \n
 * @param[out]	CWORK	
          CWORK is COMPLEX array, dimension (MAX(2,LWORK)) \n
          If the call to CGEJSV is a workspace query (indicated by LWORK=-1 or
          LRWORK=-1), then on exit CWORK(1) contains the required length of
          CWORK for the job parameters used in the call. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          Length of CWORK to confirm proper allocation of workspace. \n
          LWORK depends on the job: \n
 \n
          1. If only SIGMA is needed ( JOBU = 'N', JOBV = 'N' ) and \n
            1.1 .. no scaled condition estimate required (JOBA.NE.'E'.AND.JOBA.NE.'G'): \n
               LWORK >= 2*N+1. This is the minimal requirement.
               ->> For optimal performance (blocked code) the optimal value
               is LWORK >= N + (N+1)*NB. Here NB is the optimal
               block size for CGEQP3 and CGEQRF.
               In general, optimal LWORK is computed as
               LWORK >= max(N+LWORK(CGEQP3),N+LWORK(CGEQRF), LWORK(CGESVJ)). \n
            1.2. .. an estimate of the scaled condition number of A is
               required (JOBA='E', or 'G'). In this case, LWORK the minimal
               requirement is LWORK >= N*N + 2*N.
               ->> For optimal performance (blocked code) the optimal value
               is LWORK >= max(N+(N+1)*NB, N*N+2*N)=N**2+2*N.
               In general, the optimal length LWORK is computed as
               LWORK >= max(N+LWORK(CGEQP3),N+LWORK(CGEQRF), LWORK(CGESVJ),
                            N*N+LWORK(CPOCON)). \n
          2. If SIGMA and the right singular vectors are needed (JOBV = 'V'),
             (JOBU = 'N') \n
            2.1   .. no scaled condition estimate requested (JOBE = 'N'): \n
            -> the minimal requirement is LWORK >= 3*N. \n
            -> For optimal performance, 
               LWORK >= max(N+(N+1)*NB, 2*N+N*NB)=2*N+N*NB,
               where NB is the optimal block size for CGEQP3, CGEQRF, CGELQ,
               CUNMLQ. In general, the optimal length LWORK is computed as
               LWORK >= max(N+LWORK(CGEQP3), N+LWORK(CGESVJ),
                       N+LWORK(CGELQF), 2*N+LWORK(CGEQRF), N+LWORK(CUNMLQ)). \n
            2.2 .. an estimate of the scaled condition number of A is
               required (JOBA='E', or 'G'). \n
            -> the minimal requirement is LWORK >= 3*N. \n
            -> For optimal performance, 
               LWORK >= max(N+(N+1)*NB, 2*N,2*N+N*NB)=2*N+N*NB,
               where NB is the optimal block size for CGEQP3, CGEQRF, CGELQ,
               CUNMLQ. In general, the optimal length LWORK is computed as
               LWORK >= max(N+LWORK(CGEQP3), LWORK(CPOCON), N+LWORK(CGESVJ),
                       N+LWORK(CGELQF), 2*N+LWORK(CGEQRF), N+LWORK(CUNMLQ)). \n
          3. If SIGMA and the left singular vectors are needed \n
            3.1  .. no scaled condition estimate requested (JOBE = 'N'): \n
            -> the minimal requirement is LWORK >= 3*N. \n
            -> For optimal performance:
               if JOBU = 'U' :: LWORK >= max(3*N, N+(N+1)*NB, 2*N+N*NB)=2*N+N*NB,
               where NB is the optimal block size for CGEQP3, CGEQRF, CUNMQR.
               In general, the optimal length LWORK is computed as
               LWORK >= max(N+LWORK(CGEQP3), 2*N+LWORK(CGEQRF), N+LWORK(CUNMQR)). \n
            3.2  .. an estimate of the scaled condition number of A is
               required (JOBA='E', or 'G'). \n
            -> the minimal requirement is LWORK >= 3*N. \n
            -> For optimal performance:
               if JOBU = 'U' :: LWORK >= max(3*N, N+(N+1)*NB, 2*N+N*NB)=2*N+N*NB,
               where NB is the optimal block size for CGEQP3, CGEQRF, CUNMQR.
               In general, the optimal length LWORK is computed as \n
               LWORK >= max(N+LWORK(CGEQP3),N+LWORK(CPOCON), \n
                        2*N+LWORK(CGEQRF), N+LWORK(CUNMQR)). \n
 \n
          4. If the full SVD is needed: (JOBU = 'U' or JOBU = 'F') and \n
            4.1. if JOBV = 'V' \n
               the minimal requirement is LWORK >= 5*N+2*N*N. \n
            4.2. if JOBV = 'J' the minimal requirement is
               LWORK >= 4*N+N*N. \n
            In both cases, the allocated CWORK can accommodate blocked runs
            of CGEQP3, CGEQRF, CGELQF, CUNMQR, CUNMLQ. \n
 \n
          If the call to CGEJSV is a workspace query (indicated by LWORK=-1 or
          LRWORK=-1), then on exit CWORK(1) contains the optimal and CWORK(2) contains the
          minimal length of CWORK for the job parameters used in the call. \n
 * @param[out]	RWORK	
          RWORK is REAL array, dimension (MAX(7,LWORK)) \n
          On exit, \n
          RWORK(1) = Determines the scaling factor SCALE = RWORK(2) / RWORK(1)
                    such that SCALE*SVA(1:N) are the computed singular values
                    of A. (See the description of SVA().) \n
          RWORK(2) = See the description of RWORK(1). \n
          RWORK(3) = SCONDA is an estimate for the condition number of
                    column equilibrated A. (If JOBA = 'E' or 'G')
                    SCONDA is an estimate of SQRT(||(R^* * R)^(-1)||_1). \n
                    It is computed using SPOCON. It holds
                    N^(-1/4) * SCONDA <= ||R^(-1)||_2 <= N^(1/4) * SCONDA
                    where R is the triangular factor from the QRF of A.
                    However, if R is truncated and the numerical rank is
                    determined to be strictly smaller than N, SCONDA is
                    returned as -1, thus indicating that the smallest
                    singular values might be lost. \n
 \n
          If full SVD is needed, the following two condition numbers are
          useful for the analysis of the algorithm. They are provided for
          a developer/implementer who is familiar with the details of
          the method. \n
 \n
          RWORK(4) = an estimate of the scaled condition number of the
                    triangular factor in the first QR factorization. \n
          RWORK(5) = an estimate of the scaled condition number of the
                    triangular factor in the second QR factorization. \n
          The following two parameters are computed if JOBT = 'T'.
          They are provided for a developer/implementer who is familiar
          with the details of the method. \n
          RWORK(6) = the entropy of A^* * A :: this is the Shannon entropy
                    of diag(A^* * A) / Trace(A^* * A) taken as point in the
                    probability simplex. \n
          RWORK(7) = the entropy of A * A^*. (See the description of RWORK(6).)
          If the call to CGEJSV is a workspace query (indicated by LWORK=-1 or
          LRWORK=-1), then on exit RWORK(1) contains the required length of
          RWORK for the job parameters used in the call. \n
 * @param[in]	LRWORK	
          LRWORK is INTEGER \n
          Length of RWORK to confirm proper allocation of workspace. \n
          LRWORK depends on the job: \n
 \n
       1. If only the singular values are requested i.e. if
          LSAME(JOBU,'N') .AND. LSAME(JOBV,'N')
          then:
          1.1. If LSAME(JOBT,'T') .OR. LSAME(JOBA,'F') .OR. LSAME(JOBA,'G'),
               then: LRWORK = max( 7, 2 * M ). \n
          1.2. Otherwise, LRWORK  = max( 7,  N ). \n
       2. If singular values with the right singular vectors are requested \n
          i.e. if
          (LSAME(JOBV,'V').OR.LSAME(JOBV,'J')) .AND.
          .NOT.(LSAME(JOBU,'U').OR.LSAME(JOBU,'F'))
          then: \n
          2.1. If LSAME(JOBT,'T') .OR. LSAME(JOBA,'F') .OR. LSAME(JOBA,'G'),
          then LRWORK = max( 7, 2 * M ). \n
          2.2. Otherwise, LRWORK  = max( 7,  N ). \n
       3. If singular values with the left singular vectors are requested, i.e. if
          (LSAME(JOBU,'U').OR.LSAME(JOBU,'F')) .AND.
          .NOT.(LSAME(JOBV,'V').OR.LSAME(JOBV,'J'))
          then: \n
          3.1. If LSAME(JOBT,'T') .OR. LSAME(JOBA,'F') .OR. LSAME(JOBA,'G'),
          then LRWORK = max( 7, 2 * M ). \n
          3.2. Otherwise, LRWORK  = max( 7,  N ). \n
       4. If singular values with both the left and the right singular vectors
          are requested, i.e. if
          (LSAME(JOBU,'U').OR.LSAME(JOBU,'F')) .AND.
          (LSAME(JOBV,'V').OR.LSAME(JOBV,'J'))
          then: \n
          4.1. If LSAME(JOBT,'T') .OR. LSAME(JOBA,'F') .OR. LSAME(JOBA,'G'),
          then LRWORK = max( 7, 2 * M ). \n
          4.2. Otherwise, LRWORK  = max( 7, N ). \n
  \n
          If, on entry, LRWORK = -1 or LWORK=-1, a workspace query is assumed and 
          the length of RWORK is returned in RWORK(1).  \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, of dimension at least 4, that further depends
          on the job: \n
  \n
          1. If only the singular values are requested then: \n
             If ( LSAME(JOBT,'T') .OR. LSAME(JOBA,'F') .OR. LSAME(JOBA,'G') ) 
             then the length of IWORK is N+M; otherwise the length of IWORK is N. \n
          2. If the singular values and the right singular vectors are requested then: \n
             If ( LSAME(JOBT,'T') .OR. LSAME(JOBA,'F') .OR. LSAME(JOBA,'G') ) 
             then the length of IWORK is N+M; otherwise the length of IWORK is N.  \n
          3. If the singular values and the left singular vectors are requested then: \n
             If ( LSAME(JOBT,'T') .OR. LSAME(JOBA,'F') .OR. LSAME(JOBA,'G') ) 
             then the length of IWORK is N+M; otherwise the length of IWORK is N.  \n
          4. If the singular values with both the left and the right singular vectors \n
             are requested, then: \n
             4.1. If LSAME(JOBV,'J') the length of IWORK is determined as follows: \n
                  If ( LSAME(JOBT,'T') .OR. LSAME(JOBA,'F') .OR. LSAME(JOBA,'G') ) 
                  then the length of IWORK is N+M; otherwise the length of IWORK is N.  \n
             4.2. If LSAME(JOBV,'V') the length of IWORK is determined as follows: \n
                  If ( LSAME(JOBT,'T') .OR. LSAME(JOBA,'F') .OR. LSAME(JOBA,'G') ) 
                  then the length of IWORK is 2*N+M; otherwise the length of IWORK is 2*N. \n
         \n
          On exit, \n
          IWORK(1) = the numerical rank determined after the initial
                     QR factorization with pivoting. See the descriptions
                     of JOBA and JOBR. \n
          IWORK(2) = the number of the computed nonzero singular values \n
          IWORK(3) = if nonzero, a warning message: \n
                     If IWORK(3) = 1 then some of the column norms of A
                     were denormalized floats. The requested high accuracy
                     is not warranted by the data. \n
          IWORK(4) = 1 or -1. If IWORK(4) = 1, then the procedure used A^* to
                     do the job as specified by the JOB parameters. \n
          If the call to CGEJSV is a workspace query (indicated by LWORK = -1 and 
          LRWORK = -1), then on exit IWORK(1) contains the required length of 
          IWORK for the job parameters used in the call. \n
 * @param[out]	INFO
           INFO is INTEGER \n
           < 0:  if INFO = -i, then the i-th argument had an illegal value. \n
           = 0:  successful exit; \n
           > 0:  CGEJSV  did not converge in the maximal allowed number
                 of sweeps. The computed values may be inaccurate. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer gejsv(char* joba, char* jobu, char* jobv, char* jobr, char* jobt, char* jobp, integer* m, integer* n, T* a, integer* lda, T* sva, T* u, integer* ldu, T* v, integer* ldv, T* stat, integer* istat, T* work, integer* lwork, integer* iwork, integer* info)
{
  return gejsv(joba, jobu, jobv, jobr, jobt, jobp, m, n, a, lda, sva, u, ldu, v, ldv, work, lwork, iwork, info);
}
template< typename T, typename Ta >
integer gejsv(char* joba, char* jobu, char* jobv, char* jobr, char* jobt, char* jobp, integer* m, integer* n, T* a, integer* lda, Ta* sva, T* u, integer* ldu, T* v, integer* ldv, T* cwork, integer* lwork, Ta* rwork, integer* lrwork, integer* iwork, integer* info)
{
  return gejsv(joba, jobu, jobv, jobr, jobt, jobp, m, n, a, lda, sva, u, ldu, v, ldv, cwork, lwork, rwork, lrwork, iwork, info);
}

/*! @brief Computes LQ factorization of a real matrix
* @details
* \b Purpose:
* \verbatim
    GELQ computes an LQ factorization of a real M-by-N matrix A:

      A = ( L 0) *  Q

    where:

    Q is a N-by-N orthogonal matrix;
    L is an lower-triangular M-by-M matrix;
    0 is a M-by-(N-M) zero matrix, if M < N.
   \endverbatim

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the M-by-N matrix A. \n
          On exit, the elements on and below the diagonal of the array
          contain the M-by-min(M,N) lower trapezoidal matrix L
          (L is lower triangular if M <= N);
          the elements above the diagonal are used to store part of the
          data structure to represent - 
          computes row and column scaling to reduce condition number of matrix \n
 * @param[in] LDA/*!
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,M). \n
 * @param[out] T
          T is REAL array, dimension (MAX(5,TSIZE)) \n
          On exit, if INFO = 0, T(1) returns optimal (or either minimal
          or optimal, if query is assumed) TSIZE. See TSIZE for details.
          Remaining T contains part of the data structure used to represent Q.
          If one wants to apply or construct Q, then one needs to keep T
          (in addition to A) and pass it to further subroutines. \n
 * @param[in] TSIZE
          TSIZE is INTEGER \n
          If TSIZE >= 5, the dimension of the array T. \n
          If TSIZE = -1 or -2, then a workspace query is assumed. The routine
          only calculates the sizes of the T and WORK arrays, returns these
          values as the first entries of the T and WORK arrays, and no error
          message related to T or WORK is issued by XERBLA. \n
          If TSIZE = -1, the routine calculates optimal size of T for the
          optimum performance and returns this value in T(1). \n
          If TSIZE = -2, the routine calculates minimal size of T and
          returns this value in T(1). \n
 * @param[out]	WORK	
          (workspace) REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) contains optimal (or either minimal
          or optimal, if query was assumed) LWORK.
          See LWORK for details. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK. \n
          If LWORK = -1 or -2, then a workspace query is assumed. The routine
          only calculates the sizes of the T and WORK arrays, returns these
          values as the first entries of the T and WORK arrays, and no error
          message related to T or WORK is issued by XERBLA. \n
          If LWORK = -1, the routine calculates optimal size of WORK for the
          optimal performance and returns this value in WORK(1). \n
          If LWORK = -2, the routine calculates minimal size of WORK and 
          returns this value in WORK(1). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

* @return INTEGER Return value of the function.
* */
template< typename T >
integer gelq(integer* m, integer* n, T* a, integer* lda, T* t, integer* tsize, T* work, integer* lwork, integer* info)
{
  return gelq(m, n, a, lda, t, tsize, work, lwork, info);
}

/*! @brief GELS solves overdetermined or underdetermined systems for GE matrices
* @details
* \b Purpose:
 \verbatim
    GELS solves overdetermined or underdetermined real linear systems
    involving an M-by-N matrix A, or its transpose, using a QR or LQ
    factorization of A.  It is assumed that A has full rank.

    The following options are provided:

    1. If TRANS = 'N' and m >= n:  find the least squares solution of
      an overdetermined system, i.e., solve the least squares problem
                   minimize || B - A*X ||.

    2. If TRANS = 'N' and m < n:  find the minimum norm solution of
      an underdetermined system A * X = B.

    3. If TRANS = 'T' and m >= n:  find the minimum norm solution of
      an underdetermined system A**T * X = B.

    4. If TRANS = 'T' and m < n:  find the least squares solution of
      an overdetermined system, i.e., solve the least squares problem
                   minimize || B - A**T * X ||.

    Several right hand side vectors b and solution vectors x can be
    handled in a single call; they are stored as the columns of the
    M-by-NRHS right hand side matrix B and the N-by-NRHS solution
    matrix X.
 \endverbatim

 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          = 'N': the linear system involves A; \n
          = 'T': the linear system involves A**T. \n
 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of
          columns of the matrices B and X. NRHS >=0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the M-by-N matrix A. \n
          On exit, \n
            if M >= N, A is overwritten by details of its QR
                       factorization as returned by SGEQRF; \n
            if M <  N, A is overwritten by details of its LQ
                       factorization as returned by SGELQF. \n
 * @param[in] LDA
         LDA is INTEGER \n
         Computes row and column scaling to reduce condition number of matrix  \n
         The leading dimension of the array A.  LDA >= max(1,M). \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,NRHS) \n
          On entry, the matrix B of right hand side vectors, stored
          columnwise; B is M-by-NRHS if TRANS = 'N', or N-by-NRHS
          if TRANS = 'T'. \n
          On exit, if INFO = 0, B is overwritten by the solution
          vectors, stored columnwise: \n
          if TRANS = 'N' and m >= n, rows 1 to n of B contain the least
          squares solution vectors; the residual sum of squares for the
          solution in each column is given by the sum of squares of
          elements N+1 to M in that column; \n
          if TRANS = 'N' and m < n, rows 1 to N of B contain the
          minimum norm solution vectors; \n
          if TRANS = 'T' and m >= n, rows 1 to M of B contain the
          minimum norm solution vectors; \n
          if TRANS = 'T' and m < n, rows 1 to M of B contain the
          least squares solution vectors; the residual sum of squares
          for the solution in each column is given by the sum of
          squares of elements M+1 to N in that column. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B. LDB >= MAX(1,M,N). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK.
          LWORK >= max( 1, MN + max( MN, NRHS ) ). \n
          For optimal performance,
          LWORK >= max( 1, MN + max( MN, NRHS )*NB ).
          where MN = min(M,N) and NB is the optimum block size. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO =  i, the i-th diagonal element of the
                triangular factor of A is zero, so that A does not have
                full rank; the least squares solution could not be
                computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer gels(char* trans, integer* m, integer* n, integer* nrhs, T* a, integer* lda, T* b, integer* ldb, T* work, integer* lwork, integer* info)
{
  return gels(trans, m, n, nrhs, a, lda, b, ldb, work, lwork, info);
}

/*! @brief GELSY solves overdetermined or underdetermined systems for GE matrices
* @details
* \b Purpose:
 \verbatim
    GELSY computes the minimum-norm solution to a real linear least
    squares problem:
       minimize || A * X - B ||
    using a complete orthogonal factorization of A.  A is an M-by-N
    matrix which may be rank-deficient.

    Several right hand side vectors b and solution vectors x can be
    handled in a single call; they are stored as the columns of the
    M-by-NRHS right hand side matrix B and the N-by-NRHS solution
    matrix X.

    The routine first computes a QR factorization with column pivoting:
       A * P = Q * [ R11 R12 ]
                   [  0  R22 ]
    with R11 defined as the largest leading submatrix whose estimated
    condition number is less than 1/RCOND.  The order of R11, RANK,
    is the effective rank of A.

    Then, R22 is considered to be negligible, and R12 is annihilated
    by orthogonal transformations from the right, arriving at the
    complete orthogonal factorization:
      A * P = Q * [ T11 0 ] * Z
                  [  0  0 ]
    The minimum-norm solution is then
      X = P * Z**T [ inv(T11)*Q1**T*B ]
                   [        0         ]
    where Q1 consists of the first RANK columns of Q.

    This routine is basically identical to the original xGELSX except
    three differences:
     o The call to the subroutine xGEQPF has been substituted by the
       the call to the subroutine xGEQP3. This subroutine is a Blas-3
       version of the QR factorization with column pivoting.
     o Matrix B (the right hand side) is updated with Blas-3.
     o The permutation of matrix B (the right hand side) is faster and
       more simple.
    \endverbatim

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of
          columns of matrices B and X. NRHS >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the M-by-N matrix A. \n
          On exit, A has been overwritten by details of its
          complete orthogonal factorization. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,M). \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,NRHS) \n
          On entry, the M-by-NRHS right hand side matrix B. \n
          On exit, the N-by-NRHS solution matrix X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          Computes row and column scaling to reduce condition number of matrix B \n
          The leading dimension of the array B. LDB >= max(1,M,N). \n
 * @param[in,out] JPVT
          JPVT is INTEGER array, dimension (N) \n
          On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted
          to the front of AP, otherwise column i is a free column. \n
          On exit, if JPVT(i) = k, then the i-th column of AP
          was the k-th column of A. \n
 * @param[in] RCOND
          RCOND is REAL \n
          RCOND is used to determine the effective rank of A, which
          is defined as the order of the largest leading triangular
          submatrix R11 in the QR factorization with pivoting of A,
          whose estimated condition number < 1/RCOND. \n
 * @param[out] RANK
          RANK is INTEGER \n
          The effective rank of A, i.e., the order of the submatrix
          R11.  This is the same as the order of the submatrix T11
          in the complete orthogonal factorization of A. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK.
          The unblocked strategy requires that:
             LWORK >= MAX( MN+3*N+1, 2*MN+NRHS ),
          where MN = min( M, N ). \n
          The block algorithm requires that:
             LWORK >= MAX( MN+2*N+NB*(N+1), 2*MN+NB*NRHS ),
          where NB is an upper bound on the blocksize returned
          by ILAENV for the routines SGEQP3, STZRZF, STZRQF, SORMQR,
          and SORMRZ. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: If INFO = -i, the i-th argument had an illegal value. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer gelsy(integer* m, integer* n, integer* nrhs, T* a, integer* lda, T* b, integer* ldb, integer* jpvt, T rcond, integer* rank, T* work, integer* lwork, integer* info)
{
  return gelsy(m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank, work, lwork, info);
}
template< typename T , typename Ta >
integer gelsy(integer* m, integer* n, integer* nrhs, T* a, integer* lda, T* b, integer* ldb, integer* jpvt, Ta rcond, integer* rank, T* work, integer* lwork, Ta* rwork, integer* info)
{
  return gelsy(m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank, work, lwork, rwork, info);
}

/*! @brief GELSX solves overdetermined or underdetermined systems for GE matrices
 *  @details
 *  \b Purpose:
    \verbatim
    GELSX computes the minimum-norm solution to a real linear least
    squares problem:
       minimize || A * X - B ||
    using a complete orthogonal factorization of A.  A is an M-by-N
    matrix which may be rank-deficient.

    Several right hand side vectors b and solution vectors x can be
    handled in a single call; they are stored as the columns of the
    M-by-NRHS right hand side matrix B and the N-by-NRHS solution
    matrix X.

    The routine first computes a QR factorization with column pivoting:
       A * P = Q * [ R11 R12 ]
                   [  0  R22 ]
    with R11 defined as the largest leading submatrix whose estimated
    condition number is less than 1/RCOND.  The order of R11, RANK,
    is the effective rank of A.

    Then, R22 is considered to be negligible, and R12 is annihilated
    by orthogonal transformations from the right, arriving at the
    complete orthogonal factorization:
      A * P = Q * [ T11 0 ] * Z
                  [  0  0 ]
    The minimum-norm solution is then
      X = P * Z**T [ inv(T11)*Q1**T*B ]
                   [        0         ]
    where Q1 consists of the first RANK columns of Q.
    \endverbatim

 * @param[in]	M	
          M is INTEGER \n
          The number of rows of the matrix A.  M >= 0. \n
 * @param[in]	N	
          N is INTEGER \n
          The number of columns of the matrix A.  N >= 0. \n
 * @param[in]	NRHS	
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of
          columns of matrices B and X. NRHS >= 0. \n
 * @param[in,out]	A	
          A is REAL array, dimension (LDA,N) \n
          On entry, the M-by-N matrix A. \n
          On exit, A has been overwritten by details of its
          complete orthogonal factorization. \n
 * @param[in]	LDA	
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,M). \n
 * @param[in,out]	B	
          B is REAL array, dimension (LDB,NRHS) \n
          On entry, the M-by-NRHS right hand side matrix B.
          On exit, the N-by-NRHS solution matrix X. \n
          If m >= n and RANK = n, the residual sum-of-squares for
          the solution in the i-th column is given by the sum of
          squares of elements N+1:M in that column. \n
 * @param[in]	LDB	
          LDB is INTEGER \n
          The leading dimension of the array B. LDB >= max(1,M,N). \n
 * @param[in,out]	JPVT	
          JPVT is INTEGER array, dimension (N) \n
          On entry, if JPVT(i) .ne. 0, the i-th column of A is an
          initial column, otherwise it is a free column.  Before
          the QR factorization of A, all initial columns are
          permuted to the leading positions; only the remaining
          free columns are moved as a result of column pivoting
          during the factorization. \n
          On exit, if JPVT(i) = k, then the i-th column of A*P
          was the k-th column of A. \n
 * @param[in]	RCOND	
          RCOND is REAL \n
          RCOND is used to determine the effective rank of A, which
          is defined as the order of the largest leading triangular
          submatrix R11 in the QR factorization with pivoting of A,
          whose estimated condition number < 1/RCOND. \n
 * @param[out]	RANK	
          RANK is INTEGER \n
          The effective rank of A, i.e., the order of the submatrix
          R11.  This is the same as the order of the submatrix T11
          in the complete orthogonal factorization of A. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension \n
                      (max( min(M,N)+3*N, 2*min(M,N)+NRHS )), \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer gelsx(integer* m, integer* n, integer* nrhs, T* a, integer* lda, T* b, integer* ldb, integer* jpvt, T rcond, integer* rank, T* work, integer* info)
{
  return gelsx(m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank, work, info);
}
template< typename T , typename Ta >
integer gelsx(integer* m, integer* n, integer* nrhs, T* a, integer* lda, T* b, integer* ldb, integer* jpvt, Ta rcond, integer* rank, T* work, Ta* rwork, integer* info)
{
  return gelsx(m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank, work, rwork, info);
}

/*! @brief Overwrites general matrix with a form compatible with orthogonal matrix
 * @details
 * \b Purpose:
    \verbatim
     GEMLQ overwrites the general real M-by-N matrix C with

                    SIDE = 'L'     SIDE = 'R'
    TRANS = 'N':      Q * C          C * Q
    TRANS = 'T':      Q**T * C       C * Q**T
    where Q is a real orthogonal matrix defined as the product
    of blocked elementary reflectors computed by short wide LQ
    factorization (GELQ)
    \endverbatim

 * @param[in] SIDE
          SIDE is CHARACTER*1 \n
          = 'L': apply Q or Q**T from the Left; \n
          = 'R': apply Q or Q**T from the Right. \n
 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          = 'N':  No transpose, apply Q; \n
          = 'T':  Transpose, apply Q**T. \n
 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M >=0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix C. N >= 0. \n
 * @param[in] K
          K is INTEGER \n
          The number of elementary reflectors whose product defines
          the matrix Q. \n
          If SIDE = 'L', M >= K >= 0; \n
          if SIDE = 'R', N >= K >= 0. \n
 * @param[in] A
          A is REAL array, dimension \n
                               (LDA,M) if SIDE = 'L', \n
                               (LDA,N) if SIDE = 'R' \n
          Part of the data structure to represent Q as returned by DGELQ. \n
  * @para@[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A. LDA >= max(1,K). \n
 * @param[in] T
          T is REAL array, dimension (MAX(5,TSIZE)). \n
          Part of the data structure to represent Q as returned by SGELQ. \n
 * @param[in] TSIZE
          TSIZE is INTEGER \n
          The dimension of the array T. TSIZE >= 5. \n
 * @param[in,out] C
          C is REAL array, dimension (LDC,N) \n
          On entry, the M-by-N matrix C. \n
          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q. \n
 * @param[in] LDC
          LDC is INTEGER \n
          The leading dimension of the array C. LDC >= max(1,M). \n
 * @param[out]	WORK	
         (workspace) REAL array, dimension (MAX(1,LWORK)) \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK. \n
          If LWORK = -1, then a workspace query is assumed. The routine
          only calculates the size of the WORK array, returns this
          value as WORK(1), and no error message related to WORK 
          is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
 * */
template< typename T >
integer gemlq(char* side, char* trans, integer* m, integer* n, integer* k,  T* a, integer* lda,  T* t, integer* tsize, T* c, integer* ldc, T* work, integer* lwork, integer* info)
{
  return gemlq(side, trans, m, n, k,  a, lda,  t, tsize, c, ldc, work, lwork, info);
}

/*! @brief Multiples a matrix C by a real orthogonal or complex unitary matrix Q, as computed by ?geqr, \n
    with best performance for tall and skinny matrices.
 * @details
 * \b Purpose:
    \verbatim
     GEMQR overwrites the general real M-by-N matrix C with

                    SIDE = 'L'     SIDE = 'R'
    TRANS = 'N':      Q * C          C * Q
    TRANS = 'T':      Q**T * C       C * Q**T
    where Q is a real orthogonal matrix defined as the product
    of blocked elementary reflectors computed by short wide LQ
    factorization (GEQR)
    \endverbatim

 * @param[in] SIDE
          SIDE is CHARACTER*1 \n
          = 'L': apply Q or Q**T from the Left; \n
          = 'R': apply Q or Q**T from the Right. \n
 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          = 'N':  No transpose, apply Q; \n
          = 'T':  Transpose, apply Q**T. \n
 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M >=0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix C. N >= 0. \n
 * @param[in] K
          K is INTEGER \n
          The number of elementary reflectors whose product defines
          the matrix Q. \n
          If SIDE = 'L', M >= K >= 0; \n
          if SIDE = 'R', N >= K >= 0. \n
 * @param[in] A
          A is REAL array, dimension \n
                               (LDA,M) if SIDE = 'L', \n
                               (LDA,N) if SIDE = 'R' \n
          Part of the data structure to represent Q as returned by DGELQ. \n
 * @para@[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A. LDA >= max(1,K). \n
 * @param[in] T
          T is REAL array, dimension (MAX(5,TSIZE)). \n
          Part of the data structure to represent Q as returned by SGELQ. \n
 * @param[in] TSIZE
          TSIZE is INTEGER \n
          The dimension of the array T. TSIZE >= 5. \n
 * @param[in,out] C
          C is REAL array, dimension (LDC,N) \n
          On entry, the M-by-N matrix C. \n
          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q. \n
 * @param[in] LDC
          LDC is INTEGER \n
          The leading dimension of the array C. LDC >= max(1,M). \n
 * @param[out]	WORK	
         (workspace) COMPLEX array, dimension (MAX(1,LWORK)) \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK. \n
          If LWORK = -1, then a workspace query is assumed. The routine
          only calculates the size of the WORK array, returns this
          value as WORK(1), and no error message related to WORK 
          is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer gemqr(char* side, char* trans, integer* m, integer* n, integer* k,  T* a, integer* lda,  T* t, integer* tsize, T* c, integer* ldc, T* work, integer* lwork, integer* info)
{
  return gemqr(side, trans, m, n, k,  a, lda,  t, tsize, c, ldc, work, lwork, info);
}

/*! @brief Multiplies a general matrix by the orthogonal/unitary matrix Q of the QR factorization formed by ?geqrt.
 * @details
 * \b Purpose:
    \verbatim
     GEMQRT overwrites the general real M-by-N matrix C with

                    SIDE = 'L'     SIDE = 'R'
     TRANS = 'N':      Q C            C Q
     TRANS = 'T':   Q**T C            C Q**T

     where Q is a real orthogonal matrix defined as the product of K
     elementary reflectors:

          Q = H(1) H(2) . . . H(K) = I - V T V**T

     generated using the compact WY representation as returned by SGEQRT.

     Q is of order M if SIDE = 'L' and of order N  if SIDE = 'R'.
    \endverbatim

 * @param[in] SIDE
          SIDE is CHARACTER*1 \n
          = 'L': apply Q or Q**T from the Left; \n
          = 'R': apply Q or Q**T from the Right. \n
 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          = 'N':  No transpose, apply Q; \n
          = 'T':  Transpose, apply Q**T. \n
 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix C. M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix C. N >= 0. \n
 * @param[in] K
          K is INTEGER \n
          The number of elementary reflectors whose product defines
          the matrix Q. \n
          If SIDE = 'L', M >= K >= 0; \n
          if SIDE = 'R', N >= K >= 0. \n
 * @param[in] NB
          NB is INTEGER \n
          The block size used for the storage of T.  K >= NB >= 1. \n
          This must be the same value of NB used to generate T
          in CGEQRT. \n
 * @param[in] V
          V is REAL array, dimension (LDV,K) \n
          The i-th column must contain the vector which defines the
          elementary reflector H(i), for i = 1,2,...,k, as returned by
          CGEQRT in the first K columns of its array argument A. \n
 * @param[in] LDV
          LDV is INTEGER \n
          The leading dimension of the array V. \n
          If SIDE = 'L', L/*!DA >= max(1,M); \n
          if SIDE = 'R', LDA >= max(1,N). \n
 * @param[in] T
          T is REAL array, dimension (LDT,K) \n
          The upper triangular factors of the block reflectors
          as returned by CGEQRT, stored as a NB-by-N matrix. \n
 * @param[in] LDT
          LDT is INTEGER \n
          The leading dimension of the array T.  LDT >= NB. \n
 * @param[in,out] C
          C is REAL array, dimension (LDC,N) \n
          On entry, the M-by-N matrix C. \n
          On exit, C is overwritten by Q C, Q**T C, C Q**T or C Q. \n
 * @param[in] LDC
          LDC is INTEGER \n
          The leading dimension of the array C. LDC >= max(1,M). \n
 * @param[out]	WORK	
          WORK is COMPLEX array. The dimension of WORK is
           N*NB if SIDE = 'L', or  M*NB if SIDE = 'R'. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

* @return INTEGER Return value of the function.
* */
template< typename T >
integer gemqrt(char* side, char* trans, integer* m, integer* n, integer* k, integer* nb, T* v, integer* ldv, T* t, integer* ldt, T* c, integer* ldc, T* work, integer* info)
{
  return gemqrt(side, trans, m, n, k, nb, v, ldv, t, ldt, c, ldc, work, info);
}

/*! @brief GEQLF computes a QL factorization of M-by-N matrix
 * @details
 * \b Purpose:
    \verbatim   
    GEQLF computes a QL factorization of M-by-N matrix A:
    A = Q * L.
    \endverbatim

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the M-by-N matrix A. \n
          On exit,
          if m >= n, the lower triangle of the subarray
          A(m-n+1:m,1:n) contains the N-by-N lower triangular matrix L;
          if m <= n, the elements on and below the (n-m)-th
          superdiagonal contain the M-by-N lower trapezoidal matrix L;
          the remaining elements, with the array TAU, represent the
          orthogonal matrix Q as a product of elementary reflectors
          (see Further Details). \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,M). \n
 * @param[out] TAU
          TAU is array, dimension (min(M,N)) \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK.  LWORK >= max(1,N).
          For optimum performance LWORK >= N*NB, where NB is
          the optimal blocksize. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer geqlf(integer* m, integer* n, T* a, integer* lda, T* tau, T* work, integer* lwork, integer* info)
{
  return geqlf(m, n, a, lda, tau, work, lwork, info);
}

/*! @brief GEQR computes a QR factorization of M-by-N matrix
 * @details
 * \b Purpose:
    \verbatim 
     GEQR computes a QR factorization of M-by-N matrix A:

     A = Q * ( R),
             ( 0)

     where:
     Q is a M-by-M orthogonal matrix;
     R is an upper-triangular N-by-N matrix;
     0 is a (M-N)-by-N zero matrix, if M > N.
    \endverbatim
 
 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M >= 0. \n
  * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A.  N >= 0. \n
  * @param[in,out] A
          A is array, dimension (LDA,N) \n
          On entry, the M-by-N matrix A. \n
          On exit, the elements on and above the diagonal of the array
          contain the min(M,N)-by-N upper trapezoidal matrix R
          (R is upper triangular if M >= N);
          the elements below the diagonal are used to store part of the 
          data structure to represent Q. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,M). \n
 * @param[out] T
          T is array, dimension (MAX(5,TSIZE)) \n
          On exit, if INFO = 0, T(1) returns optimal (or either minimal 
          or optimal, if query is assumed) TSIZE. See TSIZE for details.
          Remaining T contains part of the data structure used to represent Q.
          If one wants to apply or construct Q, then one needs to keep T 
          (in addition to A) and pass it to further subroutines. \n
 * @param[in] TSIZE
          TSIZE is INTEGER \n
          If TSIZE >= 5, the dimension of the array T. \n
          If TSIZE = -1 or -2, then a workspace query is assumed. The routine
          only calculates the sizes of the T and WORK arrays, returns these
          values as the first entries of the T and WORK arrays, and no error
          message related to T or WORK is issued by XERBLA. \n
          If TSIZE = -1, the routine calculates optimal size of T for the 
          optimum performance and returns this value in T(1). \n
          If TSIZE = -2, the routine calculates minimal size of T and 
          returns this value in T(1). \n
 * @param[out]	WORK	
          (workspace) REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) contains optimal (or either minimal
          or optimal, if query was assumed) LWORK.
          See LWORK for details. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK. \n
          If LWORK = -1 or -2, then a workspace query is assumed. The routine
          only calculates the sizes of the T and WORK arrays, returns these
          values as the first entries of the T and WORK arrays, and no error
          message related to T or WORK is issued by XERBLA. \n
          If LWORK = -1, the routine calculates optimal size of WORK for the
          optimal performance and returns this value in WORK(1). \n
          If LWORK = -2, the routine calculates minimal size of WORK and 
          returns this value in WORK(1). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer geqr(integer* m, integer* n, T* a, integer* lda, T* t, integer* tsize, T* work, integer* lwork, integer* info)
{
  return geqr(m, n, a, lda, t, tsize, work, lwork, info);
}

/*! @brief GEQRP computes a QR factorization of a M-by-N matrix
 * @details
 * \b Purpose:
    \verbatim 
     GEQRP computes a QR factorization of a M-by-N matrix A:
        A = Q * ( R),
                ( 0)

     where:
        Q is a M-by-M orthogonal matrix;
        R is an upper-triangular N-by-N matrix with nonnegative diagonal
        entries;
        0 is a (M-N)-by-N zero matrix, if M > N.
    \endverbatim 
 
 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is array, dimension (LDA,N) \n
          On entry, the M-by-N matrix A. \n
          On exit, the elements on and above the diagonal of the array
          contain the min(M,N)-by-N upper trapezoidal matrix R (R is
          upper triangular if m >= n). The diagonal entries of R
          are nonnegative; the elements below the diagonal,
          with the array TAU, represent the orthogonal matrix Q as a
          product of min(m,n) elementary reflectors (see Further
          Details). \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,M). \n
 * @param[out] TAU
          TAU is array, dimension (min(M,N)) \n
          The scalar factors of the elementary reflectors (see Further
          Details). \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK.  LWORK >= max(1,N).
          For optimum performance LWORK >= N*NB, where NB is
          the optimal blocksize. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer geqrfp(integer* m, integer* n, T* a, integer* lda, T* tau, T* work, integer* lwork, integer* info)
{
  return geqrfp(m, n, a, lda, tau, work, lwork, info);
} 

/*! @brief GEQRT computes a blocked QR factorization of a M-by-N matrix A \n
     using the compact WY representation
 *  @details
 *  \b Purpose:
    \verbatim
     GEQRT computes a blocked QR factorization of a M-by-N matrix A
     using the compact WY representation of Q.
    \endverbatim 
    
 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A.  N >= 0. \n
 * @param[in] NB
          NB is INTEGER \n
          The block size to be used in the blocked QR.  MIN(M,N) >= NB >= 1. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the M-by-N matrix A. \n
          On exit, the elements on and above the diagonal of the array
          contain the min(M,N)-by-N upper trapezoidal matrix R (R is
          upper triangular if M >= N); the elements below the diagonal
          are the columns of V. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,M). \n
 * @param[out] T
          T is REAL array, dimension (LDT,MIN(M,N)) \n
          The upper triangular block reflectors stored in compact form
          as a sequence of upper triangular blocks.  See below
          for further details. \n
 * @param[in] LDT
          LDT is INTEGER \n
          The leading dimension of the array T.  LDT >= NB. \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (NB*N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer geqrt(integer* m, integer* n, integer* nb, T* a, integer* lda, T* t, integer* ldt, T* work, integer* info)
{
  return geqrt(m, n, nb, a, lda, t, ldt, work, info);
}

/*! @brief GEQRT2 computes a blocked QR factorization of a M-by-N matrix A \n
     using the compact WY representation
 * @details
 * \b Purpose:
    \verbatim
     GEQRT2 computes a QR factorization of a real M-by-N matrix A,
     using the compact WY representation of Q.
    \endverbatim 

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M >= N. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the real M-by-N matrix A.  On exit, the elements on and
          above the diagonal contain the N-by-N upper triangular matrix R; the
          elements below the diagonal are the columns of V.  See below for
          further details. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,M). \n
 * @param[out] T
          T is REAL array, dimension (LDT,N) \n
          The N-by-N upper triangular factor of the block reflector.
          The elements on and above the diagonal contain the block
          reflector T; the elements below the diagonal are not used.
          See below for further details. \n
 * @param[in] LDT
          LDT is INTEGER \n
          The leading dimension of the array T.  LDT >= max(1,N). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */ 
template< typename T >
integer geqrt2(integer* m, integer* n, T* a, integer* lda, T* t, integer* ldt, integer* info)
{
  return geqrt2(m, n, a, lda, t, ldt, info);
}

/*! @brief GEQRT3 computes a blocked QR factorization of a M-by-N matrix A \n
     using the compact WY representation
 * @details
 * \b Purpose:
    \verbatim
     GEQRT3 computes a QR factorization of a real M-by-N matrix A,
     using the compact WY representation of Q.
    \endverbatim 

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M >= N. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the real M-by-N matrix A.  On exit, the elements on and
          above the diagonal contain the N-by-N upper triangular matrix R; the
          elements below the diagonal are the columns of V.  See below for
          further details. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,M). \n
 * @param[out] T
          T is REAL array, dimension (LDT,N) \n
          The N-by-N upper triangular factor of the block reflector.
          The elements on and above the diagonal contain the block
          reflector T; the elements below the diagonal are not used.
          See below for further details. \n
 * @param[in] LDT
          LDT is INTEGER \n
          The leading dimension of the array T.  LDT >= max(1,N). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n

* @return INTEGER Return value of the function.
 * */
template< typename T >
integer geqrt3(integer* m, integer* n, T* a, integer* lda, T* t, integer* ldt, integer* info)
{
  return geqrt3(m, n, a, lda, t, ldt, info);
}

/*! @brief GERFS improves the computed solution to a system of linear equations \n
  and provides error bounds and backward error estimates for the solution
 * @details
 * \b Purpose:
    \verbatim
    GERFS improves the computed solution to a system of linear
    equations and provides error bounds and backward error estimates for
    the solution.
    \endverbatim 

 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          Specifies the form of the system of equations: \n
          = 'N':  A * X = B     (No transpose) \n
          = 'T':  A**T * X = B  (Transpose) \n
          = 'C':  A**H * X = B  (Conjugate transpose = Transpose) \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrices B and X.  NRHS >= 0. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          The original N-by-N matrix A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] AF
          AF is REAL array, dimension (LDAF,N) \n
          The factors L and U from the factorization A = P*L*U
          as computed by GETRF. \n
 * @param[in] LDAF
          LDAF is INTEGER \n
          The leading dimension of the array AF.  LDAF >= max(1,N). \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          The pivot indices from GETRF; for 1<=i<=N, row i of the
          matrix was interchanged with row IPIV(i). \n
 * @param[in] B
          B is REAL array, dimension (LDB,NRHS) \n
          The right hand side matrix B. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[in,out] X
          X is REAL array, dimension (LDX,NRHS) \n
          On entry, the solution matrix X, as computed by GETRS.
          On exit, the improved solution matrix X. \n
 * @param[in] LDX
          LDX is INTEGER \n
          The leading dimension of the array X.  LDX >= max(1,N). \n
 * @param[out] FERR
          FERR is REAL array, dimension (NRHS) \n
          The estimated forward error bound for each solution vector
          X(j) (the j-th column of the solution matrix X).
          If XTRUE is the true solution corresponding to X(j), FERR(j)
          is an estimated upper bound for the magnitude of the largest
          element in (X(j) - XTRUE) divided by the magnitude of the
          largest element in X(j).  The estimate is as reliable as
          the estimate for RCOND, and is almost always a slight
          overestimate of the true error. \n
 * @param[out] BERR
          BERR is REAL array, dimension (NRHS) \n
          The componentwise relative backward error of each solution
          vector X(j) (i.e., the smallest relative change in
          any element of A or B that makes X(j) an exact solution). \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (2*N) \n
 * @param[out]	RWORK	
          RWORK is REAL array, dimension (N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */ 
template< typename T >
integer gerfs(char* trans, integer* n, integer* nrhs, T* a, integer* lda, T* af, integer* ldaf, integer* ipiv,  T* b, integer* ldb, T* x, integer* ldx, T* ferr, T* berr, T* work, integer* iwork, integer* info)
{
  return gerfs(trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork, info);
}
template< typename T, typename Ta >
integer gerfs(char* trans, integer* n, integer* nrhs,  T* a, integer* lda,  T* af, integer* ldaf,  integer* ipiv,  T* b, integer* ldb, T* x, integer* ldx, Ta* ferr, Ta* berr, T* work, Ta* rwork, integer* info)
{
  return gerfs(trans, n, nrhs, a, lda,  af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork, info);
}

/*! @brief GERFSX improves the computed solution to a system of linear equations \n
    and provides error bounds and backward error estimates for the solution
 *  @details
 *  \b Purpose:
    \verbatim
     GERFSX improves the computed solution to a system of linear
     equations and provides error bounds and backward error estimates
     for the solution.  In addition to normwise error bound, the code
     provides maximum componentwise error bound if possible.  See
     comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the
     error bounds.

     The original system of linear equations may have been equilibrated
     before calling this routine, as described by arguments EQUED, R
     and C below. In this case, the solution and error bounds returned
     are for the original unequilibrated system.
    \endverbatim

 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          Specifies the form of the system of equations: \n
            = 'N':  A * X = B     (No transpose) \n
            = 'T':  A**T * X = B  (Transpose) \n
            = 'C':  A**H * X = B  (Conjugate transpose = Transpose) \n
 * @param[in] EQUED
          EQUED is CHARACTER*1 \n
          Specifies the form of equilibration that was done to A
          before calling this routine. This is needed to compute
          the solution and error bounds correctly. \n
           = 'N':  No equilibration \n
           = 'R':  Row equilibration, i.e., A has been premultiplied by
                   diag(R). \n
           = 'C':  Column equilibration, i.e., A has been postmultiplied
                   by diag(C). \n
           = 'B':  Both row and column equilibration, i.e., A has been
                   replaced by diag(R) * A * diag(C).
                   The right hand side B has been changed accordingly. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrices B and X.  NRHS >= 0. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          The original N-by-N matrix A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] AF
          AF is REAL array, dimension (LDAF,N) \n
          The factors L and U from the factorization A = P*L*U
          as computed by GETRF. \n
 * @param[in] LDAF
          LDAF is INTEGER \n
          The leading dimension of the array AF.  LDAF >= max(1,N). \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          The pivot indices from GETRF; for 1<=i<=N, row i of the
          matrix was interchanged with row IPIV(i). \n
 * @param[in] R
          R is REAL array, dimension (N) \n
          The row scale factors for A.  If EQUED = 'R' or 'B', A is
          multiplied on the left by diag(R); if EQUED = 'N' or 'C', R
          is not accessed. \n
          If R is accessed, each element of R should be a power of the radix
          to ensure a reliable solution and error estimates. Scaling by
          powers of the radix does not cause rounding errors unless the
          result underflows or overflows. Rounding errors during scaling
          lead to refining with a matrix that is not equivalent to the
          input matrix, producing error estimates that may not be
          reliable. \n
 * @param[in] C
          C is REAL array, dimension (N) \n
          The column scale factors for A.  If EQUED = 'C' or 'B', A is
          multiplied on the right by diag(C); if EQUED = 'N' or 'R', C
          is not accessed. \n
          If C is accessed, each element of C should be a power of the radix
          to ensure a reliable solution and error estimates. Scaling by
          powers of the radix does not cause rounding errors unless the
          result underflows or overflows. Rounding errors during scaling
          lead to refining with a matrix that is not equivalent to the
          input matrix, producing error estimates that may not be
          reliable. \n
 * @param[in] B
          B is REAL array, dimension (LDB,NRHS) \n
          The right hand side matrix B. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[in,out] X
          X is REAL array, dimension (LDX,NRHS) \n
          On entry, the solution matrix X, as computed by GETRS.
          On exit, the improved solution matrix X. \n
 * @param[in] LDX
          LDX is INTEGER \n
          The leading dimension of the array X.  LDX >= max(1,N). \n
 * @param[out] RCOND
          RCOND is REAL \n
          Reciprocal scaled condition number. This is an estimate of the
          reciprocal Skeel condition number of the matrix A after
          equilibration (if done).  If this is less than the machine
          precision (in particular, if it is zero), the matrix is singular
          to working precision.  Note that the error may still be small even
          if this number is very small and the matrix appears ill-
          conditioned. \n
 * @param[out] BERR
          BERR is REAL array, dimension (NRHS) \n
          Componentwise relative backward error. This is the
          componentwise relative backward error of each solution vector X(j)
          (i.e., the smallest relative change in any element of A or B that
          makes X(j) an exact solution). \n
 * @param[in] N_ERR_BNDS
          N_ERR_BNDS is INTEGER \n
          Number of error bounds to return for each right hand side
          and each type (normwise or componentwise).  See ERR_BNDS_NORM and
          ERR_BNDS_COMP below. \n
 * @param[out] ERR_BNDS_NORM
          ERR_BNDS_NORM is REAL array, dimension (NRHS, N_ERR_BNDS)
          For each right-hand side, this array contains information about
          various error bounds and condition numbers corresponding to the
          normwise relative error, which is defined as follows: \n
 \n
          Normwise relative error in the ith solution vector: \n
                 max_j (abs(XTRUE(j,i) - X(j,i))) \n
                ------------------------------ \n
                      max_j abs(X(j,i)) \n
 \n
          The array is indexed by the type of error information as described
          below. There currently are up to three pieces of information
          returned. \n
 \n
          The first index in ERR_BNDS_NORM(i,:) corresponds to the ith
          right-hand side. \n
 \n
          The second index in ERR_BNDS_NORM(:,err) contains the following
          three fields: \n
          err = 1 "Trust/don't trust" boolean. Trust the answer if the
                  reciprocal condition number is less than the threshold
                  sqrt(n) * slamch('Epsilon'). \n
 \n
          err = 2 "Guaranteed" error bound: The estimated forward error,
                  almost certainly within a factor of 10 of the true error
                  so long as the next entry is greater than the threshold
                  sqrt(n) * slamch('Epsilon'). This error bound should only
                  be trusted if the previous boolean is true. \n
 \n
          err = 3  Reciprocal condition number: Estimated normwise
                  reciprocal condition number.  Compared with the threshold
                  sqrt(n) * slamch('Epsilon') to determine if the error
                  estimate is "guaranteed". These reciprocal condition
                  numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
                  appropriately scaled matrix Z.
                  Let Z = S*A, where S scales each row by a power of the
                  radix so all absolute row sums of Z are approximately 1. \n
 \n
          See Lapack Working Note 165 for further details and extra
          cautions. \n
 * @param[out] ERR_BNDS_COMP
          ERR_BNDS_COMP is REAL array, dimension (NRHS, N_ERR_BNDS) \n
          For each right-hand side, this array contains information about
          various error bounds and condition numbers corresponding to the
          componentwise relative error, which is defined as follows: \n
 \n
          Componentwise relative error in the ith solution vector: \n
                        abs(XTRUE(j,i) - X(j,i)) \n
                 max_j ---------------------- \n
                             abs(X(j,i)) \n
 \n
          The array is indexed by the right-hand side i (on which the
          componentwise relative error depends), and the type of error
          information as described below. There currently are up to three
          pieces of information returned for each right-hand side. If
          componentwise accuracy is not requested (PARAMS(3) = 0.0), then
          ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS < 3, then at most
          the first (:,N_ERR_BNDS) entries are returned. \n
 \n
          The first index in ERR_BNDS_COMP(i,:) corresponds to the ith
          right-hand side. \n
 \n
          The second index in ERR_BNDS_COMP(:,err) contains the following
          three fields: \n
          err = 1 "Trust/don't trust" boolean. Trust the answer if the
                  reciprocal condition number is less than the threshold
                  sqrt(n) * slamch('Epsilon'). \n
 \n
          err = 2 "Guaranteed" error bound: The estimated forward error,
                  almost certainly within a factor of 10 of the true error
                  so long as the next entry is greater than the threshold
                  sqrt(n) * slamch('Epsilon'). This error bound should only
                  be trusted if the previous boolean is true. \n
 \n
          err = 3  Reciprocal condition number: Estimated componentwise
                  reciprocal condition number.  Compared with the threshold
                  sqrt(n) * slamch('Epsilon') to determine if the error
                  estimate is "guaranteed". These reciprocal condition
                  numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
                  appropriately scaled matrix Z.
                  Let Z = S*(A*diag(x)), where x is the solution for the
                  current right-hand side and S scales each row of
                  A*diag(x) by a power of the radix so all absolute row
                  sums of Z are approximately 1. \n
 \n
          See Lapack Working Note 165 for further details and extra
          cautions. \n
 * @param[in] NPARAMS
          NPARAMS is INTEGER \n
          Specifies the number of parameters set in PARAMS.  If <= 0, the
          PARAMS array is never referenced and default values are used. \n
 * @param[in,out] PARAMS
          PARAMS is REAL array, dimension NPARAMS \n
          Specifies algorithm parameters.  If an entry is < 0.0, then
          that entry will be filled with default value used for that
          parameter.  Only positions up to NPARAMS are accessed; defaults
          are used for higher-numbered parameters. \n
 \n
          PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative
              refinement or not. \n
           Default: 1.0 \n
              = 0.0:  No refinement is performed, and no error bounds are
                      computed. \n
              = 1.0:  Use the double-precision refinement algorithm,
                      possibly with doubled-single computations if the
                      compilation environment does not support DOUBLE
                      PRECISION.
                (other values are reserved for future use) \n
 \n
          PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual
              computations allowed for refinement. \n
           Default: 10 \n
           Aggressive: Set to 100 to permit convergence using approximate
                       factorizations or factorizations other than LU. If
                       the factorization uses a technique other than
                       Gaussian elimination, the guarantees in
                       err_bnds_norm and err_bnds_comp may no longer be
                       trustworthy. \n
 \n
          PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code
              will attempt to find a solution with small componentwise
              relative error in the double-precision algorithm.  Positive
              is true, 0.0 is false. \n
           Default: 1.0 (attempt componentwise convergence) \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (2*N) \n
 * @param[out]	RWORK	
          RWORK is REAL array, dimension (2*N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  Successful exit. The solution to every right-hand side is
           guaranteed. \n
          < 0:  If INFO = -i, the i-th argument had an illegal value \n
          > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization
           has been completed, but the factor U is exactly singular, so
           the solution and error bounds could not be computed. RCOND = 0
           is returned. \n
          = N+J: The solution corresponding to the Jth right-hand side is
           not guaranteed. The solutions corresponding to other right-
           hand sides K with K > J may not be guaranteed as well, but
           only the first such right-hand side is reported. If a small
           componentwise error is not requested (PARAMS(3) = 0.0) then
           the Jth right-hand side is the first with a normwise error
           bound that is not guaranteed (the smallest J such
           that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)
           the Jth right-hand side is the first with either a normwise or
           componentwise error bound that is not guaranteed (the smallest
           J such that either ERR_BNDS_NORM(J,1) = 0.0 or
           ERR_BNDS_COMP(J,1) = 0.0). See the definition of
           ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information
           about all of the right-hand sides check ERR_BNDS_NORM or
           ERR_BNDS_COMP. \n

* @return INTEGER Return value of the function.
 * */
template< typename T >
integer gerfsx(char* trans, char* equed, integer* n, integer* nrhs, T* a, integer* lda, T* af, integer* ldaf, integer* ipiv, T* r, T* c, T* b, integer* ldb, T* x, integer* ldx, T* rcond, T* berr, integer* n_err_bnds, T* err_bnds_norm, T* err_bnds_comp, integer* nparams, T* params, T* work, integer* iwork, integer* info)
{
  return gerfsx(trans, equed, n, nrhs, a, lda, af, ldaf, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info);
}
template< typename T, typename Ta >
integer gerfsx(char* trans, char* equed, integer* n, integer* nrhs,  T* a, integer* lda,  T* af, integer* ldaf, integer* ipiv, Ta* r, Ta* c, T* b, integer* ldb, T* x, integer* ldx, Ta* rcond, Ta* berr, integer* n_err_bnds, Ta* err_bnds_norm, Ta* err_bnds_comp, integer* nparams, Ta* params, T* work, Ta* rwork, integer* info)
{
  return gerfsx(trans, equed, n, nrhs, a, lda, af, ldaf, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info);
}

/*! @brief GERQF computes a RQ factorization of a M-by-N matrix
 * @details
 * \b Purpose:
    \verbatim
     GERQF computes an RQ factorization of a real M-by-N matrix A:
     A = R * Q.
    \endverbatim 

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the M-by-N matrix A. \n
          On exit,
          if m <= n, the upper triangle of the subarray
          A(1:m,n-m+1:n) contains the M-by-M upper triangular matrix R; \n
          if m >= n, the elements on and above the (m-n)-th subdiagonal
          contain the M-by-N upper trapezoidal matrix R;
          the remaining elements, with the array TAU, represent the
          orthogonal matrix Q as a product of min(m,n) elementary
          reflectors (see Further Details). \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,M). \n
 * @param[out] TAU
          TAU is REAL array, dimension (min(M,N)) \n
          The scalar factors of the elementary reflectors (see Further
          Details). \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK.  LWORK >= max(1,M).
          For optimum performance LWORK >= M*NB, where NB is
          the optimal blocksize. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer gerqf(integer* m, integer* n, T* a, integer* lda, T* tau, T* work, integer* lwork, integer* info)
{
  return gerqf(m, n, a, lda, tau, work, lwork, info);
}

/*! @brief GESV computes the solution to a real system of linear equations
 * @details
 * \b Purpose:
    \verbatim
     GESV computes the solution to a real system of linear equations
        A * X = B,
     where A is an N-by-N matrix and X and B are N-by-NRHS matrices.

     The LU decomposition with partial pivoting and row interchanges is
     used to factor A as
        A = P * L * U,
     where P is a permutation matrix, L is unit lower triangular, and U is
     upper triangular.  The factored form of A is then used to solve the
     system of equations A * X = B.
    \endverbatim 
    
 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the N-by-N coefficient matrix A.
          On exit, the factors L and U from the factorization
          A = P*L*U; the unit diagonal elements of L are not stored. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          The pivot indices that define the permutation matrix P;
          row i of the matrix was interchanged with row IPIV(i). \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,NRHS) \n
          On entry, the N-by-NRHS matrix of right hand side matrix B.
          On exit, if INFO = 0, the N-by-NRHS solution matrix X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization
                has been completed, but the factor U is exactly
                singular, so the solution could not be computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer gesv(integer* n, integer* nrhs, T* a, integer* lda, integer* ipiv, T* b, integer* ldb, integer* info)
{
  return gesv(n, nrhs, a, lda, ipiv, b, ldb, info);
}

/*! @brief DSGESV computes the solution to system of linear equations A * X = B \n 
     for GE matrices (mixed precision with iterative refinement)
 * @details
 * \b Purpose:
    \verbatim 
     DSGESV computes the solution to a real system of linear equations
        A * X = B,
     where A is an N-by-N matrix and X and B are N-by-NRHS matrices.

     DSGESV first attempts to factorize the matrix in SINGLE PRECISION
     and use this factorization within an iterative refinement procedure
     to produce a solution with DOUBLE PRECISION normwise backward error
     quality (see below). If the approach fails the method switches to a
     DOUBLE PRECISION factorization and solve.

     The iterative refinement is not going to be a winning strategy if
     the ratio SINGLE PRECISION performance over DOUBLE PRECISION
     performance is too small. A reasonable strategy should take the
     number of right-hand sides and the size of the matrix into account.
     This might be done with a call to ILAENV in the future. Up to now, we
     always try iterative refinement.

     The iterative refinement process is stopped if
         ITER > ITERMAX
     or for all the RHS we have:
         RNRM < SQRT(N)*XNRM*ANRM*EPS*BWDMAX
     where
         o ITER is the number of the current iteration in the iterative
           refinement process
         o RNRM is the infinity-norm of the residual
         o XNRM is the infinity-norm of the solution
         o ANRM is the infinity-operator-norm of the matrix A
         o EPS is the machine epsilon returned by DLAMCH('Epsilon')
     The value ITERMAX and BWDMAX are fixed to 30 and 1.0D+00
     respectively.
    \endverbatim 

 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in,out] A
          A is DOUBLE PRECISION array,
          dimension (LDA,N) \n
          On entry, the N-by-N coefficient matrix A. \n
          On exit, if iterative refinement has been successfully used
          (INFO = 0 and ITER >= 0, see description below), then A is
          unchanged, if double precision factorization has been used
          (INFO = 0 and ITER < 0, see description below), then the
          array A contains the factors L and U from the factorization
          A = P*L*U; the unit diagonal elements of L are not stored. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          The pivot indices that define the permutation matrix P;
          row i of the matrix was interchanged with row IPIV(i).
          Corresponds either to the single precision factorization
          (if INFO = 0 and ITER >= 0) or the double precision
          factorization (if INFO = 0 and ITER < 0). \n
 * @param[in] B
          B is DOUBLE PRECISION array, dimension (LDB,NRHS) \n
          The N-by-NRHS right hand side matrix B. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out] X
          X is DOUBLE PRECISION array, dimension (LDX,NRHS) \n
          If INFO = 0, the N-by-NRHS solution matrix X. \n
 * @param[in] LDX
          LDX is INTEGER \n
          The leading dimension of the array X.  LDX >= max(1,N). \n
 * @param[out] ITER
          ITER is INTEGER \n
          < 0: iterative refinement has failed, double precision
               factorization has been performed \n
               -1 : the routine fell back to full precision for
                    implementation- or machine-specific reasons \n
               -2 : narrowing the precision induced an overflow,
                    the routine fell back to full precision \n
               -3 : failure of SGETRF \n
               -31: stop the iterative refinement after the 30th
                    iterations \n
          > 0: iterative refinement has been successfully used.
               Returns the number of iterations \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization
                has been completed, but the factor U is exactly
                singular, so the solution could not be computed. \n

 * @return INTEGER Return value of the function.
 * */
integer sgesv(integer* n, integer* nrhs, double* a, integer* lda, integer* ipiv, double* b, integer* ldb, double* x, integer* ldx, double* work, float* swork, integer* iter, integer* info)
{
  return dsgesv_(n, nrhs, a, lda, ipiv, b, ldb, x, ldx, work, swork, iter, info);
}

/*! @brief ZCGESV computes the solution to system of linear equations A * X = B \n
     for GE matrices (mixed precision with iterative refinement)
 * @details
 * \b Purpose:
    \verbatim 
     ZCGESV computes the solution to a complex system of linear equations
        A * X = B,
     where A is an N-by-N matrix and X and B are N-by-NRHS matrices.

     ZCGESV first attempts to factorize the matrix in COMPLEX and use this
     factorization within an iterative refinement procedure to produce a
     solution with COMPLEX*16 normwise backward error quality (see below).
     If the approach fails the method switches to a COMPLEX*16
     factorization and solve.

     The iterative refinement is not going to be a winning strategy if
     the ratio COMPLEX performance over COMPLEX*16 performance is too
     small. A reasonable strategy should take the number of right-hand
     sides and the size of the matrix into account. This might be done
     with a call to ILAENV in the future. Up to now, we always try
     iterative refinement.

     The iterative refinement process is stopped if
         ITER > ITERMAX
     or for all the RHS we have:
         RNRM < SQRT(N)*XNRM*ANRM*EPS*BWDMAX
     where
         o ITER is the number of the current iteration in the iterative
           refinement process
         o RNRM is the infinity-norm of the residual
         o XNRM is the infinity-norm of the solution
         o ANRM is the infinity-operator-norm of the matrix A
         o EPS is the machine epsilon returned by DLAMCH('Epsilon')
     The value ITERMAX and BWDMAX are fixed to 30 and 1.0D+00
     respectively.
    \endverbatim  

 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in,out] A
          A is COMPLEX*16 array,
          dimension (LDA,N) \n
          On entry, the N-by-N coefficient matrix A. \n
          On exit, if iterative refinement has been successfully used
          (INFO = 0 and ITER >= 0, see description below), then A is
          unchanged, if double precision factorization has been used
          (INFO = 0 and ITER < 0, see description below), then the
          array A contains the factors L and U from the factorization
          A = P*L*U; the unit diagonal elements of L are not stored. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          The pivot indices that define the permutation matrix P;
          row i of the matrix was interchanged with row IPIV(i).
          Corresponds either to the single precision factorization
          (if INFO = 0 and ITER >= 0) or the double precision
          factorization (if INFO = 0 and ITER < 0). \n
 * @param[in] B
          B is COMPLEX*16 array, dimension (LDB,NRHS) \n
          The N-by-NRHS right hand side matrix B. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out] X
          X is COMPLEX*16 array, dimension (LDX,NRHS) \n
          If INFO = 0, the N-by-NRHS solution matrix X. \n
 * @param[in] LDX
          LDX is INTEGER \n
          The leading dimension of the array X.  LDX >= max(1,N). \n
 * @param[out] ITER
          ITER is INTEGER \n
          < 0: iterative refinement has failed, COMPLEX*16
               factorization has been performed \n
               -1 : the routine fell back to full precision for
                    implementation- or machine-specific reasons \n
               -2 : narrowing the precision induced an overflow,
                    the routine fell back to full precision \n
               -3 : failure of CGETRF \n
               -31: stop the iterative refinement after the 30th
                    iterations \n
          > 0: iterative refinement has been successfully used.
               Returns the number of iterations \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization
                has been completed, but the factor U is exactly
                singular, so the solution could not be computed. \n

 * @return INTEGER Return value of the function.
 * */
integer cgesv(integer* n, integer* nrhs, dcomplex* a, integer* lda, integer* ipiv, dcomplex* b, integer* ldb, dcomplex* x, integer* ldx, dcomplex *work, scomplex *swork, double *rwork, integer *iter, integer *info)
{
  return zcgesv_(n, nrhs, a, lda, ipiv, b, ldb, x, ldx, work, swork, rwork, iter, info);
}

/*! @brief GESVDQ computes the singular value decomposition (SVD) with a QR-Preconditioned QR SVD Method for GE matrices
 * @details
 * \b Purpose:
    \verbatim
     GESVDQ computes the singular value decomposition (SVD) of a real
     M-by-N matrix A, where M >= N. The SVD of A is written as
                                        [++]   [xx]   [x0]   [xx]
                  A = U * SIGMA * V^*,  [++] = [xx] * [ox] * [xx]
                                        [++]   [xx]
     where SIGMA is an N-by-N diagonal matrix, U is an M-by-N orthonormal
     matrix, and V is an N-by-N orthogonal matrix. The diagonal elements
     of SIGMA are the singular values of A. The columns of U and V are the
     left and the right singular vectors of A, respectively.
    \endverbatim 

 * @param[in] JOBP
          JOBP is CHARACTER*1 \n
          = 'P' The rows of A are ordered in decreasing order with respect to
                ||A(i,:)||_\infty. This enhances numerical accuracy at the cost
                of extra data movement. Recommended for numerical robustness. \n
          = 'N' No row pivoting. \n
 * @param[in] JOBR
          JOBR is CHARACTER*1 \n
          = 'T' After the initial pivoted QR factorization, GESVD is applied to
          the transposed R**T of the computed triangular factor R. This involves
          some extra data movement (matrix transpositions). Useful for
          experiments, research and development. \n
          = 'N' The triangular factor R is given as input to GESVD. This may be
          preferred as it involves less data movement. \n
 * @param[in] JOBU
          JOBU is CHARACTER*1 \n
          = 'A' All M left singular vectors are computed and returned in the
          matrix U. See the description of U. \n
          = 'S' or 'U' N = min(M,N) left singular vectors are computed and returned
          in the matrix U. See the description of U. \n
          = 'R' Numerical rank NUMRANK is determined and only NUMRANK left singular
          vectors are computed and returned in the matrix U. \n
          = 'F' The N left singular vectors are returned in factored form as the
          product of the Q factor from the initial QR factorization and the
          N left singular vectors of (R**T , 0)**T. If row pivoting is used,
          then the necessary information on the row pivoting is stored in
          IWORK(N+1:N+M-1). \n
          = 'N' The left singular vectors are not computed. \n
 * @param[in] JOBV
          JOBV is CHARACTER*1 \n
          = 'A', 'V' All N right singular vectors are computed and returned in
          the matrix V. \n
          = 'R' Numerical rank NUMRANK is determined and only NUMRANK right singular
          vectors are computed and returned in the matrix V. This option is
          allowed only if JOBU = 'R' or JOBU = 'N'; otherwise it is illegal. \n
          = 'N' The right singular vectors are not computed. \n
 * @param[in] M
          M is INTEGER \n
          The number of rows of the input matrix A.  M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the input matrix A.  M >= N >= 0. \n
 * @param[in,out] A
          A is REAL array of dimensions LDA x N \n
          On entry, the input matrix A. \n
          On exit, if JOBU .NE. 'N' or JOBV .NE. 'N', the lower triangle of A contains
          the Householder vectors as stored by GEQP3. If JOBU = 'F', these Householder
          vectors together with WORK(1:N) can be used to restore the Q factors from
          the initial pivoted QR factorization of A. See the description of U. \n
 * @param[in] LDA
          LDA is INTEGER. \n
          The leading dimension of the array A.  LDA >= max(1,M). \n
 * @param[out] S
          S is REAL array of dimension N. \n
          The singular values of A, ordered so that S(i) >= S(i+1). \n
 * @param[out] U
          U is REAL array, dimension \n
          LDU x M if JOBU = 'A'; see the description of LDU. In this case,
          on exit, U contains the M left singular vectors. \n
          LDU x N if JOBU = 'S', 'U', 'R' ; see the description of LDU. In this
          case, U contains the leading N or the leading NUMRANK left singular vectors. \n
          LDU x N if JOBU = 'F' ; see the description of LDU. In this case U
          contains N x N orthogonal matrix that can be used to form the left
          singular vectors. \n
          If JOBU = 'N', U is not referenced. \n
 * @param[in] LDU
          LDU is INTEGER. \n
          The leading dimension of the array U. \n
          If JOBU = 'A', 'S', 'U', 'R',  LDU >= max(1,M). \n
          If JOBU = 'F',                 LDU >= max(1,N). \n
          Otherwise,                     LDU >= 1. \n
 * @param[out] V
          V is REAL array, dimension \n
          LDV x N if JOBV = 'A', 'V', 'R' or if JOBA = 'E' . \n
          If JOBV = 'A', or 'V',  V contains the N-by-N orthogonal matrix  V**T; \n
          If JOBV = 'R', V contains the first NUMRANK rows of V**T (the right
          singular vectors, stored rowwise, of the NUMRANK largest singular values). \n
          If JOBV = 'N' and JOBA = 'E', V is used as a workspace. \n
          If JOBV = 'N', and JOBA.NE.'E', V is not referenced. \n
 * @param[in] LDV
          LDV is INTEGER \n
          The leading dimension of the array V. \n
          If JOBV = 'A', 'V', 'R',  or JOBA = 'E', LDV >= max(1,N).
          Otherwise,                               LDV >= 1. \n
 * @param[out] NUMRANK
          NUMRANK is INTEGER \n
          NUMRANK is the numerical rank first determined after the rank
          revealing QR factorization, following the strategy specified by the
          value of JOBA. If JOBV = 'R' and JOBU = 'R', only NUMRANK
          leading singular values and vectors are then requested in the call
          of GESVD. The final value of NUMRANK might be further reduced if
          some singular values are computed as zeros. \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (max(1, LIWORK)). \n
          On exit, IWORK(1:N) contains column pivoting permutation of the
          rank revealing QR factorization. \n
          If JOBP = 'P', IWORK(N+1:N+M-1) contains the indices of the sequence
          of row swaps used in row pivoting. These can be used to restore the
          left singular vectors in the case JOBU = 'F'. \n
 \n
          If LIWORK, LCWORK, or LRWORK = -1, then on exit, if INFO = 0,
          IWORK(1) returns the minimal LIWORK. \n
 * @param[in]	LIWORK	
          LIWORK is INTEGER \n
          The dimension of the array IWORK. \n
          LIWORK >= N + M - 1,  if JOBP = 'P'; \n
          LIWORK >= N           if JOBP = 'N'. \n
 \n
          If LIWORK = -1, then a workspace query is assumed; the routine
          only calculates and returns the optimal and minimal sizes
          for the CWORK, IWORK, and RWORK arrays, and no error
          message related to LCWORK is issued by XERBLA. \n
 * @param[out]	CWORK	
          CWORK is COMPLEX array, dimension (max(2, LCWORK)), used as a workspace.
          On exit, if, on entry, LCWORK.NE.-1, CWORK(1:N) contains parameters
          needed to recover the Q factor from the QR factorization computed by
          CGEQP3. \n
 \n
          If LIWORK, LCWORK, or LRWORK = -1, then on exit, if INFO = 0,
          CWORK(1) returns the optimal LCWORK, and
          CWORK(2) returns the minimal LCWORK. \n
 * @param[in,out]	LCWORK	
          LCWORK is INTEGER \n
          The dimension of the array CWORK. It is determined as follows:
          Let  LWQP3 = N+1,  LWCON = 2*N, and let \n
          LWUNQ = { MAX( N, 1 ),  if JOBU = 'R', 'S', or 'U' \n
                  { MAX( M, 1 ),  if JOBU = 'A' \n
          LWSVD = MAX( 3*N, 1 ) \n
          LWLQF = MAX( N/2, 1 ), LWSVD2 = MAX( 3*(N/2), 1 ), LWUNLQ = MAX( N, 1 ), \n
          LWQRF = MAX( N/2, 1 ), LWUNQ2 = MAX( N, 1 ) \n
          Then the minimal value of LCWORK is: \n
          = MAX( N + LWQP3, LWSVD )        if only the singular values are needed; \n
          = MAX( N + LWQP3, LWCON, LWSVD ) if only the singular values are needed,
                                   and a scaled condition estimate requested; \n
 \n
          = N + MAX( LWQP3, LWSVD, LWUNQ ) if the singular values and the left
                                   singular vectors are requested; \n
          = N + MAX( LWQP3, LWCON, LWSVD, LWUNQ ) if the singular values and the left
                                   singular vectors are requested, and also
                                   a scaled condition estimate requested; \n
 \n
          = N + MAX( LWQP3, LWSVD )        if the singular values and the right
                                   singular vectors are requested; \n
          = N + MAX( LWQP3, LWCON, LWSVD ) if the singular values and the right
                                   singular vectors are requested, and also
                                   a scaled condition etimate requested; \n
 \n
          = N + MAX( LWQP3, LWSVD, LWUNQ ) if the full SVD is requested with JOBV = 'R';
                                   independent of JOBR; \n
          = N + MAX( LWQP3, LWCON, LWSVD, LWUNQ ) if the full SVD is requested,
                                   JOBV = 'R' and, also a scaled condition
                                   estimate requested; independent of JOBR; \n
          = MAX( N + MAX( LWQP3, LWSVD, LWUNQ ),
         N + MAX( LWQP3, N/2+LWLQF, N/2+LWSVD2, N/2+LWUNLQ, LWUNQ) ) if the
                         full SVD is requested with JOBV = 'A' or 'V', and
                         JOBR ='N' \n
          = MAX( N + MAX( LWQP3, LWCON, LWSVD, LWUNQ ),
         N + MAX( LWQP3, LWCON, N/2+LWLQF, N/2+LWSVD2, N/2+LWUNLQ, LWUNQ ) )
                         if the full SVD is requested with JOBV = 'A' or 'V', and
                         JOBR ='N', and also a scaled condition number estimate
                         requested. \n
          = MAX( N + MAX( LWQP3, LWSVD, LWUNQ ),
         N + MAX( LWQP3, N/2+LWQRF, N/2+LWSVD2, N/2+LWUNQ2, LWUNQ ) ) if the
                         full SVD is requested with JOBV = 'A', 'V', and JOBR ='T'
          = MAX( N + MAX( LWQP3, LWCON, LWSVD, LWUNQ ), \n
         N + MAX( LWQP3, LWCON, N/2+LWQRF, N/2+LWSVD2, N/2+LWUNQ2, LWUNQ ) )
                         if the full SVD is requested with JOBV = 'A', 'V' and
                         JOBR ='T', and also a scaled condition number estimate
                         requested. \n
          Finally, LCWORK must be at least two: LCWORK = MAX( 2, LCWORK ). \n
 \n
          If LCWORK = -1, then a workspace query is assumed; the routine
          only calculates and returns the optimal and minimal sizes
          for the CWORK, IWORK, and RWORK arrays, and no error
          message related to LCWORK is issued by XERBLA. \n
 * @param[out]	RWORK	
          RWORK is REAL array, dimension (max(1, LRWORK)). \n
          On exit, \n
          1. If JOBA = 'E', RWORK(1) contains an estimate of the condition
          number of column scaled A. If A = C * D where D is diagonal and C
          has unit columns in the Euclidean norm, then, assuming full column rank,
          N^(-1/4) * RWORK(1) <= ||pinv(C)||_2 <= N^(1/4) * RWORK(1).
          Otherwise, RWORK(1) = -1. \n
          2. RWORK(2) contains the number of singular values computed as
          exact zeros in CGESVD applied to the upper triangular or trapezoidal
          R (from the initial QR factorization). In case of early exit (no call to
          CGESVD, such as in the case of zero matrix) RWORK(2) = -1. \n
 \n
          If LIWORK, LCWORK, or LRWORK = -1, then on exit, if INFO = 0,
          RWORK(1) returns the minimal LRWORK. \n
 * @param[in]	LRWORK	
          LRWORK is INTEGER. \n
          The dimension of the array RWORK.
          If JOBP ='P', then LRWORK >= MAX(2, M, 5*N);
          Otherwise, LRWORK >= MAX(2, 5*N). \n
 \n
          If LRWORK = -1, then a workspace query is assumed; the routine
          only calculates and returns the optimal and minimal sizes
          for the CWORK, IWORK, and RWORK arrays, and no error
          message related to LCWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n
          > 0:  if CBDSQR did not converge, INFO specifies how many superdiagonals
          of an intermediate bidiagonal form B (computed in CGESVD) did not
          converge to zero. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer gesvdq(char* joba, char* jobp, char* jobr, char* jobu, char* jobv, integer* m, integer* n, T* a, integer* lda, T* s, T* u, integer* ldu, T* v, integer* ldv, integer* numrank, integer* iwork, integer* liwork, T* work, integer* lwork, T* rwork, integer* lrwork, integer* info)
{
  return gesvdq(joba, jobp, jobr, jobu, jobv, m, n, a, lda, s, u, ldu, v, ldv, numrank, iwork, liwork, work, lwork, rwork, lrwork, info);
}
template< typename T, typename Ta >
integer gesvdq(char* joba, char* jobp, char* jobr, char* jobu, char* jobv, integer* m, integer* n, T* a, integer* lda, Ta* s, T* u, integer* ldu, T* v, integer* ldv, integer* numrank, integer* iwork, integer* liwork, T* cwork, integer* lcwork, Ta* rwork, integer* lrwork, integer* info)
{
  return gesvdq(joba, jobp, jobr, jobu, jobv, m, n, a, lda, s, u, ldu, v, ldv, numrank, iwork, liwork, cwork, lcwork, rwork, lrwork, info);
}

/*! @brief GESVDX computes the singular value decomposition (SVD) for GE matrices
 * @details
 * \b Purpose:
    \verbatim
     GESVDX computes the singular value decomposition (SVD) of a real
     M-by-N matrix A, optionally computing the left and/or right singular
     vectors. The SVD is written

         A = U * SIGMA * transpose(V)

     where SIGMA is an M-by-N matrix which is zero except for its
     min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
     V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
     are the singular values of A; they are real and non-negative, and
     are returned in descending order.  The first min(m,n) columns of
     U and V are the left and right singular vectors of A.

     GESVDX uses an eigenvalue problem for obtaining the SVD, which
     allows for the computation of a subset of singular values and
     vectors. See BDSVDX for details.

     Note that the routine returns V**T, not V.
    \endverbatim 

 * @param[in] JOBU
          JOBU is CHARACTER*1 \n
          Specifies options for computing all or part of the matrix U:
          = 'V':  the first min(m,n) columns of U (the left singular
                  vectors) or as specified by RANGE are returned in
                  the array U; \n
          = 'N':  no columns of U (no left singular vectors) are
                  computed. \n
 * @param[in] JOBVT
          JOBVT is CHARACTER*1 \n
          Specifies options for computing all or part of the matrix
          V**T: \n
          = 'V':  the first min(m,n) rows of V**T (the right singular
                  vectors) or as specified by RANGE are returned in
                  the array VT; \n
          = 'N':  no rows of V**T (no right singular vectors) are
                  computed. \n
 * @param[in] RANGE
          RANGE is CHARACTER*1 \n
          = 'A': all singular values will be found. \n
          = 'V': all singular values in the half-open interval (VL,VU]
                 will be found. \n
          = 'I': the IL-th through IU-th singular values will be found. \n
 * @param[in] M
          M is INTEGER \n
          The number of rows of the input matrix A.  M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the input matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the M-by-N matrix A.
          On exit, the contents of A are destroyed. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,M). \n
 * @param[in] VL
          VL is REAL \n
          If RANGE='V', the lower bound of the interval to
          be searched for singular values. VU > VL.
          Not referenced if RANGE = 'A' or 'I'. \n
 * @param[in] VU
          VU is REAL \n
          If RANGE='V', the upper bound of the interval to
          be searched for singular values. VU > VL.
          Not referenced if RANGE = 'A' or 'I'. \n
 * @param[in] IL
          IL is INTEGER \n
          If RANGE='I', the index of the
          smallest singular value to be returned.
          1 <= IL <= IU <= min(M,N), if min(M,N) > 0.
          Not referenced if RANGE = 'A' or 'V'. \n
 * @param[in] IU
          IU is INTEGER \n
          If RANGE='I', the index of the
          largest singular value to be returned.
          1 <= IL <= IU <= min(M,N), if min(M,N) > 0.
          Not referenced if RANGE = 'A' or 'V'. \n
 * @param[out] NS
          NS is INTEGER \n
          The total number of singular values found,
          0 <= NS <= min(M,N). \n
          If RANGE = 'A', NS = min(M,N); if RANGE = 'I', NS = IU-IL+1. \n
 * @param[out] S
          S is REAL array, dimension (min(M,N)) \n
          The singular values of A, sorted so that S(i) >= S(i+1). \n
 * @param[out] U
          U is REAL array, dimension (LDU,UCOL) \n
          If JOBU = 'V', U contains columns of U (the left singular
          vectors, stored columnwise) as specified by RANGE; if
          JOBU = 'N', U is not referenced. \n
          Note: The user must ensure that UCOL >= NS; if RANGE = 'V',
          the exact value of NS is not known in advance and an upper
          bound must be used. \n
 * @param[in] LDU
          LDU is INTEGER \n
          The leading dimension of the array U.  LDU >= 1; if
          JOBU = 'V', LDU >= M. \n
 * @param[out] VT
          VT is REAL array, dimension (LDVT,N) \n
          If JOBVT = 'V', VT contains the rows of V**T (the right singular
          vectors, stored rowwise) as specified by RANGE; if JOBVT = 'N',
          VT is not referenced. \n
          Note: The user must ensure that LDVT >= NS; if RANGE = 'V',
          the exact value of NS is not known in advance and an upper
          bound must be used. \n
 * @param[in] LDVT
          LDVT is INTEGER \n
          The leading dimension of the array VT.  LDVT >= 1; if
          JOBVT = 'V', LDVT >= NS (see above). \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK; \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK. \n
          LWORK >= MAX(1,MIN(M,N)*(MIN(M,N)+4)) for the paths (see
          comments inside the code): \n
             - PATH 1  (M much larger than N) \n
             - PATH 1t (N much larger than M) \n
          LWORK >= MAX(1,MIN(M,N)*2+MAX(M,N)) for the other paths.
          For good performance, LWORK should generally be larger. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	RWORK	
          RWORK is REAL array, dimension (MAX(1,LRWORK)) \n
          LRWORK >= MIN(M,N)*(MIN(M,N)*2+15*MIN(M,N)). \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (12*MIN(M,N)) \n
          If INFO = 0, the first NS elements of IWORK are zero. If INFO > 0,
          then IWORK contains the indices of the eigenvectors that failed
          to converge in SBDSVDX/SSTEVX. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
           = 0:  successful exit \n
           < 0:  if INFO = -i, the i-th argument had an illegal value \n
           > 0:  if INFO = i, then i eigenvectors failed to converge
                 in SBDSVDX/SSTEVX.
                 if INFO = N*2 + 1, an internal error occurred in
                 SBDSVDX \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer gesvdx(char* jobu, char* jobvt, char* range, integer* m, integer* n, T* a, integer* lda, T* vl, T* vu, integer* il, integer* iu, integer* ns, T* s, T* u, integer* ldu, T* vt, integer* ldvt, T* work, integer* lwork, integer* iwork, integer* info)
{
  return gesvdx(jobu, jobvt, range, m, n, a, lda, vl, vu, il, iu, ns, s, u, ldu, vt, ldvt, work, lwork, iwork, info);
}
template< typename T, typename Ta >
integer gesvdx(char* jobu, char* jobvt, char* range, integer* m, integer* n, T* a, integer* lda, Ta* vl, Ta* vu, integer* il, integer* iu, integer* ns, Ta* s, T* u, integer* ldu, T* vt, integer* ldvt, T* work, integer* lwork, Ta* rwork, integer* iwork, integer* info)
{
  return gesvdx(jobu, jobvt, range, m, n, a, lda, vl, vu, il, iu, ns, s, u, ldu, vt, ldvt, work, lwork, rwork, iwork, info);
}

/*! @brief GESVJ computes the singular value decomposition (SVD) of a M-by-N matrix A
 * @details
 * \b Purpose:
    \verbatim
     GESVJ computes the singular value decomposition (SVD) of a real
     M-by-N matrix A, where M >= N. The SVD of A is written as
                                        [++]   [xx]   [x0]   [xx]
                  A = U * SIGMA * V^t,  [++] = [xx] * [ox] * [xx]
                                        [++]   [xx]
     where SIGMA is an N-by-N diagonal matrix, U is an M-by-N orthonormal
     matrix, and V is an N-by-N orthogonal matrix. The diagonal elements
     of SIGMA are the singular values of A. The columns of U and V are the
     left and the right singular vectors of A, respectively.
     GESVJ can sometimes compute tiny singular values and their singular vectors much
     more accurately than other SVD routines, see below under Further Details.
    \endverbatim 

 * @param[in] JOBA
          JOBA is CHARACTER*1 \n
          Specifies the structure of A. \n
          = 'L': The input matrix A is lower triangular; \n
          = 'U': The input matrix A is upper triangular; \n
          = 'G': The input matrix A is general M-by-N matrix, M >= N. \n
 * @param[in] JOBU
          JOBU is CHARACTER*1 \n
          Specifies whether to compute the left singular vectors
          (columns of U): \n
          = 'U': The left singular vectors corresponding to the nonzero
                 singular values are computed and returned in the leading
                 columns of A. See more details in the description of A.
                 The default numerical orthogonality threshold is set to
                 approximately TOL=CTOL*EPS, CTOL=SQRT(M), EPS=SLAMCH('E'). \n
          = 'C': Analogous to JOBU='U', except that user can control the
                 level of numerical orthogonality of the computed left
                 singular vectors. TOL can be set to TOL = CTOL*EPS, where
                 CTOL is given on input in the array WORK.
                 No CTOL smaller than ONE is allowed. CTOL greater
                 than 1 / EPS is meaningless. The option 'C'
                 can be used if M*EPS is satisfactory orthogonality
                 of the computed left singular vectors, so CTOL=M could
                 save few sweeps of Jacobi rotations.
                 See the descriptions of A and WORK(1). \n
          = 'N': The matrix U is not computed. However, see the
                 description of A. \n
 * @param[in] JOBV
          JOBV is CHARACTER*1 \n
          Specifies whether to compute the right singular vectors, that
          is, the matrix V: \n
          = 'V':  the matrix V is computed and returned in the array V \n
          = 'A':  the Jacobi rotations are applied to the MV-by-N
                  array V. In other words, the right singular vector
                  matrix V is not computed explicitly; instead it is
                  applied to an MV-by-N matrix initially stored in the
                  first MV rows of V. \n
          = 'N':  the matrix V is not computed and the array V is not
                  referenced \n
 * @param[in] M
          M is INTEGER \n
          The number of rows of the input matrix A. 1/SLAMCH('E') > M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the input matrix A.
          M >= N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the M-by-N matrix A. \n
          On exit,
          If JOBU = 'U' .OR. JOBU = 'C': \n
                 If INFO = 0: \n
                 RANKA orthonormal columns of U are returned in the
                 leading RANKA columns of the array A. Here RANKA <= N
                 is the number of computed singular values of A that are
                 above the underflow threshold SLAMCH('S'). The singular
                 vectors corresponding to underflowed or zero singular
                 values are not computed. The value of RANKA is returned
                 in the array WORK as RANKA=NINT(WORK(2)). Also see the
                 descriptions of SVA and WORK. The computed columns of U
                 are mutually numerically orthogonal up to approximately
                 TOL=SQRT(M)*EPS (default); or TOL=CTOL*EPS (JOBU = 'C'),
                 see the description of JOBU. \n
                 If INFO > 0, \n
                 the procedure GESVJ did not converge in the given number
                 of iterations (sweeps). In that case, the computed
                 columns of U may not be orthogonal up to TOL. The output
                 U (stored in A), SIGMA (given by the computed singular
                 values in SVA(1:N)) and V is still a decomposition of the
                 input matrix A in the sense that the residual
                 ||A-SCALE*U*SIGMA*V^T||_2 / ||A||_2 is small. \n
          If JOBU = 'N': \n
                 If INFO = 0: \n
                 Note that the left singular vectors are 'for free' in the
                 one-sided Jacobi SVD algorithm. However, if only the
                 singular values are needed, the level of numerical
                 orthogonality of U is not an issue and iterations are
                 stopped when the columns of the iterated matrix are
                 numerically orthogonal up to approximately M*EPS. Thus,
                 on exit, A contains the columns of U scaled with the
                 corresponding singular values. \n
                 If INFO > 0: \n
                 the procedure GESVJ did not converge in the given number
                 of iterations (sweeps). \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,M). \n
 * @param[out] SVA
          SVA is REAL array, dimension (N) \n
          On exit, \n
          If INFO = 0 : \n
          depending on the value SCALE = WORK(1), we have: \n
                 If SCALE = ONE: \n
                 SVA(1:N) contains the computed singular values of A.
                 During the computation SVA contains the Euclidean column
                 norms of the iterated matrices in the array A.
                 If SCALE .NE. ONE:
                 The singular values of A are SCALE*SVA(1:N), and this
                 factored representation is due to the fact that some of the
                 singular values of A might underflow or overflow. \n
 \n
          If INFO > 0 : \n
          the procedure GESVJ did not converge in the given number of
          iterations (sweeps) and SCALE*SVA(1:N) may not be accurate. \n
 * @param[in] MV
          MV is INTEGER \n
          If JOBV = 'A', then the product of Jacobi rotations in GESVJ
          is applied to the first MV rows of V. See the description of JOBV. \n
 * @param[in,out] V
          V is REAL array, dimension (LDV,N) \n
          If JOBV = 'V', then V contains on exit the N-by-N matrix of
                         the right singular vectors; \n
          If JOBV = 'A', then V contains the product of the computed right
                         singular vector matrix and the initial matrix in
                         the array V. \n
          If JOBV = 'N', then V is not referenced. \n
 * @param[in] LDV
          LDV is INTEGER \n
          The leading dimension of the array V, LDV >= 1. \n
          If JOBV = 'V', then LDV >= max(1,N). \n
          If JOBV = 'A', then LDV >= max(1,MV) . \n
 * @param[in,out]	CWORK	
          CWORK is COMPLEX array, dimension (max(1,LWORK)) \n
          Used as workspace. \n
          If on entry LWORK = -1, then a workspace query is assumed and
          no computation is done; CWORK(1) is set to the minial (and optimal)
          length of CWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER. \n
          Length of CWORK, LWORK >= M+N. \n
 * @param[in,out]	RWORK	
          RWORK is REAL array, dimension (max(6,LRWORK)) \n
          On entry, \n
          If JOBU = 'C' : \n
          RWORK(1) = CTOL, where CTOL defines the threshold for convergence.
                    The process stops if all columns of A are mutually
                    orthogonal up to CTOL*EPS, EPS=SLAMCH('E').
                    It is required that CTOL >= ONE, i.e. it is not
                    allowed to force the routine to obtain orthogonality
                    below EPSILON. \n
          On exit, \n
          RWORK(1) = SCALE is the scaling factor such that SCALE*SVA(1:N)
                    are the computed singular values of A.
                    (See description of SVA().) \n
          RWORK(2) = NINT(RWORK(2)) is the number of the computed nonzero
                    singular values. \n
          RWORK(3) = NINT(RWORK(3)) is the number of the computed singular
                    values that are larger than the underflow threshold. \n
          RWORK(4) = NINT(RWORK(4)) is the number of sweeps of Jacobi
                    rotations needed for numerical convergence. \n
          RWORK(5) = max_{i.NE.j} |COS(A(:,i),A(:,j))| in the last sweep.
                    This is useful information in cases when CGESVJ did
                    not converge, as it can be used to estimate whether
                    the output is still useful and for post festum analysis. \n
          RWORK(6) = the largest absolute value over all sines of the
                    Jacobi rotation angles in the last sweep. It can be
                    useful for a post festum analysis. \n
         If on entry LRWORK = -1, then a workspace query is assumed and
         no computation is done; RWORK(1) is set to the minial (and optimal)
         length of RWORK. \n
 * @param[in]	LRWORK	
         LRWORK is INTEGER \n
         Length of RWORK, LRWORK >= MAX(6,N). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, then the i-th argument had an illegal value \n
          > 0:  CGESVJ did not converge in the maximal allowed number
                (NSWEEP=30) of sweeps. The output may still be useful.
                See the description of RWORK. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer gesvj(char* joba, char* jobu, char* jobv, integer* m, integer* n, T* a, integer* lda, T* sva, integer* mv, T* v, integer* ldv, T* work, integer* lwork, integer* info)
{
  return gesvj( joba, jobu, jobv, m, n, a, lda, sva, mv, v, ldv, work, lwork, info);
}
template< typename T,typename Ta >
integer gesvj(char* joba, char* jobu, char* jobv, integer* m, integer* n, T* a, integer* lda, Ta* sva, integer* mv, T* v, integer* ldv, T* cwork, integer* lwork, Ta* rwork, integer* lrwork, integer* info)
{
  return gesvj( joba, jobu, jobv, m, n, a, lda, sva, mv, v, ldv, cwork, lwork, rwork, lrwork, info);
}

/*! @brief GESVX computes the solution to system of linear equations A * X = B for GE matrices
 * @details
 * \b Purpose:
    \verbatim
     GESVX uses the LU factorization to compute the solution to a real
     system of linear equations
        A * X = B,
     where A is an N-by-N matrix and X and B are N-by-NRHS matrices.

     Error bounds on the solution and a condition estimate are also
     provided.
    \endverbatim 

 * @param[in] FACT
          FACT is CHARACTER*1 \n
          Specifies whether or not the factored form of the matrix A is
          supplied on entry, and if not, whether the matrix A should be
          equilibrated before it is factored. \n
          = 'F':  On entry, AF and IPIV contain the factored form of A.
                  If EQUED is not 'N', the matrix A has been
                  equilibrated with scaling factors given by R and C.
                  A, AF, and IPIV are not modified. \n
          = 'N':  The matrix A will be copied to AF and factored. \n
          = 'E':  The matrix A will be equilibrated if necessary, then
                  copied to AF and factored. \n
 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          Specifies the form of the system of equations: \n
          = 'N':  A * X = B     (No transpose) \n
          = 'T':  A**T * X = B  (Transpose) \n
          = 'C':  A**H * X = B  (Transpose) \n
 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrices B and X.  NRHS >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the N-by-N matrix A.  If FACT = 'F' and EQUED is
          not 'N', then A must have been equilibrated by the scaling
          factors in R and/or C.  A is not modified if FACT = 'F' or
          'N', or if FACT = 'E' and EQUED = 'N' on exit. \n
 \n
          On exit, if EQUED .ne. 'N', A is scaled as follows: \n
          EQUED = 'R':  A := diag(R) * A \n
          EQUED = 'C':  A := A * diag(C) \n
          EQUED = 'B':  A := diag(R) * A * diag(C). \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in,out] AF
          AF is REAL array, dimension (LDAF,N) \n
          If FACT = 'F', then AF is an input argument and on entry
          contains the factors L and U from the factorization
          A = P*L*U as computed by GETRF.  If EQUED .ne. 'N', then
          AF is the factored form of the equilibrated matrix A. \n
 \n
          If FACT = 'N', then AF is an output argument and on exit
          returns the factors L and U from the factorization A = P*L*U
          of the original matrix A. \n
 \n
          If FACT = 'E', then AF is an output argument and on exit
          returns the factors L and U from the factorization A = P*L*U
          of the equilibrated matrix A (see the description of A for
          the form of the equilibrated matrix). \n
 * @param[in] LDAF
          LDAF is INTEGER \n
          The leading dimension of the array AF.  LDAF >= max(1,N). \n
 * @param[in,out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          If FACT = 'F', then IPIV is an input argument and on entry
          contains the pivot indices from the factorization A = P*L*U
          as computed by GETRF; row i of the matrix was interchanged
          with row IPIV(i). \n
 \n
          If FACT = 'N', then IPIV is an output argument and on exit
          contains the pivot indices from the factorization A = P*L*U
          of the original matrix A. \n
 \n
          If FACT = 'E', then IPIV is an output argument and on exit
          contains the pivot indices from the factorization A = P*L*U
          of the equilibrated matrix A. \n
 * @param[in,out] EQUED
          EQUED is CHARACTER*1 \n
          Specifies the form of equilibration that was done. \n
          = 'N':  No equilibration (always true if FACT = 'N'). \n
          = 'R':  Row equilibration, i.e., A has been premultiplied by
                  diag(R). \n
          = 'C':  Column equilibration, i.e., A has been postmultiplied
                  by diag(C). \n
          = 'B':  Both row and column equilibration, i.e., A has been
                  replaced by diag(R) * A * diag(C). \n
          EQUED is an input argument if FACT = 'F'; otherwise, it is an
          output argument. \n
 * @param[in,out] R
          R is REAL array, dimension (N) \n
          The row scale factors for A.  If EQUED = 'R' or 'B', A is
          multiplied on the left by diag(R); if EQUED = 'N' or 'C', R
          is not accessed.  R is an input argument if FACT = 'F';
          otherwise, R is an output argument.  If FACT = 'F' and
          EQUED = 'R' or 'B', each element of R must be positive. \n
 * @param[in,out] C
          C is REAL array, dimension (N) \n
          The column scale factors for A.  If EQUED = 'C' or 'B', A is
          multiplied on the right by diag(C); if EQUED = 'N' or 'R', C
          is not accessed.  C is an input argument if FACT = 'F';
          otherwise, C is an output argument.  If FACT = 'F' and
          EQUED = 'C' or 'B', each element of C must be positive. \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,NRHS) \n
          On entry, the N-by-NRHS right hand side matrix B. \n
          On exit, \n
          if EQUED = 'N', B is not modified; \n
          if TRANS = 'N' and EQUED = 'R' or 'B', B is overwritten by
          diag(R)*B; \n
          if TRANS = 'T' or 'C' and EQUED = 'C' or 'B', B is
          overwritten by diag(C)*B. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out] X
          X is REAL array, dimension (LDX,NRHS) \n
          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X
          to the original system of equations.  Note that A and B are
          modified on exit if EQUED .ne. 'N', and the solution to the
          equilibrated system is inv(diag(C))*X if TRANS = 'N' and
          EQUED = 'C' or 'B', or inv(diag(R))*X if TRANS = 'T' or 'C'
          and EQUED = 'R' or 'B'. \n
 * @param[in] LDX
          LDX is INTEGER \n
          The leading dimension of the array X.  LDX >= max(1,N). \n
 * @param[out] RCOND
          RCOND is REAL \n
          The estimate of the reciprocal condition number of the matrix
          A after equilibration (if done).  If RCOND is less than the
          machine precision (in particular, if RCOND = 0), the matrix
          is singular to working precision.  This condition is
          indicated by a return code of INFO > 0. \n
 * @param[out] FERR
          FERR is REAL array, dimension (NRHS) \n
          The estimated forward error bound for each solution vector
          X(j) (the j-th column of the solution matrix X).
          If XTRUE is the true solution corresponding to X(j), FERR(j)
          is an estimated upper bound for the magnitude of the largest
          element in (X(j) - XTRUE) divided by the magnitude of the
          largest element in X(j).  The estimate is as reliable as
          the estimate for RCOND, and is almost always a slight
          overestimate of the true error. \n
 * @param[out] BERR
          BERR is REAL array, dimension (NRHS) \n
          The componentwise relative backward error of each solution
          vector X(j) (i.e., the smallest relative change in
          any element of A or B that makes X(j) an exact solution). \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (2*N) \n
 * @param[out]	RWORK	
          RWORK is REAL array, dimension (2*N) \n
          On exit, RWORK(1) contains the reciprocal pivot growth
          factor norm(A)/norm(U). The "max absolute element" norm is
          used. If RWORK(1) is much less than 1, then the stability
          of the LU factorization of the (equilibrated) matrix A
          could be poor. This also means that the solution X, condition
          estimator RCOND, and forward error bound FERR could be
          unreliable. If factorization fails with 0<INFO<=N, then
          RWORK(1) contains the reciprocal pivot growth factor for the
          leading INFO columns of A. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, and i is \n
                <= N:  U(i,i) is exactly zero.  The factorization has
                       been completed, but the factor U is exactly
                       singular, so the solution and error bounds
                       could not be computed. RCOND = 0 is returned. \n
                = N+1: U is nonsingular, but RCOND is less than machine
                       precision, meaning that the matrix is singular
                       to working precision.  Nevertheless, the
                       solution and error bounds are computed because
                       there are a number of situations where the
                       computed solution can be more accurate than the
                       value of RCOND would suggest. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer gesvx(char* fact, char* trans, integer* n, integer* nrhs, T* a, integer* lda, T* af, integer* ldaf, integer* ipiv, char* equed, T* r, T* c, T* b, integer* ldb, T* x, integer* ldx, T* rcond, T* ferr, T* berr, T* work, integer* iwork, integer* info)
{
  return gesvx( fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, iwork, info);
}
template< typename T, typename Ta >
integer gesvx(char* fact, char* trans, integer* n, integer* nrhs, T* a, integer* lda, T* af, integer* ldaf, integer* ipiv, char* equed, Ta* r, Ta* c, T* b, integer* ldb, T* x, integer* ldx, Ta* rcond, Ta* ferr, Ta* berr, T* work, Ta* rwork, integer* info)
{
  return gesvx( fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, rwork, info);
}

/*! @brief GESVXX computes the solution to system of linear equations A * X = B for GE matrices

 * @details
 * \b Purpose:
    \verbatim
     GESVXX uses the LU factorization to compute the solution to a
     real system of linear equations  A * X = B,  where A is an
     N-by-N matrix and X and B are N-by-NRHS matrices.

     If requested, both normwise and maximum componentwise error bounds
     are returned. GESVXX will return a solution with a tiny
     guaranteed error (O(eps) where eps is the working machine
     precision) unless the matrix is very ill-conditioned, in which
     case a warning is returned. Relevant condition numbers also are
     calculated and returned.

     GESVXX accepts user-provided factorizations and equilibration
     factors; see the definitions of the FACT and EQUED options.
     Solving with refinement and using a factorization from a previous
     GESVXX call will also produce a solution with either O(eps)
     errors or warnings, but we cannot make that claim for general
     user-provided factorizations and equilibration factors if they
     differ from what GESVXX would itself produce.
    \endverbatim 

 * @param[in] FACT
          FACT is CHARACTER*1 \n
          Specifies whether or not the factored form of the matrix A is
          supplied on entry, and if not, whether the matrix A should be
          equilibrated before it is factored. \n
           = 'F':  On entry, AF and IPIV contain the factored form of A.
                   If EQUED is not 'N', the matrix A has been
                   equilibrated with scaling factors given by R and C.
                   A, AF, and IPIV are not modified. \n
           = 'N':  The matrix A will be copied to AF and factored. \n
           = 'E':  The matrix A will be equilibrated if necessary, then
                   copied to AF and factored. \n
 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          Specifies the form of the system of equations: \n
           = 'N':  A * X = B     (No transpose) \n
           = 'T':  A**T * X = B  (Transpose) \n
           = 'C':  A**H * X = B  (Conjugate Transpose = Transpose) \n
 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrices B and X.  NRHS >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the N-by-N matrix A.  If FACT = 'F' and EQUED is
          not 'N', then A must have been equilibrated by the scaling
          factors in R and/or C.  A is not modified if FACT = 'F' or
          'N', or if FACT = 'E' and EQUED = 'N' on exit. \n
 \n
          On exit, if EQUED .ne. 'N', A is scaled as follows: \n
          EQUED = 'R':  A := diag(R) * A \n
          EQUED = 'C':  A := A * diag(C) \n
          EQUED = 'B':  A := diag(R) * A * diag(C). \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in,out] AF
          AF is REAL array, dimension (LDAF,N) \n
          If FACT = 'F', then AF is an input argument and on entry
          contains the factors L and U from the factorization
          A = P*L*U as computed by GETRF.  If EQUED .ne. 'N', then
          AF is the factored form of the equilibrated matrix A. \n
 \n
          If FACT = 'N', then AF is an output argument and on exit
          returns the factors L and U from the factorization A = P*L*U
          of the original matrix A. \n
 \n
          If FACT = 'E', then AF is an output argument and on exit
          returns the factors L and U from the factorization A = P*L*U
          of the equilibrated matrix A (see the description of A for
          the form of the equilibrated matrix). \n
 * @param[in] LDAF
          LDAF is INTEGER \n
          The leading dimension of the array AF.  LDAF >= max(1,N). \n
 * @param[in,out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          If FACT = 'F', then IPIV is an input argument and on entry
          contains the pivot indices from the factorization A = P*L*U
          as computed by GETRF; row i of the matrix was interchanged
          with row IPIV(i). \n
 \n
          If FACT = 'N', then IPIV is an output argument and on exit
          contains the pivot indices from the factorization A = P*L*U
          of the original matrix A. \n
 \n
          If FACT = 'E', then IPIV is an output argument and on exit
          contains the pivot indices from the factorization A = P*L*U
          of the equilibrated matrix A. \n
 * @param[in,out] EQUED
          EQUED is CHARACTER*1 \n
          Specifies the form of equilibration that was done. \n
           = 'N':  No equilibration (always true if FACT = 'N'). \n
           = 'R':  Row equilibration, i.e., A has been premultiplied by
                   diag(R). \n
           = 'C':  Column equilibration, i.e., A has been postmultiplied
                   by diag(C). \n
           = 'B':  Both row and column equilibration, i.e., A has been
                   replaced by diag(R) * A * diag(C). \n
          EQUED is an input argument if FACT = 'F'; otherwise, it is an
          output argument. \n
 * @param[in,out] R
          R is REAL array, dimension (N) \n
          The row scale factors for A.  If EQUED = 'R' or 'B', A is
          multiplied on the left by diag(R); if EQUED = 'N' or 'C', R
          is not accessed.  R is an input argument if FACT = 'F';
          otherwise, R is an output argument.  If FACT = 'F' and
          EQUED = 'R' or 'B', each element of R must be positive. \n
          If R is output, each element of R is a power of the radix.
          If R is input, each element of R should be a power of the radix
          to ensure a reliable solution and error estimates. Scaling by
          powers of the radix does not cause rounding errors unless the
          result underflows or overflows. Rounding errors during scaling
          lead to refining with a matrix that is not equivalent to the
          input matrix, producing error estimates that may not be
          reliable. \n
 * @param[in,out] C
          C is REAL array, dimension (N) \n
          The column scale factors for A. If EQUED = 'C' or 'B', A is
          multiplied on the right by diag(C); if EQUED = 'N' or 'R', C
          is not accessed.  C is an input argument if FACT = 'F';
          otherwise, C is an output argument.  If FACT = 'F' and
          EQUED = 'C' or 'B', each element of C must be positive. \n
          If C is output, each element of C is a power of the radix. \n
          If C is input, each element of C should be a power of the radix
          to ensure a reliable solution and error estimates. Scaling by
          powers of the radix does not cause rounding errors unless the
          result underflows or overflows. Rounding errors during scaling
          lead to refining with a matrix that is not equivalent to the
          input matrix, producing error estimates that may not be
          reliable. \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,NRHS) \n
          On entry, the N-by-NRHS right hand side matrix B. \n
          On exit, \n
          if EQUED = 'N', B is not modified; \n
          if TRANS = 'N' and EQUED = 'R' or 'B', B is overwritten by
            diag(R)*B; \n
          if TRANS = 'T' or 'C' and EQUED = 'C' or 'B', B is
            overwritten by diag(C)*B. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out] X
          X is REAL array, dimension (LDX,NRHS) \n
          If INFO = 0, the N-by-NRHS solution matrix X to the original
          system of equations. Note that A and B are modified on exit
          if EQUED .ne. 'N', and the solution to the equilibrated system is
          inv(diag(C))*X if TRANS = 'N' and EQUED = 'C' or 'B', or
          inv(diag(R))*X if TRANS = 'T' or 'C' and EQUED = 'R' or 'B'. \n
 * @param[in] LDX
          LDX is INTEGER \n
          The leading dimension of the array X.  LDX >= max(1,N). \n
 * @param[out] RCOND
          RCOND is REAL \n
          Reciprocal scaled condition number. This is an estimate of the
          reciprocal Skeel condition number of the matrix A after
          equilibration (if done). If this is less than the machine
          precision (in particular, if it is zero), the matrix is singular
          to working precision.  Note that the error may still be small even
          if this number is very small and the matrix appears ill-
          conditioned. \n
 * @param[out] RPVGRW
          RPVGRW is REAL \n
          Reciprocal pivot growth.  On exit, this contains the reciprocal
          pivot growth factor norm(A)/norm(U). The "max absolute element"
          norm is used.  If this is much less than 1, then the stability of
          the LU factorization of the (equilibrated) matrix A could be poor. \n
          This also means that the solution X, estimated condition numbers,
          and error bounds could be unreliable. If factorization fails with
          0<INFO<=N, then this contains the reciprocal pivot growth factor
          for the leading INFO columns of A.  In GESVX, this quantity is
          returned in WORK(1). \n
 * @param[out] BERR
          BERR is REAL array, dimension (NRHS)
          Componentwise relative backward error. This is the
          componentwise relative backward error of each solution vector X(j)
          (i.e., the smallest relative change in any element of A or B that
          makes X(j) an exact solution). \n
 * @param[in] N_ERR_BNDS
          N_ERR_BNDS is INTEGER \n
          Number of error bounds to return for each right hand side
          and each type (normwise or componentwise). See ERR_BNDS_NORM and
          ERR_BNDS_COMP below. \n
 * @param[out] ERR_BNDS_NORM
          ERR_BNDS_NORM is REAL array, dimension (NRHS, N_ERR_BNDS) \n
          For each right-hand side, this array contains information about
          various error bounds and condition numbers corresponding to the
          normwise relative error, which is defined as follows: \n
 \n
          Normwise relative error in the ith solution vector: \n
                 max_j (abs(XTRUE(j,i) - X(j,i))) \n
                ------------------------------ \n
                      max_j abs(X(j,i)) \n
 \n
          The array is indexed by the type of error information as described
          below. There currently are up to three pieces of information
          returned. \n
 \n
          The first index in ERR_BNDS_NORM(i,:) corresponds to the ith
          right-hand side. \n
 \n
          The second index in ERR_BNDS_NORM(:,err) contains the following
          three fields: \n
          err = 1 "Trust/don't trust" boolean. Trust the answer if the
                  reciprocal condition number is less than the threshold
                  sqrt(n) * slamch('Epsilon'). \n
 \n
          err = 2 "Guaranteed" error bound: The estimated forward error,
                  almost certainly within a factor of 10 of the true error
                  so long as the next entry is greater than the threshold
                  sqrt(n) * slamch('Epsilon'). This error bound should only
                  be trusted if the previous boolean is true. \n
 \n
          err = 3  Reciprocal condition number: Estimated normwise
                  reciprocal condition number.  Compared with the threshold
                  sqrt(n) * slamch('Epsilon') to determine if the error
                  estimate is "guaranteed". These reciprocal condition
                  numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
                  appropriately scaled matrix Z.
                  Let Z = S*A, where S scales each row by a power of the
                  radix so all absolute row sums of Z are approximately 1. \n
 \n
          See Lapack Working Note 165 for further details and extra
          cautions. \n
 * @param[out] ERR_BNDS_COMP
          ERR_BNDS_COMP is REAL array, dimension (NRHS, N_ERR_BNDS) \n
          For each right-hand side, this array contains information about
          various error bounds and condition numbers corresponding to the
          componentwise relative error, which is defined as follows: \n
 \n
          Componentwise relative error in the ith solution vector: \n
                        abs(XTRUE(j,i) - X(j,i)) \n
                 max_j ---------------------- \n
                             abs(X(j,i)) \n
 \n
          The array is indexed by the right-hand side i (on which the
          componentwise relative error depends), and the type of error
          information as described below. There currently are up to three
          pieces of information returned for each right-hand side. If
          componentwise accuracy is not requested (PARAMS(3) = 0.0), then
          ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS < 3, then at most
          the first (:,N_ERR_BNDS) entries are returned. \n
 \n
          The first index in ERR_BNDS_COMP(i,:) corresponds to the ith
          right-hand side. \n
 \n
          The second index in ERR_BNDS_COMP(:,err) contains the following
          three fields: \n
          err = 1 "Trust/don't trust" boolean. Trust the answer if the
                  reciprocal condition number is less than the threshold
                  sqrt(n) * slamch('Epsilon'). \n
 \n
          err = 2 "Guaranteed" error bound: The estimated forward error,
                  almost certainly within a factor of 10 of the true error
                  so long as the next entry is greater than the threshold
                  sqrt(n) * slamch('Epsilon'). This error bound should only
                  be trusted if the previous boolean is true. \n
 \n
          err = 3  Reciprocal condition number: Estimated componentwise
                  reciprocal condition number.  Compared with the threshold
                  sqrt(n) * slamch('Epsilon') to determine if the error
                  estimate is "guaranteed". These reciprocal condition
                  numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
                  appropriately scaled matrix Z. \n
                  Let Z = S*(A*diag(x)), where x is the solution for the
                  current right-hand side and S scales each row of
                  A*diag(x) by a power of the radix so all absolute row
                  sums of Z are approximately 1. \n
 \n
          See Lapack Working Note 165 for further details and extra
          cautions. \n
 * @param[in] NPARAMS
          NPARAMS is INTEGER \n
          Specifies the number of parameters set in PARAMS.  If <= 0, the
          PARAMS array is never referenced and default values are used. \n
 * @param[in,out] PARAMS
          PARAMS is REAL array, dimension NPARAMS \n
          Specifies algorithm parameters.  If an entry is < 0.0, then
          that entry will be filled with default value used for that
          parameter.  Only positions up to NPARAMS are accessed; defaults
          are used for higher-numbered parameters. \n
 \n
           PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative
                refinement or not. \n
             Default: 1.0 \n
                = 0.0:  No refinement is performed, and no error bounds are
                        computed. \n
                = 1.0:  Use the double-precision refinement algorithm,
                        possibly with doubled-single computations if the
                        compilation environment does not support DOUBLE
                        PRECISION.
                  (other values are reserved for future use) \n
 \n
           PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual
                computations allowed for refinement. \n
             Default: 10 \n
             Aggressive: Set to 100 to permit convergence using approximate
                         factorizations or factorizations other than LU. If
                         the factorization uses a technique other than
                         Gaussian elimination, the guarantees in
                         err_bnds_norm and err_bnds_comp may no longer be
                         trustworthy. \n
 \n
           PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code
                will attempt to find a solution with small componentwise
                relative error in the double-precision algorithm.  Positive
                is true, 0.0 is false. \n
             Default: 1.0 (attempt componentwise convergence) \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (2*N) \n
 * @param[out]	RWORK	
          RWORK is REAL array, dimension (2*N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  Successful exit. The solution to every right-hand side is
           guaranteed. \n
          < 0:  If INFO = -i, the i-th argument had an illegal value \n
          > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization
           has been completed, but the factor U is exactly singular, so
           the solution and error bounds could not be computed. RCOND = 0
           is returned. \n
          = N+J: The solution corresponding to the Jth right-hand side is
           not guaranteed. The solutions corresponding to other right-
           hand sides K with K > J may not be guaranteed as well, but
           only the first such right-hand side is reported. If a small
           componentwise error is not requested (PARAMS(3) = 0.0) then
           the Jth right-hand side is the first with a normwise error
           bound that is not guaranteed (the smallest J such
           that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)
           the Jth right-hand side is the first with either a normwise or
           componentwise error bound that is not guaranteed (the smallest
           J such that either ERR_BNDS_NORM(J,1) = 0.0 or
           ERR_BNDS_COMP(J,1) = 0.0). See the definition of
           ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information
           about all of the right-hand sides check ERR_BNDS_NORM or
           ERR_BNDS_COMP. \n

 * @return INTEGER Return value of the function.
 * */   
template< typename T >
integer gesvxx(char* fact, char* trans, integer* n, integer* nrhs, T* a, integer* lda, T* af, integer* ldaf, integer* ipiv, char* equed, T* r, T* c, T* b, integer* ldb, T* x, integer* ldx, T* rcond, T* rpvgrw, T* berr, integer* n_err_bnds, T* err_bnds_norm, T* err_bnds_comp, integer* nparams, T* params, T* work, integer* iwork, integer* info)
{
  return gesvxx(fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info);
}
template< typename T , typename Ta >
integer gesvxx(char* fact, char* trans, integer* n, integer* nrhs, T* a, integer* lda, T* af, integer* ldaf, integer* ipiv, char* equed, Ta* r, Ta* c, T* b, integer* ldb, T* x, integer* ldx, Ta* rcond, Ta* rpvgrw, Ta* berr, integer* n_err_bnds, Ta* err_bnds_norm, Ta* err_bnds_comp, integer* nparams, Ta* params, T* work, Ta* rwork, integer* info)
{
  return gesvxx(fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info);
}

/*! @brief GETRF2 computes an LU factorization of a general M-by-N matrix A
 * @details
 * \b Purpose:
    \verbatim
    GETRF2 computes an LU factorization of a general M-by-N matrix A
    using partial pivoting with row interchanges.
    The factorization has the form
       A = P * L * U
    where P is a permutation matrix, L is lower triangular with unit
    diagonal elements (lower trapezoidal if m > n), and U is upper
    triangular (upper trapezoidal if m < n).
    This is the recursive version of the algorithm. It divides
    the matrix into four submatrices:
           [  A11 | A12  ]  where A11 is n1 by n1 and A22 is n2 by n2
       A = [ -----|----- ]  with n1 = min(m,n)/2
           [  A21 | A22  ]       n2 = n-n1
                                          [ A11 ]
    The subroutine calls itself to factor [ --- ],
                                          [ A12 ]
                    [ A12 ]
    do the swaps on [ --- ], solve A12, update A22,
                    [ A22 ]
    then calls itself to factor A22 and do the swaps on A21.
    \endverbatim

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the M-by-N matrix to be factored. \n
          On exit, the factors L and U from the factorization
          A = P*L*U; the unit diagonal elements of L are not stored. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,M). \n
 * @param[out] IPIV
          IPIV is INTEGER array, dimension (min(M,N)) \n
          The pivot indices; for 1 <= i <= min(M,N), row i of the
          matrix was interchanged with row IPIV(i). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, U(i,i) is exactly zero. The factorization
                has been completed, but the factor U is exactly
                singular, and division by zero will occur if it is used
                to solve a system of equations. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer getrf2(integer* m, integer* n, T* a, integer* lda, integer* ipiv, integer* info)
{
  return getrf2(m, n, a, lda, ipiv, info);
}

/*! @brief GETRI computes the inverse of a matrix using the LU factorization computed by GETRF
 * @details
 * \b Purpose:
    \verbatim
     GETRI computes the inverse of a matrix using the LU factorization
     computed by GETRF.

     This method inverts U and then computes inv(A) by solving the system
     inv(A)*L = inv(U) for inv(A).
    \endverbatim 

 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the factors L and U from the factorization
          A = P*L*U as computed by GETRF. \n
          On exit, if INFO = 0, the inverse of the original matrix A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          The pivot indices from GETRF; for 1<=i<=N, row i of the
          matrix was interchanged with row IPIV(i). \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO=0, then WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK.  LWORK >= max(1,N).
          For optimal performance LWORK >= N*NB, where NB is
          the optimal blocksize returned by ILAENV. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, U(i,i) is exactly zero; the matrix is
                singular and its inverse could not be computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer getri(integer* n, T* a, integer* lda, integer* ipiv, T* work, integer* lwork, integer* info)
{
  return getri(n, a, lda, ipiv, work, lwork, info);
}

/*! @brief GETRS solves a system of linear equations
 * @details
 * \b Purpose:
    \verbatim
     GETRS solves a system of linear equations
        A * X = B  or  A**T * X = B
     with a general N-by-N matrix A using the LU factorization computed
     by GETRF.
    \endverbatim
    
 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          Specifies the form of the system of equations: \n
          = 'N':  A * X = B  (No transpose) \n
          = 'T':  A**T* X = B  (Transpose) \n
          = 'C':  A**T* X = B  (Conjugate transpose = Transpose) \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          The factors L and U from the factorization A = P*L*U
          as computed by GETRF. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          The pivot indices from GETRF; for 1<=i<=N, row i of the
          matrix was interchanged with row IPIV(i). \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,NRHS) \n
          On entry, the right hand side matrix B.
          On exit, the solution matrix X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

* @return INTEGER Return value of the function.
 * */
template< typename T >
integer getrs(char* trans, integer* n, integer* nrhs,  T* a, integer* lda,  integer* ipiv, T* b, integer* ldb, integer* info)
{
  return getrs(trans, n, nrhs,  a, lda,  ipiv, b, ldb, info);
}

/*! @brief GETSLS solves overdetermined or underdetermined real linear systems
 * @details
 * \b Purpose:
    \verbatim
     GETSLS solves overdetermined or underdetermined real linear systems
     involving an M-by-N matrix A, using a tall skinny QR or short wide LQ
     factorization of A.  It is assumed that A has full rank.
     
     The following options are provided:
    
     1. If TRANS = 'N' and m >= n:  find the least squares solution of
        an overdetermined system, i.e., solve the least squares problem
                     minimize || B - A*X ||.
    
     2. If TRANS = 'N' and m < n:  find the minimum norm solution of
        an underdetermined system A * X = B.
    
     3. If TRANS = 'T' and m >= n:  find the minimum norm solution of
        an undetermined system A**T * X = B.
    
     4. If TRANS = 'T' and m < n:  find the least squares solution of
        an overdetermined system, i.e., solve the least squares problem
                     minimize || B - A**T * X ||.
    
     Several right hand side vectors b and solution vectors x can be
     handled in a single call; they are stored as the columns of the
     M-by-NRHS right hand side matrix B and the N-by-NRHS solution
     matrix X.
    \endverbatim  

  * @param[in] TRANS
           TRANS is CHARACTER*1 \n
           = 'N': the linear system involves A; \n
           = 'T': the linear system involves A**T. \n
  * @param[in] M
           M is INTEGER \n
           The number of rows of the matrix A.  M >= 0. \n
  * @param[in] N
           N is INTEGER \n
           The number of columns of the matrix A.  N >= 0. \n
  * @param[in] NRHS
           NRHS is INTEGER \n
           The number of right hand sides, i.e., the number of
           columns of the matrices B and X. NRHS >=0. \n
  * @param[in,out] A
           A is REAL array, dimension (LDA,N) \n
           On entry, the M-by-N matrix A. \n
           On exit,
           A is overwritten by details of its QR or LQ
           factorization as returned by SGEQR or SGELQ. \n
  * @param[in] LDA
           LDA is INTEGER \n
           The leading dimension of the array A.  LDA >= max(1,M). \n
  * @param[in,out] B
           B is REAL array, dimension (LDB,NRHS) \n
           On entry, the matrix B of right hand side vectors, stored
           columnwise; B is M-by-NRHS if TRANS = 'N', or N-by-NRHS
           if TRANS = 'T'. \n
           On exit, if INFO = 0, B is overwritten by the solution
           vectors, stored columnwise: \n
           if TRANS = 'N' and m >= n, rows 1 to n of B contain the least
           squares solution vectors. \n
           if TRANS = 'N' and m < n, rows 1 to N of B contain the
           minimum norm solution vectors; \n
           if TRANS = 'T' and m >= n, rows 1 to M of B contain the
           minimum norm solution vectors; \n
           if TRANS = 'T' and m < n, rows 1 to M of B contain the
           least squares solution vectors. \n
  * @param[in] LDB
           LDB is INTEGER \n
           The leading dimension of the array B. LDB >= MAX(1,M,N). \n
  * @param[out]	WORK	
          (workspace) COMPLEX array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) contains optimal (or either minimal
          or optimal, if query was assumed) LWORK.
          See LWORK for details. \n
  * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK. \n
          If LWORK = -1 or -2, then a workspace query is assumed. \n
          If LWORK = -1, the routine calculates optimal size of WORK for the
          optimal performance and returns this value in WORK(1). \n
          If LWORK = -2, the routine calculates minimal size of WORK and 
          returns this value in WORK(1). \n
  * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO =  i, the i-th diagonal element of the
                triangular factor of A is zero, so that A does not have
                full rank; the least squares solution could not be
                computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer getsls(char* trans, integer* m, integer* n, integer* nrhs, T* a, integer* lda, T* b, integer* ldb, T* work, integer* lwork, integer* info)
{
  return getsls(trans, m, n, nrhs, a, lda, b, ldb, work, lwork, info);
}

/*! @brief GGBAK forms the right or left eigenvectors of a real generalized eigenvalue problem
 * @details
 * \b Purpose:
    \verbatim
     GGBAK forms the right or left eigenvectors of a real generalized
     eigenvalue problem A*x = lambda*B*x, by backward transformation on
     the computed eigenvectors of the balanced pair of matrices output by
     GGBAL.
    \endverbatim 

 * @param[in] JOB
          JOB is CHARACTER*1 \n
          Specifies the type of backward transformation required: \n
          = 'N':  do nothing, return immediately; \n
          = 'P':  do backward transformation for permutation only; \n
          = 'S':  do backward transformation for scaling only; \n
          = 'B':  do backward transformations for both permutation and
                  scaling. \n
          JOB must be the same as the argument JOB supplied to SGGBAL. \n
 * @param[in] SIDE
          SIDE is CHARACTER*1 \n
          = 'R':  V contains right eigenvectors; \n
          = 'L':  V contains left eigenvectors. \n
 * @param[in] N
          N is INTEGER \n
          The number of rows of the matrix V.  N >= 0. \n
 * @param[in] ILO
          ILO is INTEGER \n
 * @param[in] IHI
          IHI is INTEGER \n
          The integers ILO and IHI determined by SGGBAL. \n
          1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0. \n
 * @param[in] LSCALE
          LSCALE is REAL array, dimension (N) \n
          Details of the permutations and/or scaling factors applied
          to the left side of A and B, as returned by SGGBAL. \n
 * @param[in] RSCALE
          RSCALE is REAL array, dimension (N) \n
          Details of the permutations and/or scaling factors applied
          to the right side of A and B, as returned by SGGBAL. \n
 * @param[in] M
          M is INTEGER \n
          The number of columns of the matrix V.  M >= 0. \n
 * @param[in,out] V
          V is REAL array, dimension (LDV,M) \n
          On entry, the matrix of right or left eigenvectors to be
          transformed, as returned by STGEVC. \n
          On exit, V is overwritten by the transformed eigenvectors. \n
 * @param[in] LDV
          LDV is INTEGER \n
          The leading dimension of the matrix V. LDV >= max(1,N). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer ggbak(char* job, char* side, integer* n, integer* ilo, integer* ihi,  T* lscale,  T* rscale, integer* m, T* v, integer* ldv, integer* info)
{
  return ggbak(job, side, n, ilo, ihi,  lscale,  rscale, m, v, ldv, info);
}
template< typename T , typename Ta >
integer ggbak(char* job, char* side, integer* n, integer* ilo, integer* ihi,  Ta* lscale,  Ta* rscale, integer* m, T* v, integer* ldv, integer* info)
{
  return ggbak(job, side, n, ilo, ihi,  lscale,  rscale, m, v, ldv, info);
}

/*! @brief GGBAL balances a pair of general real matrices (A,B)
 * @details
 * \b Purpose:
    \verbatim
     SGGBAL balances a pair of general real matrices (A,B).  This
     involves, first, permuting A and B by similarity transformations to
     isolate eigenvalues in the first 1 to ILO$-$1 and last IHI+1 to N
     elements on the diagonal; and second, applying a diagonal similarity
     transformation to rows and columns ILO to IHI to make the rows
     and columns as close in norm as possible. Both steps are optional.

     Balancing may reduce the 1-norm of the matrices, and improve the
     accuracy of the computed eigenvalues and/or eigenvectors in the
     generalized eigenvalue problem A*x = lambda*B*x.
    \endverbatim 

 * @param[in] JOB
          JOB is CHARACTER*1 \n
          Specifies the operations to be performed on A and B: \n
          = 'N':  none:  simply set ILO = 1, IHI = N, LSCALE(I) = 1.0
                  and RSCALE(I) = 1.0 for i = 1,...,N. \n
          = 'P':  permute only; \n
          = 'S':  scale only; \n
          = 'B':  both permute and scale. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrices A and B.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the input matrix A. \n
          On exit,  A is overwritten by the balanced matrix.
          If JOB = 'N', A is not referenced. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A. LDA >= max(1,N). \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,N) \n
          On entry, the input matrix B. \n
          On exit,  B is overwritten by the balanced matrix.
          If JOB = 'N', B is not referenced. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B. LDB >= max(1,N). \n
 * @param[out] ILO
          ILO is INTEGER \n
 * @param[out] IHI
          IHI is INTEGER \n
          ILO and IHI are set to integers such that on exit
          A(i,j) = 0 and B(i,j) = 0 if i > j and
          j = 1,...,ILO-1 or i = IHI+1,...,N.
          If JOB = 'N' or 'S', ILO = 1 and IHI = N. \n
 * @param[out] LSCALE
          LSCALE is REAL array, dimension (N) \n
          Details of the permutations and scaling factors applied
          to the left side of A and B.  If P(j) is the index of the
          row interchanged with row j, and D(j)
          is the scaling factor applied to row j, then \n
            LSCALE(j) = P(j)    for J = 1,...,ILO-1 \n
                      = D(j)    for J = ILO,...,IHI \n
                      = P(j)    for J = IHI+1,...,N. \n
          The order in which the interchanges are made is N to IHI+1,
          then 1 to ILO-1. \n
 * @param[out] RSCALE
          RSCALE is REAL array, dimension (N) \n
          Details of the permutations and scaling factors applied
          to the right side of A and B.  If P(j) is the index of the
          column interchanged with column j, and D(j)
          is the scaling factor applied to column j, then \n
            LSCALE(j) = P(j)    for J = 1,...,ILO-1 \n
                      = D(j)    for J = ILO,...,IHI \n
                      = P(j)    for J = IHI+1,...,N. \n
          The order in which the interchanges are made is N to IHI+1,
          then 1 to ILO-1. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (lwork) \n
          lwork must be at least max(1,6*N) when JOB = 'S' or 'B', and
          at least 1 when JOB = 'N' or 'P'. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer ggbal(char* job, integer* n, T* a, integer* lda, T* b, integer* ldb, integer* ilo, integer* ihi, T* lscale, T* rscale, T* work, integer* info)
{
  return ggbal(job, n, a, lda, b, ldb, ilo, ihi, lscale, rscale, work, info);
}
template< typename T , typename Ta >
integer ggbal(char* job, integer* n, T* a, integer* lda, T* b, integer* ldb, integer* ilo, integer* ihi, Ta* lscale, Ta* rscale, Ta* work, integer* info)
{
  return ggbal(job, n, a, lda, b, ldb, ilo, ihi, lscale, rscale, work, info);
}

/*! @brief GGES computes the eigenvalues, the Schur form, and, optionally, the matrix of Schur vectors for GE matrices
 * @details
 * \b Purpose:
    \verbatim
     GGES computes for a pair of N-by-N real nonsymmetric matrices (A,B),
     the generalized eigenvalues, the generalized real Schur form (S,T),
     optionally, the left and/or right matrices of Schur vectors (VSL and
     VSR). This gives the generalized Schur factorization

              (A,B) = ( (VSL)*S*(VSR)**T, (VSL)*T*(VSR)**T)

     Optionally, it also orders the eigenvalues so that a selected cluster
     of eigenvalues appears in the leading diagonal blocks of the upper
     quasi-triangular matrix S and the upper triangular matrix T.The
     leading columns of VSL and VSR then form an orthonormal basis for the
     corresponding left and right eigenspaces (deflating subspaces).

     (If only the generalized eigenvalues are needed, use the driver
     SGGEV instead, which is faster.)

     A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
     or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
     usually represented as the pair (alpha,beta), as there is a
     reasonable interpretation for beta=0 or both being zero.

     A pair of matrices (S,T) is in generalized real Schur form if T is
     upper triangular with non-negative diagonal and S is block upper
     triangular with 1-by-1 and 2-by-2 blocks.  1-by-1 blocks correspond
     to real generalized eigenvalues, while 2-by-2 blocks of S will be
     "standardized" by making the corresponding elements of T have the
     form:
             [  a  0  ]
             [  0  b  ]

     and the pair of corresponding 2-by-2 blocks in S and T will have a
     complex conjugate pair of generalized eigenvalues.
    \endverbatim

 * @param[in] JOBVSL
          JOBVSL is CHARACTER*1 \n
          = 'N':  do not compute the left Schur vectors; \n
          = 'V':  compute the left Schur vectors. \n
 * @param[in] JOBVSR
          JOBVSR is CHARACTER*1 \n
          = 'N':  do not compute the right Schur vectors; \n
          = 'V':  compute the right Schur vectors. \n
 * @param[in] SORT
          SORT is CHARACTER*1 \n
          Specifies whether or not to order the eigenvalues on the
          diagonal of the generalized Schur form. \n
          = 'N':  Eigenvalues are not ordered; \n
          = 'S':  Eigenvalues are ordered (see SELCTG); \n
 * @param[in] SELCTG
          SELCTG is a LOGICAL FUNCTION of three REAL arguments
          SELCTG must be declared EXTERNAL in the calling subroutine. \n
          If SORT = 'N', SELCTG is not referenced. \n
          If SORT = 'S', SELCTG is used to select eigenvalues to sort
          to the top left of the Schur form. \n
          An eigenvalue (ALPHAR(j)+ALPHAI(j))/BETA(j) is selected if
          SELCTG(ALPHAR(j),ALPHAI(j),BETA(j)) is true; i.e. if either
          one of a complex conjugate pair of eigenvalues is selected,
          then both complex eigenvalues are selected. \n
 \n
          Note that in the ill-conditioned case, a selected complex
          eigenvalue may no longer satisfy SELCTG(ALPHAR(j),ALPHAI(j),
          BETA(j)) = .TRUE. after ordering. INFO is to be set to N+2
          in this case. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrices A, B, VSL, and VSR.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA, N) \n
          On entry, the first of the pair of matrices. \n
          On exit, A has been overwritten by its generalized Schur
          form S. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of A.  LDA >= max(1,N). \n
 * @param[in,out] B
          B is REAL array, dimension (LDB, N) \n
          On entry, the second of the pair of matrices. \n
          On exit, B has been overwritten by its generalized Schur
          form T. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of B.  LDB >= max(1,N). \n
 * @param[out] SDIM
          SDIM is INTEGER \n
          If SORT = 'N', SDIM = 0. \n
          If SORT = 'S', SDIM = number of eigenvalues (after sorting)
          for which SELCTG is true.  (Complex conjugate pairs for which
          SELCTG is true for either eigenvalue count as 2.) \n
 * @param[out] ALPHAR
          ALPHAR is REAL array, dimension (N) \n
 * @param[out] ALPHAI
          ALPHAI is REAL array, dimension (N) \n
 * @param[out] BETA
          BETA is REAL array, dimension (N) \n
          On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will
          be the generalized eigenvalues.  ALPHAR(j) + ALPHAI(j)*i,
          and  BETA(j),j=1,...,N are the diagonals of the complex Schur
          form (S,T) that would result if the 2-by-2 diagonal blocks of
          the real Schur form of (A,B) were further reduced to
          triangular form using 2-by-2 complex unitary transformations.
          If ALPHAI(j) is zero, then the j-th eigenvalue is real; if
          positive, then the j-th and (j+1)-st eigenvalues are a
          complex conjugate pair, with ALPHAI(j+1) negative. \n
 \n
          Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
          may easily over- or underflow, and BETA(j) may even be zero.
          Thus, the user should avoid naively computing the ratio.
          However, ALPHAR and ALPHAI will be always less than and
          usually comparable with norm(A) in magnitude, and BETA always
          less than and usually comparable with norm(B). \n
 * @param[out] VSL
          VSL is REAL array, dimension (LDVSL,N) \n
          If JOBVSL = 'V', VSL will contain the left Schur vectors.
          Not referenced if JOBVSL = 'N'. \n
 * @param[in] LDVSL
          LDVSL is INTEGER \n
          The leading dimension of the matrix VSL. LDVSL >=1, and
          if JOBVSL = 'V', LDVSL >= N. \n
 * @param[out] VSR
          VSR is REAL array, dimension (LDVSR,N) \n
          If JOBVSR = 'V', VSR will contain the right Schur vectors.
          Not referenced if JOBVSR = 'N'. \n
 * @param[in] LDVSR
          LDVSR is INTEGER \n
          The leading dimension of the matrix VSR. LDVSR >= 1, and
          if JOBVSR = 'V', LDVSR >= N. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK. \n
          If N = 0, LWORK >= 1, else LWORK >= max(8*N,6*N+16).
          For good performance , LWORK must generally be larger. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	BWORK	
          BWORK is LOGICAL array, dimension (N) \n
          Not referenced if SORT = 'N'. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n
          = 1,...,N:
                The QZ iteration failed.  (A,B) are not in Schur
                form, but ALPHAR(j), ALPHAI(j), and BETA(j) should
                be correct for j=INFO+1,...,N. \n
          > N:  =N+1: other than QZ iteration failed in SHGEQZ. \n
                =N+2: after reordering, roundoff changed values of
                      some complex eigenvalues so that leading
                      eigenvalues in the Generalized Schur form no
                      longer satisfy SELCTG=.TRUE.  This could also
                      be caused due to scaling. \n
                =N+3: reordering failed in STGSEN. \n

 * @return INTEGER Return value of the function.
 * */ 
template< typename T >
integer gges(char* jobvsl, char* jobvsr, char* sort, void *selctg, integer* n, T* a, integer* lda, T* b, integer* ldb, integer* sdim, T* alphar, T* alphai, T* beta, T* vsl, integer* ldvsl, T* vsr, integer* ldvsr, T* work, integer* lwork, logical* bwork, integer* info)
{
  return gges(jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, bwork, info);
}
template< typename T, typename Ta >
integer gges(char* jobvsl, char* jobvsr, char* sort, void *selctg, integer* n, T* a, integer* lda, T* b, integer* ldb, integer* sdim, T* alpha, T* beta, T* vsl, integer* ldvsl, T* vsr, integer* ldvsr, T* work, integer* lwork, Ta* rwork, logical* bwork, integer* info)
{
  return gges(jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, rwork, bwork, info);
}

/*! @brief GGES3 computes the eigenvalues, the Schur form, and, optionally, the matrix of Schur vectors for GE matrices (blocked algorithm)
 * @details
 * \b Purpose:
    \verbatim
     GGES3 computes for a pair of N-by-N real nonsymmetric matrices (A,B),
     the generalized eigenvalues, the generalized real Schur form (S,T),
     optionally, the left and/or right matrices of Schur vectors (VSL and
     VSR). This gives the generalized Schur factorization

              (A,B) = ( (VSL)*S*(VSR)**T, (VSL)*T*(VSR)**T)

     Optionally, it also orders the eigenvalues so that a selected cluster
     of eigenvalues appears in the leading diagonal blocks of the upper
     quasi-triangular matrix S and the upper triangular matrix T.The
     leading columns of VSL and VSR then form an orthonormal basis for the
     corresponding left and right eigenspaces (deflating subspaces).

     (If only the generalized eigenvalues are needed, use the driver
     SGGEV instead, which is faster.)

     A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
     or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
     usually represented as the pair (alpha,beta), as there is a
     reasonable interpretation for beta=0 or both being zero.

     A pair of matrices (S,T) is in generalized real Schur form if T is
     upper triangular with non-negative diagonal and S is block upper
     triangular with 1-by-1 and 2-by-2 blocks.  1-by-1 blocks correspond
     to real generalized eigenvalues, while 2-by-2 blocks of S will be
     "standardized" by making the corresponding elements of T have the
     form:
             [  a  0  ]
             [  0  b  ]

     and the pair of corresponding 2-by-2 blocks in S and T will have a
     complex conjugate pair of generalized eigenvalues.
    \endverbatim

 * @param[in] JOBVSL
          JOBVSL is CHARACTER*1 \n
          = 'N':  do not compute the left Schur vectors; \n
          = 'V':  compute the left Schur vectors. \n
 * @param[in] JOBVSR
          JOBVSR is CHARACTER*1 \n
          = 'N':  do not compute the right Schur vectors; \n
          = 'V':  compute the right Schur vectors. \n
 * @param[in] SORT
          SORT is CHARACTER*1 \n
          Specifies whether or not to order the eigenvalues on the
          diagonal of the generalized Schur form. \n
          = 'N':  Eigenvalues are not ordered; \n
          = 'S':  Eigenvalues are ordered (see SELCTG); \n
 * @param[in] SELCTG
          SELCTG is a LOGICAL FUNCTION of three REAL arguments \n
          SELCTG must be declared EXTERNAL in the calling subroutine.
          If SORT = 'N', SELCTG is not referenced.
          If SORT = 'S', SELCTG is used to select eigenvalues to sort
          to the top left of the Schur form. \n
          An eigenvalue (ALPHAR(j)+ALPHAI(j))/BETA(j) is selected if
          SELCTG(ALPHAR(j),ALPHAI(j),BETA(j)) is true; i.e. if either
          one of a complex conjugate pair of eigenvalues is selected,
          then both complex eigenvalues are selected. \n
 \n
          Note that in the ill-conditioned case, a selected complex
          eigenvalue may no longer satisfy SELCTG(ALPHAR(j),ALPHAI(j),
          BETA(j)) = .TRUE. after ordering. INFO is to be set to N+2
          in this case. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrices A, B, VSL, and VSR.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA, N) \n
          On entry, the first of the pair of matrices.
          On exit, A has been overwritten by its generalized Schur
          form S. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of A.  LDA >= max(1,N). \n
 * @param[in,out] B
          B is REAL array, dimension (LDB, N) \n
          On entry, the second of the pair of matrices.
          On exit, B has been overwritten by its generalized Schur
          form T. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of B.  LDB >= max(1,N). \n
 * @param[out] SDIM
          SDIM is INTEGER \n
          If SORT = 'N', SDIM = 0. \n
          If SORT = 'S', SDIM = number of eigenvalues (after sorting)
          for which SELCTG is true.  (Complex conjugate pairs for which
          SELCTG is true for either eigenvalue count as 2.) \n
 * @param[out] ALPHAR
          ALPHAR is REAL array, dimension (N) \n
 * @param[out] ALPHAI
          ALPHAI is REAL array, dimension (N) \n
 * @param[out] BETA
          BETA is REAL array, dimension (N) \n
          On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will
          be the generalized eigenvalues.  ALPHAR(j) + ALPHAI(j)*i,
          and  BETA(j),j=1,...,N are the diagonals of the complex Schur
          form (S,T) that would result if the 2-by-2 diagonal blocks of
          the real Schur form of (A,B) were further reduced to
          triangular form using 2-by-2 complex unitary transformations.
          If ALPHAI(j) is zero, then the j-th eigenvalue is real; if
          positive, then the j-th and (j+1)-st eigenvalues are a
          complex conjugate pair, with ALPHAI(j+1) negative. \n
 \n
          Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
          may easily over- or underflow, and BETA(j) may even be zero.
          Thus, the user should avoid naively computing the ratio.
          However, ALPHAR and ALPHAI will be always less than and
          usually comparable with norm(A) in magnitude, and BETA always
          less than and usually comparable with norm(B). \n
 * @param[out] VSL
          VSL is REAL array, dimension (LDVSL,N) \n
          If JOBVSL = 'V', VSL will contain the left Schur vectors.
          Not referenced if JOBVSL = 'N'. \n
 * @param[in] LDVSL
          LDVSL is INTEGER \n
          The leading dimension of the matrix VSL. LDVSL >=1, and
          if JOBVSL = 'V', LDVSL >= N. \n
 * @param[out] VSR
          VSR is REAL array, dimension (LDVSR,N) \n
          If JOBVSR = 'V', VSR will contain the right Schur vectors.
          Not referenced if JOBVSR = 'N'. \n
 * @param[in] LDVSR
          LDVSR is INTEGER \n
          The leading dimension of the matrix VSR. LDVSR >= 1, and
          if JOBVSR = 'V', LDVSR >= N. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	BWORK	
          BWORK is LOGICAL array, dimension (N) \n
          Not referenced if SORT = 'N'. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n
          = 1,...,N: \n
                The QZ iteration failed.  (A,B) are not in Schur
                form, but ALPHAR(j), ALPHAI(j), and BETA(j) should
                be correct for j=INFO+1,...,N. \n
          > N:  =N+1: other than QZ iteration failed in SHGEQZ. \n
                =N+2: after reordering, roundoff changed values of
                      some complex eigenvalues so that leading
                      eigenvalues in the Generalized Schur form no
                      longer satisfy SELCTG=.TRUE.  This could also
                      be caused due to scaling. \n
                =N+3: reordering failed in STGSEN. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer gges3(char* jobvsl, char* jobvsr, char* sort, void *selctg, integer* n, T* a, integer* lda, T* b, integer* ldb, integer* sdim, T* alphar, T* alphai, T* beta, T* vsl, integer* ldvsl, T* vsr, integer* ldvsr, T* work, integer* lwork, logical* bwork, integer* info)
{
  return gges3(jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, bwork, info);
}
template< typename T, typename Ta >
integer gges3(char* jobvsl, char* jobvsr, char* sort, void *selctg, integer* n, T* a, integer* lda, T* b, integer* ldb, integer* sdim, T* alpha, T* beta, T* vsl, integer* ldvsl, T* vsr, integer* ldvsr, T* work, integer* lwork, Ta* rwork, logical* bwork, integer* info)
{
  return gges3(jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, rwork, bwork, info);
}

/*! @brief GGESX computes the eigenvalues, the Schur form, and, optionally, the matrix of Schur vectors for GE matrices

 * @details
 * \b Purpose:
    \verbatim
      GGESX computes for a pair of N-by-N real nonsymmetric matrices
     (A,B), the generalized eigenvalues, the real Schur form (S,T), and,
     optionally, the left and/or right matrices of Schur vectors (VSL and
     VSR).  This gives the generalized Schur factorization

          (A,B) = ( (VSL) S (VSR)**T, (VSL) T (VSR)**T)

     Optionally, it also orders the eigenvalues so that a selected cluster
     of eigenvalues appears in the leading diagonal blocks of the upper
     quasi-triangular matrix S and the upper triangular matrix T; computes
     a reciprocal condition number for the average of the selected
     eigenvalues (RCONDE); and computes a reciprocal condition number for
     the right and left deflating subspaces corresponding to the selected
     eigenvalues (RCONDV). The leading columns of VSL and VSR then form
     an orthonormal basis for the corresponding left and right eigenspaces
     (deflating subspaces).

     A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
     or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
     usually represented as the pair (alpha,beta), as there is a
     reasonable interpretation for beta=0 or for both being zero.

     A pair of matrices (S,T) is in generalized real Schur form if T is
     upper triangular with non-negative diagonal and S is block upper
     triangular with 1-by-1 and 2-by-2 blocks.  1-by-1 blocks correspond
     to real generalized eigenvalues, while 2-by-2 blocks of S will be
     "standardized" by making the corresponding elements of T have the
     form:
             [  a  0  ]
             [  0  b  ]

     and the pair of corresponding 2-by-2 blocks in S and T will have a
     complex conjugate pair of generalized eigenvalues.
    \endverbatim

 * @param[in] JOBVSL
          JOBVSL is CHARACTER*1 \n
          = 'N':  do not compute the left Schur vectors; \n
          = 'V':  compute the left Schur vectors. \n
 * @param[in] JOBVSR
          JOBVSR is CHARACTER*1 \n
          = 'N':  do not compute the right Schur vectors; \n
          = 'V':  compute the right Schur vectors. \n
 * @param[in] SORT
          SORT is CHARACTER*1 \n
          Specifies whether or not to order the eigenvalues on the
          diagonal of the generalized Schur form. \n
          = 'N':  Eigenvalues are not ordered; \n
          = 'S':  Eigenvalues are ordered (see SELCTG). \n
 * @param[in] SELCTG
          SELCTG is a LOGICAL FUNCTION of three REAL arguments \n
          SELCTG must be declared EXTERNAL in the calling subroutine. \n
          If SORT = 'N', SELCTG is not referenced. \n
          If SORT = 'S', SELCTG is used to select eigenvalues to sort
          to the top left of the Schur form. \n
          An eigenvalue (ALPHAR(j)+ALPHAI(j))/BETA(j) is selected if
          SELCTG(ALPHAR(j),ALPHAI(j),BETA(j)) is true; i.e. if either
          one of a complex conjugate pair of eigenvalues is selected,
          then both complex eigenvalues are selected. \n
          Note that a selected complex eigenvalue may no longer satisfy
          SELCTG(ALPHAR(j),ALPHAI(j),BETA(j)) = .TRUE. after ordering,
          since ordering may change the value of complex eigenvalues
          (especially if the eigenvalue is ill-conditioned), in this
          case INFO is set to N+3. \n
 * @param[in] SENSE
          SENSE is CHARACTER*1 \n
          Determines which reciprocal condition numbers are computed. \n
          = 'N':  None are computed; \n
          = 'E':  Computed for average of selected eigenvalues only; \n
          = 'V':  Computed for selected deflating subspaces only; \n
          = 'B':  Computed for both. \n
          If SENSE = 'E', 'V', or 'B', SORT must equal 'S'. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrices A, B, VSL, and VSR.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA, N) \n
          On entry, the first of the pair of matrices. \n
          On exit, A has been overwritten by its generalized Schur
          form S. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of A.  LDA >= max(1,N). \n
 * @param[in,out] B
          B is REAL array, dimension (LDB, N) \n
          On entry, the second of the pair of matrices. \n
          On exit, B has been overwritten by its generalized Schur
          form T. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of B.  LDB >= max(1,N). \n
 * @param[out] SDIM
          SDIM is INTEGER \n
          If SORT = 'N', SDIM = 0. \n
          If SORT = 'S', SDIM = number of eigenvalues (after sorting)
          for which SELCTG is true.  (Complex conjugate pairs for which
          SELCTG is true for either eigenvalue count as 2.) \n
 * @param[out] ALPHAR
          ALPHAR is REAL array, dimension (N) \n
 * @param[out] ALPHAI
          ALPHAI is REAL array, dimension (N) \n
 * @param[out] BETA
          BETA is REAL array, dimension (N) \n
          On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will
          be the generalized eigenvalues.  ALPHAR(j) + ALPHAI(j)*i
          and BETA(j),j=1,...,N  are the diagonals of the complex Schur
          form (S,T) that would result if the 2-by-2 diagonal blocks of
          the real Schur form of (A,B) were further reduced to
          triangular form using 2-by-2 complex unitary transformations.
          If ALPHAI(j) is zero, then the j-th eigenvalue is real; if
          positive, then the j-th and (j+1)-st eigenvalues are a
          complex conjugate pair, with ALPHAI(j+1) negative. \n
 \n
          Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
          may easily over- or underflow, and BETA(j) may even be zero.
          Thus, the user should avoid naively computing the ratio.
          However, ALPHAR and ALPHAI will be always less than and
          usually comparable with norm(A) in magnitude, and BETA always
          less than and usually comparable with norm(B). \n
 * @param[out] VSL
          VSL is REAL array, dimension (LDVSL,N) \n
          If JOBVSL = 'V', VSL will contain the left Schur vectors.
          Not referenced if JOBVSL = 'N'. \n
 * @param[in] LDVSL
          LDVSL is INTEGER \n
          The leading dimension of the matrix VSL. LDVSL >=1, and
          if JOBVSL = 'V', LDVSL >= N. \n
 * @param[out] VSR
          VSR is REAL array, dimension (LDVSR,N) \n
          If JOBVSR = 'V', VSR will contain the right Schur vectors.
          Not referenced if JOBVSR = 'N'. \n
 * @param[in] LDVSR
          LDVSR is INTEGER \n
          The leading dimension of the matrix VSR. LDVSR >= 1, and
          if JOBVSR = 'V', LDVSR >= N. \n
 * @param[out] RCONDE
          RCONDE is REAL array, dimension ( 2) \n
          If SENSE = 'E' or 'B', RCONDE(1) and RCONDE(2) contain the
          reciprocal condition numbers for the average of the selected
          eigenvalues.
          Not referenced if SENSE = 'N' or 'V'. \n
 * @param[out] RCONDV
          RCONDV is REAL array, dimension ( 2) \n
          If SENSE = 'V' or 'B', RCONDV(1) and RCONDV(2) contain the
          reciprocal condition numbers for the selected deflating
          subspaces.
          Not referenced if SENSE = 'N' or 'E'. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK. \n
          If N = 0, LWORK >= 1, else if SENSE = 'E', 'V', or 'B',
          LWORK >= max( 8*N, 6*N+16, 2*SDIM*(N-SDIM) ), else
          LWORK >= max( 8*N, 6*N+16 ). \n
          Note that 2*SDIM*(N-SDIM) <= N*N/2.
          Note also that an error is only returned if
          LWORK < max( 8*N, 6*N+16), but if SENSE = 'E' or 'V' or 'B'
          this may not be large enough. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the bound on the optimal size of the WORK
          array and the minimum size of the IWORK array, returns these
          values as the first entries of the WORK and IWORK arrays, and
          no error message related to LWORK or LIWORK is issued by
          XERBLA. \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (MAX(1,LIWORK)) \n
          On exit, if INFO = 0, IWORK(1) returns the minimum LIWORK. \n
 * @param[in]	LIWORK	
          LIWORK is INTEGER \n
          The dimension of the array IWORK. \n
          If SENSE = 'N' or N = 0, LIWORK >= 1, otherwise
          LIWORK >= N+6. \n
 \n
          If LIWORK = -1, then a workspace query is assumed; the
          routine only calculates the bound on the optimal size of the
          WORK array and the minimum size of the IWORK array, returns
          these values as the first entries of the WORK and IWORK
          arrays, and no error message related to LWORK or LIWORK is
          issued by XERBLA. \n
 * @param[out]	BWORK	
          BWORK is LOGICAL array, dimension (N) \n
          Not referenced if SORT = 'N'. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n
          = 1,...,N: \n
                The QZ iteration failed.  (A,B) are not in Schur
                form, but ALPHAR(j), ALPHAI(j), and BETA(j) should
                be correct for j=INFO+1,...,N. \n
          > N:  =N+1: other than QZ iteration failed in SHGEQZ \n
                =N+2: after reordering, roundoff changed values of
                      some complex eigenvalues so that leading
                      eigenvalues in the Generalized Schur form no
                      longer satisfy SELCTG=.TRUE.  This could also
                      be caused due to scaling. \n
                =N+3: reordering failed in STGSEN. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer ggesx(char* jobvsl, char* jobvsr, char* sort, void *selctg, char* sense, integer* n, T* a, integer* lda, T* b, integer* ldb, integer* sdim, T* alphar, T* alphai, T* beta, T* vsl, integer* ldvsl, T* vsr, integer* ldvsr, T* rconde, T* rcondv, T* work, integer* lwork, integer* iwork, integer* liwork, logical* bwork, integer* info)
{
  return ggesx(jobvsl, jobvsr, sort, selctg, sense, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv, work, lwork, iwork, liwork, bwork, info);
}
template< typename T , typename Ta >
integer ggesx(char* jobvsl, char* jobvsr, char* sort, void *selctg, char* sense, integer* n, T* a, integer* lda, T* b, integer* ldb, integer* sdim, T* alpha, T* beta, T* vsl, integer* ldvsl, T* vsr, integer* ldvsr, Ta* rconde, Ta* rcondv, T* work, integer* lwork, Ta* rwork, integer* iwork, integer* liwork, logical* bwork, integer* info)
{
  return ggesx(jobvsl, jobvsr, sort, selctg, sense, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv, work, lwork, rwork, iwork, liwork, bwork, info);
}

/*! @brief GGEV computes the eigenvalues and, optionally, the left and/or right eigenvectors for GE matrices
 * @details
 * \b Purpose:
    \verbatim
     GGEV computes for a pair of N-by-N real nonsymmetric matrices (A,B)
     the generalized eigenvalues, and optionally, the left and/or right
     generalized eigenvectors.
     A generalized eigenvalue for a pair of matrices (A,B) is a scalar
     lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
     singular. It is usually represented as the pair (alpha,beta), as
     there is a reasonable interpretation for beta=0, and even for both
     being zero.
     The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
     of (A,B) satisfies
                      A * v(j) = lambda(j) * B * v(j).
     The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
     of (A,B) satisfies
                      u(j)**H * A  = lambda(j) * u(j)**H * B .
     where u(j)**H is the conjugate-transpose of u(j).
    \endverbatim

 * @param[in] JOBVL
          JOBVL is CHARACTER*1 \n
          = 'N':  do not compute the left generalized eigenvectors; \n
          = 'V':  compute the left generalized eigenvectors. \n
 * @param[in] JOBVR
          JOBVR is CHARACTER*1 \n
          = 'N':  do not compute the right generalized eigenvectors; \n
          = 'V':  compute the right generalized eigenvectors. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrices A, B, VL, and VR.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA, N) \n
          On entry, the matrix A in the pair (A,B).
          On exit, A has been overwritten. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of A.  LDA >= max(1,N). \n
 * @param[in,out] B
          B is REAL array, dimension (LDB, N) \n
          On entry, the matrix B in the pair (A,B).
          On exit, B has been overwritten. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of B.  LDB >= max(1,N). \n
 * @param[out] ALPHAR
          ALPHAR is REAL array, dimension (N) \n
 * @param[out] ALPHAI
          ALPHAI is REAL array, dimension (N) \n
 * @param[out] BETA
          BETA is REAL array, dimension (N) \n
          On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will
          be the generalized eigenvalues.  If ALPHAI(j) is zero, then
          the j-th eigenvalue is real; if positive, then the j-th and
          (j+1)-st eigenvalues are a complex conjugate pair, with
          ALPHAI(j+1) negative. \n
 \n
          Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
          may easily over- or underflow, and BETA(j) may even be zero.
          Thus, the user should avoid naively computing the ratio
          alpha/beta.  However, ALPHAR and ALPHAI will be always less
          than and usually comparable with norm(A) in magnitude, and
          BETA always less than and usually comparable with norm(B). \n
 * @param[out] VL
          VL is REAL array, dimension (LDVL,N) \n
          If JOBVL = 'V', the left eigenvectors u(j) are stored one
          after another in the columns of VL, in the same order as
          their eigenvalues. If the j-th eigenvalue is real, then
          u(j) = VL(:,j), the j-th column of VL. If the j-th and
          (j+1)-th eigenvalues form a complex conjugate pair, then
          u(j) = VL(:,j)+i*VL(:,j+1) and u(j+1) = VL(:,j)-i*VL(:,j+1).
          Each eigenvector is scaled so the largest component has
          abs(real part)+abs(imag. part)=1. \n
          Not referenced if JOBVL = 'N'. \n
 * @param[in] LDVL
          LDVL is INTEGER \n
          The leading dimension of the matrix VL. LDVL >= 1, and
          if JOBVL = 'V', LDVL >= N. \n
 * @param[out] VR
          VR is REAL array, dimension (LDVR,N) \n
          If JOBVR = 'V', the right eigenvectors v(j) are stored one
          after another in the columns of VR, in the same order as
          their eigenvalues. If the j-th eigenvalue is real, then
          v(j) = VR(:,j), the j-th column of VR. If the j-th and
          (j+1)-th eigenvalues form a complex conjugate pair, then
          v(j) = VR(:,j)+i*VR(:,j+1) and v(j+1) = VR(:,j)-i*VR(:,j+1).
          Each eigenvector is scaled so the largest component has
          abs(real part)+abs(imag. part)=1. \n
          Not referenced if JOBVR = 'N'. \n
 * @param[in] LDVR
          LDVR is INTEGER \n
          The leading dimension of the matrix VR. LDVR >= 1, and
          if JOBVR = 'V', LDVR >= N. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK.  LWORK >= max(1,8*N).
          For good performance, LWORK must generally be larger. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n
          = 1,...,N: \n
                The QZ iteration failed.  No eigenvectors have been
                calculated, but ALPHAR(j), ALPHAI(j), and BETA(j)
                should be correct for j=INFO+1,...,N. \n
          > N:  =N+1: other than QZ iteration failed in SHGEQZ.
                =N+2: error return from STGEVC. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer ggev(char* jobvl, char* jobvr, integer* n, T* a, integer* lda, T* b, integer* ldb, T* alphar, T* alphai, T* beta, T* vl, integer* ldvl, T* vr, integer* ldvr, T* work, integer* lwork, integer* info)
{
  return ggev(jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, work, lwork, info);
} 
template< typename T, typename Ta >
integer ggev(char* jobvl, char* jobvr, integer* n, T* a, integer* lda, T* b, integer* ldb, T* alpha, T* beta, T* vl, integer* ldvl, T* vr, integer* ldvr, T* work, integer* lwork, Ta* rwork, integer* info)
{
  return ggev(jobvl, jobvr, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, work, lwork, rwork, info);
}

/*! @brief GGEV3 computes the eigenvalues and, optionally, the left and/or right eigenvectors for GE matrices (blocked algorithm)
 * @details
 * \b Purpose:
    \verbatim
     GGEV3 computes for a pair of N-by-N real nonsymmetric matrices (A,B)
     the generalized eigenvalues, and optionally, the left and/or right
     generalized eigenvectors.
     A generalized eigenvalue for a pair of matrices (A,B) is a scalar
     lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
     singular. It is usually represented as the pair (alpha,beta), as
     there is a reasonable interpretation for beta=0, and even for both
     being zero.
     The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
     of (A,B) satisfies
                      A * v(j) = lambda(j) * B * v(j).
     The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
     of (A,B) satisfies
                      u(j)**H * A  = lambda(j) * u(j)**H * B .
     where u(j)**H is the conjugate-transpose of u(j).
    \endverbatim

 * @param[in] JOBVL
          JOBVL is CHARACTER*1 \n
          = 'N':  do not compute the left generalized eigenvectors; \n
          = 'V':  compute the left generalized eigenvectors. \n
 * @param[in] JOBVR
          JOBVR is CHARACTER*1 \n
          = 'N':  do not compute the right generalized eigenvectors; \n
          = 'V':  compute the right generalized eigenvectors. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrices A, B, VL, and VR.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA, N) \n
          On entry, the matrix A in the pair (A,B).
          On exit, A has been overwritten. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of A.  LDA >= max(1,N). \n
 * @param[in,out] B
          B is REAL array, dimension (LDB, N) \n
          On entry, the matrix B in the pair (A,B).
          On exit, B has been overwritten. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of B.  LDB >= max(1,N). \n
 * @param[out] ALPHAR
          ALPHAR is REAL array, dimension (N) \n
 * @param[out] ALPHAI
          ALPHAI is REAL array, dimension (N) \n
 * @param[out] BETA
          BETA is REAL array, dimension (N) \n
          On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will
          be the generalized eigenvalues.  If ALPHAI(j) is zero, then
          the j-th eigenvalue is real; if positive, then the j-th and
          (j+1)-st eigenvalues are a complex conjugate pair, with
          ALPHAI(j+1) negative. \n
 \n
          Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
          may easily over- or underflow, and BETA(j) may even be zero.
          Thus, the user should avoid naively computing the ratio
          alpha/beta.  However, ALPHAR and ALPHAI will be always less
          than and usually comparable with norm(A) in magnitude, and
          BETA always less than and usually comparable with norm(B). \n
 * @param[out] VL
          VL is REAL array, dimension (LDVL,N) \n
          If JOBVL = 'V', the left eigenvectors u(j) are stored one
          after another in the columns of VL, in the same order as
          their eigenvalues. If the j-th eigenvalue is real, then
          u(j) = VL(:,j), the j-th column of VL. If the j-th and
          (j+1)-th eigenvalues form a complex conjugate pair, then
          u(j) = VL(:,j)+i*VL(:,j+1) and u(j+1) = VL(:,j)-i*VL(:,j+1).
          Each eigenvector is scaled so the largest component has
          abs(real part)+abs(imag. part)=1. \n
          Not referenced if JOBVL = 'N'. \n
 * @param[in] LDVL
          LDVL is INTEGER \n
          The leading dimension of the matrix VL. LDVL >= 1, and
          if JOBVL = 'V', LDVL >= N. \n
 * @param[out] VR
          VR is REAL array, dimension (LDVR,N) \n
          If JOBVR = 'V', the right eigenvectors v(j) are stored one
          after another in the columns of VR, in the same order as
          their eigenvalues. If the j-th eigenvalue is real, then
          v(j) = VR(:,j), the j-th column of VR. If the j-th and
          (j+1)-th eigenvalues form a complex conjugate pair, then
          v(j) = VR(:,j)+i*VR(:,j+1) and v(j+1) = VR(:,j)-i*VR(:,j+1).
          Each eigenvector is scaled so the largest component has
          abs(real part)+abs(imag. part)=1. \n
          Not referenced if JOBVR = 'N'. \n
 * @param[in] LDVR
          LDVR is INTEGER \n
          The leading dimension of the matrix VR. LDVR >= 1, and
          if JOBVR = 'V', LDVR >= N. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n
          = 1,...,N: \n
                The QZ iteration failed.  No eigenvectors have been
                calculated, but ALPHAR(j), ALPHAI(j), and BETA(j)
                should be correct for j=INFO+1,...,N. \n
          > N:  =N+1: other than QZ iteration failed in SHGEQZ. \n
                =N+2: error return from STGEVC. \n

* @return INTEGER Return value of the function.
 * */
template< typename T >
integer ggev3(char* jobvl, char* jobvr, integer* n, T* a, integer* lda, T* b, integer* ldb, T* alphar, T* alphai, T* beta, T* vl, integer* ldvl, T* vr, integer* ldvr, T* work, integer* lwork, integer* info)
{
  return ggev3( jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, work, lwork, info);
}
template< typename T, typename Ta >
integer ggev3(char* jobvl, char* jobvr, integer* n, T* a, integer* lda, T* b, integer* ldb, T* alpha, T* beta, T* vl, integer* ldvl, T* vr, integer* ldvr, T* work, integer* lwork, Ta* rwork, integer* info)
{
  return ggev3( jobvl, jobvr, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, work, lwork, rwork, info);
}

/*! @brief GGEVX computes the eigenvalues and, optionally, the left and/or right eigenvectors for GE matrices
 * @details
 * \b Purpose:
    \verbatim
     SGGEVX computes for a pair of N-by-N real nonsymmetric matrices (A,B)
     the generalized eigenvalues, and optionally, the left and/or right
     generalized eigenvectors.
     Optionally also, it computes a balancing transformation to improve
     the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
     LSCALE, RSCALE, ABNRM, and BBNRM), reciprocal condition numbers for
     the eigenvalues (RCONDE), and reciprocal condition numbers for the
     right eigenvectors (RCONDV).
     A generalized eigenvalue for a pair of matrices (A,B) is a scalar
     lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
     singular. It is usually represented as the pair (alpha,beta), as
     there is a reasonable interpretation for beta=0, and even for both
     being zero.
     The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
     of (A,B) satisfies
                      A * v(j) = lambda(j) * B * v(j) .
     The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
     of (A,B) satisfies
                      u(j)**H * A  = lambda(j) * u(j)**H * B.
     where u(j)**H is the conjugate-transpose of u(j).
    \endverbatim
 
 * @param[in] BALANC
          BALANC is CHARACTER*1 \n
          Specifies the balance option to be performed. \n
          = 'N':  do not diagonally scale or permute; \n
          = 'P':  permute only; \n
          = 'S':  scale only; \n
          = 'B':  both permute and scale. \n
          Computed reciprocal condition numbers will be for the
          matrices after permuting and/or balancing. Permuting does
          not change condition numbers (in exact arithmetic), but
          balancing does. \n
 * @param[in] JOBVL
          JOBVL is CHARACTER*1 \n
          = 'N':  do not compute the left generalized eigenvectors; \n
          = 'V':  compute the left generalized eigenvectors. \n
 * @param[in] JOBVR
          JOBVR is CHARACTER*1 \n
          = 'N':  do not compute the right generalized eigenvectors; \n
          = 'V':  compute the right generalized eigenvectors. \n
 * @param[in] SENSE
          SENSE is CHARACTER*1 \n
          Determines which reciprocal condition numbers are computed. \n
          = 'N': none are computed; \n
          = 'E': computed for eigenvalues only; \n
          = 'V': computed for eigenvectors only; \n
          = 'B': computed for eigenvalues and eigenvectors. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrices A, B, VL, and VR.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA, N) \n
          On entry, the matrix A in the pair (A,B). \n
          On exit, A has been overwritten. If JOBVL='V' or JOBVR='V'
          or both, then A contains the first part of the real Schur
          form of the "balanced" versions of the input A and B. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of A.  LDA >= max(1,N). \n
 * @param[in,out] B
          B is REAL array, dimension (LDB, N) \n
          On entry, the matrix B in the pair (A,B). \n
          On exit, B has been overwritten. If JOBVL='V' or JOBVR='V'
          or both, then B contains the second part of the real Schur
          form of the "balanced" versions of the input A and B. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of B.  LDB >= max(1,N). \n
 * @param[out] ALPHAR
          ALPHAR is REAL array, dimension (N) \n
 * @param[out] ALPHAI
          ALPHAI is REAL array, dimension (N) \n
 * @param[out] BETA
          BETA is REAL array, dimension (N) \n
          On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will
          be the generalized eigenvalues.  If ALPHAI(j) is zero, then
          the j-th eigenvalue is real; if positive, then the j-th and
          (j+1)-st eigenvalues are a complex conjugate pair, with
          ALPHAI(j+1) negative. \n
 \n
          Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
          may easily over- or underflow, and BETA(j) may even be zero.
          Thus, the user should avoid naively computing the ratio
          ALPHA/BETA. However, ALPHAR and ALPHAI will be always less
          than and usually comparable with norm(A) in magnitude, and
          BETA always less than and usually comparable with norm(B). \n
 * @param[out] VL
          VL is REAL array, dimension (LDVL,N) \n
          If JOBVL = 'V', the left eigenvectors u(j) are stored one
          after another in the columns of VL, in the same order as
          their eigenvalues. If the j-th eigenvalue is real, then
          u(j) = VL(:,j), the j-th column of VL. If the j-th and
          (j+1)-th eigenvalues form a complex conjugate pair, then
          u(j) = VL(:,j)+i*VL(:,j+1) and u(j+1) = VL(:,j)-i*VL(:,j+1).
          Each eigenvector will be scaled so the largest component have
          abs(real part) + abs(imag. part) = 1. \n
          Not referenced if JOBVL = 'N'. \n
 * @param[in] LDVL
          LDVL is INTEGER \n
          The leading dimension of the matrix VL. LDVL >= 1, and
          if JOBVL = 'V', LDVL >= N. \n
 * @param[out] VR
          VR is REAL array, dimension (LDVR,N) \n
          If JOBVR = 'V', the right eigenvectors v(j) are stored one
          after another in the columns of VR, in the same order as
          their eigenvalues. If the j-th eigenvalue is real, then
          v(j) = VR(:,j), the j-th column of VR. If the j-th and
          (j+1)-th eigenvalues form a complex conjugate pair, then
          v(j) = VR(:,j)+i*VR(:,j+1) and v(j+1) = VR(:,j)-i*VR(:,j+1).
          Each eigenvector will be scaled so the largest component have
          abs(real part) + abs(imag. part) = 1. \n
          Not referenced if JOBVR = 'N'. \n
 * @param[in] LDVR
          LDVR is INTEGER \n
          The leading dimension of the matrix VR. LDVR >= 1, and
          if JOBVR = 'V', LDVR >= N. \n
 * @param[out] ILO
          ILO is INTEGER \n
 * @param[out] IHI
          IHI is INTEGER \n
          ILO and IHI are integer values such that on exit
          A(i,j) = 0 and B(i,j) = 0 if i > j and
          j = 1,...,ILO-1 or i = IHI+1,...,N.
          If BALANC = 'N' or 'S', ILO = 1 and IHI = N. \n
 * @param[out] LSCALE
          LSCALE is REAL array, dimension (N) \n
          Details of the permutations and scaling factors applied
          to the left side of A and B.  If PL(j) is the index of the
          row interchanged with row j, and DL(j) is the scaling
          factor applied to row j, then \n
            LSCALE(j) = PL(j)  for j = 1,...,ILO-1 \n
                      = DL(j)  for j = ILO,...,IHI \n
                      = PL(j)  for j = IHI+1,...,N. \n
          The order in which the interchanges are made is N to IHI+1,
          then 1 to ILO-1. \n
 * @param[out] RSCALE
          RSCALE is REAL array, dimension (N) \n
          Details of the permutations and scaling factors applied
          to the right side of A and B.  If PR(j) is the index of the
          column interchanged with column j, and DR(j) is the scaling
          factor applied to column j, then \n
            RSCALE(j) = PR(j)  for j = 1,...,ILO-1 \n
                      = DR(j)  for j = ILO,...,IHI \n
                      = PR(j)  for j = IHI+1,...,N \n
          The order in which the interchanges are made is N to IHI+1,
          then 1 to ILO-1. \n
 * @param[out] ABNRM
          ABNRM is REAL \n
          The one-norm of the balanced matrix A. \n
 * @param[out] BBNRM
          BBNRM is REAL \n
          The one-norm of the balanced matrix B. \n
 * @param[out] RCONDE
          RCONDE is REAL array, dimension (N) \n
          If SENSE = 'E' or 'B', the reciprocal condition numbers of
          the eigenvalues, stored in consecutive elements of the array.
          For a complex conjugate pair of eigenvalues two consecutive
          elements of RCONDE are set to the same value. Thus RCONDE(j),
          RCONDV(j), and the j-th columns of VL and VR all correspond
          to the j-th eigenpair. \n
          If SENSE = 'N' or 'V', RCONDE is not referenced. \n
 * @param[out] RCONDV
          RCONDV is REAL array, dimension (N) \n
          If SENSE = 'V' or 'B', the estimated reciprocal condition
          numbers of the eigenvectors, stored in consecutive elements
          of the array. For a complex eigenvector two consecutive
          elements of RCONDV are set to the same value. If the
          eigenvalues cannot be reordered to compute RCONDV(j),
          RCONDV(j) is set to 0; this can only occur when the true
          value would be very small anyway. \n
          If SENSE = 'N' or 'E', RCONDV is not referenced. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK. LWORK >= max(1,2*N). \n
          If BALANC = 'S' or 'B', or JOBVL = 'V', or JOBVR = 'V',
          LWORK >= max(1,6*N). \n
          If SENSE = 'E', LWORK >= max(1,10*N). \n
          If SENSE = 'V' or 'B', LWORK >= 2*N*N+8*N+16. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (N+6) \n
          If SENSE = 'E', IWORK is not referenced. \n
 * @param[out]	BWORK	
          BWORK is LOGICAL array, dimension (N) \n
          If SENSE = 'N', BWORK is not referenced. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n
          = 1,...,N: \n
                The QZ iteration failed.  No eigenvectors have been
                calculated, but ALPHAR(j), ALPHAI(j), and BETA(j)
                should be correct for j=INFO+1,...,N. \n
          > N:  =N+1: other than QZ iteration failed in SHGEQZ. \n
                =N+2: error return from STGEVC. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer ggevx(char* balanc, char* jobvl, char* jobvr, char* sense, integer* n, T* a, integer* lda, T* b, integer* ldb, T* alphar, T* alphai, T* beta, T* vl, integer* ldvl, T* vr, integer* ldvr, integer* ilo, integer* ihi, T* lscale, T* rscale, T* abnrm, T* bbnrm, T* rconde, T* rcondv, T* work, integer* lwork, integer* iwork, logical* bwork, integer* info)
{
  return ggevx(balanc, jobvl, jobvr, sense, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv, work, lwork, iwork, bwork, info);
}
template< typename T , typename Ta >
integer ggevx(char* balanc, char* jobvl, char* jobvr, char* sense, integer* n, T* a, integer* lda, T* b, integer* ldb, T* alpha, T* beta, T* vl, integer* ldvl, T* vr, integer* ldvr, integer* ilo, integer* ihi, Ta* lscale, Ta* rscale, Ta* abnrm, Ta* bbnrm, Ta* rconde, Ta* rcondv, T* work, integer* lwork, Ta* rwork, integer* iwork, logical* bwork, integer* info)
{
  return ggevx(balanc, jobvl, jobvr, sense, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv, work, lwork, rwork, iwork, bwork, info);
}

/*! @brief GGGLM solves a general Gauss-Markov linear model (GLM) problem
 * @details
 * \b Purpose:
    \verbatim
     GGGLM solves a general Gauss-Markov linear model (GLM) problem:
             minimize || y ||_2   subject to   d = A*x + B*y
                 x
     where A is an N-by-M matrix, B is an N-by-P matrix, and d is a
     given N-vector. It is assumed that M <= N <= M+P, and
                rank(A) = M    and    rank( A B) = N.
     Under these assumptions, the constrained equation is always
     consistent, and there is a unique solution x and a minimal 2-norm
     solution y, which is obtained using a generalized QR factorization
     of the matrices (A, B) given by
        A = Q*(R),   B = Q*T*Z.
              (0)
     In particular, if matrix B is square nonsingular, then the problem
     GLM is equivalent to the following weighted linear least squares
     problem
                  minimize || inv(B)*(d-A*x) ||_2
                      x
     where inv(B) denotes the inverse of B.
    \endverbatim 
    
 * @param[in] N
          N is INTEGER \n
          The number of rows of the matrices A and B.  N >= 0. \n
 * @param[in] M
          M is INTEGER \n
          The number of columns of the matrix A.  0 <= M <= N. \n
 * @param[in] P
          P is INTEGER \n
          The number of columns of the matrix B.  P >= N-M. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,M) \n
          On entry, the N-by-M matrix A. \n
          On exit, the upper triangular part of the array A contains
          the M-by-M upper triangular matrix R. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A. LDA >= max(1,N). \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,P) \n
          On entry, the N-by-P matrix B. \n
          On exit, if N <= P, the upper triangle of the subarray
          B(1:N,P-N+1:P) contains the N-by-N upper triangular matrix T;
          if N > P, the elements on and above the (N-P)th subdiagonal
          contain the N-by-P upper trapezoidal matrix T. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B. LDB >= max(1,N). \n
 * @param[in,out] D
          D is REAL array, dimension (N) \n
          On entry, D is the left hand side of the GLM equation.
          On exit, D is destroyed. \n
 * @param[out] X
          X is REAL array, dimension (M) \n
 * @param[out] Y
          Y is REAL array, dimension (P) \n
          On exit, X and Y are the solutions of the GLM problem. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK. LWORK >= max(1,N+M+P).
          For optimum performance, LWORK >= M+min(N,P)+max(N,P)*NB,
          where NB is an upper bound for the optimal blocksizes for
          SGEQRF, SGERQF, SORMQR and SORMRQ. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, the i-th argument had an illegal value.
          = 1:  the upper triangular factor R associated with A in the
                generalized QR factorization of the pair (A, B) is
                singular, so that rank(A) < M; the least squares
                solution could not be computed. \n
          = 2:  the bottom (N-M) by (N-M) part of the upper trapezoidal
                factor T associated with B in the generalized QR
                factorization of the pair (A, B) is singular, so that
                rank( A B ) < N; the least squares solution could not
                be computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer ggglm(integer* n, integer* m, integer* p, T* a, integer* lda, T* b, integer* ldb, T* d, T* x, T* y, T* work, integer* lwork, integer* info)
{
  return ggglm( n, m, p, a, lda, b, ldb, d, x, y, work, lwork, info);
}

/*! @brief GGHD3 reduces a pair of real matrices (A,B) to generalized upper Hessenberg \n
    form using orthogonal transformations

 * @details
 * \b Purpose:
    \verbatim
     GGHD3 reduces a pair of real matrices (A,B) to generalized upper
     Hessenberg form using orthogonal transformations, where A is a
     general matrix and B is upper triangular.  The form of the
     generalized eigenvalue problem is
        A*x = lambda*B*x,
     and B is typically made upper triangular by computing its QR
     factorization and moving the orthogonal matrix Q to the left side
     of the equation.

     This subroutine simultaneously reduces A to a Hessenberg matrix H:
        Q**T*A*Z = H
     and transforms B to another upper triangular matrix T:
        Q**T*B*Z = T
     in order to reduce the problem to its standard form
        H*y = lambda*T*y
     where y = Z**T*x.

     The orthogonal matrices Q and Z are determined as products of Givens
     rotations.  They may either be formed explicitly, or they may be
     postmultiplied into input matrices Q1 and Z1, so that
          Q1 * A * Z1**T = (Q1*Q) * H * (Z1*Z)**T
          Q1 * B * Z1**T = (Q1*Q) * T * (Z1*Z)**T

     If Q1 is the orthogonal matrix from the QR factorization of B in the
     original equation A*x = lambda*B*x, then SGGHD3 reduces the original
     problem to generalized Hessenberg form.

     This is a blocked variant of SGGHRD, using matrix-matrix
     multiplications for parts of the computation to enhance performance.
    \endverbatim
    
 * @param[in] COMPQ
          COMPQ is CHARACTER*1 \n
          = 'N': do not compute Q; \n
          = 'I': Q is initialized to the unit matrix, and the
                 orthogonal matrix Q is returned; \n
          = 'V': Q must contain an orthogonal matrix Q1 on entry,
                 and the product Q1*Q is returned. \n
 * @param[in] COMPZ
          COMPZ is CHARACTER*1 \n
          = 'N': do not compute Z; \n
          = 'I': Z is initialized to the unit matrix, and the
                 orthogonal matrix Z is returned; \n
          = 'V': Z must contain an orthogonal matrix Z1 on entry,
                 and the product Z1*Z is returned. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrices A and B.  N >= 0. \n
 * @param[in] ILO
          ILO is INTEGER \n
 * @param[in] IHI
          IHI is INTEGER
 \n
          ILO and IHI mark the rows and columns of A which are to be
          reduced.  It is assumed that A is already upper triangular
          in rows and columns 1:ILO-1 and IHI+1:N.  ILO and IHI are
          normally set by a previous call to SGGBAL; otherwise they
          should be set to 1 and N respectively. \n
          1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA, N) \n
          On entry, the N-by-N general matrix to be reduced. \n
          On exit, the upper triangle and the first subdiagonal of A
          are overwritten with the upper Hessenberg matrix H, and the
          rest is set to zero. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in,out] B
          B is REAL array, dimension (LDB, N) \n
          On entry, the N-by-N upper triangular matrix B. \n
          On exit, the upper triangular matrix T = Q**T B Z.  The
          elements below the diagonal are set to zero. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[in,out] Q
          Q is REAL array, dimension (LDQ, N) \n
          On entry, if COMPQ = 'V', the orthogonal matrix Q1,
          typically from the QR factorization of B. \n
          On exit, if COMPQ='I', the orthogonal matrix Q, and if
          COMPQ = 'V', the product Q1*Q. \n
          Not referenced if COMPQ='N'. \n
 * @param[in] LDQ
          LDQ is INTEGER \n
          The leading dimension of the array Q. \n
          LDQ >= N if COMPQ='V' or 'I'; LDQ >= 1 otherwise. \n
 * @param[in,out] Z
          Z is REAL array, dimension (LDZ, N) \n
          On entry, if COMPZ = 'V', the orthogonal matrix Z1. \n
          On exit, if COMPZ='I', the orthogonal matrix Z, and if
          COMPZ = 'V', the product Z1*Z. \n
          Not referenced if COMPZ='N'. \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of the array Z. \n
          LDZ >= N if COMPZ='V' or 'I'; LDZ >= 1 otherwise. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (LWORK) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The length of the array WORK.  LWORK >= 1. \n
          For optimum performance LWORK >= 6*N*NB, where NB is the
          optimal blocksize. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer gghd3(char* compq, char* compz, integer* n, integer* ilo, integer* ihi, T* a, integer* lda, T* b, integer* ldb, T* q, integer* ldq, T* z, integer* ldz, T* work, integer* lwork, integer* info)
{
  return gghd3(compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz, work, lwork, info);
} 

/*! @brief GGHRD reduces a pair of real matrices (A,B) to generalized upper Hessenberg \n
    form using orthogonal transformations
 * @details
 * \b Purpose:
    \verbatim
     GGHRD reduces a pair of real matrices (A,B) to generalized upper
     Hessenberg form using orthogonal transformations, where A is a
     general matrix and B is upper triangular.  The form of the
     generalized eigenvalue problem is
        A*x = lambda*B*x,
     and B is typically made upper triangular by computing its QR
     factorization and moving the orthogonal matrix Q to the left side
     of the equation.

     This subroutine simultaneously reduces A to a Hessenberg matrix H:
        Q**T*A*Z = H
     and transforms B to another upper triangular matrix T:
        Q**T*B*Z = T
     in order to reduce the problem to its standard form
        H*y = lambda*T*y
     where y = Z**T*x.

     The orthogonal matrices Q and Z are determined as products of Givens
     rotations.  They may either be formed explicitly, or they may be
     postmultiplied into input matrices Q1 and Z1, so that
          Q1 * A * Z1**T = (Q1*Q) * H * (Z1*Z)**T
          Q1 * B * Z1**T = (Q1*Q) * T * (Z1*Z)**T

     If Q1 is the orthogonal matrix from the QR factorization of B in the
     original equation A*x = lambda*B*x, then SGGHD3 reduces the original
     problem to generalized Hessenberg form.

     This is a blocked variant of SGGHRD, using matrix-matrix
     multiplications for parts of the computation to enhance performance.
    \endverbatim
    
 * @param[in] COMPQ
          COMPQ is CHARACTER*1 \n
          = 'N': do not compute Q; \n
          = 'I': Q is initialized to the unit matrix, and the
                 orthogonal matrix Q is returned; \n
          = 'V': Q must contain an orthogonal matrix Q1 on entry,
                 and the product Q1*Q is returned. \n
 * @param[in] COMPZ
          COMPZ is CHARACTER*1 \n
          = 'N': do not compute Z; \n
          = 'I': Z is initialized to the unit matrix, and the
                 orthogonal matrix Z is returned; \n
          = 'V': Z must contain an orthogonal matrix Z1 on entry,
                 and the product Z1*Z is returned. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrices A and B.  N >= 0. \n
 * @param[in] ILO
          ILO is INTEGER \n
 * @param[in] IHI
          IHI is INTEGER \n
 \n
          ILO and IHI mark the rows and columns of A which are to be
          reduced.  It is assumed that A is already upper triangular
          in rows and columns 1:ILO-1 and IHI+1:N.  ILO and IHI are
          normally set by a previous call to SGGBAL; otherwise they
          should be set to 1 and N respectively. \n
          1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA, N) \n
          On entry, the N-by-N general matrix to be reduced. \n
          On exit, the upper triangle and the first subdiagonal of A
          are overwritten with the upper Hessenberg matrix H, and the
          rest is set to zero. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in,out] B
          B is REAL array, dimension (LDB, N) \n
          On entry, the N-by-N upper triangular matrix B. \n
          On exit, the upper triangular matrix T = Q**T B Z.  The
          elements below the diagonal are set to zero. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[in,out] Q
          Q is REAL array, dimension (LDQ, N) \n
          On entry, if COMPQ = 'V', the orthogonal matrix Q1,
          typically from the QR factorization of B. \n
          On exit, if COMPQ='I', the orthogonal matrix Q, and if
          COMPQ = 'V', the product Q1*Q.
          Not referenced if COMPQ='N'. \n
 * @param[in] LDQ
          LDQ is INTEGER \n
          The leading dimension of the array Q. \n
          LDQ >= N if COMPQ='V' or 'I'; LDQ >= 1 otherwise. \n
 * @param[in,out] Z
          Z is REAL array, dimension (LDZ, N) \n
          On entry, if COMPZ = 'V', the orthogonal matrix Z1. \n
          On exit, if COMPZ='I', the orthogonal matrix Z, and if
          COMPZ = 'V', the product Z1*Z.
          Not referenced if COMPZ='N'. \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of the array Z. \n
          LDZ >= N if COMPZ='V' or 'I'; LDZ >= 1 otherwise. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer gghrd(char* compq, char* compz, integer* n, integer* ilo, integer* ihi, T* a, integer* lda, T* b, integer* ldb, T* q, integer* ldq, T* z, integer* ldz, integer* info)
{
  return gghrd(compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz, info);
}

/*! @brief GGLSE solves overdetermined or underdetermined systems for OTHER matrices
 * @details
 * \b Purpose:
    \verbatim
     GGLSE solves the linear equality-constrained least squares (LSE)
     problem:
             minimize || c - A*x ||_2   subject to   B*x = d
     where A is an M-by-N matrix, B is a P-by-N matrix, c is a given
     M-vector, and d is a given P-vector. It is assumed that
     P <= N <= M+P, and
              rank(B) = P and  rank( (A)) = N.
                                   ( (B))
     These conditions ensure that the LSE problem has a unique solution,
     which is obtained using a generalized RQ factorization of the
     matrices (B, A) given by
        B = (0 R)*Q,   A = Z*T*Q.
    \endverbatim 

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrices A and B. N >= 0. \n
 * @param[in] P
          P is INTEGER \n
          The number of rows of the matrix B. 0 <= P <= N <= M+P. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the M-by-N matrix A. \n
          On exit, the elements on and above the diagonal of the array
          contain the min(M,N)-by-N upper trapezoidal matrix T. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A. LDA >= max(1,M). \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,N) \n
          On entry, the P-by-N matrix B. \n
          On exit, the upper triangle of the subarray B(1:P,N-P+1:N)
          contains the P-by-P upper triangular matrix R. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B. LDB >= max(1,P). \n
 * @param[in,out] C
          C is REAL array, dimension (M) \n
          On entry, C contains the right hand side vector for the
          least squares part of the LSE problem. \n
          On exit, the residual sum of squares for the solution
          is given by the sum of squares of elements N-P+1 to M of
          vector C. \n
 * @param[in,out] D
          D is REAL array, dimension (P) \n
          On entry, D contains the right hand side vector for the
          constrained equation. \n
          On exit, D is destroyed. \n
 * @param[out] X
          X is REAL array, dimension (N) \n
          On exit, X is the solution of the LSE problem. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK. LWORK >= max(1,M+N+P). \n
          For optimum performance LWORK >= P+min(M,N)+max(M,N)*NB,
          where NB is an upper bound for the optimal blocksizes for
          SGEQRF, SGERQF, SORMQR and SORMRQ. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n
          = 1:  the upper triangular factor R associated with B in the
                generalized RQ factorization of the pair (B, A) is
                singular, so that rank(B) < P; the least squares
                solution could not be computed. \n
          = 2:  the (N-P) by (N-P) part of the upper trapezoidal factor
                T associated with A in the generalized RQ factorization
                of the pair (B, A) is singular, so that
                rank( (A) ) < N; the least squares solution could not
                    ( (B) )
                be computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer gglse(integer* m, integer* n, integer* p, T* a, integer* lda, T* b, integer* ldb, T* c, T* d, T* x, T* work, integer* lwork, integer* info)
{
  return gglse( m, n, p, a, lda, b, ldb, c, d, x, work, lwork, info);
}

/*! @brief GGQRF computes a generalized QR factorization of an N-by-M matrix A and an N-by-P matrix B
 * @details
 * \b Purpose:
    \verbatim
     GGQRF computes a generalized QR factorization of an N-by-M matrix A
     and an N-by-P matrix B:
                 A = Q*R,        B = Q*T*Z,

     where Q is an N-by-N orthogonal matrix, Z is a P-by-P orthogonal
     matrix, and R and T assume one of the forms:
     if N >= M,  R = ( R11) M  ,   or if N < M,  R = ( R11  R12) N,
                     (  0 ) N-M                         N   M-N
                        M
     where R11 is upper triangular, and
     if N <= P,  T = ( 0  T12) N,   or if N > P,  T = ( T11) N-P,
                      P-N  N                           ( T21) P
                                                          P
     where T12 or T21 is upper triangular.
     In particular, if B is square and nonsingular, the GQR factorization
     of A and B implicitly gives the QR factorization of inv(B)*A:
                  inv(B)*A = Z**T*(inv(T)*R)
     where inv(B) denotes the inverse of the matrix B, and Z**T denotes the
     transpose of the matrix Z.
    \endverbatim 

 * @param[in] N
          N is INTEGER \n
          The number of rows of the matrices A and B. N >= 0. \n
 * @param[in] M
          M is INTEGER \n
          The number of columns of the matrix A.  M >= 0. \n
 * @param[in] P
          P is INTEGER \n
          The number of columns of the matrix B.  P >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,M) \n
          On entry, the N-by-M matrix A. \n
          On exit, the elements on and above the diagonal of the array
          contain the min(N,M)-by-M upper trapezoidal matrix R (R is
          upper triangular if N >= M); the elements below the diagonal,
          with the array TAUA, represent the orthogonal matrix Q as a
          product of min(N,M) elementary reflectors (see Further
          Details). \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A. LDA >= max(1,N). \n
  * @param[out] TAUA
          TAUA is REAL array, dimension (min(N,M)) \n
          The scalar factors of the elementary reflectors which
          represent the orthogonal matrix Q (see Further Details). \n
  * @param[in,out] B
          B is REAL array, dimension (LDB,P) \n
          On entry, the N-by-P matrix B. \n
          On exit, if N <= P, the upper triangle of the subarray
          B(1:N,P-N+1:P) contains the N-by-N upper triangular matrix T;
          if N > P, the elements on and above the (N-P)-th subdiagonal
          contain the N-by-P upper trapezoidal matrix T; the remaining
          elements, with the array TAUB, represent the orthogonal
          matrix Z as a product of elementary reflectors (see Further
          Details). \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B. LDB >= max(1,N). \n
 * @param[out] TAUB
          TAUB is REAL array, dimension (min(N,P)) \n
          The scalar factors of the elementary reflectors which
          represent the orthogonal matrix Z (see Further Details). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK. LWORK >= max(1,N,M,P).
          For optimum performance LWORK >= max(N,M,P)*max(NB1,NB2,NB3),
          where NB1 is the optimal blocksize for the QR factorization
          of an N-by-M matrix, NB2 is the optimal blocksize for the
          RQ factorization of an N-by-P matrix, and NB3 is the optimal
          blocksize for a call of SORMQR. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer ggqrf(integer* n, integer* m, integer* p, T* a, integer* lda, T* taua, T* b, integer* ldb, T* taub, T* work, integer* lwork, integer* info)
{
  return ggqrf(n, m, p, a, lda, taua, b, ldb, taub, work, lwork, info);
}

/*! @brief GGRQF computes a generalized RQ factorization of an M-by-N matrix A and a P-by-N matrix B
 * @details
 * \b Purpose:
    \verbatim
     GGRQF computes a generalized RQ factorization of an M-by-N matrix A
     and a P-by-N matrix B:
                 A = R*Q,        B = Z*T*Q,

     where Q is an N-by-N orthogonal matrix, Z is a P-by-P orthogonal
     matrix, and R and T assume one of the forms:
     if M <= N,  R = ( 0  R12) M,   or if M > N,  R = ( R11) M-N,
                      N-M  M                           ( R21) N
                                                          N
     where R12 or R21 is upper triangular, and
     if P >= N,  T = ( T11) N  ,   or if P < N,  T = ( T11  T12) P,
                     (  0 ) P-N                         P   N-P
                        N
     where T11 is upper triangular.
     In particular, if B is square and nonsingular, the GRQ factorization
     of A and B implicitly gives the RQ factorization of A*inv(B):
                  A*inv(B) = (R*inv(T))*Z**T
     where inv(B) denotes the inverse of the matrix B, and Z**T denotes the
     transpose of the matrix Z.
    \endverbatim 

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M >= 0. \n
 * @param[in] P
          P is INTEGER \n
          The number of rows of the matrix B.  P >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrices A and B. N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the M-by-N matrix A. \n
          On exit, if M <= N, the upper triangle of the subarray
          A(1:M,N-M+1:N) contains the M-by-M upper triangular matrix R;
          if M > N, the elements on and above the (M-N)-th subdiagonal
          contain the M-by-N upper trapezoidal matrix R; the remaining
          elements, with the array TAUA, represent the orthogonal
          matrix Q as a product of elementary reflectors (see Further
          Details). \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A. LDA >= max(1,M). \n
 * @param[out] TAUA
          TAUA is REAL array, dimension (min(M,N)) \n
          The scalar factors of the elementary reflectors which
          represent the orthogonal matrix Q (see Further Details). \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,N) \n
          On entry, the P-by-N matrix B. \n
          On exit, the elements on and above the diagonal of the array
          contain the min(P,N)-by-N upper trapezoidal matrix T (T is
          upper triangular if P >= N); the elements below the diagonal,
          with the array TAUB, represent the orthogonal matrix Z as a
          product of elementary reflectors (see Further Details). \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B. LDB >= max(1,P). \n
 * @param[out] TAUB
          TAUB is REAL array, dimension (min(P,N)) \n
          The scalar factors of the elementary reflectors which
          represent the orthogonal matrix Z (see Further Details). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK. LWORK >= max(1,N,M,P). \n
          For optimum performance LWORK >= max(N,M,P)*max(NB1,NB2,NB3),
          where NB1 is the optimal blocksize for the RQ factorization
          of an M-by-N matrix, NB2 is the optimal blocksize for the
          QR factorization of a P-by-N matrix, and NB3 is the optimal
          blocksize for a call of SORMRQ. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INF0= -i, the i-th argument had an illegal value. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer ggrqf(integer* m, integer* p, integer* n, T* a, integer* lda, T* taua, T* b, integer* ldb, T* taub, T* work, integer* lwork, integer* info)
{
  return ggrqf( m, p, n, a, lda, taua, b, ldb, taub, work, lwork, info);
}

/*! @brief GGSVD computes the singular value decomposition (SVD) for OTHER matrices
 * @details
 * \b Purpose:
    \verbatim
      This routine is deprecated and has been replaced by routine GGSVD3.
      
      GGSVD computes the generalized singular value decomposition (GSVD)
      of an M-by-N real matrix A and P-by-N real matrix B:
     
            U**T*A*Q = D1*( 0 R),    V**T*B*Q = D2*( 0 R)
     
      where U, V and Q are orthogonal matrices.
      Let K+L = the effective numerical rank of the matrix (A**T,B**T)**T,
      then R is a K+L-by-K+L nonsingular upper triangular matrix, D1 and
      D2 are M-by-(K+L) and P-by-(K+L) "diagonal" matrices and of the
      following structures, respectively:
     
      If M-K-L >= 0,
     
                          K  L
             D1 =     K ( I  0)
                      L ( 0  C)
                  M-K-L ( 0  0)
     
                        K  L
             D2 =   L ( 0  S)
                  P-L ( 0  0)
     
                      N-K-L  K    L
        ( 0 R) = K (  0   R11  R12)
                  L (  0    0   R22)
     
      where
     
        C = diag( ALPHA(K+1), ... , ALPHA(K+L)),
        S = diag( BETA(K+1),  ... , BETA(K+L)),
        C**2 + S**2 = I.
     
        R is stored in A(1:K+L,N-K-L+1:N) on exit.
     
      If M-K-L < 0,
     
                        K M-K K+L-M
             D1 =   K ( I  0    0  )
                  M-K ( 0  C    0  )
     
                          K M-K K+L-M
             D2 =   M-K ( 0  S    0 )
                  K+L-M ( 0  0    I )
                    P-L ( 0  0    0 )
     
                         N-K-L  K   M-K  K+L-M
        ( 0 R) =     K ( 0    R11  R12  R13 )
                    M-K ( 0     0   R22  R23 )
                  K+L-M ( 0     0    0   R33 )
     
      where
        C = diag( ALPHA(K+1), ... , ALPHA(M)),
        S = diag( BETA(K+1),  ... , BETA(M)),
        C**2 + S**2 = I.
        (R11 R12 R13) is stored in A(1:M, N-K-L+1:N), and R33 is stored
        ( 0  R22 R23)
        in B(M-K+1:L,N+M-K-L+1:N) on exit.
     
      The routine computes C, S, R, and optionally the orthogonal
      transformation matrices U, V and Q.
     
      In particular, if B is an N-by-N nonsingular matrix, then the GSVD of
      A and B implicitly gives the SVD of A*inv(B):
                           A*inv(B) = U*(D1*inv(D2))*V**T.
      If ( A**T,B**T)**T  has orthonormal columns, then the GSVD of A and B is
      also equal to the CS decomposition of A and B. Furthermore, the GSVD
      can be used to derive the solution of the eigenvalue problem:
                           A**T*A x = lambda* B**T*B x.
      In some literature, the GSVD of A and B is presented in the form
                       U**T*A*X = ( 0 D1),   V**T*B*X = ( 0 D2)
      where U and V are orthogonal and X is nonsingular, D1 and D2 are
      ``diagonal''.  The former GSVD form can be converted to the latter
      form by taking the nonsingular matrix X as
                           X = Q*( I   0   )
                                 ( 0 inv(R)).
    \endverbatim  

 * @param[in] JOBU
          JOBU is CHARACTER*1 \n
          = 'U':  Orthogonal matrix U is computed; \n
          = 'N':  U is not computed. \n
 * @param[in] JOBV
          JOBV is CHARACTER*1 \n
          = 'V':  Orthogonal matrix V is computed; \n
          = 'N':  V is not computed. \n
 * @param[in] JOBQ
          JOBQ is CHARACTER*1 \n
          = 'Q':  Orthogonal matrix Q is computed; \n
          = 'N':  Q is not computed. \n
 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrices A and B.  N >= 0. \n
 * @param[in] P
          P is INTEGER \n
          The number of rows of the matrix B.  P >= 0. \n
 * @param[out] K
          K is INTEGER \n
 * @param[out] L
          L is INTEGER \n
          On exit, K and L specify the dimension of the subblocks
          described in Purpose. \n
          K + L = effective numerical rank of (A**T,B**T)**T. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the M-by-N matrix A. \n
          On exit, A contains the triangular matrix R, or part of R.
          See Purpose for details. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A. LDA >= max(1,M). \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,N) \n
          On entry, the P-by-N matrix B. \n
          On exit, B contains the triangular matrix R if M-K-L < 0.
          See Purpose for details. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B. LDB >= max(1,P). \n
 * @param[out] ALPHA
          ALPHA is REAL array, dimension (N) \n
 * @param[out] BETA
          BETA is REAL array, dimension (N) \n
          On exit, ALPHA and BETA contain the generalized singular
          value pairs of A and B; \n
            ALPHA(1:K) = 1, \n
            BETA(1:K)  = 0, \n
          and if M-K-L >= 0, \n
            ALPHA(K+1:K+L) = C, \n
            BETA(K+1:K+L)  = S, \n
          or if M-K-L < 0, \n
            ALPHA(K+1:M)=C, ALPHA(M+1:K+L)=0 \n
            BETA(K+1:M) =S, BETA(M+1:K+L) =1 \n
          and \n
            ALPHA(K+L+1:N) = 0 \n
            BETA(K+L+1:N)  = 0 \n
 * @param[out] U
          U is REAL array, dimension (LDU,M) \n
          If JOBU = 'U', U contains the M-by-M orthogonal matrix U. \n
          If JOBU = 'N', U is not referenced. \n
 * @param[in] LDU
          LDU is INTEGER \n
          The leading dimension of the array U. LDU >= max(1,M) if
          JOBU = 'U'; LDU >= 1 otherwise. \n
 * @param[out] V
          V is REAL array, dimension (LDV,P) \n
          If JOBV = 'V', V contains the P-by-P orthogonal matrix V. \n
          If JOBV = 'N', V is not referenced. \n
 * @param[in] LDV
          LDV is INTEGER \n
          The leading dimension of the array V. LDV >= max(1,P) if
          JOBV = 'V'; LDV >= 1 otherwise. \n
 * @param[out] Q
          Q is REAL array, dimension (LDQ,N) \n
          If JOBQ = 'Q', Q contains the N-by-N orthogonal matrix Q. \n
          If JOBQ = 'N', Q is not referenced. \n
 * @param[in] LDQ
          LDQ is INTEGER \n
          The leading dimension of the array Q. LDQ >= max(1,N) if
          JOBQ = 'Q'; LDQ >= 1 otherwise. \n
 * @param[out]	WORK	
          WORK is REAL array,
                      dimension (max(3*N,M,P)+N) \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (N) \n
          On exit, IWORK stores the sorting information. More
          precisely, the following loop will sort ALPHA \n
             for I = K+1, min(M,K+L) \n
                 swap ALPHA(I) and ALPHA(IWORK(I)) \n
             endfor \n
          such that ALPHA(1) >= ALPHA(2) >= ... >= ALPHA(N). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n
          > 0:  if INFO = 1, the Jacobi-type procedure failed to
                converge.  For further details, see subroutine STGSJA. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer ggsvd(char* jobu, char* jobv, char* jobq, integer* m, integer* n, integer* p, integer* k, integer* l, T* a, integer* lda, T* b, integer* ldb, T* alpha, T* beta, T* u, integer* ldu, T* v, integer* ldv, T* q, integer* ldq, T* work, integer* iwork, integer* info)
{
  return ggsvd(jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, iwork, info);
}
template< typename T , typename Ta >
integer ggsvd(char* jobu, char* jobv, char* jobq, integer* m, integer* n, integer* p, integer* k, integer* l, T* a, integer* lda, T* b, integer* ldb, Ta* alpha, Ta* beta, T* u, integer* ldu, T* v, integer* ldv, T* q, integer* ldq, T* work, Ta* rwork, integer* iwork, integer* info)
{
  return ggsvd(jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, rwork, iwork, info);
}

/*! @brief GGSVD3 computes the singular value decomposition (SVD) for OTHER matrices
 * @details
 * \b Purpose:
    \verbatim
      GGSVD3 computes the generalized singular value decomposition (GSVD)
      of an M-by-N real matrix A and P-by-N real matrix B:
     
            U**T*A*Q = D1*( 0 R),    V**T*B*Q = D2*( 0 R)
     
      where U, V and Q are orthogonal matrices.
      Let K+L = the effective numerical rank of the matrix (A**T,B**T)**T,
      then R is a K+L-by-K+L nonsingular upper triangular matrix, D1 and
      D2 are M-by-(K+L) and P-by-(K+L) "diagonal" matrices and of the
      following structures, respectively:
     
      If M-K-L >= 0,
     
                          K  L
             D1 =     K ( I  0)
                      L ( 0  C)
                  M-K-L ( 0  0)
     
                        K  L
             D2 =   L ( 0  S)
                  P-L ( 0  0)
     
                      N-K-L  K    L
        ( 0 R) = K (  0   R11  R12)
                  L (  0    0   R22)
     
      where
     
        C = diag( ALPHA(K+1), ... , ALPHA(K+L)),
        S = diag( BETA(K+1),  ... , BETA(K+L)),
        C**2 + S**2 = I.
     
        R is stored in A(1:K+L,N-K-L+1:N) on exit.
     
      If M-K-L < 0,
     
                        K M-K K+L-M
             D1 =   K ( I  0    0  )
                  M-K ( 0  C    0  )
     
                          K M-K K+L-M
             D2 =   M-K ( 0  S    0 )
                  K+L-M ( 0  0    I )
                    P-L ( 0  0    0 )
     
                         N-K-L  K   M-K  K+L-M
        ( 0 R) =     K ( 0    R11  R12  R13 )
                    M-K ( 0     0   R22  R23 )
                  K+L-M ( 0     0    0   R33 )
     
      where
        C = diag( ALPHA(K+1), ... , ALPHA(M)),
        S = diag( BETA(K+1),  ... , BETA(M)),
        C**2 + S**2 = I.
        (R11 R12 R13) is stored in A(1:M, N-K-L+1:N), and R33 is stored
        ( 0  R22 R23)
        in B(M-K+1:L,N+M-K-L+1:N) on exit.
     
      The routine computes C, S, R, and optionally the orthogonal
      transformation matrices U, V and Q.
     
      In particular, if B is an N-by-N nonsingular matrix, then the GSVD of
      A and B implicitly gives the SVD of A*inv(B):
                           A*inv(B) = U*(D1*inv(D2))*V**T.
      If ( A**T,B**T)**T  has orthonormal columns, then the GSVD of A and B is
      also equal to the CS decomposition of A and B. Furthermore, the GSVD
      can be used to derive the solution of the eigenvalue problem:
                           A**T*A x = lambda* B**T*B x.
      In some literature, the GSVD of A and B is presented in the form
                       U**T*A*X = ( 0 D1),   V**T*B*X = ( 0 D2)
      where U and V are orthogonal and X is nonsingular, D1 and D2 are
      ``diagonal''.  The former GSVD form can be converted to the latter
      form by taking the nonsingular matrix X as
                           X = Q*( I   0   )
                                 ( 0 inv(R)).
    \endverbatim  

 * @param[in] JOBU
          JOBU is CHARACTER*1 \n
          = 'U':  Orthogonal matrix U is computed; \n
          = 'N':  U is not computed. \n
 * @param[in] JOBV
          JOBV is CHARACTER*1 \n
          = 'V':  Orthogonal matrix V is computed; \n
          = 'N':  V is not computed. \n
 * @param[in] JOBQ
          JOBQ is CHARACTER*1 \n
          = 'Q':  Orthogonal matrix Q is computed; \n
          = 'N':  Q is not computed. \n
 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrices A and B.  N >= 0. \n
 * @param[in] P
          P is INTEGER \n
          The number of rows of the matrix B.  P >= 0. \n
 * @param[out] K
          K is INTEGER \n
 * @param[out] L
          L is INTEGER \n
          On exit, K and L specify the dimension of the subblocks
          described in Purpose.
          K + L = effective numerical rank of (A**T,B**T)**T. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the M-by-N matrix A. \n
          On exit, A contains the triangular matrix R, or part of R.
          See Purpose for details. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A. LDA >= max(1,M). \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,N) \n
          On entry, the P-by-N matrix B. \n
          On exit, B contains the triangular matrix R if M-K-L < 0.
          See Purpose for details. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B. LDB >= max(1,P). \n
 * @param[out] ALPHA
          ALPHA is REAL array, dimension (N) \n
 * @param[out] BETA
          BETA is REAL array, dimension (N) \n
          On exit, ALPHA and BETA contain the generalized singular
          value pairs of A and B; \n
            ALPHA(1:K) = 1, \n
            BETA(1:K)  = 0, \n
          and if M-K-L >= 0, \n
            ALPHA(K+1:K+L) = C, \n
            BETA(K+1:K+L)  = S, \n
          or if M-K-L < 0, \n
            ALPHA(K+1:M)=C, ALPHA(M+1:K+L)=0 \n
            BETA(K+1:M) =S, BETA(M+1:K+L) =1 \n
          and \n
            ALPHA(K+L+1:N) = 0 \n
            BETA(K+L+1:N)  = 0 \n
 * @param[out] U
          U is REAL array, dimension (LDU,M) \n
          If JOBU = 'U', U contains the M-by-M orthogonal matrix U. \n
          If JOBU = 'N', U is not referenced. \n
 * @param[in] LDU
          LDU is INTEGER \n
          The leading dimension of the array U. LDU >= max(1,M) if
          JOBU = 'U'; LDU >= 1 otherwise. \n
 * @param[out] V
          V is REAL array, dimension (LDV,P) \n
          If JOBV = 'V', V contains the P-by-P orthogonal matrix V. \n
          If JOBV = 'N', V is not referenced. \n
 * @param[in] LDV
          LDV is INTEGER \n
          The leading dimension of the array V. LDV >= max(1,P) if
          JOBV = 'V'; LDV >= 1 otherwise. \n
 * @param[out] Q
          Q is REAL array, dimension (LDQ,N) \n
          If JOBQ = 'Q', Q contains the N-by-N orthogonal matrix Q. \n
          If JOBQ = 'N', Q is not referenced. \n
 * @param[in] LDQ
          LDQ is INTEGER \n
          The leading dimension of the array Q. LDQ >= max(1,N) if
          JOBQ = 'Q'; LDQ >= 1 otherwise. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (N) \n
          On exit, IWORK stores the sorting information. More
          precisely, the following loop will sort ALPHA \n
             for I = K+1, min(M,K+L) \n
                 swap ALPHA(I) and ALPHA(IWORK(I)) \n
             endfor \n
          such that ALPHA(1) >= ALPHA(2) >= ... >= ALPHA(N). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n
          > 0:  if INFO = 1, the Jacobi-type procedure failed to
                converge.  For further details, see subroutine STGSJA. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer ggsvd3(char* jobu, char* jobv, char* jobq, integer* m, integer* n, integer* p, integer* k, integer* l, T* a, integer* lda, T* b, integer* ldb, T* alpha, T* beta, T* u, integer* ldu, T* v, integer* ldv, T* q, integer* ldq, T* work, integer* lwork, integer* iwork, integer* info)
{
  return ggsvd3(jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, lwork, iwork, info);
}
template< typename T, typename Ta >
integer ggsvd3(char* jobu, char* jobv, char* jobq, integer* m, integer* n, integer* p, integer* k, integer* l, T* a, integer* lda, T* b, integer* ldb, Ta* alpha, Ta* beta, T* u, integer* ldu, T* v, integer* ldv, T* q, integer* ldq, T* work, integer* lwork, Ta* rwork, integer* iwork, integer* info)
{
  return ggsvd3(jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, lwork, rwork, iwork, info);
}

/*! @brief GGSVP computes orthogonal matrices U, V and Q
 * @details
 * \b Purpose:
    \verbatim
     This routine is deprecated and has been replaced by routine GGSVP3.
    
     GGSVP computes orthogonal matrices U, V and Q such that
    
                        N-K-L  K    L
      U**T*A*Q =     K ( 0    A12  A13)  if M-K-L >= 0;
                     L ( 0     0   A23)
                 M-K-L ( 0     0    0 )
    
                      N-K-L  K    L
             =     K ( 0    A12  A13)  if M-K-L < 0;
                 M-K ( 0     0   A23)
    
                      N-K-L  K    L
      V**T*B*Q =   L ( 0     0   B13)
                 P-L ( 0     0    0 )
    
     where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
     upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,
     otherwise A23 is (M-K)-by-L upper trapezoidal.  K+L = the effective
     numerical rank of the (M+P)-by-N matrix (A**T,B**T)**T.
    
     This decomposition is the preprocessing step for computing the
     Generalized Singular Value Decomposition (GSVD), see subroutine
     SGGSVD.
    \endverbatim  

 * @param[in] JOBU
          JOBU is CHARACTER*1 \n
          = 'U':  Orthogonal matrix U is computed; \n
          = 'N':  U is not computed. \n
 * @param[in] JOBV
          JOBV is CHARACTER*1 \n
          = 'V':  Orthogonal matrix V is computed; \n
          = 'N':  V is not computed. \n
 * @param[in] JOBQ
          JOBQ is CHARACTER*1 \n
          = 'Q':  Orthogonal matrix Q is computed; \n
          = 'N':  Q is not computed. \n
 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M >= 0. \n
 * @param[in] P
          P is INTEGER \n
          The number of rows of the matrix B.  P >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrices A and B.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the M-by-N matrix A. \n
          On exit, A contains the triangular (or trapezoidal) matrix
          described in the Purpose section. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A. LDA >= max(1,M). \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,N) \n
          On entry, the P-by-N matrix B. \n
          On exit, B contains the triangular matrix described in
          the Purpose section. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B. LDB >= max(1,P). \n
 * @param[in] TOLA
          TOLA is REAL \n
 * @param[in] TOLB
          TOLB is REAL \n
          TOLA and TOLB are the thresholds to determine the effective
          numerical rank of matrix B and a subblock of A. Generally,
          they are set to \n
             TOLA = MAX(M,N)*norm(A)*MACHEPS, \n
             TOLB = MAX(P,N)*norm(B)*MACHEPS. \n
          The size of TOLA and TOLB may affect the size of backward
          errors of the decomposition. \n
 * @param[out] K
          K is INTEGER \n
 * @param[out] L
          L is INTEGER \n
          On exit, K and L specify the dimension of the subblocks
          described in Purpose section. \n
          K + L = effective numerical rank of (A**T,B**T)**T. \n
 * @param[out] U
          U is REAL array, dimension (LDU,M) \n
          If JOBU = 'U', U contains the orthogonal matrix U. \n
          If JOBU = 'N', U is not referenced. \n
 * @param[in] LDU
          LDU is INTEGER \n
          The leading dimension of the array U. LDU >= max(1,M) if
          JOBU = 'U'; LDU >= 1 otherwise. \n
 * @param[out] V
          V is REAL array, dimension (LDV,P) \n
          If JOBV = 'V', V contains the orthogonal matrix V. \n
          If JOBV = 'N', V is not referenced. \n
 * @param[in] LDV
          LDV is INTEGER \n
          The leading dimension of the array V. LDV >= max(1,P) if
          JOBV = 'V'; LDV >= 1 otherwise. \n
 * @param[out] Q
          Q is REAL array, dimension (LDQ,N) \n
          If JOBQ = 'Q', Q contains the orthogonal matrix Q. \n
          If JOBQ = 'N', Q is not referenced. \n
 * @param[in] LDQ
          LDQ is INTEGER \n
          The leading dimension of the array Q. LDQ >= max(1,N) if
          JOBQ = 'Q'; LDQ >= 1 otherwise. \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (N) \n
 * @param[out]	TAU	
          TAU is REAL array, dimension (N) \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (max(3*N,M,P)) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer ggsvp(char* jobu, char* jobv, char* jobq, integer* m, integer* p, integer* n, T* a, integer* lda, T* b, integer* ldb, T* tola, T* tolb, integer* k, integer* l, T* u, integer* ldu, T* v, integer* ldv, T* q, integer* ldq, integer* iwork, T* tau, T* work, integer* info)
{
  return ggsvp(jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, tau, work, info);
}
template< typename T, typename Ta >
integer ggsvp(char* jobu, char* jobv, char* jobq, integer* m, integer* p, integer* n, T* a, integer* lda, T* b, integer* ldb, Ta* tola, Ta* tolb, integer* k, integer* l, T* u, integer* ldu, T* v, integer* ldv, T* q, integer* ldq, integer* iwork, Ta* rwork, T* tau, T* work, integer* info)
{
  return ggsvp(jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, rwork, tau, work, info);
}

/*! @brief GGSVP3 computes orthogonal matrices U, V and Q
 * @details
 * \b Purpose:
    \verbatim
     GGSVP3 computes orthogonal matrices U, V and Q such that
    
                        N-K-L  K    L
      U**T*A*Q =     K ( 0    A12  A13)  if M-K-L >= 0;
                     L ( 0     0   A23)
                 M-K-L ( 0     0    0 )
    
                      N-K-L  K    L
             =     K ( 0    A12  A13)  if M-K-L < 0;
                 M-K ( 0     0   A23)
    
                      N-K-L  K    L
      V**T*B*Q =   L ( 0     0   B13)
                 P-L ( 0     0    0 )
    
     where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
     upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,
     otherwise A23 is (M-K)-by-L upper trapezoidal.  K+L = the effective
     numerical rank of the (M+P)-by-N matrix (A**T,B**T)**T.
    
     This decomposition is the preprocessing step for computing the
     Generalized Singular Value Decomposition (GSVD), see subroutine
     SGGSVD.
    \endverbatim  

 * @param[in] JOBU
          JOBU is CHARACTER*1 \n
          = 'U':  Orthogonal matrix U is computed; \n
          = 'N':  U is not computed. \n
 * @param[in] JOBV
          JOBV is CHARACTER*1 \n
          = 'V':  Orthogonal matrix V is computed; \n
          = 'N':  V is not computed. \n
 * @param[in] JOBQ
          JOBQ is CHARACTER*1 \n
          = 'Q':  Orthogonal matrix Q is computed; \n
          = 'N':  Q is not computed. \n
 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M >= 0. \n
 * @param[in] P
          P is INTEGER \n
          The number of rows of the matrix B.  P >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrices A and B.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the M-by-N matrix A. \n
          On exit, A contains the triangular (or trapezoidal) matrix
          described in the Purpose section. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A. LDA >= max(1,M). \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,N) \n
          On entry, the P-by-N matrix B. \n
          On exit, B contains the triangular matrix described in
          the Purpose section. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B. LDB >= max(1,P). \n
 * @param[in] TOLA
          TOLA is REAL \n
 * @param[in] TOLB
          TOLB is REAL \n
          TOLA and TOLB are the thresholds to determine the effective
          numerical rank of matrix B and a subblock of A. Generally,
          they are set to \n
             TOLA = MAX(M,N)*norm(A)*MACHEPS, \n
             TOLB = MAX(P,N)*norm(B)*MACHEPS. \n
          The size of TOLA and TOLB may affect the size of backward
          errors of the decomposition. \n
 * @param[out] K
          K is INTEGER \n
 * @param[out] L
          L is INTEGER \n
          On exit, K and L specify the dimension of the subblocks
          described in Purpose section. \n
          K + L = effective numerical rank of (A**T,B**T)**T. \n
 * @param[out] U
          U is REAL array, dimension (LDU,M) \n
          If JOBU = 'U', U contains the orthogonal matrix U. \n
          If JOBU = 'N', U is not referenced. \n
 * @param[in] LDU
          LDU is INTEGER \n
          The leading dimension of the array U. LDU >= max(1,M) if
          JOBU = 'U'; LDU >= 1 otherwise. \n
 * @param[out] V
          V is REAL array, dimension (LDV,P) \n
          If JOBV = 'V', V contains the orthogonal matrix V. \n
          If JOBV = 'N', V is not referenced. \n
 * @param[in] LDV
          LDV is INTEGER \n
          The leading dimension of the array V. LDV >= max(1,P) if
          JOBV = 'V'; LDV >= 1 otherwise. \n
 * @param[out] Q
          Q is REAL array, dimension (LDQ,N) \n
          If JOBQ = 'Q', Q contains the orthogonal matrix Q. \n
          If JOBQ = 'N', Q is not referenced. \n
 * @param[in] LDQ
          LDQ is INTEGER \n
          The leading dimension of the array Q. LDQ >= max(1,N) if
          JOBQ = 'Q'; LDQ >= 1 otherwise. \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (N) \n
 * @param[out]	TAU	
          TAU is REAL array, dimension (N) \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer ggsvp3(char* jobu, char* jobv, char* jobq, integer* m, integer* p, integer* n, T* a, integer* lda, T* b, integer* ldb, T* tola, T* tolb, integer* k, integer* l, T* u, integer* ldu, T* v, integer* ldv, T* q, integer* ldq, integer* iwork, T* tau, T* work, integer* lwork, integer* info)
{
  return ggsvp3(jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, tau, work, lwork, info);
} 
template< typename T, typename Ta >
integer ggsvp3(char* jobu, char* jobv, char* jobq, integer* m, integer* p, integer* n, T* a, integer* lda, T* b, integer* ldb, Ta* tola, Ta* tolb, integer* k, integer* l, T* u, integer* ldu, T* v, integer* ldv, T* q, integer* ldq, integer* iwork, Ta* rwork, T* tau, T* work, integer* lwork, integer* info)
{
  return ggsvp3(jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, rwork, tau, work, lwork, info);
}

/*! @brief GTCON estimates the reciprocal of the condition number of a real tridiagonal matrix A
 * @details
 * \b Purpose:
    \verbatim
     GTCON estimates the reciprocal of the condition number of a real
     tridiagonal matrix A using the LU factorization as computed by
     SGTTRF.

     An estimate is obtained for norm(inv(A)), and the reciprocal of the
     condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
    \endverbatim 

 * @param[in] NORM
          NORM is CHARACTER*1 \n
          Specifies whether the 1-norm condition number or the
          infinity-norm condition number is required: \n
          = '1' or 'O':  1-norm; \n
          = 'I':         Infinity-norm. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] DL
          DL is REAL array, dimension (N-1) \n
          The (n-1) multipliers that define the matrix L from the
          LU factorization of A as computed by SGTTRF. \n
 * @param[in] D
          D is REAL array, dimension (N) \n
          The n diagonal elements of the upper triangular matrix U from
          the LU factorization of A. \n
 * @param[in] DU
          DU is REAL array, dimension (N-1) \n
          The (n-1) elements of the first superdiagonal of U. \n
 * @param[in] DU2
          DU2 is REAL array, dimension (N-2) \n
          The (n-2) elements of the second superdiagonal of U. \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          The pivot indices; for 1 <= i <= n, row i of the matrix was
          interchanged with row IPIV(i).  IPIV(i) will always be either
          i or i+1; IPIV(i) = i indicates a row interchange was not
          required. \n
 * @param[in] ANORM
          ANORM is REAL \n
          If NORM = '1' or 'O', the 1-norm of the original matrix A. \n
          If NORM = 'I', the infinity-norm of the original matrix A. \n
 * @param[out] RCOND
          RCOND is REAL \n
          The reciprocal of the condition number of the matrix A,
          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
          estimate of the 1-norm of inv(A) computed in this routine. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (2*N) \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

* @return INTEGER Return value of the function.
 * */
template< typename T >
integer gtcon(char* norm, integer* n,  T* dl,  T* d,  T* du,  T* du2,  integer* ipiv, T* anorm, T* rcond, T* work, integer* iwork, integer* info)
{
  return gtcon(norm, n,  dl,  d,  du,  du2,  ipiv, anorm, rcond, work, iwork, info);
}
template< typename T, typename Ta >
integer gtcon(char* norm, integer* n,  T* dl,  T* d,  T* du,  T* du2, integer* ipiv, Ta* anorm, Ta* rcond, T* work, integer* info)
{
  return gtcon(norm, n,  dl,  d,  du,  du2,  ipiv, anorm, rcond, work, info);
}

/*! @brief GTRFS improves the computed solution to a system of linear equations

 * @details
 * \b Purpose:
    \verbatim
     GTRFS improves the computed solution to a system of linear
     equations when the coefficient matrix is tridiagonal, and provides
     error bounds and backward error estimates for the solution.
    \endverbatim 

 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          Specifies the form of the system of equations: \n
          = 'N':  A * X = B     (No transpose) \n
          = 'T':  A**T * X = B  (Transpose) \n
          = 'C':  A**H * X = B  (Conjugate transpose = Transpose) \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in] DL
          DL is REAL array, dimension (N-1) \n
          The (n-1) subdiagonal elements of A. \n
 * @param[in] D
          D is REAL array, dimension (N) \n
          The diagonal elements of A. \n
 * @param[in] DU
          DU is REAL array, dimension (N-1) \n
          The (n-1) superdiagonal elements of A. \n
 * @param[in] DLF
          DLF is REAL array, dimension (N-1) \n
          The (n-1) multipliers that define the matrix L from the
          LU factorization of A as computed by SGTTRF. \n
 * @param[in] DF
          DF is REAL array, dimension (N) \n
          The n diagonal elements of the upper triangular matrix U from
          the LU factorization of A. \n
 * @param[in] DUF
          DUF is REAL array, dimension (N-1) \n
          The (n-1) elements of the first superdiagonal of U. \n
 * @param[in] DU2
          DU2 is REAL array, dimension (N-2) \n
          The (n-2) elements of the second superdiagonal of U. \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          The pivot indices; for 1 <= i <= n, row i of the matrix was
          interchanged with row IPIV(i).  IPIV(i) will always be either
          i or i+1; IPIV(i) = i indicates a row interchange was not
          required. \n
 * @param[in] B
          B is REAL array, dimension (LDB,NRHS) \n
          The right hand side matrix B. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[in,out] X
          X is REAL array, dimension (LDX,NRHS) \n
          On entry, the solution matrix X, as computed by SGTTRS.
          On exit, the improved solution matrix X. \n
 * @param[in] LDX
          LDX is INTEGER \n
          The leading dimension of the array X.  LDX >= max(1,N). \n
 * @param[out] FERR
          FERR is REAL array, dimension (NRHS) \n
          The estimated forward error bound for each solution vector
          X(j) (the j-th column of the solution matrix X).
          If XTRUE is the true solution corresponding to X(j), FERR(j)
          is an estimated upper bound for the magnitude of the largest
          element in (X(j) - XTRUE) divided by the magnitude of the
          largest element in X(j).  The estimate is as reliable as
          the estimate for RCOND, and is almost always a slight
          overestimate of the true error. \n
 * @param[out] BERR
          BERR is REAL array, dimension (NRHS) \n
          The componentwise relative backward error of each solution
          vector X(j) (i.e., the smallest relative change in
          any element of A or B that makes X(j) an exact solution). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (3*N) \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer gtrfs(char* trans, integer* n, integer* nrhs, T* dl, T* d, T* du, T* dlf, T* df, T* duf, T* du2, integer* ipiv, T* b, integer* ldb, T* x, integer* ldx, T* ferr, T* berr, T* work, T* iwork, integer* info)
{
  return gtrfs(trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork, info);
}
template< typename T , typename Ta >
integer gtrfs(char* trans, integer* n, integer* nrhs,  T* dl,  T* d,  T* du,  T* dlf,  T* df,  T* duf,  T* du2,  integer* ipiv,  T* b, integer* ldb, T* x, integer* ldx, Ta* ferr, Ta* berr, T* work, Ta* rwork, integer* info)
{
  return gtrfs(trans, n, nrhs, dl, d,  du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork, info);
}

/*! @brief GTSV computes the solution to system of linear equations A * X = B for GT matrices

 * @details
 * \b Purpose:
    \verbatim
     GTSV  solves the equation
        A*X = B,
     where A is an n by n tridiagonal matrix, by Gaussian elimination with
     partial pivoting.

     Note that the equation  A**T*X = B  may be solved by interchanging the
     order of the arguments DU and DL.
    \endverbatim 

 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in,out] DL
          DL is REAL array, dimension (N-1) \n
          On entry, DL must contain the (n-1) sub-diagonal elements of
          A. \n
 \n
          On exit, DL is overwritten by the (n-2) elements of the
          second super-diagonal of the upper triangular matrix U from
          the LU factorization of A, in DL(1), ..., DL(n-2). \n
 * @param[in,out] D
          D is REAL array, dimension (N) \n
          On entry, D must contain the diagonal elements of A. \n
 \n
          On exit, D is overwritten by the n diagonal elements of U. \n
 * @param[in,out] DU
          DU is REAL array, dimension (N-1) \n
          On entry, DU must contain the (n-1) super-diagonal elements
          of A. \n
 \n
          On exit, DU is overwritten by the (n-1) elements of the first
          super-diagonal of U. \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,NRHS) \n
          On entry, the N by NRHS matrix of right hand side matrix B. \n
          On exit, if INFO = 0, the N by NRHS solution matrix X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n
          > 0: if INFO = i, U(i,i) is exactly zero, and the solution
               has not been computed.  The factorization has not been
               completed unless i = N. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer gtsv(integer* n, integer* nrhs, T* dl, T* d, T* du, T* b, integer* ldb, integer* info)
{
  return gtsv(n, nrhs, dl, d, du, b, ldb, info);
}

/*! @brief GTSVX uses the LU factorization to compute the solution to a real system of linear equations

 * @details
 * \b Purpose:
    \verbatim
     GTSVX uses the LU factorization to compute the solution to a real
     system of linear equations A * X = B or A**T * X = B,
     where A is a tridiagonal matrix of order N and X and B are N-by-NRHS
     matrices.

     Error bounds on the solution and a condition estimate are also
     provided.
     
 * \b Description:
     The following steps are performed:

     1. If FACT = 'N', the LU decomposition is used to factor the matrix A
        as A = L * U, where L is a product of permutation and unit lower
        bidiagonal matrices and U is upper triangular with nonzeros in
        only the main diagonal and first two superdiagonals.

     2. If some U(i,i)=0, so that U is exactly singular, then the routine
        returns with INFO = i. Otherwise, the factored form of A is used
        to estimate the condition number of the matrix A.  If the
        reciprocal of the condition number is less than machine precision,
        INFO = N+1 is returned as a warning, but the routine still goes on
        to solve for X and compute error bounds as described below.

     3. The system of equations is solved for X using the factored form
        of A.

     4. Iterative refinement is applied to improve the computed solution
        matrix and calculate error bounds and backward error estimates
        for it.
    \endverbatim 

 * @param[in] FACT
          FACT is CHARACTER*1 \n
          Specifies whether or not the factored form of A has been
          supplied on entry. \n
          = 'F':  DLF, DF, DUF, DU2, and IPIV contain the factored
                  form of A; DL, D, DU, DLF, DF, DUF, DU2 and IPIV
                  will not be modified. \n
          = 'N':  The matrix will be copied to DLF, DF, and DUF
                  and factored. \n
 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          Specifies the form of the system of equations: \n
          = 'N':  A * X = B     (No transpose) \n
          = 'T':  A**T * X = B  (Transpose) \n
          = 'C':  A**H * X = B  (Conjugate transpose = Transpose) \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in] DL
          DL is REAL array, dimension (N-1) \n
          The (n-1) subdiagonal elements of A. \n
 * @param[in] D
          D is REAL array, dimension (N) \n
          The n diagonal elements of A. \n
 * @param[in] DU
          DU is REAL array, dimension (N-1) \n
          The (n-1) superdiagonal elements of A. \n
 * @param[in,out] DLF
          DLF is REAL array, dimension (N-1) \n
          If FACT = 'F', then DLF is an input argument and on entry
          contains the (n-1) multipliers that define the matrix L from
          the LU factorization of A as computed by SGTTRF. \n
 \n
          If FACT = 'N', then DLF is an output argument and on exit
          contains the (n-1) multipliers that define the matrix L from
          the LU factorization of A. \n
 * @param[in,out] DF
          DF is REAL array, dimension (N) \n
          If FACT = 'F', then DF is an input argument and on entry
          contains the n diagonal elements of the upper triangular
          matrix U from the LU factorization of A. \n
 \n
          If FACT = 'N', then DF is an output argument and on exit
          contains the n diagonal elements of the upper triangular
          matrix U from the LU factorization of A. \n
 * @param[in,out] DUF
          DUF is REAL array, dimension (N-1) \n
          If FACT = 'F', then DUF is an input argument and on entry
          contains the (n-1) elements of the first superdiagonal of U. \n
 \n
          If FACT = 'N', then DUF is an output argument and on exit
          contains the (n-1) elements of the first superdiagonal of U. \n
 * @param[in,out] DU2
          DU2 is REAL array, dimension (N-2) \n
          If FACT = 'F', then DU2 is an input argument and on entry
          contains the (n-2) elements of the second superdiagonal of
          U. \n
 \n
          If FACT = 'N', then DU2 is an output argument and on exit
          contains the (n-2) elements of the second superdiagonal of
          U. \n
 * @param[in,out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          If FACT = 'F', then IPIV is an input argument and on entry
          contains the pivot indices from the LU factorization of A as
          computed by SGTTRF. \n
 \n
          If FACT = 'N', then IPIV is an output argument and on exit
          contains the pivot indices from the LU factorization of A;
          row i of the matrix was interchanged with row IPIV(i).
          IPIV(i) will always be either i or i+1; IPIV(i) = i indicates
          a row interchange was not required. \n
 * @param[in] B
          B is REAL array, dimension (LDB,NRHS) \n
          The N-by-NRHS right hand side matrix B. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out] X
          X is REAL array, dimension (LDX,NRHS) \n
          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X. \n
 * @param[in] LDX
          LDX is INTEGER \n
          The leading dimension of the array X.  LDX >= max(1,N). \n
 * @param[out] RCOND
          RCOND is REAL \n
          The estimate of the reciprocal condition number of the matrix
          A.  If RCOND is less than the machine precision (in
          particular, if RCOND = 0), the matrix is singular to working
          precision.  This condition is indicated by a return code of
          INFO > 0. \n
 * @param[out] FERR
          FERR is REAL array, dimension (NRHS) \n
          The estimated forward error bound for each solution vector
          X(j) (the j-th column of the solution matrix X). \n
          If XTRUE is the true solution corresponding to X(j), FERR(j)
          is an estimated upper bound for the magnitude of the largest
          element in (X(j) - XTRUE) divided by the magnitude of the
          largest element in X(j).  The estimate is as reliable as
          the estimate for RCOND, and is almost always a slight
          overestimate of the true error. \n
 * @param[out] BERR
          BERR is REAL array, dimension (NRHS) \n
          The componentwise relative backward error of each solution
          vector X(j) (i.e., the smallest relative change in
          any element of A or B that makes X(j) an exact solution). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (3*N) \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, and i is \n
                <= N:  U(i,i) is exactly zero.  The factorization
                       has not been completed unless i = N, but the
                       factor U is exactly singular, so the solution
                       and error bounds could not be computed.
                       RCOND = 0 is returned. \n
                = N+1: U is nonsingular, but RCOND is less than machine
                       precision, meaning that the matrix is singular
                       to working precision.  Nevertheless, the
                       solution and error bounds are computed because
                       there are a number of situations where the
                       computed solution can be more accurate than the
                       value of RCOND would suggest. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer gtsvx(char* fact, char* trans, integer* n, integer* nrhs,  T* dl,  T* d,  T* du, T* dlf, T* df, T* duf, T* du2, integer* ipiv,  T* b, integer* ldb, T* x, integer* ldx, T* rcond, T* ferr, T* berr, T* work, integer* iwork, integer* info)
{
  return gtsvx(fact, trans, n, nrhs,  dl,  d,  du, dlf, df, duf, du2, ipiv,  b, ldb, x, ldx, rcond, ferr, berr, work, iwork, info);
}
template< typename T, typename Ta >
integer gtsvx(char* fact, char* trans, integer* n, integer* nrhs,  T* dl,  T* d,  T* du, T* dlf, T* df, T* duf, T* du2, integer* ipiv,  T* b, integer* ldb, T* x, integer* ldx, Ta* rcond, Ta* ferr, Ta* berr, T* work, Ta* rwork, integer* info)
{
  return gtsvx(fact, trans, n, nrhs,  dl,  d,  du, dlf, df, duf, du2, ipiv,  b, ldb, x, ldx, rcond, ferr, berr, work, rwork, info);
}

/*! @brief GTTRF computes an LU factorization of a real tridiagonal matrix A
 *
 * @details
 * \b Purpose:
    \verbatim
     GTTRF computes an LU factorization of a real tridiagonal matrix A
     using elimination with partial pivoting and row interchanges.
     The factorization has the form
        A = L * U
     where L is a product of permutation and unit lower bidiagonal
     matrices and U is upper triangular with nonzeros in only the main
     diagonal and first two superdiagonals.
    \endverbatim 

 * @param[in] N
          N is INTEGER \n
          The order of the matrix A. \n
 * @param[in,out] DL
          DL is REAL array, dimension (N-1) \n
          On entry, DL must contain the (n-1) sub-diagonal elements of
          A. \n
 \n
          On exit, DL is overwritten by the (n-1) multipliers that
          define the matrix L from the LU factorization of A. \n
 * @param[in,out] D
          D is REAL array, dimension (N) \n
          On entry, D must contain the diagonal elements of A. \n
 \n
          On exit, D is overwritten by the n diagonal elements of the
          upper triangular matrix U from the LU factorization of A. \n
 * @param[in,out] DU
          DU is REAL array, dimension (N-1) \n
          On entry, DU must contain the (n-1) super-diagonal elements
          of A. \n
 \n
          On exit, DU is overwritten by the (n-1) elements of the first
          super-diagonal of U. \n
 * @param[out] DU2
          DU2 is REAL array, dimension (N-2) \n
          On exit, DU2 is overwritten by the (n-2) elements of the
          second super-diagonal of U. \n
 * @param[out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          The pivot indices; for 1 <= i <= n, row i of the matrix was
          interchanged with row IPIV(i).  IPIV(i) will always be either
          i or i+1; IPIV(i) = i indicates a row interchange was not
          required. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -k, the k-th argument had an illegal value \n
          > 0:  if INFO = k, U(k,k) is exactly zero. The factorization
                has been completed, but the factor U is exactly
                singular, and division by zero will occur if it is used
                to solve a system of equations. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer gttrf(integer* n, T* dl, T* d, T* du, T* du2, integer* ipiv, integer* info)
{
  return gttrf(n, dl, d, du, du2, ipiv, info);
}

/*! @brief GTTRS solves one of the systems of equations
 * @details
 * \b Purpose:
    \verbatim
     GTTRS solves one of the systems of equations
        A*X = B  or  A**T*X = B,
     with a tridiagonal matrix A using the LU factorization computed
     by SGTTRF.
    \endverbatim 

 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          Specifies the form of the system of equations. \n
          = 'N':  A * X = B  (No transpose) \n
          = 'T':  A**T* X = B  (Transpose) \n
          = 'C':  A**T* X = B  (Conjugate transpose = Transpose) \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in] DL
          DL is REAL array, dimension (N-1) \n
          The (n-1) multipliers that define the matrix L from the
          LU factorization of A. \n
 * @param[in] D
          D is REAL array, dimension (N) \n
          The n diagonal elements of the upper triangular matrix U from
          the LU factorization of A. \n
 * @param[in] DU
          DU is REAL array, dimension (N-1) \n
          The (n-1) elements of the first super-diagonal of U. \n
 * @param[in] DU2
          DU2 is REAL array, dimension (N-2) \n
          The (n-2) elements of the second super-diagonal of U. \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          The pivot indices; for 1 <= i <= n, row i of the matrix was
          interchanged with row IPIV(i).  IPIV(i) will always be either
          i or i+1; IPIV(i) = i indicates a row interchange was not
          required. \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,NRHS) \n
          On entry, the matrix of right hand side vectors B. \n
          On exit, B is overwritten by the solution vectors X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer gttrs(char* trans, integer* n, integer* nrhs,  T* dl,  T* d,  T* du,  T* du2,  integer* ipiv, T* b, integer* ldb, integer* info)
{
  return gttrs(trans, n, nrhs,  dl,  d,  du,  du2,  ipiv, b, ldb, info);
}

/*! @brief LACN2 estimates the 1-norm of a square matrix

 * @details
 * \b Purpose:
    \verbatim
     LACN2 estimates the 1-norm of a square, real matrix A.
     Reverse communication is used for evaluating matrix-vector products.
    \endverbatim 

 * @param[in] N
          N is INTEGER \n
          The order of the matrix.  N >= 1. \n
 * @param[out] V
          V is REAL array, dimension (N) \n
          On the final return, V = A*W,  where  EST = norm(V)/norm(W)
          (W is not returned). \n
 * @param[in,out] X
          X is REAL array, dimension (N) \n
          On an intermediate return, X should be overwritten by \n
                A * X,   if KASE=1, \n
                A**T * X,  if KASE=2, \n
          and SLACN2 must be re-called with all the other parameters
          unchanged. \n
 * @param[out] ISGN
          ISGN is INTEGER array, dimension (N) \n
 * @param[in,out] EST
          EST is REAL \n
          On entry with KASE = 1 or 2 and ISAVE(1) = 3, EST should be
          unchanged from the previous call to SLACN2. \n
          On exit, EST is an estimate (a lower bound) for norm(A). \n
 * @param[in,out] KASE
          KASE is INTEGER \n
          On the initial call to SLACN2, KASE should be 0. \n
          On an intermediate return, KASE will be 1 or 2, indicating
          whether X should be overwritten by A * X  or A**T * X.
          On the final return from SLACN2, KASE will again be 0. \n
 * @param[in,out] ISAVE
          ISAVE is INTEGER array, dimension (3) \n
          ISAVE is used to save variables between calls to SLACN2 \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lacn2(integer* n, T* v, T* x, integer* isgn, T* est, integer* kase, integer* isave)
{
  return lacn2(n, v, x, isgn, est, kase, isave);
}
template< typename T, typename Ta >
integer lacn2(integer* n, T* v, T* x, Ta* est, integer* kase, integer* isave)
{
  return lacn2(n, v, x, est, kase, isave);
}

/*! @brief LACPY copies all or part of one two-dimensional array to another.

 * @details
 * \b Purpose:
    \verbatim
     LACPY copies all or part of a two-dimensional matrix A to another
     matrix B.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies the part of the matrix A to be copied to B. \n
          = 'U':      Upper triangular part \n
          = 'L':      Lower triangular part \n
          Otherwise:  All of the matrix A \n
 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A.  N >= 0. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          The m by n matrix A.  If UPLO = 'U', only the upper triangle
          or trapezoid is accessed; if UPLO = 'L', only the lower
          triangle or trapezoid is accessed. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,M). \n
 * @param[out] B
          B is REAL array, dimension (LDB,N) \n
          On exit, B = A in the locations specified by UPLO. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,M). \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lacpy(char* uplo, integer* m, integer* n,  T* a, integer* lda, T* b, integer* ldb)
{
  return lacpy(uplo, m, n,  a, lda, b, ldb);
}

/*! @brief LANGE returns the value of the 1-norm, Frobenius norm, infinity-norm, \n
     or the largest absolute value of any element of a general rectangular matrix.
 * @details
 * \b Purpose:
    \verbatim
     LANGE  returns the value of the one norm,  or the Frobenius norm, or
     the  infinity norm,  or the  element of  largest absolute value  of a
     real matrix A.
     \return LANGE
         LANGE = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                 (
                 ( norm1(A),         NORM = '1', 'O' or 'o'
                 (
                 ( normI(A),         NORM = 'I' or 'i'
                 (
                 ( normF(A),         NORM = 'F', 'f', 'E' or 'e'

     where  norm1  denotes the  one norm of a matrix (maximum column sum),
     normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
     normF  denotes the  Frobenius norm of a matrix (square root of sum of
     squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
    \endverbatim  

 * @param[in] NORM
          NORM is CHARACTER*1 \n
          Specifies the value to be returned in SLANGE as described
          above. \n
 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M >= 0.  When M = 0,
          SLANGE is set to zero. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A.  N >= 0.  When N = 0,
          SLANGE is set to zero. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          The m by n matrix A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(M,1). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)), \n
          where LWORK >= M when NORM = 'I'; otherwise, WORK is not
          referenced. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
T lange(char* norm, integer* m, integer* n,  T* a, integer* lda, T* work)
{
  return lange(norm, m, n,  a, lda, work);
}
template< typename T, typename Ta >
Ta lange(char* norm, integer* m, integer* n,  T* a, integer* lda, Ta* work)
{
  return lange(norm, m, n,  a, lda, work);
}

/*! @brief LANSY returns the value of the 1-norm, or the Frobenius norm, or the infinity 
      norm, or the element of largest absolute value of a real symmetric matrix.
 * @details
 * \b Purpose:
    \verbatim
     LANSY  returns the value of the one norm,  or the Frobenius norm, or
     the  infinity norm,  or the  element of  largest absolute value  of a
     real symmetric matrix A.

     \return LANSY
        LANSY = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                 (
                 ( norm1(A),         NORM = '1', 'O' or 'o'
                 (
                 ( normI(A),         NORM = 'I' or 'i'
                 (
                 ( normF(A),         NORM = 'F', 'f', 'E' or 'e'

     where  norm1  denotes the  one norm of a matrix (maximum column sum),
     normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
     normF  denotes the  Frobenius norm of a matrix (square root of sum of
     squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
    \endverbatim 

 * @param[in] NORM
          NORM is CHARACTER*1 \n
          Specifies the value to be returned in SLANSY as described
          above. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the upper or lower triangular part of the
          symmetric matrix A is to be referenced. \n
          = 'U':  Upper triangular part of A is referenced \n
          = 'L':  Lower triangular part of A is referenced \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0.  When N = 0, SLANSY is
          set to zero. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          The symmetric matrix A.  If UPLO = 'U', the leading n by n
          upper triangular part of A contains the upper triangular part
          of the matrix A, and the strictly lower triangular part of A
          is not referenced.  If UPLO = 'L', the leading n by n lower
          triangular part of A contains the lower triangular part of
          the matrix A, and the strictly upper triangular part of A is
          not referenced. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(N,1). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)), \n
          where LWORK >= N when NORM = 'I' or '1' or 'O'; otherwise,
          WORK is not referenced. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
T lansy(char* norm, char* uplo, integer* n,  T* a, integer* lda, T* work)
{
  return lansy(norm, uplo, n,  a, lda, work);
}
template< typename T, typename Ta >
Ta lansy(char* norm, char* uplo, integer* n,  T* a, integer* lda, Ta* work)
{
  return lansy(norm, uplo, n,  a, lda, work);
}

/*! @brief LANTR returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, \n
     or the element of largest absolute value of a trapezoidal or triangular matrix.
 * @details
 * \b Purpose:
    \verbatim
     LANTR  returns the value of the one norm,  or the Frobenius norm, or
     the  infinity norm,  or the  element of  largest absolute value  of a
     trapezoidal or triangular matrix A.
     \return LANTR
        LANTR = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                 (
                 ( norm1(A),         NORM = '1', 'O' or 'o'
                 (
                 ( normI(A),         NORM = 'I' or 'i'
                 (
                 ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
     where  norm1  denotes the  one norm of a matrix (maximum column sum),
     normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
     normF  denotes the  Frobenius norm of a matrix (square root of sum of
     squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
    \endverbatim 

 * @param[in] NORM
          NORM is CHARACTER*1 \n
          Specifies the value to be returned in SLANTR as described
          above. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the matrix A is upper or lower trapezoidal. \n
          = 'U':  Upper trapezoidal \n
          = 'L':  Lower trapezoidal \n
          Note that A is triangular instead of trapezoidal if M = N. \n
 * @param[in] DIAG
          DIAG is CHARACTER*1 \n
          Specifies whether or not the matrix A has unit diagonal. \n
          = 'N':  Non-unit diagonal \n
          = 'U':  Unit diagonal \n
 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M >= 0, and if
          UPLO = 'U', M <= N.  When M = 0, SLANTR is set to zero. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A.  N >= 0, and if
          UPLO = 'L', N <= M.  When N = 0, SLANTR is set to zero. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          The trapezoidal matrix A (A is triangular if M = N). \n
          If UPLO = 'U', the leading m by n upper trapezoidal part of
          the array A contains the upper trapezoidal matrix, and the
          strictly lower triangular part of A is not referenced. \n
          If UPLO = 'L', the leading m by n lower trapezoidal part of
          the array A contains the lower trapezoidal matrix, and the
          strictly upper triangular part of A is not referenced.  Note
          that when DIAG = 'U', the diagonal elements of A are not
          referenced and are assumed to be one. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(M,1). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)), \n
          where LWORK >= M when NORM = 'I'; otherwise, WORK is not
          referenced. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
T lantr(char* norm, char* uplo, char* diag, integer* m, integer* n,  T* a, integer* lda, T* work)
{
  return lantr(norm, uplo, diag, m, n, a, lda, work);
} 
template< typename T, typename Ta >
Ta lantr(char* norm, char* uplo, char* diag, integer* m, integer* n,  T* a, integer* lda, Ta* work)
{
  return lantr(norm, uplo, diag, m, n, a, lda, work);
}

/*! @brief LAPMR rearranges rows of a matrix as specified by a permutation vector.

 * @details
 * \b Purpose:
    \verbatim
     LAPMR rearranges the rows of the M by N matrix X as specified
     by the permutation K(1),K(2),...,K(M) of the integers 1,...,M.
     If FORWRD = .TRUE.,  forward permutation:
          X(K(I),*) is moved X(I,*) for I = 1,2,...,M.

     If FORWRD = .FALSE., backward permutation:
          X(I,*) is moved to X(K(I),*) for I = 1,2,...,M.
    \endverbatim 

 * @param[in] FORWRD
          FORWRD is LOGICAL \n
          = .TRUE., forward permutation \n
          = .FALSE., backward permutation \n
 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix X. M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix X. N >= 0. \n
 * @param[in,out] X
          X is REAL array, dimension (LDX,N) \n
          On entry, the M by N matrix X. \n
          On exit, X contains the permuted matrix X. \n
 * @param[in] LDX
          LDX is INTEGER \n
          The leading dimension of the array X, LDX >= MAX(1,M). \n
 * @param[in,out] K
          K is INTEGER array, dimension (M) \n
          On entry, K contains the permutation vector. K is used as
          internal workspace, but reset to its original value on
          output. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lapmr(logical* forwrd, integer* m, integer* n, T* x, integer* ldx, integer* k)
{
  return lapmr(forwrd, m, n, x, ldx, k);
}

/*! @brief LAPMT performs a forward or backward permutation of the columns of a matrix.

 * @details
 * \b Purpose:
    \verbatim
     LAPMT rearranges the columns of the M by N matrix X as specified
     by the permutation K(1),K(2),...,K(N) of the integers 1,...,N.
     If FORWRD = .TRUE.,  forward permutation:
          X(*,K(J)) is moved X(*,J) for J = 1,2,...,N.

     If FORWRD = .FALSE., backward permutation:
          X(*,J) is moved to X(*,K(J)) for J = 1,2,...,N.
    \endverbatim 

 * @param[in] FORWRD
          FORWRD is LOGICAL \n
          = .TRUE., forward permutation \n
          = .FALSE., backward permutation \n
 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix X. M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix X. N >= 0. \n
 * @param[in,out] X
          X is REAL array, dimension (LDX,N) \n
          On entry, the M by N matrix X. \n
          On exit, X contains the permuted matrix X. \n
 * @param[in] LDX
          LDX is INTEGER \n
          The leading dimension of the array X, LDX >= MAX(1,M). \n
 * @param[in,out] K
          K is INTEGER array, dimension (M) \n
          On entry, K contains the permutation vector. K is used as
          internal workspace, but reset to its original value on
          output. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lapmt(logical* forwrd, integer* m, integer* n, T* x, integer* ldx, integer* k)
{
  return lapmt(forwrd, m, n, x, ldx, k);
}

/*! @brief LARFB applies a block reflector or its transpose to a general rectangular matrix

 * @details
 * \b Purpose:
    \verbatim
     LARFB applies a real block reflector H or its transpose H**T to a
     real m by n matrix C, from either the left or the right.
    \endverbatim
    
 * @param[in] SIDE
          SIDE is CHARACTER*1 \n
          = 'L': apply H or H**T from the Left \n
          = 'R': apply H or H**T from the Right \n
 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          = 'N': apply H (No transpose) \n
          = 'T': apply H**T (Transpose) \n
 * @param[in] DIRECT
          DIRECT is CHARACTER*1 \n
          Indicates how H is formed from a product of elementary
          reflectors \n
          = 'F': H = H(1) H(2) . . . H(k) (Forward) \n
          = 'B': H = H(k) . . . H(2) H(1) (Backward) \n
 * @param[in] STOREV
          STOREV is CHARACTER*1 \n
          Indicates how the vectors which define the elementary
          reflectors are stored: \n
          = 'C': Columnwise \n
          = 'R': Rowwise \n
 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix C. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix C. \n
 * @param[in] K
          K is INTEGER \n
          The order of the matrix T (= the number of elementary
          reflectors whose product defines the block reflector). \n
          If SIDE = 'L', M >= K >= 0; \n
          if SIDE = 'R', N >= K >= 0. \n
 * @param[in] V
          V is REAL array, dimension \n
                                (LDV,K) if STOREV = 'C' \n
                                (LDV,M) if STOREV = 'R' and SIDE = 'L' \n
                                (LDV,N) if STOREV = 'R' and SIDE = 'R' \n
          The matrix V. See Further Details. \n
 * @param[in] LDV
          LDV is INTEGER \n
          The leading dimension of the array V. \n
          If STOREV = 'C' and SIDE = 'L', LDV >= max(1,M); \n
          if STOREV = 'C' and SIDE = 'R', LDV >= max(1,N); \n
          if STOREV = 'R', LDV >= K. \n
 * @param[in] T
          T is REAL array, dimension (LDT,K) \n
          The triangular k by k matrix T in the representation of the
          block reflector. \n
 * @param[in] LDT
          LDT is INTEGER \n
          The leading dimension of the array T. LDT >= K. \n
 * @param[in,out] C
          C is REAL array, dimension (LDC,N) \n
          On entry, the m by n matrix C. \n
          On exit, C is overwritten by H*C or H**T*C or C*H or C*H**T. \n
 * @param[in] LDC
          LDC is INTEGER \n
          The leading dimension of the array C. LDC >= max(1,M). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (LDWORK,K) \n
 * @param[in]	LDWORK	
          LDWORK is INTEGER \n
          The leading dimension of the array WORK. \n
          If SIDE = 'L', LDWORK >= max(1,N); \n
          if SIDE = 'R', LDWORK >= max(1,M). \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer larfb(char* side, char* trans, char* direct, char* storev, integer* m, integer* n, integer* k,  T* v, integer* ldv,  T* t, integer* ldt, T* c, integer* ldc, T* work, integer* ldwork)
{
  return larfb( side, trans, direct, storev, m, n, k,  v, ldv,  t, ldt, c, ldc, work, ldwork);
} 

/*! @brief LARFX applies an elementary reflector to a general rectangular matrix, \n
     with loop unrolling when the reflector has order  10
 * @details
 * \b Purpose:
    \verbatim
     LARFX applies a real elementary reflector H to a real m by n
     matrix C, from either the left or the right. H is represented in the
     form
           H = I - tau * v * v**T

     where tau is a real scalar and v is a real vector.

     If tau = 0, then H is taken to be the unit matrix

     This version uses inline code if H has order < 11.
    \endverbatim 

 * @param[in] SIDE
          SIDE is CHARACTER*1 \n
          = 'L': form  H * C \n
          = 'R': form  C * H \n
 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix C. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix C. \n
 * @param[in] V
          V is REAL array, dimension (M) if SIDE = 'L'
                                     or (N) if SIDE = 'R' \n
          The vector v in the representation of H. \n
 * @param[in] TAU
          TAU is REAL \n
          The value tau in the representation of H. \n
 * @param[in,out] C
          C is REAL array, dimension (LDC,N) \n
          On entry, the m by n matrix C. \n
          On exit, C is overwritten by the matrix H * C if SIDE = 'L',
          or C * H if SIDE = 'R'. \n
 * @param[in] LDC
          LDC is INTEGER \n
          The leading dimension of the array C. LDC >= (1,M). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension
                      (N) if SIDE = 'L'
                      or (M) if SIDE = 'R' \n
          WORK is not referenced if H has order < 11. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer larfx(char* side, integer* m, integer* n,  T* v, T* tau, T* c, integer* ldc, T* work)
{
  return larfx(side, m, n,  v, tau, c, ldc, work);
}

/*! @brief LARNV returns a vector of random numbers from a uniform or normal distribution
 * @details
 * \b Purpose:
    \verbatim
     LARNV returns a vector of n random real numbers from a uniform or
     normal distribution.
    \endverbatim 

 * @param[in] IDIST
          IDIST is INTEGER \n
          Specifies the distribution of the random numbers: \n
          = 1:  uniform (0,1) \n
          = 2:  uniform (-1,1) \n
          = 3:  normal (0,1) \n
 * @param[in,out] ISEED
          ISEED is INTEGER array, dimension (4) \n
          On entry, the seed of the random number generator; the array
          elements must be between 0 and 4095, and ISEED(4) must be
          odd. \n
          On exit, the seed is updated. \n
 * @param[in] N
          N is INTEGER \n
          The number of random numbers to be generated. \n
 * @param[out] X
          X is REAL array, dimension (N) \n
          The generated random numbers. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer larnv(integer* idist, integer* iseed, integer* n, T* x)
{
  return larnv(idist, iseed, n, x);
}

/*! @brief LARTGS generates a plane rotation designed to introduce a bulge \n
     in implicit QR iteration for the bidiagonal SVD problem
 * @details
 * \b Purpose:
    \verbatim
     LARTGS generates a plane rotation designed to introduce a bulge in
     Golub-Reinsch-style implicit QR iteration for the bidiagonal SVD
     problem. X and Y are the top-row entries, and SIGMA is the shift.
     The computed CS and SN define a plane rotation satisfying

        [  CS  SN  ]  .  [ X^2 - SIGMA ]  =  [ R ],
        [ -SN  CS  ]     [    X * Y    ]     [ 0 ]

     with R nonnegative.  If X^2 - SIGMA and X * Y are 0, then the
     rotation is by PI/2.
    \endverbatim 

 * @param[in] X
          X is REAL \n
          The (1,1) entry of an upper bidiagonal matrix. \n
 * @param[in] Y
          Y is REAL \n
          The (1,2) entry of an upper bidiagonal matrix. \n
 * @param[in] SIGMA
          SIGMA is REAL \n
          The shift. \n
 * @param[out] CS
          CS is REAL \n
          The cosine of the rotation. \n
 * @param[out] SN
          SN is REAL \n
          The sine of the rotation. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lartgs(T* x, T* y, T* sigma, T* cs, T* sn)
{
  return lartgs(x, y, sigma, cs, sn);
}

/*! @brief LASCL multiplies a general rectangular matrix by a real scalar defined as cto/cfrom

 * @details
 * \b Purpose:
    \verbatim
     LASCL multiplies the M by N real matrix A by the real scalar
     CTO/CFROM.  This is done without over/underflow as long as the final
     result CTO*A(I,J)/CFROM does not over/underflow. TYPE specifies that
     A may be full, upper triangular, lower triangular, upper Hessenberg,
     or banded.
    \endverbatim 

 * @param[in] TYPE
          TYPE is CHARACTER*1 \n
          TYPE indices the storage type of the input matrix. \n
          = 'G':  A is a full matrix. \n
          = 'L':  A is a lower triangular matrix. \n
          = 'U':  A is an upper triangular matrix. \n
          = 'H':  A is an upper Hessenberg matrix. \n
          = 'B':  A is a symmetric band matrix with lower bandwidth KL
                  and upper bandwidth KU and with the only the lower
                  half stored. \n
          = 'Q':  A is a symmetric band matrix with lower bandwidth KL
                  and upper bandwidth KU and with the only the upper
                  half stored. \n
          = 'Z':  A is a band matrix with lower bandwidth KL and upper
                  bandwidth KU. See SGBTRF for storage details. \n
 * @param[in] KL
          KL is INTEGER \n
          The lower bandwidth of A.  Referenced only if TYPE = 'B',
          'Q' or 'Z'. \n
 * @param[in] KU
          KU is INTEGER \n
          The upper bandwidth of A.  Referenced only if TYPE = 'B',
          'Q' or 'Z'. \n
 * @param[in] CFROM
          CFROM is REAL \n
 * @param[in] CTO
          CTO is REAL \n
          The matrix A is multiplied by CTO/CFROM. A(I,J) is computed
          without over/underflow if the final result CTO*A(I,J)/CFROM
          can be represented without over/underflow.  CFROM must be
          nonzero. \n
 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          The matrix to be multiplied by CTO/CFROM.  See TYPE for the
          storage type. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A. \n
          If TYPE = 'G', 'L', 'U', 'H', LDA >= max(1,M); \n
             TYPE = 'B', LDA >= KL+1; \n
             TYPE = 'Q', LDA >= KU+1; \n
             TYPE = 'Z', LDA >= 2*KL+KU+1. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          0  - successful exit \n
          <0 - if INFO = -i, the i-th argument had an illegal value. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lascl(char* type, integer* kl, integer* ku, T* cfrom, T* cto, integer* m, integer* n, T* a, integer* lda, integer* info)
{
  return lascl(type, kl, ku, cfrom, cto, m, n, a, lda, info);
}
template< typename T , typename Ta >
integer lascl(char* type, integer* kl, integer* ku, Ta* cfrom, Ta* cto, integer* m, integer* n, T* a, integer* lda, integer* info)
{
  return lascl(type, kl, ku, cfrom, cto, m, n, a, lda, info);
}

/*! @brief LASRT sorts numbers in increasing or decreasing order

 * @details
 * \b Purpose:
    \verbatim
     Sort the numbers in D in increasing order (if ID = 'I') or
     in decreasing order (if ID = 'D').

     Use Quick Sort, reverting to Insertion sort on arrays of
     size <= 20. Dimension of STACK limits N to about 2**32.
    \endverbatim 

 * @param[in] ID
          ID is CHARACTER*1 \n
          = 'I': sort D in increasing order; \n
          = 'D': sort D in decreasing order. \n
 * @param[in] N
          N is INTEGER \n
          The length of the array D. \n
 * @param[in,out] D
          D is REAL array, dimension (N) \n
          On entry, the array to be sorted. \n
          On exit, D has been sorted into increasing order \n
          (D(1) <= ... <= D(N)) or into decreasing order \n
          (D(1) >= ... >= D(N)), depending on ID. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lasrt(char* id, integer* n, T* d, integer* info)
{
  return lasrt(id, n, d, info);
}

/*! @brief LASSQ updates a sum of squares represented in scaled form

 * @details
 * \b Purpose:
    \verbatim
     LASSQ  returns the values  scl  and  smsq  such that

        ( scl**2)*smsq = x( 1)**2 +...+ x( n)**2 + ( scale**2)*sumsq,

     where  x( i) = X( 1 + ( i - 1)*INCX). The value of  sumsq  is
     assumed to be non-negative and  scl  returns the value

        scl = max( scale, abs( x( i))).

     scale and sumsq must be supplied in SCALE and SUMSQ and
     scl and smsq are overwritten on SCALE and SUMSQ respectively.

     The routine makes only one pass through the vector x.
    \endverbatim 

 * @param[in] N
          N is INTEGER \n
          The number of elements to be used from the vector X. \n
 * @param[in] X
          X is REAL array, dimension (1+(N-1)*INCX) \n
          The vector for which a scaled sum of squares is computed. \n
             x( i)  = X( 1 + ( i - 1)*INCX), 1 <= i <= n. \n
 * @param[in] INCX
          INCX is INTEGER \n
          The increment between successive values of the vector X.
          INCX > 0. \n
 * @param[in,out] SCALE
          SCALE is REAL \n
          On entry, the value  scale  in the equation above. \n
          On exit, SCALE is overwritten with  scl , the scaling factor
          for the sum of squares. \n
 * @param[in,out] SUMSQ
          SUMSQ is REAL \n
          On entry, the value  sumsq  in the equation above. \n
          On exit, SUMSQ is overwritten with  smsq , the basic sum of
          squares from which  scl  has been factored out. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lassq(integer* n, T* x, integer* incx, T* scale, T* sumsq)
{
  return lassq(n, x, incx, scale, sumsq);
}
template< typename T, typename Ta >
integer lassq(integer* n, T* x, integer* incx, Ta* scale, Ta* sumsq)
{
  return lassq( n, x, incx, scale, sumsq);
}

/*! @brief OPGTR generates a real orthogonal matrix Q

 * @details
 * \b Purpose:
    \verbatim 
     OPGTR generates a real orthogonal matrix Q which is defined as the
     product of n-1 elementary reflectors H(i) of order n, as returned by
     SSPTRD using packed storage:

     if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),

     if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U': Upper triangular packed storage used in previous
                 call to SSPTRD; \n
          = 'L': Lower triangular packed storage used in previous
                 call to SSPTRD. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix Q. N >= 0. \n
 * @param[in] AP
          AP is REAL array, dimension (N*(N+1)/2) \n
          The vectors which define the elementary reflectors, as
          returned by SSPTRD. \n
 * @param[in] TAU
          TAU is REAL array, dimension (N-1) \n
          TAU(i) must contain the scalar factor of the elementary
          reflector H(i), as returned by SSPTRD. \n
 * @param[out] Q
          Q is REAL array, dimension (LDQ,N) \n
          The N-by-N orthogonal matrix Q. \n
 * @param[in] LDQ
          LDQ is INTEGER \n
          The leading dimension of the array Q. LDQ >= max(1,N). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (N-1) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer opgtr(char* uplo, integer* n,  T* ap,  T* tau, T* q, integer* ldq, T *work, integer *info)
{
  return opgtr(uplo, n, ap, tau, q, ldq, work, info);
}
template< typename T >
integer upgtr(char* uplo, integer* n,  T* ap,  T* tau, T* q, integer* ldq, T *work, integer *info)
{
  return upgtr(uplo, n, ap, tau, q, ldq, work, info);
}

/*! @brief OPMTR overwrites the general real M-by-N matrix

 * @details
 * \b Purpose:
    \verbatim
     OPMTR overwrites the general real M-by-N matrix C with
                     SIDE = 'L'     SIDE = 'R'
     TRANS = 'N':      Q * C          C * Q
     TRANS = 'T':      Q**T * C       C * Q**T

     where Q is a real orthogonal matrix of order nq, with nq = m if
     SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
     nq-1 elementary reflectors, as returned by SSPTRD using packed
     storage:
     if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
     if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
    \endverbatim 

 * @param[in] SIDE
          SIDE is CHARACTER*1 \n
          = 'L': apply Q or Q**T from the Left; \n
          = 'R': apply Q or Q**T from the Right. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U': Upper triangular packed storage used in previous
                 call to SSPTRD; \n
          = 'L': Lower triangular packed storage used in previous
                 call to SSPTRD. \n
 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          = 'N':  No transpose, apply Q; \n
          = 'T':  Transpose, apply Q**T. \n
 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix C. M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix C. N >= 0. \n
 * @param[in] AP
          AP is REAL array, dimension \n
                               (M*(M+1)/2) if SIDE = 'L' \n
                               (N*(N+1)/2) if SIDE = 'R' \n
          The vectors which define the elementary reflectors, as
          returned by SSPTRD.  AP is modified by the routine but
          restored on exit. \n
 * @param[in] TAU
          TAU is REAL array, dimension (M-1) if SIDE = 'L'
                                     or (N-1) if SIDE = 'R' \n
          TAU(i) must contain the scalar factor of the elementary
          reflector H(i), as returned by SSPTRD. \n
 * @param[in,out] C
          C is REAL array, dimension (LDC,N) \n
          On entry, the M-by-N matrix C. \n
          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q. \n
 * @param[in] LDC
          LDC is INTEGER \n
          The leading dimension of the array C. LDC >= max(1,M). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension \n
                                   (N) if SIDE = 'L' \n
                                   (M) if SIDE = 'R' \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer opmtr(char* side, char* uplo, char* trans, integer* m, integer* n,  T* ap,  T* tau, T* c, integer* ldc, T* work, integer* info)
{
  return opmtr(side, uplo, trans, m, n,  ap,  tau, c, ldc, work, info);
}

template< typename T >
integer upmtr(char* side, char* uplo, char* trans, integer* m, integer* n,  T* ap,  T* tau, T* c, integer* ldc, T* work, integer* info)
{
  return upmtr(side, uplo, trans, m, n,  ap,  tau, c, ldc, work, info);
}

/*! @brief ORBDB simultaneously bidiagonalizes the blocks of an M-by-M \n
 partitioned orthogonal matrix X
 * @details
 * \b Purpose:
    \verbatim
     ORBDB simultaneously bidiagonalizes the blocks of an M-by-M
     partitioned orthogonal matrix X:

                                     [ B11 | B12 0  0 ]
         [ X11 | X12 ]   [ P1 |    ] [  0  |  0 -I  0 ] [ Q1 |    ]**T
     X = [-----------] = [---------] [----------------] [---------]   .
         [ X21 | X22 ]   [    | P2 ] [ B21 | B22 0  0 ] [    | Q2 ]
                                     [  0  |  0  0  I ]

     X11 is P-by-Q. Q must be no larger than P, M-P, or M-Q. (If this is
     not the case, then X must be transposed and/or permuted. This can be
     done in constant time using the TRANS and SIGNS options. See SORCSD
     for details.)

     The orthogonal matrices P1, P2, Q1, and Q2 are P-by-P, (M-P)-by-
     (M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. They are
     represented implicitly by Householder vectors.

     B11, B12, B21, and B22 are Q-by-Q bidiagonal matrices represented
     implicitly by angles THETA, PHI.
    \endverbatim 

 * @param[in] TRANS
          TRANS is CHARACTER \n
          = 'T':      X, U1, U2, V1T, and V2T are stored in row-major
                      order; \n
          otherwise:  X, U1, U2, V1T, and V2T are stored in column-
                      major order. \n
 * @param[in] SIGNS
          SIGNS is CHARACTER \n
          = 'O':      The lower-left block is made nonpositive (the
                      "other" convention); \n
          otherwise:  The upper-right block is made nonpositive (the
                      "default" convention). \n
 * @param[in] M
          M is INTEGER \n
          The number of rows and columns in X. \n
 * @param[in] P
          P is INTEGER \n
          The number of rows in X11 and X12. 0 <= P <= M. \n
 * @param[in] Q
          Q is INTEGER \n
          The number of columns in X11 and X21. 0 <= Q <=
          MIN(P,M-P,M-Q). \n
 * @param[in,out] X11
          X11 is REAL array, dimension (LDX11,Q) \n
          On entry, the top-left block of the orthogonal matrix to be
          reduced. On exit, the form depends on TRANS: \n
          If TRANS = 'N', then \n
             the columns of tril(X11) specify reflectors for P1,
             the rows of triu(X11,1) specify reflectors for Q1; \n
          else TRANS = 'T', and \n
             the rows of triu(X11) specify reflectors for P1,
             the columns of tril(X11,-1) specify reflectors for Q1. \n
 * @param[in] LDX11
          LDX11 is INTEGER \n
          The leading dimension of X11. If TRANS = 'N', then LDX11 >=
          P; else LDX11 >= Q. \n
 * @param[in,out] X12
          X12 is REAL array, dimension (LDX12,M-Q) \n
          On entry, the top-right block of the orthogonal matrix to
          be reduced. On exit, the form depends on TRANS: \n
          If TRANS = 'N', then \n
             the rows of triu(X12) specify the first P reflectors for
             Q2; \n
          else TRANS = 'T', and \n
             the columns of tril(X12) specify the first P reflectors
             for Q2. \n
 * @param[in] LDX12
          LDX12 is INTEGER \n
          The leading dimension of X12. If TRANS = 'N', then LDX12 >=
          P; else LDX11 >= M-Q. \n
 * @param[in,out] X21
          X21 is REAL array, dimension (LDX21,Q) \n
          On entry, the bottom-left block of the orthogonal matrix to
          be reduced. On exit, the form depends on TRANS: \n
          If TRANS = 'N', then \n
             the columns of tril(X21) specify reflectors for P2; \n
          else TRANS = 'T', and \n
             the rows of triu(X21) specify reflectors for P2. \n
 * @param[in] LDX21
          LDX21 is INTEGER \n
          The leading dimension of X21. If TRANS = 'N', then LDX21 >=
          M-P; else LDX21 >= Q. \n
 * @param[in,out] X22
          X22 is REAL array, dimension (LDX22,M-Q) \n
          On entry, the bottom-right block of the orthogonal matrix to
          be reduced. On exit, the form depends on TRANS: \n
          If TRANS = 'N', then \n
             the rows of triu(X22(Q+1:M-P,P+1:M-Q)) specify the last
             M-P-Q reflectors for Q2, \n
          else TRANS = 'T', and \n
             the columns of tril(X22(P+1:M-Q,Q+1:M-P)) specify the last
             M-P-Q reflectors for P2. \n
 * @param[in] LDX22
          LDX22 is INTEGER \n
          The leading dimension of X22. If TRANS = 'N', then LDX22 >=
          M-P; else LDX22 >= M-Q. \n
 * @param[out] THETA
          THETA is REAL array, dimension (Q) \n
          The entries of the bidiagonal blocks B11, B12, B21, B22 can
          be computed from the angles THETA and PHI. See Further
          Details. \n
 * @param[out] PHI
          PHI is REAL array, dimension (Q-1) \n
          The entries of the bidiagonal blocks B11, B12, B21, B22 can
          be computed from the angles THETA and PHI. See Further
          Details. \n
 * @param[out] TAUP1
          TAUP1 is REAL array, dimension (P) \n
          The scalar factors of the elementary reflectors that define
          P1. \n
 * @param[out] TAUP2
          TAUP2 is REAL array, dimension (M-P) \n
          The scalar factors of the elementary reflectors that define
          P2. \n
 * @param[out] TAUQ1
          TAUQ1 is REAL array, dimension (Q) \n
          The scalar factors of the elementary reflectors that define
          Q1. \n
 * @param[out] TAUQ2
          TAUQ2 is REAL array, dimension (M-Q) \n
          The scalar factors of the elementary reflectors that define
          Q2. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (LWORK) \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK. LWORK >= M-Q. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n


 * @return INTEGER Return value of the function.
 * */ 
template< typename T >
integer orbdb(char* trans, char* signs, integer* m, integer* p, integer* q, T* x11, integer* ldx11, T* x12, integer* ldx12, T* x21, integer* ldx21, T* x22, integer* ldx22, T* theta, T* phi, T* taup1, T* taup2, T* tauq1, T* tauq2, T* work, integer* lwork, integer* info)
{
  return orbdb(trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2, work, lwork, info);
}

template< typename T, typename Ta >
integer unbdb(char* trans, char* signs, integer* m, integer* p, integer* q, T* x11, integer* ldx11, T* x12, integer* ldx12, T* x21, integer* ldx21, T* x22, integer* ldx22, Ta* theta, Ta* phi, T* taup1, T* taup2, T* tauq1, T* tauq2, T* work, integer* lwork, integer* info)
{
  return unbdb(trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2, work, lwork, info);
}

/*! @brief ORCSD computes the CS decomposition of an M-by-M partitioned orthogonal/unitary matrix X

 * @details
 * \b Purpose:
    \verbatim 
     ORCSD computes the CS decomposition of an M-by-M partitioned
     orthogonal/unitary  matrix X:

                                     [  I  0  0 |  0  0  0 ]
                                     [  0  C  0 |  0 -S  0 ]
         [ X11 | X12 ]   [ U1 |    ] [  0  0  0 |  0  0 -I ] [ V1 |    ]**T
     X = [-----------] = [---------] [---------------------] [---------]   .
         [ X21 | X22 ]   [    | U2 ] [  0  0  0 |  I  0  0 ] [    | V2 ]
                                     [  0  S  0 |  0  C  0 ]
                                     [  0  0  I |  0  0  0 ]

     X11 is P-by-Q. The orthogonal/unitary  matrices U1, U2, V1, and V2 are P-by-P,
     (M-P)-by-(M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. C and S are
     R-by-R nonnegative diagonal matrices satisfying C^2 + S^2 = I, in
     which R = MIN(P,M-P,Q,M-Q).
    \endverbatim 

 * @param[in] JOBU1
          JOBU1 is CHARACTER \n
          = 'Y':      U1 is computed; \n
          otherwise:  U1 is not computed. \n
 * @param[in] JOBU2
          JOBU2 is CHARACTER \n
          = 'Y':      U2 is computed; \n
          otherwise:  U2 is not computed. \n
 * @param[in] JOBV1T
          JOBV1T is CHARACTER \n
          = 'Y':      V1T is computed; \n
          otherwise:  V1T is not computed. \n
 * @param[in] JOBV2T
          JOBV2T is CHARACTER \n
          = 'Y':      V2T is computed; \n
          otherwise:  V2T is not computed. \n
 * @param[in] TRANS
          TRANS is CHARACTER \n
          = 'T':      X, U1, U2, V1T, and V2T are stored in row-major
                      order; \n
          otherwise:  X, U1, U2, V1T, and V2T are stored in column-
                      major order. \n
 * @param[in] SIGNS
          SIGNS is CHARACTER \n
          = 'O':      The lower-left block is made nonpositive (the
                      "other" convention); \n
          otherwise:  The upper-right block is made nonpositive (the
                      "default" convention). \n
 * @param[in] M
          M is INTEGER \n
          The number of rows and columns in X. \n
 * @param[in] P
          P is INTEGER \n
          The number of rows in X11 and X12. 0 <= P <= M. \n
 * @param[in] Q
          Q is INTEGER \n
          The number of columns in X11 and X21. 0 <= Q <= M. \n
 * @param[in,out] X11
          X11 is REAL array, dimension (LDX11,Q) \n
          On entry, part of the orthogonal matrix whose CSD is desired. \n
 * @param[in] LDX11
          LDX11 is INTEGER \n
          The leading dimension of X11. LDX11 >= MAX(1,P). \n
 * @param[in,out] X12
          X12 is REAL array, dimension (LDX12,M-Q) \n
          On entry, part of the orthogonal matrix whose CSD is desired. \n
 * @param[in] LDX12
          LDX12 is INTEGER \n
          The leading dimension of X12. LDX12 >= MAX(1,P). \n
 * @param[in,out] X21
          X21 is REAL array, dimension (LDX21,Q) \n
          On entry, part of the orthogonal matrix whose CSD is desired. \n
 * @param[in] LDX21
          LDX21 is INTEGER \n
          The leading dimension of X11. LDX21 >= MAX(1,M-P). \n
 * @param[in,out] X22
          X22 is REAL array, dimension (LDX22,M-Q) \n
          On entry, part of the orthogonal matrix whose CSD is desired. \n
 * @param[in] LDX22
          LDX22 is INTEGER \n
          The leading dimension of X11. LDX22 >= MAX(1,M-P). \n
 * @param[out] THETA
          THETA is REAL array, dimension (R), in which R =
          MIN(P,M-P,Q,M-Q). \n
          C = DIAG( COS(THETA(1)), ... , COS(THETA(R))) and \n
          S = DIAG( SIN(THETA(1)), ... , SIN(THETA(R))). \n
 * @param[out] U1
          U1 is REAL array, dimension (LDU1,P) \n
          If JOBU1 = 'Y', U1 contains the P-by-P orthogonal matrix U1. \n
 * @param[in] LDU1
          LDU1 is INTEGER \n
          The leading dimension of U1. If JOBU1 = 'Y', LDU1 >=
          MAX(1,P). \n
 * @param[out] U2
          U2 is REAL array, dimension (LDU2,M-P) \n
          If JOBU2 = 'Y', U2 contains the (M-P)-by-(M-P) orthogonal
          matrix U2. \n
 * @param[in] LDU2
          LDU2 is INTEGER \n
          The leading dimension of U2. If JOBU2 = 'Y', LDU2 >=
          MAX(1,M-P). \n
 * @param[out] V1T
          V1T is REAL array, dimension (LDV1T,Q) \n
          If JOBV1T = 'Y', V1T contains the Q-by-Q matrix orthogonal
          matrix V1**T. \n
 * @param[in] LDV1T
          LDV1T is INTEGER \n
          The leading dimension of V1T. If JOBV1T = 'Y', LDV1T >=
          MAX(1,Q). \n
 * @param[out] V2T
          V2T is REAL array, dimension (LDV2T,M-Q) \n
          If JOBV2T = 'Y', V2T contains the (M-Q)-by-(M-Q) orthogonal
          matrix V2**T. \n
 * @param[in] LDV2T
          LDV2T is INTEGER \n
          The leading dimension of V2T. If JOBV2T = 'Y', LDV2T >=
          MAX(1,M-Q). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
          If INFO > 0 on exit, WORK(2:R) contains the values PHI(1),
          ..., PHI(R-1) that, together with THETA(1), ..., THETA(R),
          define the matrix in intermediate bidiagonal-block form
          remaining after nonconvergence. INFO specifies the number
          of nonzero PHI's. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the work array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (M-MIN(P, M-P, Q, M-Q)) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n
          > 0:  SBBCSD did not converge. See the description of WORK
                above for details. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer orcsd(char* jobu1, char* jobu2, char* jobv1t, char* jobv2t, char* trans, char* signs, integer* m, integer* p, integer* q, T* x11, integer* ldx11, T* x12, integer* ldx12, T* x21, integer* ldx21, T* x22, integer* ldx22, T* theta, T* u1, integer* ldu1, T* u2, integer* ldu2, T* v1t, integer* ldv1t, T* v2t, integer* ldv2t, T *work, integer *lwork, integer *iwork, integer *info)
{
  return orcsd(jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, work, lwork, iwork, info);
}
template< typename T, typename Ta >
integer uncsd(char* jobu1, char* jobu2, char* jobv1t, char* jobv2t, char* trans, char* signs, integer* m, integer* p, integer* q, T* x11, integer* ldx11, T* x12, integer* ldx12, T* x21, integer* ldx21, T* x22, integer* ldx22, Ta* theta, T* u1, integer* ldu1, T* u2, integer* ldu2, T* v1t, integer* ldv1t, T* v2t, integer* ldv2t, T* work, integer* lwork, Ta* rwork, integer* lrwork, integer* iwork, integer* info)
{
  return uncsd(jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, work, lwork, rwork, lrwork, iwork, info);
}

/*! @brief ORCSD2BY1 computes the CS decomposition of an M-by-Q matrix X with orthonormal columns

 * @details
 * \b Purpose:
    \verbatim 
     ORCSD2BY1 computes the CS decomposition of an M-by-Q matrix X with
     orthonormal columns that has been partitioned into a 2-by-1 block
     structure:

                                    [  I1 0  0 ]
                                    [  0  C  0 ]
              [ X11 ]   [ U1 |    ] [  0  0  0 ]
          X = [-----] = [---------] [----------] V1**T .
              [ X21 ]   [    | U2 ] [  0  0  0 ]
                                    [  0  S  0 ]
                                    [  0  0  I2]

     X11 is P-by-Q. The orthogonal matrices U1, U2, and V1 are P-by-P,
     (M-P)-by-(M-P), and Q-by-Q, respectively. C and S are R-by-R
     nonnegative diagonal matrices satisfying C^2 + S^2 = I, in which
     R = MIN(P,M-P,Q,M-Q). I1 is a K1-by-K1 identity matrix and I2 is a
     K2-by-K2 identity matrix, where K1 = MAX(Q+P-M,0), K2 = MAX(Q-P,0).
    \endverbatim  

 * @param[in] JOBU1
          JOBU1 is CHARACTER \n
          = 'Y':      U1 is computed; \n
          otherwise:  U1 is not computed. \n
 * @param[in] JOBU2
          JOBU2 is CHARACTER \n
          = 'Y':      U2 is computed; \n
          otherwise:  U2 is not computed. \n
 * @param[in] JOBV1T
          JOBV1T is CHARACTER \n
          = 'Y':      V1T is computed; \n
          otherwise:  V1T is not computed. \n
 * @param[in] M
          M is INTEGER \n
          The number of rows in X. \n
 * @param[in] P
          P is INTEGER \n
          The number of rows in X11. 0 <= P <= M. \n
 * @param[in] Q
          Q is INTEGER \n
          The number of columns in X11 and X21. 0 <= Q <= M. \n
 * @param[in,out] X11
          X11 is REAL array, dimension (LDX11,Q) \n
          On entry, part of the orthogonal matrix whose CSD is desired. \n
 * @param[in] LDX11
          LDX11 is INTEGER \n
          The leading dimension of X11. LDX11 >= MAX(1,P). \n
 * @param[in,out] X21
          X21 is REAL array, dimension (LDX21,Q) \n
          On entry, part of the orthogonal matrix whose CSD is desired. \n
 * @param[in] LDX21
          LDX21 is INTEGER \n
          The leading dimension of X21. LDX21 >= MAX(1,M-P). \n
 * @param[out] THETA
          THETA is REAL array, dimension (R), in which R =
          MIN(P,M-P,Q,M-Q). \n
          C = DIAG( COS(THETA(1)), ... , COS(THETA(R))) and \n
          S = DIAG( SIN(THETA(1)), ... , SIN(THETA(R))). \n
 * @param[out] U1
          U1 is REAL array, dimension (P) \n
          If JOBU1 = 'Y', U1 contains the P-by-P orthogonal matrix U1. \n
 * @param[in] LDU1
          LDU1 is INTEGER \n
          The leading dimension of U1. If JOBU1 = 'Y', LDU1 >=
          MAX(1,P). \n
 * @param[out] U2
          U2 is REAL array, dimension (M-P) \n
          If JOBU2 = 'Y', U2 contains the (M-P)-by-(M-P) orthogonal
          matrix U2. \n
 * @param[in] LDU2
          LDU2 is INTEGER \n
          The leading dimension of U2. If JOBU2 = 'Y', LDU2 >=
          MAX(1,M-P). \n
 * @param[out] V1T
          V1T is REAL array, dimension (Q) \n
          If JOBV1T = 'Y', V1T contains the Q-by-Q matrix orthogonal
          matrix V1**T. \n
 * @param[in] LDV1T
          LDV1T is INTEGER \n
          The leading dimension of V1T. If JOBV1T = 'Y', LDV1T >=
          MAX(1,Q). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
          If INFO > 0 on exit, WORK(2:R) contains the values PHI(1),
          ..., PHI(R-1) that, together with THETA(1), ..., THETA(R),
          define the matrix in intermediate bidiagonal-block form
          remaining after nonconvergence. INFO specifies the number
          of nonzero PHI's. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the work array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (M-MIN(P,M-P,Q,M-Q)) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n
          > 0:  SBBCSD did not converge. See the description of WORK
                above for details. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer orcsd2by1(char* jobu1, char* jobu2, char* jobv1t, integer* m, integer* p, integer* q, T* x11, integer* ldx11, T* x21, integer* ldx21, T* theta, T* u1, integer* ldu1, T* u2, integer* ldu2, T* v1t, integer* ldv1t, T *work, integer *lwork, integer *iwork, integer *info)
{
  return orcsd2by1(jobu1, jobu2, jobv1t, m, p, q, x11, ldx11, x21, ldx21, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, work, lwork, iwork, info);
}
template< typename T, typename Ta >
integer uncsd2by1(char* jobu1, char* jobu2, char* jobv1t, integer* m, integer* p, integer* q, T* x11, integer* ldx11, T* x21, integer* ldx21, Ta* theta, T* u1, integer* ldu1, T* u2, integer* ldu2, T* v1t, integer* ldv1t, T* work, integer* lwork, Ta* rwork, integer* lrwork, integer* iwork, integer* info)
{
  return uncsd2by1(jobu1, jobu2, jobv1t, m, p, q, x11, ldx11, x21, ldx21, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, work, lwork, rwork, lrwork, iwork, info);
}

/*! @brief ORGQL generates an M-by-N real matrix Q with orthonormal columns

 * @details
 * \b Purpose:
    \verbatim
    ORGQL generates an M-by-N real matrix Q with orthonormal columns,
    which is defined as the last N columns of a product of K elementary
    reflectors of order M
          Q  =  H(k) . . . H(2) H(1)
    as returned by GEQLF.
    \endverbatim 

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix Q. M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix Q. M >= N >= 0. \n
 * @param[in] K
          K is INTEGER \n
          The number of elementary reflectors whose product defines the
          matrix Q. N >= K >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the (n-k+i)-th column must contain the vector which
          defines the elementary reflector H(i), for i = 1,2,...,k, as
          returned by SGEQLF in the last k columns of its array
          argument A. \n
          On exit, the M-by-N matrix Q. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The first dimension of the array A. LDA >= max(1,M). \n
 * @param[in] TAU
          TAU is REAL array, dimension (K) \n
          TAU(i) must contain the scalar factor of the elementary
          reflector H(i), as returned by GEQLF. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK. LWORK >= max(1,N).
          For optimum performance LWORK >= N*NB, where NB is the
          optimal blocksize. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument has an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer orgql(integer* m, integer* n, integer* k, T* a, integer* lda, T* tau, T* work, integer* lwork, integer* info)
{
  return orgql(m, n, k, a, lda, tau, work, lwork, info);
}
template< typename T >
integer ungql(integer* m, integer* n, integer* k, T* a, integer* lda,  T* tau, T* work, integer* lwork, integer* info)
{
  return ungql(m, n, k, a, lda, tau, work, lwork, info);
}

/*! @brief ORGRQ generates an M-by-N real matrix Q with orthonormal rows

 * @details
 * \b Purpose:
    \verbatim
     ORGRQ generates an M-by-N real matrix Q with orthonormal rows,
     which is defined as the last M rows of a product of K elementary
     reflectors of order N

           Q  =  H(1) H(2) . . . H(k)

     as returned by SGERQF.
    \endverbatim 

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix Q. M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix Q. N >= M. \n
 * @param[in] K
          K is INTEGER \n
          The number of elementary reflectors whose product defines the
          matrix Q. M >= K >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the (m-k+i)-th row must contain the vector which
          defines the elementary reflector H(i), for i = 1,2,...,k, as
          returned by SGERQF in the last k rows of its array argument
          A. \n
          On exit, the M-by-N matrix Q. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The first dimension of the array A. LDA >= max(1,M). \n
 * @param[in] TAU
          TAU is REAL array, dimension (K) \n
          TAU(i) must contain the scalar factor of the elementary
          reflector H(i), as returned by SGERQF. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK. LWORK >= max(1,M).
          For optimum performance LWORK >= M*NB, where NB is the
          optimal blocksize. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument has an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer orgrq(integer* m, integer* n, integer* k, T* a, integer* lda, T* tau, T* work, integer* lwork, integer* info)
{
  return orgrq(m, n, k, a, lda, tau, work, lwork, info);
}
template< typename T >
integer ungrq(integer* m, integer* n, integer* k, T* a, integer* lda, T* tau, T* work, integer* lwork, integer* info)
{
  return ungrq( m, n, k, a, lda, tau, work, lwork, info);
}

/*! @brief ORMQL overwrites the general real M-by-N matrix

 * @details
 * \b Purpose:
    \verbatim
     ORMQL overwrites the general real M-by-N matrix C with

                     SIDE = 'L'     SIDE = 'R'
     TRANS = 'N':      Q * C          C * Q
     TRANS = 'T':      Q**T * C       C * Q**T

     where Q is a real orthogonal matrix defined as the product of k
     elementary reflectors

           Q = H(k) . . . H(2) H(1)

     as returned by SGEQLF. Q is of order M if SIDE = 'L' and of order N
     if SIDE = 'R'.
    \endverbatim 

 * @param[in] SIDE
          SIDE is CHARACTER*1 \n
          = 'L': apply Q or Q**T from the Left; \n
          = 'R': apply Q or Q**T from the Right. \n
 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          = 'N':  No transpose, apply Q; \n
          = 'T':  Transpose, apply Q**T. \n
 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix C. M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix C. N >= 0. \n
 * @param[in] K
          K is INTEGER \n
          The number of elementary reflectors whose product defines
          the matrix Q. \n
          If SIDE = 'L', M >= K >= 0; \n
          if SIDE = 'R', N >= K >= 0. \n
 * @param[in] A
          A is REAL array, dimension (LDA,K) \n
          The i-th column must contain the vector which defines the
          elementary reflector H(i), for i = 1,2,...,k, as returned by
          SGEQLF in the last k columns of its array argument A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A. \n
          If SIDE = 'L', LDA >= max(1,M); \n
          if SIDE = 'R', LDA >= max(1,N). \n
 * @param[in] TAU
          TAU is REAL array, dimension (K) \n
          TAU(i) must contain the scalar factor of the elementary
          reflector H(i), as returned by SGEQLF. \n
 * @param[in,out] C
          C is REAL array, dimension (LDC,N) \n
          On entry, the M-by-N matrix C. \n
          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q. \n
 * @param[in] LDC
          LDC is INTEGER \n
          The leading dimension of the array C. LDC >= max(1,M). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK. \n
          If SIDE = 'L', LWORK >= max(1,N); \n
          if SIDE = 'R', LWORK >= max(1,M). \n
          For good performance, LWORK should generally be larger. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer ormql(char* side, char* trans, integer* m, integer* n, integer* k,  T* a, integer* lda,  T* tau, T* c, integer* ldc, T* work, integer* lwork, integer* info)
{
  return ormql(side, trans, m, n, k,  a, lda,  tau, c, ldc, work, lwork, info);
}
template< typename T >
integer unmql(char* side, char* trans, integer* m, integer* n, integer* k,  T* a, integer* lda,  T* tau, T* c, integer* ldc, T* work, integer* lwork, integer* info)
{
  return unmql(side, trans, m, n, k,  a, lda,  tau, c, ldc, work, lwork, info);
}

/*! @brief ORMRQ overwrites the general real M-by-N matrix 

 * @details
 * \b Purpose:
    \verbatim
     ORMRQ overwrites the general real M-by-N matrix C with

                     SIDE = 'L'     SIDE = 'R'
     TRANS = 'N':      Q * C          C * Q
     TRANS = 'T':      Q**T * C       C * Q**T

     where Q is a real orthogonal matrix defined as the product of k
     elementary reflectors

           Q = H(1) H(2) . . . H(k)

     as returned by SGERQF. Q is of order M if SIDE = 'L' and of order N
     if SIDE = 'R'.
    \endverbatim 

 * @param[in] SIDE
          SIDE is CHARACTER*1 \n
          = 'L': apply Q or Q**T from the Left; \n
          = 'R': apply Q or Q**T from the Right. \n
 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          = 'N':  No transpose, apply Q; \n
          = 'T':  Transpose, apply Q**T. \n
 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix C. M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix C. N >= 0. \n
 * @param[in] K
          K is INTEGER \n
          The number of elementary reflectors whose product defines
          the matrix Q. \n
          If SIDE = 'L', M >= K >= 0; \n
          if SIDE = 'R', N >= K >= 0. \n
 * @param[in] A
          A is REAL array, dimension \n
                               (LDA,M) if SIDE = 'L', \n
                               (LDA,N) if SIDE = 'R' \n
          The i-th row must contain the vector which defines the
          elementary reflector H(i), for i = 1,2,...,k, as returned by
          SGERQF in the last k rows of its array argument A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A. LDA >= max(1,K). \n
 * @param[in] TAU
          TAU is REAL array, dimension (K) \n
          TAU(i) must contain the scalar factor of the elementary
          reflector H(i), as returned by SGERQF. \n
 * @param[in,out] C
          C is REAL array, dimension (LDC,N) \n
          On entry, the M-by-N matrix C. \n
          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q. \n
 * @param[in] LDC
          LDC is INTEGER \n
          The leading dimension of the array C. LDC >= max(1,M). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK. \n
          If SIDE = 'L', LWORK >= max(1,N); \n
          if SIDE = 'R', LWORK >= max(1,M). \n
          For good performance, LWORK should generally be larger. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer ormrq(char* side, char* trans, integer* m, integer* n, integer* k, T* a, integer* lda, T* tau, T* c, integer* ldc, T* work, integer* lwork, integer* info)
{
  return ormrq(side, trans, m, n, k,  a, lda,  tau, c, ldc, work, lwork, info);
}
template< typename T >
integer unmrq(char* side, char* trans, integer* m, integer* n, integer* k, T* a, integer* lda, T* tau, T* c, integer* ldc, T* work, integer* lwork, integer* info)
{
  return unmrq(side, trans, m, n, k,  a, lda,  tau, c, ldc, work, lwork, info);
}

/*! @brief ORMRZ overwrites the general real M-by-N matrix

 * @details
 * \b Purpose:
    \verbatim
     ORMRZ overwrites the general real M-by-N matrix C with

                     SIDE = 'L'     SIDE = 'R'
     TRANS = 'N':      Q * C          C * Q
     TRANS = 'T':      Q**T * C       C * Q**T

     where Q is a real orthogonal matrix defined as the product of k
     elementary reflectors

           Q = H(1) H(2) . . . H(k)

     as returned by STZRZF. Q is of order M if SIDE = 'L' and of order N
     if SIDE = 'R'.
    \endverbatim 
*
*  Arguments:
*  ==========
*
 * @param[in] SIDE
          SIDE is CHARACTER*1 \n
          = 'L': apply Q or Q**T from the Left; \n
          = 'R': apply Q or Q**T from the Right. \n
 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          = 'N':  No transpose, apply Q; \n
          = 'T':  Transpose, apply Q**T. \n
 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix C. M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix C. N >= 0. \n
 * @param[in] K
          K is INTEGER \n
          The number of elementary reflectors whose product defines
          the matrix Q. \n
          If SIDE = 'L', M >= K >= 0; \n
          if SIDE = 'R', N >= K >= 0. \n
 * @param[in] L
          L is INTEGER \n
          The number of columns of the matrix A containing
          the meaningful part of the Householder reflectors. \n
          If SIDE = 'L', M >= L >= 0, if SIDE = 'R', N >= L >= 0. \n
 * @param[in] A
          A is REAL array, dimension \n
                               (LDA,M) if SIDE = 'L', \n
                               (LDA,N) if SIDE = 'R' \n
          The i-th row must contain the vector which defines the
          elementary reflector H(i), for i = 1,2,...,k, as returned by
          STZRZF in the last k rows of its array argument A.
          A is modified by the routine but restored on exit. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A. LDA >= max(1,K). \n
 * @param[in] TAU
          TAU is REAL array, dimension (K) \n
          TAU(i) must contain the scalar factor of the elementary
          reflector H(i), as returned by STZRZF. \n
 * @param[in,out] C
          C is REAL array, dimension (LDC,N) \n
          On entry, the M-by-N matrix C. \n
          On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q. \n
 * @param[in] LDC
          LDC is INTEGER \n
          The leading dimension of the array C. LDC >= max(1,M). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK. \n
          If SIDE = 'L', LWORK >= max(1,N); \n
          if SIDE = 'R', LWORK >= max(1,M). \n
          For good performance, LWORK should generally be larger. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer ormrz(char* side, char* trans, integer* m, integer* n, integer* k, integer* l,  T* a, integer* lda,  T* tau, T* c, integer* ldc, T* work, integer* lwork, integer* info)
{
  return ormrz(side, trans, m, n, k, l,  a, lda,  tau, c, ldc, work, lwork, info);
}
template< typename T >
integer unmrz(char* side, char* trans, integer* m, integer* n, integer* k, integer* l,  T* a, integer* lda,  T* tau, T* c, integer* ldc, T* work, integer* lwork, integer* info)
{
  return unmrz(side, trans, m, n, k, l,  a, lda,  tau, c, ldc, work, lwork, info);
}

/*! @brief ORGHR generates a real orthogonal matrix Q

 * @details
 * \b Purpose:
    \verbatim 
     ORGHR generates a real orthogonal matrix Q which is defined as the
     product of IHI-ILO elementary reflectors of order N, as returned by
     SGEHRD:

     Q = H(ilo) H(ilo+1) . . . H(ihi-1).
    \endverbatim  

 * @param[in] N
          N is INTEGER \n
          The order of the matrix Q. N >= 0. \n
 * @param[in] ILO
          ILO is INTEGER \n
 * @param[in] IHI
          IHI is INTEGER \n
          ILO and IHI must have the same values as in the previous call
          of SGEHRD. Q is equal to the unit matrix except in the
          submatrix Q(ilo+1:ihi,ilo+1:ihi). \n
          1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the vectors which define the elementary reflectors,
          as returned by SGEHRD. \n
          On exit, the N-by-N orthogonal matrix Q. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A. LDA >= max(1,N). \n
 * @param[in] TAU
          TAU is REAL array, dimension (N-1) \n
          TAU(i) must contain the scalar factor of the elementary
          reflector H(i), as returned by SGEHRD. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK. LWORK >= IHI-ILO.
          For optimum performance LWORK >= (IHI-ILO)*NB, where NB is
          the optimal blocksize. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer orghr(integer* n, integer* ilo, integer* ihi, T* a, integer* lda, T* tau, T *work, integer *lwork, integer *info)
{
  return orghr(n, ilo, ihi, a, lda, tau, work, lwork, info);
}
template< typename T >
integer unghr(integer* n, integer* ilo, integer* ihi, T* a, integer* lda,  T* tau, T* work, integer* lwork, integer* info)
{
  return unghr(n, ilo, ihi, a, lda, tau, work, lwork, info);
}

/*! @brief ORMHR overwrites the general real M-by-N matrix C

 * @details
 * \b Purpose:
    \verbatim 
    ORMHR overwrites the general real M-by-N matrix C with

                    SIDE = 'L'     SIDE = 'R'
    TRANS = 'N':      Q * C          C * Q
    TRANS = 'T':      Q**T * C       C * Q**T

    where Q is a real orthogonal matrix of order nq, with nq = m if
    SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
    IHI-ILO elementary reflectors, as returned by SGEHRD:

    Q = H(ilo) H(ilo+1) . . . H(ihi-1).
    \endverbatim  

 * @param[in] SIDE
          SIDE is CHARACTER*1 \n
          = 'L': apply Q or Q**T from the Left; \n
          = 'R': apply Q or Q**T from the Right. \n
 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          = 'N':  No transpose, apply Q; \n
          = 'T':  Transpose, apply Q**T. \n
 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix C. M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix C. N >= 0. \n
 * @param[in] ILO
          ILO is INTEGER \n
 * @param[in] IHI
          IHI is INTEGER \n
          ILO and IHI must have the same values as in the previous call
          of SGEHRD. Q is equal to the unit matrix except in the
          submatrix Q(ilo+1:ihi,ilo+1:ihi). \n
          If SIDE = 'L', then 1 <= ILO <= IHI <= M, if M > 0, and
          ILO = 1 and IHI = 0, if M = 0; \n
          if SIDE = 'R', then 1 <= ILO <= IHI <= N, if N > 0, and
          ILO = 1 and IHI = 0, if N = 0. \n
 * @param[in] A
          A is REAL array, dimension \n
                               (LDA,M) if SIDE = 'L' \n
                               (LDA,N) if SIDE = 'R' \n
          The vectors which define the elementary reflectors, as
          returned by SGEHRD. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A. \n
          LDA >= max(1,M) if SIDE = 'L'; LDA >= max(1,N) if SIDE = 'R'. \n
 * @param[in] TAU
          TAU is REAL array, dimension \n
                               (M-1) if SIDE = 'L' \n
                               (N-1) if SIDE = 'R' \n
          TAU(i) must contain the scalar factor of the elementary
          reflector H(i), as returned by SGEHRD. \n
 * @param[in,out] C
          C is REAL array, dimension (LDC,N) \n
          On entry, the M-by-N matrix C. \n
          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q. \n
 * @param[in] LDC
          LDC is INTEGER \n
          The leading dimension of the array C. LDC >= max(1,M). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK. \n
          If SIDE = 'L', LWORK >= max(1,N); \n
          if SIDE = 'R', LWORK >= max(1,M). \n
          For optimum performance LWORK >= N*NB if SIDE = 'L', and
          LWORK >= M*NB if SIDE = 'R', where NB is the optimal
          blocksize. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer ormhr(char* side, char* trans, integer* m, integer* n, integer* ilo, integer* ihi,  T* a, integer* lda,  T* tau, T* c, integer* ldc, T *work, integer *lwork, integer *info)
{
  return ormhr(side, trans, m, n, ilo, ihi,  a, lda,  tau, c, ldc, work, lwork, info);
}
template< typename T >
integer unmhr(char* side, char* trans, integer* m, integer* n, integer* ilo, integer* ihi,  T* a, integer* lda,  T* tau, T* c, integer* ldc, T* work, integer* lwork, integer* info)
{
  return unmhr(side, trans, m, n, ilo, ihi,  a, lda,  tau, c, ldc, work, lwork, info);
}

/*! @brief PBCON estimates the reciprocal of the condition number

 * @details
 * \b Purpose:
    \verbatim
     PBCON estimates the reciprocal of the condition number (in the
     1-norm) of a real symmetric positive definite band matrix using the
     Cholesky factorization A = U**T*U or A = L*L**T computed by SPBTRF.

     An estimate is obtained for norm(inv(A)), and the reciprocal of the
     condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangular factor stored in AB; \n
          = 'L':  Lower triangular factor stored in AB. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] KD
          KD is INTEGER \n
          The number of superdiagonals of the matrix A if UPLO = 'U',
          or the number of subdiagonals if UPLO = 'L'.  KD >= 0. \n
 * @param[in] AB
          AB is REAL array, dimension (LDAB,N) \n
          The triangular factor U or L from the Cholesky factorization
          A = U**T*U or A = L*L**T of the band matrix A, stored in the
          first KD+1 rows of the array.  The j-th column of U or L is
          stored in the j-th column of the array AB as follows:
          if UPLO ='U', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)<=i<=j;
          if UPLO ='L', AB(1+i-j,j)    = L(i,j) for j<=i<=min(n,j+kd). \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          The leading dimension of the array AB.  LDAB >= KD+1. \n
 * @param[in] ANORM
          ANORM is REAL \n
          The 1-norm (or infinity-norm) of the symmetric band matrix A. \n
 * @param[out] RCOND
          RCOND is REAL \n
          The reciprocal of the condition number of the matrix A,
          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
          estimate of the 1-norm of inv(A) computed in this routine. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (3*N) \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer pbcon(char* uplo, integer* n, integer* kd,  T* ab, integer* ldab, T* anorm, T* rcond, T* work, integer* iwork, integer* info)
{
  return pbcon(uplo, n, kd,  ab, ldab, anorm, rcond, work, iwork, info);
}
template< typename T , typename Ta >
integer pbcon(char* uplo, integer* n, integer* kd,  T* ab, integer* ldab, Ta* anorm, Ta* rcond, T* work, Ta* rwork, integer* info)
{
  return pbcon(uplo, n, kd,  ab, ldab, anorm, rcond, work, rwork, info);
}

/*! @brief PBEQU computes row and column scalings

 * @details
 * \b Purpose:
    \verbatim
     PBEQU computes row and column scalings intended to equilibrate a
     symmetric positive definite band matrix A and reduce its condition
     number (with respect to the two-norm).  S contains the scale factors,
     S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
     elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This
     choice of S puts the condition number of B within a factor N of the
     smallest possible condition number over all possible diagonal
     scalings.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangular of A is stored; \n
          = 'L':  Lower triangular of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] KD
          KD is INTEGER \n
          The number of superdiagonals of the matrix A if UPLO = 'U',
          or the number of subdiagonals if UPLO = 'L'.  KD >= 0. \n
 * @param[in] AB
          AB is REAL array, dimension (LDAB,N) \n
          The upper or lower triangle of the symmetric band matrix A,
          stored in the first KD+1 rows of the array.  The j-th column
          of A is stored in the j-th column of the array AB as follows: \n
          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j; \n
          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd). \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          The leading dimension of the array A.  LDAB >= KD+1. \n
 * @param[out] S
          S is REAL array, dimension (N) \n
          If INFO = 0, S contains the scale factors for A. \n
 * @param[out] SCOND
          SCOND is REAL \n
          If INFO = 0, S contains the ratio of the smallest S(i) to
          the largest S(i).  If SCOND >= 0.1 and AMAX is neither too
          large nor too small, it is not worth scaling by S. \n
 * @param[out] AMAX
          AMAX is REAL \n
          Absolute value of largest matrix element.  If AMAX is very
          close to overflow or very close to underflow, the matrix
          should be scaled. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n
          > 0:  if INFO = i, the i-th diagonal element is nonpositive. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer pbequ(char* uplo, integer* n, integer* kd,  T* ab, integer* ldab, T* s, T* scond, T* amax, integer* info)
{
  return pbequ(uplo, n, kd,  ab, ldab, s, scond, amax, info);
}
template< typename T , typename Ta >
integer pbequ(char* uplo, integer* n, integer* kd,  T* ab, integer* ldab, T* s, Ta* scond, Ta* amax, integer* info)
{
  return pbequ(uplo, n, kd,  ab, ldab, s, scond, amax, info);
}

/*! @brief PBRFS improves the computed solution to a system of linear equations

 * @details
 * \b Purpose:
    \verbatim
     PBRFS improves the computed solution to a system of linear
     equations when the coefficient matrix is symmetric positive definite
     and banded, and provides error bounds and backward error estimates
     for the solution.
    \endverbatim

 * @param[in] UPLOz
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] KD
          KD is INTEGER \n
          The number of superdiagonals of the matrix A if UPLO = 'U',
          or the number of subdiagonals if UPLO = 'L'.  KD >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrices B and X.  NRHS >= 0. \n
 * @param[in] AB
          AB is REAL array, dimension (LDAB,N) \n
          The upper or lower triangle of the symmetric band matrix A,
          stored in the first KD+1 rows of the array.  The j-th column
          of A is stored in the j-th column of the array AB as follows: \n
          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j; \n
          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd). \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          The leading dimension of the array AB.  LDAB >= KD+1. \n
 * @param[in] AFB
          AFB is REAL array, dimension (LDAFB,N) \n
          The triangular factor U or L from the Cholesky factorization
          A = U**T*U or A = L*L**T of the band matrix A as computed by
          SPBTRF, in the same storage format as A (see AB). \n
 * @param[in] LDAFB
          LDAFB is INTEGER \n
          The leading dimension of the array AFB.  LDAFB >= KD+1. \n
 * @param[in] B
          B is REAL array, dimension (LDB,NRHS) \n
          The right hand side matrix B. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[in,out] X
          X is REAL array, dimension (LDX,NRHS) \n
          On entry, the solution matrix X, as computed by SPBTRS. \n
          On exit, the improved solution matrix X. \n
 * @param[in] LDX
          LDX is INTEGER \n
          The leading dimension of the array X.  LDX >= max(1,N). \n
 * @param[out] FERR
          FERR is REAL array, dimension (NRHS) \n
          The estimated forward error bound for each solution vector
          X(j) (the j-th column of the solution matrix X). \n
          If XTRUE is the true solution corresponding to X(j), FERR(j)
          is an estimated upper bound for the magnitude of the largest
          element in (X(j) - XTRUE) divided by the magnitude of the
          largest element in X(j).  The estimate is as reliable as
          the estimate for RCOND, and is almost always a slight
          overestimate of the true error. \n
  * @param[out] BERR
          BERR is REAL array, dimension (NRHS) \n
          The componentwise relative backward error of each solution
          vector X(j) (i.e., the smallest relative change in
          any element of A or B that makes X(j) an exact solution). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (3*N) \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer pbrfs(char* uplo, integer* n, integer* kd, integer* nrhs,  T* ab, integer* ldab,  T* afb, integer* ldafb,  T* b, integer* ldb, T* x, integer* ldx, T* ferr, T* berr, T* work, integer* iwork, integer* info)
{
  return pbrfs(uplo, n, kd, nrhs,  ab, ldab,  afb, ldafb,  b, ldb, x, ldx, ferr, berr, work, iwork, info);
}
template< typename T, typename Ta >
integer pbrfs(char* uplo, integer* n, integer* kd, integer* nrhs,  T* ab, integer* ldab,  T* afb, integer* ldafb,  T* b, integer* ldb, T* x, integer* ldx, Ta* ferr, Ta* berr, T* work, Ta* rwork, integer* info)
{
  return pbrfs(uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, ldx, ferr, berr, work, rwork, info);
}

/*! @brief PBSTF computes a split Cholesky factorization of a real symmetric \n
     positive definite band matrix

 * @details
 * \b Purpose:
    \verbatim
     PBSTF computes a split Cholesky factorization of a real
     symmetric positive definite band matrix A.

     This routine is designed to be used in conjunction with SSBGST.

     The factorization has the form  A = S**T*S  where S is a band matrix
     of the same bandwidth as A and the following structure:

       S = ( U   )
           ( M  L)

     where U is upper triangular of order m = (n+kd)/2, and L is lower
     triangular of order n-m.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] KD
          KD is INTEGER \n
          The number of superdiagonals of the matrix A if UPLO = 'U',
          or the number of subdiagonals if UPLO = 'L'.  KD >= 0. \n
 * @param[in,out] AB
          AB is REAL array, dimension (LDAB,N) \n
          On entry, the upper or lower triangle of the symmetric band
          matrix A, stored in the first kd+1 rows of the array. The
          j-th column of A is stored in the j-th column of the array AB
          as follows: \n
          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j; \n
          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd). \n
 \n
          On exit, if INFO = 0, the factor S from the split Cholesky
          factorization A = S**T*S. See Further Details. \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          The leading dimension of the array AB.  LDAB >= KD+1. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n
          > 0: if INFO = i, the factorization could not be completed,
               because the updated element a(i,i) was negative; the
               matrix A is not positive definite. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer pbstf(char* uplo, integer* n, integer* kb, T* bb, integer* ldbb, integer* info)
{
  return pbstf(uplo, n, kb, bb, ldbb, info);
}

/*! @brief PBSV computes the solution to system of linear equations A * X = B for OTHER matrices

 * @details
 * \b Purpose:
    \verbatim
     PBSV computes the solution to a real system of linear equations
        A * X = B,
     where A is an N-by-N symmetric positive definite band matrix and X
     and B are N-by-NRHS matrices.

     The Cholesky decomposition is used to factor A as
        A = U**T * U,  if UPLO = 'U', or
        A = L * L**T,  if UPLO = 'L',
     where U is an upper triangular band matrix, and L is a lower
     triangular band matrix, with the same number of superdiagonals or
     subdiagonals as A.  The factored form of A is then used to solve the
     system of equations A * X = B.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] KD
          KD is INTEGER \n
          The number of superdiagonals of the matrix A if UPLO = 'U',
          or the number of subdiagonals if UPLO = 'L'.  KD >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in,out] AB
          AB is REAL array, dimension (LDAB,N) \n
          On entry, the upper or lower triangle of the symmetric band
          matrix A, stored in the first KD+1 rows of the array.  The
          j-th column of A is stored in the j-th column of the array AB
          as follows: \n
          if UPLO = 'U', AB(KD+1+i-j,j) = A(i,j) for max(1,j-KD)<=i<=j; \n
          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(N,j+KD). \n
          See below for further details. \n
 \n
          On exit, if INFO = 0, the triangular factor U or L from the
          Cholesky factorization A = U**T*U or A = L*L**T of the band
          matrix A, in the same storage format as A. \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          The leading dimension of the array AB.  LDAB >= KD+1. \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,NRHS) \n
          On entry, the N-by-NRHS right hand side matrix B. \n
          On exit, if INFO = 0, the N-by-NRHS solution matrix X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, the leading minor of order i of A is not
                positive definite, so the factorization could not be
                completed, and the solution has not been computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer pbsv(char* uplo, integer* n, integer* kd, integer* nrhs, T* ab, integer* ldab, T* b, integer* ldb, integer* info)
{
  return pbsv(uplo, n, kd, nrhs, ab, ldab, b, ldb, info);
}

/*! @brief PBSVX computes the solution to system of linear equations A * X = B for OTHER matrices

 * @details
 * \b Purpose:
    \verbatim
     PBSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to
     compute the solution to a real system of linear equations
        A * X = B,
     where A is an N-by-N symmetric positive definite band matrix and X
     and B are N-by-NRHS matrices.

     Error bounds on the solution and a condition estimate are also
     provided.
     
    * \b Description:
      =================

     The following steps are performed:

     1. If FACT = 'E', real scaling factors are computed to equilibrate
        the system:
           diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B
        Whether or not the system will be equilibrated depends on the
        scaling of the matrix A, but if equilibration is used, A is
        overwritten by diag(S)*A*diag(S) and B by diag(S)*B.

     2. If FACT = 'N' or 'E', the Cholesky decomposition is used to
        factor the matrix A (after equilibration if FACT = 'E') as
           A = U**T * U,  if UPLO = 'U', or
           A = L * L**T,  if UPLO = 'L',
        where U is an upper triangular band matrix, and L is a lower
        triangular band matrix.

     3. If the leading i-by-i principal minor is not positive definite,
        then the routine returns with INFO = i. Otherwise, the factored
        form of A is used to estimate the condition number of the matrix
        A.  If the reciprocal of the condition number is less than machine
        precision, INFO = N+1 is returned as a warning, but the routine
        still goes on to solve for X and compute error bounds as
        described below.

     4. The system of equations is solved for X using the factored form
        of A.

     5. Iterative refinement is applied to improve the computed solution
        matrix and calculate error bounds and backward error estimates
        for it.

     6. If equilibration was used, the matrix X is premultiplied by
        diag(S) so that it solves the original system before
        equilibration.
    \endverbatim 

 * @param[in] FACT
          FACT is CHARACTER*1 \n
          Specifies whether or not the factored form of the matrix A is
          supplied on entry, and if not, whether the matrix A should be
          equilibrated before it is factored. \n
          = 'F':  On entry, AFB contains the factored form of A.
                  If EQUED = 'Y', the matrix A has been equilibrated
                  with scaling factors given by S.  AB and AFB will not
                  be modified. \n
          = 'N':  The matrix A will be copied to AFB and factored. \n
          = 'E':  The matrix A will be equilibrated if necessary, then
                  copied to AFB and factored. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] KD
          KD is INTEGER \n
          The number of superdiagonals of the matrix A if UPLO = 'U',
          or the number of subdiagonals if UPLO = 'L'.  KD >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right-hand sides, i.e., the number of columns
          of the matrices B and X.  NRHS >= 0. \n
 * @param[in,out] AB
          AB is REAL array, dimension (LDAB,N) \n
          On entry, the upper or lower triangle of the symmetric band
          matrix A, stored in the first KD+1 rows of the array, except
          if FACT = 'F' and EQUED = 'Y', then A must contain the
          equilibrated matrix diag(S)*A*diag(S).  The j-th column of A
          is stored in the j-th column of the array AB as follows: \n
          if UPLO = 'U', AB(KD+1+i-j,j) = A(i,j) for max(1,j-KD)<=i<=j; \n
          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(N,j+KD). \n
          See below for further details. \n
 \n
          On exit, if FACT = 'E' and EQUED = 'Y', A is overwritten by
          diag(S)*A*diag(S). \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          The leading dimension of the array A.  LDAB >= KD+1. \n
 * @param[in,out] AFB
          AFB is REAL array, dimension (LDAFB,N) \n
          If FACT = 'F', then AFB is an input argument and on entry
          contains the triangular factor U or L from the Cholesky
          factorization A = U**T*U or A = L*L**T of the band matrix
          A, in the same storage format as A (see AB).  If EQUED = 'Y',
          then AFB is the factored form of the equilibrated matrix A. \n
 \n
          If FACT = 'N', then AFB is an output argument and on exit
          returns the triangular factor U or L from the Cholesky
          factorization A = U**T*U or A = L*L**T. \n
 \n
          If FACT = 'E', then AFB is an output argument and on exit
          returns the triangular factor U or L from the Cholesky
          factorization A = U**T*U or A = L*L**T of the equilibrated
          matrix A (see the description of A for the form of the
          equilibrated matrix). \n
 * @param[in] LDAFB
          LDAFB is INTEGER \n
          The leading dimension of the array AFB.  LDAFB >= KD+1. \n
 * @param[in,out] EQUED
          EQUED is CHARACTER*1 \n
          Specifies the form of equilibration that was done. \n
          = 'N':  No equilibration (always true if FACT = 'N'). \n
          = 'Y':  Equilibration was done, i.e., A has been replaced by
                  diag(S) * A * diag(S). \n
          EQUED is an input argument if FACT = 'F'; otherwise, it is an
          output argument. \n
 * @param[in,out] S
          S is REAL array, dimension (N) \n
          The scale factors for A; not accessed if EQUED = 'N'.  S is
          an input argument if FACT = 'F'; otherwise, S is an output
          argument.  If FACT = 'F' and EQUED = 'Y', each element of S
          must be positive. \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,NRHS) \n
          On entry, the N-by-NRHS right hand side matrix B. \n
          On exit, if EQUED = 'N', B is not modified; if EQUED = 'Y',
          B is overwritten by diag(S) * B. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out] X
          X is REAL array, dimension (LDX,NRHS) \n
          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to
          the original system of equations.  Note that if EQUED = 'Y',
          A and B are modified on exit, and the solution to the
          equilibrated system is inv(diag(S))*X. \n
 * @param[in] LDX
          LDX is INTEGER \n
          The leading dimension of the array X.  LDX >= max(1,N). \n
 * @param[out] RCOND
          RCOND is REAL \n
          The estimate of the reciprocal condition number of the matrix
          A after equilibration (if done).  If RCOND is less than the
          machine precision (in particular, if RCOND = 0), the matrix
          is singular to working precision.  This condition is
          indicated by a return code of INFO > 0. \n
 * @param[out] FERR
          FERR is REAL array, dimension (NRHS) \n
          The estimated forward error bound for each solution vector
          X(j) (the j-th column of the solution matrix X).
          If XTRUE is the true solution corresponding to X(j), FERR(j)
          is an estimated upper bound for the magnitude of the largest
          element in (X(j) - XTRUE) divided by the magnitude of the
          largest element in X(j).  The estimate is as reliable as
          the estimate for RCOND, and is almost always a slight
          overestimate of the true error. \n
 * @param[out] BERR
          BERR is REAL array, dimension (NRHS) \n
          The componentwise relative backward error of each solution
          vector X(j) (i.e., the smallest relative change in
          any element of A or B that makes X(j) an exact solution). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (3*N) \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, and i is \n
                <= N:  the leading minor of order i of A is
                       not positive definite, so the factorization
                       could not be completed, and the solution has not
                       been computed. RCOND = 0 is returned. \n
                = N+1: U is nonsingular, but RCOND is less than machine
                       precision, meaning that the matrix is singular
                       to working precision.  Nevertheless, the
                       solution and error bounds are computed because
                       there are a number of situations where the
                       computed solution can be more accurate than the
                       value of RCOND would suggest. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer pbsvx(char* fact, char* uplo, integer* n, integer* kd, integer* nrhs, T* ab, integer* ldab, T* afb, integer* ldafb, char* equed, T* s, T* b, integer* ldb, T* x, integer* ldx, T* rcond, T* ferr, T* berr, T* work, integer* iwork, integer* info)
{
  return pbsvx(fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, iwork, info);
}
template< typename T, typename Ta >
integer pbsvx(char* fact, char* uplo, integer* n, integer* kd, integer* nrhs, T* ab, integer* ldab, T* afb, integer* ldafb, char* equed, Ta* s, T* b, integer* ldb, T* x, integer* ldx, Ta* rcond, Ta* ferr, Ta* berr, T* work, Ta* rwork, integer* info)
{
  return pbsvx(fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, rwork, info);
}

/*! @brief PBTRF computes the Cholesky factorization of a real symmetric  \n
     positive definite band matrix A.

 * @details
 * \b Purpose:
    \verbatim
     PBTRF computes the Cholesky factorization of a real symmetric
     positive definite band matrix A.

     The factorization has the form
        A = U**T * U,  if UPLO = 'U', or
        A = L  * L**T,  if UPLO = 'L',
     where U is an upper triangular matrix and L is lower triangular.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] KD
          KD is INTEGER \n
          The number of superdiagonals of the matrix A if UPLO = 'U',
          or the number of subdiagonals if UPLO = 'L'.  KD >= 0. \n
 * @param[in,out] AB
          AB is REAL array, dimension (LDAB,N) \n
          On entry, the upper or lower triangle of the symmetric band
          matrix A, stored in the first KD+1 rows of the array.  The
          j-th column of A is stored in the j-th column of the array AB
          as follows: \n
          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j; \n
          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd). \n
 \n
          On exit, if INFO = 0, the triangular factor U or L from the
          Cholesky factorization A = U**T*U or A = L*L**T of the band
          matrix A, in the same storage format as A. \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          The leading dimension of the array AB.  LDAB >= KD+1. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, the leading minor of order i is not
                positive definite, and the factorization could not be
                completed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer pbtrf(char* uplo, integer* n, integer* kd, T* ab, integer *ldab, integer* info)
{
  return pbtrf(uplo, n, kd, ab, ldab, info);
}

/*! @brief PBTRS solves a system of linear equations

 * @details
 * \b Purpose:
    \verbatim
    PBTRS solves a system of linear equations A*X = B with a symmetric
    positive definite band matrix A using the Cholesky factorization
    A = U**T*U or A = L*L**T computed by PBTRF.
    \endverbatim

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangular factor stored in AB; \n
          = 'L':  Lower triangular factor stored in AB. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] KD
          KD is INTEGER \n
          The number of superdiagonals of the matrix A if UPLO = 'U',
          or the number of subdiagonals if UPLO = 'L'.  KD >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in] AB
          AB is REAL array, dimension (LDAB,N) \n
          The triangular factor U or L from the Cholesky factorization
          A = U**T*U or A = L*L**T of the band matrix A, stored in the
          first KD+1 rows of the array.  The j-th column of U or L is
          stored in the j-th column of the array AB as follows: \n
          if UPLO ='U', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)<=i<=j; \n
          if UPLO ='L', AB(1+i-j,j)    = L(i,j) for j<=i<=min(n,j+kd). \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          The leading dimension of the array AB.  LDAB >= KD+1. \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,NRHS) \n
          On entry, the right hand side matrix B.
          On exit, the solution matrix X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer pbtrs(char* uplo, integer* n, integer* kd, integer* nrhs,  T* ab, integer* ldab, T* b, integer* ldb, integer* info)
{
  return pbtrs(uplo, n, kd, nrhs,  ab, ldab, b, ldb, info);
}

/*! @brief PFTRF computes the Cholesky factorization

 * @details
 * \b Purpose:
    \verbatim
     PFTRF computes the Cholesky factorization of a real symmetric
     positive definite matrix A.

     The factorization has the form
        A = U**T * U,  if UPLO = 'U', or
        A = L  * L**T,  if UPLO = 'L',
     where U is an upper triangular matrix and L is lower triangular.

     This is the block version of the algorithm, calling Level 3 BLAS.
    \endverbatim 

 * @param[in] TRANSR
          TRANSR is CHARACTER*1 \n
          = 'N':  The Normal TRANSR of RFP A is stored; \n
          = 'T':  The Transpose TRANSR of RFP A is stored. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of RFP A is stored; \n
          = 'L':  Lower triangle of RFP A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension ( N*(N+1)/2); \n
          On entry, the symmetric matrix A in RFP format. RFP format is
          described by TRANSR, UPLO, and N as follows: If TRANSR = 'N'
          then RFP A is (0:N,0:k-1) when N is even; k=N/2. RFP A is
          (0:N-1,0:k) when N is odd; k=N/2. IF TRANSR = 'T' then RFP is
          the transpose of RFP A as defined when
          TRANSR = 'N'. The contents of RFP A are defined by UPLO as
          follows: If UPLO = 'U' the RFP A contains the NT elements of
          upper packed A. If UPLO = 'L' the RFP A contains the elements
          of lower packed A. The LDA of RFP A is (N+1)/2 when TRANSR =
          'T'. When TRANSR is 'N' the LDA is N+1 when N is even and N
          is odd. See the Note below for more details. \n
 \n
          On exit, if INFO = 0, the factor U or L from the Cholesky
          factorization RFP A = U**T*U or RFP A = L*L**T. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, the leading minor of order i is not
                positive definite, and the factorization could not be
                completed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer pftrf(char* transr, char* uplo, integer* n, T* a, integer* info)
{
  return pftrf(transr, uplo, n, a, info);
}

/*! @brief PFTRI computes the inverse of a real (symmetric) positive definite matrix

 * @details
 * \b Purpose:
    \verbatim
     PFTRI computes the inverse of a real (symmetric) positive definite
     matrix A using the Cholesky factorization A = U**T*U or A = L*L**T
     computed by PFTRF.
    \endverbatim 

 * @param[in] TRANSR
          TRANSR is CHARACTER*1 \n
          = 'N':  The Normal TRANSR of RFP A is stored; \n
          = 'T':  The Transpose TRANSR of RFP A is stored. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension ( N*(N+1)/2) \n
          On entry, the symmetric matrix A in RFP format. RFP format is
          described by TRANSR, UPLO, and N as follows: If TRANSR = 'N'
          then RFP A is (0:N,0:k-1) when N is even; k=N/2. RFP A is
          (0:N-1,0:k) when N is odd; k=N/2. IF TRANSR = 'T' then RFP is
          the transpose of RFP A as defined when
          TRANSR = 'N'. The contents of RFP A are defined by UPLO as
          follows: If UPLO = 'U' the RFP A contains the nt elements of
          upper packed A. If UPLO = 'L' the RFP A contains the elements
          of lower packed A. The LDA of RFP A is (N+1)/2 when TRANSR =
          'T'. When TRANSR is 'N' the LDA is N+1 when N is even and N
          is odd. See the Note below for more details. \n
 \n
          On exit, the symmetric inverse of the original matrix, in the
          same storage format. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, the (i,i) element of the factor U or L is
                zero, and the inverse could not be computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer pftri(char* transr, char* uplo, integer* n, T* a, integer* info)
{
  return pftri(transr, uplo, n, a, info);
}

/*! @brief PFTRS solves a system of linear equations A*X = B with a symmetric positive definite matrix

 * @details
 * \b Purpose:
    \verbatim
     PFTRS solves a system of linear equations A*X = B with a symmetric
     positive definite matrix A using the Cholesky factorization
     A = U**T*U or A = L*L**T computed by PFTRF.
    \endverbatim 

 * @param[in] TRANSR
          TRANSR is CHARACTER*1 \n
          = 'N':  The Normal TRANSR of RFP A is stored; \n
          = 'T':  The Transpose TRANSR of RFP A is stored. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of RFP A is stored; \n
          = 'L':  Lower triangle of RFP A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in] A
          A is REAL array, dimension ( N*(N+1)/2) \n
          The triangular factor U or L from the Cholesky factorization
          of RFP A = U**H*U or RFP A = L*L**T, as computed by SPFTRF.
          See note below for more details about RFP A. \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,NRHS) \n
          On entry, the right hand side matrix B.
          On exit, the solution matrix X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer pftrs(char* transr, char* uplo, integer* n, integer* nrhs,  T* a, T* b, integer* ldb, integer* info)
{
  return pftrs(transr, uplo, n, nrhs, a, b, ldb, info);
}

/*! @brief POCON estimates the reciprocal of the condition number

 * @details
 * \b Purpose:
    \verbatim
     POCON estimates the reciprocal of the condition number (in the
     1-norm) of a real symmetric positive definite matrix using the
     Cholesky factorization A = U**T*U or A = L*L**T computed by SPOTRF.

     An estimate is obtained for norm(inv(A)), and the reciprocal of the
     condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          The triangular factor U or L from the Cholesky factorization
          A = U**T*U or A = L*L**T, as computed by SPOTRF. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] ANORM
          ANORM is REAL \n
          The 1-norm (or infinity-norm) of the symmetric matrix A. \n
 * @param[out] RCOND
          RCOND is REAL \n
          The reciprocal of the condition number of the matrix A,
          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
          estimate of the 1-norm of inv(A) computed in this routine. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (3*N) \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer pocon(char* uplo, integer* n,  T* a, integer* lda, T* anorm, T* rcond, T* work, integer* iwork, integer* info)
{
  return pocon(uplo, n,  a, lda, anorm, rcond, work, iwork, info);
}
template< typename T, typename Ta >
integer pocon(char* uplo, integer* n,  T* a, integer* lda, Ta* anorm, Ta* rcond, T* work, Ta* rwork, integer* info)
{
  return pocon(uplo, n,  a, lda, anorm, rcond, work, rwork, info);
}

/*! @brief POEQU computes row and column scalings

 * @details
 * \b Purpose:
    \verbatim
     POEQU computes row and column scalings intended to equilibrate a
     symmetric positive definite matrix A and reduce its condition number
     (with respect to the two-norm).  S contains the scale factors,
     S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
     elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This
     choice of S puts the condition number of B within a factor N of the
     smallest possible condition number over all possible diagonal
     scalings.
    \endverbatim 

 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          The N-by-N symmetric positive definite matrix whose scaling
          factors are to be computed.  Only the diagonal elements of A
          are referenced. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] S
          S is REAL array, dimension (N) \n
          If INFO = 0, S contains the scale factors for A. \n
 * @param[out] SCOND
          SCOND is REAL \n
          If INFO = 0, S contains the ratio of the smallest S(i) to
          the largest S(i).  If SCOND >= 0.1 and AMAX is neither too
          large nor too small, it is not worth scaling by S. \n
 * @param[out] AMAX
          AMAX is REAL \n
          Absolute value of largest matrix element.  If AMAX is very
          close to overflow or very close to underflow, the matrix
          should be scaled. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, the i-th diagonal element is nonpositive. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer poequ(integer* n,  T* a, integer* lda, T* s, T* scond, T* amax, integer* info)
{
  return poequ(n, a, lda, s, scond, amax, info);
}
template< typename T, typename Ta >
integer poequ(integer* n,  T* a, integer* lda, Ta* s, Ta* scond, Ta* amax, integer* info)
{
  return poequ(n, a, lda, s, scond, amax, info);
}

/*! @brief POEQUB computes row and column scalings

 * @details
 * \b Purpose:
    \verbatim
     POEQUB computes row and column scalings intended to equilibrate a
     symmetric positive definite matrix A and reduce its condition number
     (with respect to the two-norm).  S contains the scale factors,
     S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
     elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This
     choice of S puts the condition number of B within a factor N of the
     smallest possible condition number over all possible diagonal
     scalings.

     This routine differs from SPOEQU by restricting the scaling factors
     to a power of the radix.  Barring over- and underflow, scaling by
     these factors introduces no additional rounding errors.  However, the
     scaled diagonal entries are no longer approximately 1 but lie
     between sqrt(radix) and 1/sqrt(radix).
    \endverbatim 

 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          The N-by-N symmetric positive definite matrix whose scaling
          factors are to be computed.  Only the diagonal elements of A
          are referenced. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] S
          S is REAL array, dimension (N) \n
          If INFO = 0, S contains the scale factors for A. \n
 * @param[out] SCOND
          SCOND is REAL \n
          If INFO = 0, S contains the ratio of the smallest S(i) to
          the largest S(i).  If SCOND >= 0.1 and AMAX is neither too
          large nor too small, it is not worth scaling by S. \n
 * @param[out] AMAX
          AMAX is REAL \n
          Absolute value of largest matrix element.  If AMAX is very
          close to overflow or very close to underflow, the matrix
          should be scaled. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, the i-th diagonal element is nonpositive. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer poequb(integer* n, T* a, integer* lda, T* s, T* scond, T* amax, integer* info)
{
  return poequb(n, a, lda, s, scond, amax, info);
}
template< typename T, typename Ta >
integer poequb(integer* n, T* a, integer* lda, Ta* s, Ta* scond, Ta* amax, integer* info)
{
  return poequb(n, a, lda, s, scond, amax, info);
}

/*! @brief PORFS improves the computed solution to a system of linear equations

 * @details
 * \b Purpose:
    \verbatim
     PORFS improves the computed solution to a system of linear
     equations when the coefficient matrix is symmetric positive definite,
     and provides error bounds and backward error estimates for the
     solution.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrices B and X.  NRHS >= 0. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          The symmetric matrix A.  If UPLO = 'U', the leading N-by-N
          upper triangular part of A contains the upper triangular part
          of the matrix A, and the strictly lower triangular part of A
          is not referenced.  If UPLO = 'L', the leading N-by-N lower
          triangular part of A contains the lower triangular part of
          the matrix A, and the strictly upper triangular part of A is
          not referenced. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] AF
          AF is REAL array, dimension (LDAF,N) \n
          The triangular factor U or L from the Cholesky factorization
          A = U**T*U or A = L*L**T, as computed by SPOTRF. \n
 * @param[in] LDAF
          LDAF is INTEGER \n
          The leading dimension of the array AF.  LDAF >= max(1,N). \n
 * @param[in] B
          B is REAL array, dimension (LDB,NRHS) \n
          The right hand side matrix B. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[in,out] X
          X is REAL array, dimension (LDX,NRHS) \n
          On entry, the solution matrix X, as computed by SPOTRS.
          On exit, the improved solution matrix X. \n
 * @param[in] LDX
          LDX is INTEGER \n
          The leading dimension of the array X.  LDX >= max(1,N). \n
 * @param[out] FERR
          FERR is REAL array, dimension (NRHS) \n
          The estimated forward error bound for each solution vector
          X(j) (the j-th column of the solution matrix X). \n
          If XTRUE is the true solution corresponding to X(j), FERR(j)
          is an estimated upper bound for the magnitude of the largest
          element in (X(j) - XTRUE) divided by the magnitude of the
          largest element in X(j).  The estimate is as reliable as
          the estimate for RCOND, and is almost always a slight
          overestimate of the true error. \n
 * @param[out] BERR
          BERR is REAL array, dimension (NRHS) \n
          The componentwise relative backward error of each solution
          vector X(j) (i.e., the smallest relative change in
          any element of A or B that makes X(j) an exact solution). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (3*N) \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer porfs(char* uplo, integer* n, integer* nrhs, T* a, integer* lda, T* af, integer* ldaf, T* b, integer* ldb, T* x, integer* ldx, T* ferr, T* berr, T* work, integer* iwork, integer* info)
{
  return porfs(uplo, n, nrhs,  a, lda,  af, ldaf,  b, ldb, x, ldx, ferr, berr, work, iwork, info);
}
template< typename T , typename Ta>
integer porfs(char* uplo, integer* n, integer* nrhs, T* a, integer* lda, T* af, integer* ldaf, T* b, integer* ldb, T* x, integer* ldx, Ta* ferr, Ta* berr, T* work, Ta* rwork, integer* info)
{
  return porfs(uplo, n, nrhs,  a, lda,  af, ldaf,  b, ldb, x, ldx, ferr, berr, work, rwork, info);
}

/*! @brief PORFSX improves the computed solution to a system of linear equations

 * @details
 * \b Purpose:
    \verbatim
     PORFSX improves the computed solution to a system of linear
     equations when the coefficient matrix is symmetric positive
     definite, and provides error bounds and backward error estimates
     for the solution.  In addition to normwise error bound, the code
     provides maximum componentwise error bound if possible.  See
     comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the
     error bounds.
 
     The original system of linear equations may have been equilibrated
     before calling this routine, as described by arguments EQUED and S
     below. In this case, the solution and error bounds returned are
     for the original unequilibrated system.
    \endverbatim  
 
  * @param[in] UPLO
           UPLO is CHARACTER*1 \n
           = 'U':  Upper triangle of A is stored; \n
           = 'L':  Lower triangle of A is stored. \n
  * @param[in] EQUED
           EQUED is CHARACTER*1 \n
           Specifies the form of equilibration that was done to A
           before calling this routine. This is needed to compute
           the solution and error bounds correctly. \n
             = 'N':  No equilibration \n
             = 'Y':  Both row and column equilibration, i.e., A has been
                     replaced by diag(S) * A * diag(S).
                     The right hand side B has been changed accordingly. \n
  * @param[in] N
           N is INTEGER \n
           The order of the matrix A.  N >= 0. \n
  * @param[in] NRHS
           NRHS is INTEGER \n
           The number of right hand sides, i.e., the number of columns
           of the matrices B and X.  NRHS >= 0. \n
  * @param[in] A
           A is REAL array, dimension (LDA,N) \n
           The symmetric matrix A.  If UPLO = 'U', the leading N-by-N
           upper triangular part of A contains the upper triangular part
           of the matrix A, and the strictly lower triangular part of A
           is not referenced.  If UPLO = 'L', the leading N-by-N lower
           triangular part of A contains the lower triangular part of
           the matrix A, and the strictly upper triangular part of A is
           not referenced. \n
  * @param[in] LDA
           LDA is INTEGER \n
           The leading dimension of the array A.  LDA >= max(1,N). \n
  * @param[in] AF
           AF is REAL array, dimension (LDAF,N) \n
           The triangular factor U or L from the Cholesky factorization
           A = U**T*U or A = L*L**T, as computed by SPOTRF. \n
  * @param[in] LDAF
           LDAF is INTEGER \n
           The leading dimension of the array AF.  LDAF >= max(1,N). \n
  * @param[in,out] S
           S is REAL array, dimension (N) \n
           The scale factors for A.  If EQUED = 'Y', A is multiplied on
           the left and right by diag(S).  S is an input argument if FACT =
           'F'; otherwise, S is an output argument.  If FACT = 'F' and EQUED
           = 'Y', each element of S must be positive.  If S is output, each
           element of S is a power of the radix. If S is input, each element
           of S should be a power of the radix to ensure a reliable solution
           and error estimates. Scaling by powers of the radix does not cause
           rounding errors unless the result underflows or overflows.
           Rounding errors during scaling lead to refining with a matrix that
           is not equivalent to the input matrix, producing error estimates
           that may not be reliable. \n
  * @param[in] B
           B is REAL array, dimension (LDB,NRHS) \n
           The right hand side matrix B. \n
  * @param[in] LDB
           LDB is INTEGER \n
           The leading dimension of the array B.  LDB >= max(1,N). \n
  * @param[in,out] X
           X is REAL array, dimension (LDX,NRHS) \n
           On entry, the solution matrix X, as computed by SGETRS.
           On exit, the improved solution matrix X. \n
  * @param[in] LDX
           LDX is INTEGER \n
           The leading dimension of the array X.  LDX >= max(1,N). \n
  * @param[out] RCOND
           RCOND is REAL \n
           Reciprocal scaled condition number. This is an estimate of the
           reciprocal Skeel condition number of the matrix A after
           equilibration (if done).  If this is less than the machine
           precision (in particular, if it is zero), the matrix is singular
           to working precision.  Note that the error may still be small even
           if this number is very small and the matrix appears ill-
           conditioned. \n
  * @param[out] BERR
           BERR is REAL array, dimension (NRHS) \n
           Componentwise relative backward error. This is the
           componentwise relative backward error of each solution vector X(j)
           (i.e., the smallest relative change in any element of A or B that
           makes X(j) an exact solution). \n
  * @param[in] N_ERR_BNDS
           N_ERR_BNDS is INTEGER \n
           Number of error bounds to return for each right hand side
           and each type (normwise or componentwise).  See ERR_BNDS_NORM and
           ERR_BNDS_COMP below. \n
  * @param[out] ERR_BNDS_NORM
           ERR_BNDS_NORM is REAL array, dimension (NRHS, N_ERR_BNDS) \n
           For each right-hand side, this array contains information about
           various error bounds and condition numbers corresponding to the
           normwise relative error, which is defined as follows: \n
 \n
           Normwise relative error in the ith solution vector: \n
                   max_j (abs(XTRUE(j,i) - X(j,i))) \n
                  ------------------------------ \n
                        max_j abs(X(j,i)) \n
           The array is indexed by the type of error information as described
           below. There currently are up to three pieces of information
           returned. \n
 \n
           The first index in ERR_BNDS_NORM(i,:) corresponds to the ith
           right-hand side. \n
 \n
           The second index in ERR_BNDS_NORM(:,err) contains the following
           three fields: \n
           err = 1 "Trust/don't trust" boolean. Trust the answer if the
                    reciprocal condition number is less than the threshold
                    sqrt(n) * slamch('Epsilon'). \n
 \n
           err = 2 "Guaranteed" error bound: The estimated forward error,
                    almost certainly within a factor of 10 of the true error
                    so long as the next entry is greater than the threshold
                    sqrt(n) * slamch('Epsilon'). This error bound should only
                    be trusted if the previous boolean is true. \n
 \n
           err = 3  Reciprocal condition number: Estimated normwise
                    reciprocal condition number.  Compared with the threshold
                    sqrt(n) * slamch('Epsilon') to determine if the error
                    estimate is "guaranteed". These reciprocal condition
                    numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
                    appropriately scaled matrix Z.
                    Let Z = S*A, where S scales each row by a power of the
                    radix so all absolute row sums of Z are approximately 1. \n
 \n
           See Lapack Working Note 165 for further details and extra
           cautions. \n
  * @param[out] ERR_BNDS_COMP
           ERR_BNDS_COMP is REAL array, dimension (NRHS, N_ERR_BNDS) \n
           For each right-hand side, this array contains information about
           various error bounds and condition numbers corresponding to the
           componentwise relative error, which is defined as follows: \n
 \n
           Componentwise relative error in the ith solution vector: \n
                          abs(XTRUE(j,i) - X(j,i)) \n
                   max_j ---------------------- \n
                               abs(X(j,i)) \n
 \n
           The array is indexed by the right-hand side i (on which the
           componentwise relative error depends), and the type of error
           information as described below. There currently are up to three
           pieces of information returned for each right-hand side. If
           componentwise accuracy is not requested (PARAMS(3) = 0.0), then
           ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS < 3, then at most
           the first (:,N_ERR_BNDS) entries are returned. \n
 \n
           The first index in ERR_BNDS_COMP(i,:) corresponds to the ith
           right-hand side. \n
 \n
           The second index in ERR_BNDS_COMP(:,err) contains the following
           three fields: \n
           err = 1 "Trust/don't trust" boolean. Trust the answer if the
                    reciprocal condition number is less than the threshold
                    sqrt(n) * slamch('Epsilon'). \n
 \n
           err = 2 "Guaranteed" error bound: The estimated forward error,
                    almost certainly within a factor of 10 of the true error
                    so long as the next entry is greater than the threshold
                    sqrt(n) * slamch('Epsilon'). This error bound should only
                    be trusted if the previous boolean is true. \n
 \n
           err = 3  Reciprocal condition number: Estimated componentwise
                    reciprocal condition number.  Compared with the threshold
                    sqrt(n) * slamch('Epsilon') to determine if the error
                    estimate is "guaranteed". These reciprocal condition
                    numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
                    appropriately scaled matrix Z. \n
                    Let Z = S*(A*diag(x)), where x is the solution for the
                    current right-hand side and S scales each row of
                    A*diag(x) by a power of the radix so all absolute row
                    sums of Z are approximately 1. \n
 \n
           See Lapack Working Note 165 for further details and extra
           cautions. \n
  * @param[in] NPARAMS
           NPARAMS is INTEGER \n
           Specifies the number of parameters set in PARAMS.  If <= 0, the
           PARAMS array is never referenced and default values are used. \n
  * @param[in,out] PARAMS
           PARAMS is REAL array, dimension NPARAMS \n
           Specifies algorithm parameters.  If an entry is < 0.0, then
           that entry will be filled with default value used for that
           parameter.  Only positions up to NPARAMS are accessed; defaults
           are used for higher-numbered parameters. \n
 \n
              PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative
                   refinement or not. \n
                Default: 1.0 \n
                   = 0.0:  No refinement is performed, and no error bounds are
                           computed. \n
                   = 1.0:  Use the double-precision refinement algorithm,
                           possibly with doubled-single computations if the
                           compilation environment does not support DOUBLE
                           PRECISION. \n
                     (other values are reserved for future use) \n
 \n
              PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual
                   computations allowed for refinement. \n
                Default: 10 \n
                Aggressive: Set to 100 to permit convergence using approximate
                            factorizations or factorizations other than LU. If
                            the factorization uses a technique other than
                            Gaussian elimination, the guarantees in
                            err_bnds_norm and err_bnds_comp may no longer be
                            trustworthy. \n
 \n
              PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code
                   will attempt to find a solution with small componentwise
                   relative error in the double-precision algorithm.  Positive
                   is true, 0.0 is false. \n
                Default: 1.0 (attempt componentwise convergence) \n
  * @param[out]	WORK	
          WORK is REAL array, dimension (4*N) \n
  * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (N) \n
  * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  Successful exit. The solution to every right-hand side is
           guaranteed. \n
          < 0:  If INFO = -i, the i-th argument had an illegal value \n
          > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization
           has been completed, but the factor U is exactly singular, so
           the solution and error bounds could not be computed. RCOND = 0
           is returned. \n
          = N+J: The solution corresponding to the Jth right-hand side is
           not guaranteed. The solutions corresponding to other right-
           hand sides K with K > J may not be guaranteed as well, but
           only the first such right-hand side is reported. If a small
           componentwise error is not requested (PARAMS(3) = 0.0) then
           the Jth right-hand side is the first with a normwise error
           bound that is not guaranteed (the smallest J such
           that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)
           the Jth right-hand side is the first with either a normwise or
           componentwise error bound that is not guaranteed (the smallest
           J such that either ERR_BNDS_NORM(J,1) = 0.0 or
           ERR_BNDS_COMP(J,1) = 0.0). See the definition of
           ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information
           about all of the right-hand sides check ERR_BNDS_NORM or
           ERR_BNDS_COMP. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer porfsx(char* uplo, char* equed, integer* n, integer* nrhs,  T* a, integer* lda,  T* af, integer* ldaf,  T* s,  T* b, integer* ldb, T* x, integer* ldx, T* rcond, T* berr, integer* n_err_bnds, T* err_bnds_norm, T* err_bnds_comp, integer* nparams, T* params, T* work, integer* iwork, integer* info)
{
  return porfsx(uplo, equed, n, nrhs,  a, lda,  af, ldaf,  s,  b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info);
}
template< typename T, typename Ta >
integer porfsx(char* uplo, char* equed, integer* n, integer* nrhs,  T* a, integer* lda,  T* af, integer* ldaf,  Ta* s,  T* b, integer* ldb, T* x, integer* ldx, Ta* rcond, Ta* berr, integer* n_err_bnds, Ta* err_bnds_norm, Ta* err_bnds_comp, integer* nparams, Ta* params, T* work, Ta* rwork, integer* info)
{
  return porfsx(uplo, equed, n, nrhs,  a, lda,  af, ldaf,  s,  b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info);
}

/*! @brief POSV computes the solution to system of linear equations A * X = B for PO matrices

 * @details
 * \b Purpose:
    \verbatim
    POSV computes the solution to a real system of linear equations
       A * X = B,
    where A is an N-by-N symmetric positive definite matrix and X and B
    are N-by-NRHS matrices.

    The Cholesky decomposition is used to factor A as
       A = U**T* U,  if UPLO = 'U', or
       A = L * L**T,  if UPLO = 'L',
    where U is an upper triangular matrix and L is a lower triangular
    matrix.  The factored form of A is then used to solve the system of
    equations A * X = B.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
          N-by-N upper triangular part of A contains the upper
          triangular part of the matrix A, and the strictly lower
          triangular part of A is not referenced.  If UPLO = 'L', the
          leading N-by-N lower triangular part of A contains the lower
          triangular part of the matrix A, and the strictly upper
          triangular part of A is not referenced. \n
 \n
          On exit, if INFO = 0, the factor U or L from the Cholesky
          factorization A = U**T*U or A = L*L**T. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,NRHS) \n
          On entry, the N-by-NRHS right hand side matrix B.
          On exit, if INFO = 0, the N-by-NRHS solution matrix X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, the leading minor of order i of A is not
                positive definite, so the factorization could not be
                completed, and the solution has not been computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer posv(char* uplo, integer* n, integer* nrhs, T* a, integer* lda, T* b, integer* ldb, integer* info)
{
  return posv(uplo, n, nrhs, a, lda, b, ldb, info);
}

/*! @brief POSVX uses the Cholesky factorization to compute the solution to a real system of linear equations
 * @details
 * \b Purpose:
    \verbatim
     POSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to
     compute the solution to a real system of linear equations
        A * X = B,
     where A is an N-by-N symmetric positive definite matrix and X and B
     are N-by-NRHS matrices.

     Error bounds on the solution and a condition estimate are also
     provided.

     \b Description:
      =================

     The following steps are performed:

     1. If FACT = 'E', real scaling factors are computed to equilibrate
        the system:
           diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B
        Whether or not the system will be equilibrated depends on the
        scaling of the matrix A, but if equilibration is used, A is
        overwritten by diag(S)*A*diag(S) and B by diag(S)*B.

     2. If FACT = 'N' or 'E', the Cholesky decomposition is used to
        factor the matrix A (after equilibration if FACT = 'E') as
           A = U**T* U,  if UPLO = 'U', or
           A = L * L**T,  if UPLO = 'L',
        where U is an upper triangular matrix and L is a lower triangular
        matrix.

     3. If the leading i-by-i principal minor is not positive definite,
        then the routine returns with INFO = i. Otherwise, the factored
        form of A is used to estimate the condition number of the matrix
        A.  If the reciprocal of the condition number is less than machine
        precision, INFO = N+1 is returned as a warning, but the routine
        still goes on to solve for X and compute error bounds as
        described below.

     4. The system of equations is solved for X using the factored form
        of A.

     5. Iterative refinement is applied to improve the computed solution
        matrix and calculate error bounds and backward error estimates
        for it.

     6. If equilibration was used, the matrix X is premultiplied by
        diag(S) so that it solves the original system before
        equilibration.
    \endverbatim 

 * @param[in] FACT
          FACT is CHARACTER*1 \n
          Specifies whether or not the factored form of the matrix A is
          supplied on entry, and if not, whether the matrix A should be
          equilibrated before it is factored. \n
          = 'F':  On entry, AF contains the factored form of A. \n
                  If EQUED = 'Y', the matrix A has been equilibrated
                  with scaling factors given by S.  A and AF will not
                  be modified. \n
          = 'N':  The matrix A will be copied to AF and factored. \n
          = 'E':  The matrix A will be equilibrated if necessary, then
                  copied to AF and factored. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrices B and X.  NRHS >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the symmetric matrix A, except if FACT = 'F' and
          EQUED = 'Y', then A must contain the equilibrated matrix
          diag(S)*A*diag(S).  If UPLO = 'U', the leading
          N-by-N upper triangular part of A contains the upper
          triangular part of the matrix A, and the strictly lower
          triangular part of A is not referenced.  If UPLO = 'L', the
          leading N-by-N lower triangular part of A contains the lower
          triangular part of the matrix A, and the strictly upper
          triangular part of A is not referenced.  A is not modified if
          FACT = 'F' or 'N', or if FACT = 'E' and EQUED = 'N' on exit. \n
 \n
          On exit, if FACT = 'E' and EQUED = 'Y', A is overwritten by
          diag(S)*A*diag(S). \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in,out] AF
          AF is REAL array, dimension (LDAF,N) \n
          If FACT = 'F', then AF is an input argument and on entry
          contains the triangular factor U or L from the Cholesky
          factorization A = U**T*U or A = L*L**T, in the same storage
          format as A.  If EQUED .ne. 'N', then AF is the factored form
          of the equilibrated matrix diag(S)*A*diag(S). \n
 \n
          If FACT = 'N', then AF is an output argument and on exit
          returns the triangular factor U or L from the Cholesky
          factorization A = U**T*U or A = L*L**T of the original
          matrix A. \n
 \n
          If FACT = 'E', then AF is an output argument and on exit
          returns the triangular factor U or L from the Cholesky
          factorization A = U**T*U or A = L*L**T of the equilibrated
          matrix A (see the description of A for the form of the
          equilibrated matrix). \n
 * @param[in] LDAF
          LDAF is INTEGER \n
          The leading dimension of the array AF.  LDAF >= max(1,N). \n
 * @param[in,out] EQUED
          EQUED is CHARACTER*1 \n
          Specifies the form of equilibration that was done. \n
          = 'N':  No equilibration (always true if FACT = 'N'). \n
          = 'Y':  Equilibration was done, i.e., A has been replaced by
                  diag(S) * A * diag(S). \n
          EQUED is an input argument if FACT = 'F'; otherwise, it is an
          output argument. \n
 * @param[in,out] S
          S is REAL array, dimension (N) \n
          The scale factors for A; not accessed if EQUED = 'N'.  S is
          an input argument if FACT = 'F'; otherwise, S is an output
          argument.  If FACT = 'F' and EQUED = 'Y', each element of S
          must be positive. \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,NRHS) \n
          On entry, the N-by-NRHS right hand side matrix B.
          On exit, if EQUED = 'N', B is not modified; if EQUED = 'Y',
          B is overwritten by diag(S) * B. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out] X
          X is REAL array, dimension (LDX,NRHS) \n
          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to
          the original system of equations.  Note that if EQUED = 'Y',
          A and B are modified on exit, and the solution to the
          equilibrated system is inv(diag(S))*X. \n
 * @param[in] LDX
          LDX is INTEGER \n
          The leading dimension of the array X.  LDX >= max(1,N). \n
 * @param[out] RCOND
          RCOND is REAL \n
          The estimate of the reciprocal condition number of the matrix
          A after equilibration (if done).  If RCOND is less than the
          machine precision (in particular, if RCOND = 0), the matrix
          is singular to working precision.  This condition is
          indicated by a return code of INFO > 0. \n
 * @param[out] FERR
          FERR is REAL array, dimension (NRHS) \n
          The estimated forward error bound for each solution vector
          X(j) (the j-th column of the solution matrix X).
          If XTRUE is the true solution corresponding to X(j), FERR(j)
          is an estimated upper bound for the magnitude of the largest
          element in (X(j) - XTRUE) divided by the magnitude of the
          largest element in X(j).  The estimate is as reliable as
          the estimate for RCOND, and is almost always a slight
          overestimate of the true error. \n
 * @param[out] BERR
          BERR is REAL array, dimension (NRHS) \n
          The componentwise relative backward error of each solution
          vector X(j) (i.e., the smallest relative change in
          any element of A or B that makes X(j) an exact solution). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (3*N) \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n
          > 0: if INFO = i, and i is \n
                <= N:  the leading minor of order i of A is
                       not positive definite, so the factorization
                       could not be completed, and the solution has not
                       been computed. RCOND = 0 is returned. \n
                = N+1: U is nonsingular, but RCOND is less than machine
                       precision, meaning that the matrix is singular
                       to working precision.  Nevertheless, the
                       solution and error bounds are computed because
                       there are a number of situations where the
                       computed solution can be more accurate than the
                       value of RCOND would suggest. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer posvx(char* fact, char* uplo, integer* n, integer* nrhs, T* a, integer* lda, T* af, integer* ldaf, char* equed, T* s, T* b, integer* ldb, T* x, integer* ldx, T* rcond, T* ferr, T* berr, T* work, integer* iwork, integer* info)
{
  return posvx(fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, iwork, info);
}
template< typename T, typename Ta >
integer posvx(char* fact, char* uplo, integer* n, integer* nrhs, T* a, integer* lda, T* af, integer* ldaf, char* equed, Ta* s, T* b, integer* ldb, T* x, integer* ldx, Ta* rcond, Ta* ferr, Ta* berr, T* work, Ta* rwork, integer* info)
{
  return posvx(fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, rwork, info);
}

/*! @brief POSVXX computes the solution to system of linear equations A * X = B for PO matrices

 * @details
 * \b Purpose:
    \verbatim
    POSVXX uses the Cholesky factorization A = U**T*U or A = L*L**T
    to compute the solution to a real system of linear equations
    A * X = B, where A is an N-by-N symmetric positive definite matrix
    and X and B are N-by-NRHS matrices.

    If requested, both normwise and maximum componentwise error bounds
    are returned. POSVXX will return a solution with a tiny
    guaranteed error (O(eps) where eps is the working machine
    precision) unless the matrix is very ill-conditioned, in which
    case a warning is returned. Relevant condition numbers also are
    calculated and returned.

    POSVXX accepts user-provided factorizations and equilibration
    factors; see the definitions of the FACT and EQUED options.
    Solving with refinement and using a factorization from a previous
    SPOSVXX call will also produce a solution with either O(eps)
    errors or warnings, but we cannot make that claim for general
    user-provided factorizations and equilibration factors if they
    differ from what POSVXX would itself produce.

 *\b Description:
    =================
    The following steps are performed:

    1. If FACT = 'E', real scaling factors are computed to equilibrate
    the system:

      diag(S)*A*diag(S)     *inv(diag(S))*X = diag(S)*B

    Whether or not the system will be equilibrated depends on the
    scaling of the matrix A, but if equilibration is used, A is
    overwritten by diag(S)*A*diag(S) and B by diag(S)*B.

    2. If FACT = 'N' or 'E', the Cholesky decomposition is used to
    factor the matrix A (after equilibration if FACT = 'E') as
       A = U**T* U,  if UPLO = 'U', or
       A = L * L**T,  if UPLO = 'L',
    where U is an upper triangular matrix and L is a lower triangular
    matrix.

    3. If the leading i-by-i principal minor is not positive definite,
    then the routine returns with INFO = i. Otherwise, the factored
    form of A is used to estimate the condition number of the matrix
    A (see argument RCOND).  If the reciprocal of the condition number
    is less than machine precision, the routine still goes on to solve
    for X and compute error bounds as described below.

    4. The system of equations is solved for X using the factored form
    of A.

    5. By default (unless PARAMS(LA_LINRX_ITREF_I) is set to zero),
    the routine will use iterative refinement to try to get a small
    error and error bounds.  Refinement calculates the residual to at
    least twice the working precision.

    6. If equilibration was used, the matrix X is premultiplied by
    diag(S) so that it solves the original system before
    equilibration.
    \endverbatim 
    
 * @param[in] FACT
          FACT is CHARACTER*1 \n
          Specifies whether or not the factored form of the matrix A is
          supplied on entry, and if not, whether the matrix A should be
          equilibrated before it is factored. \n
           = 'F':  On entry, AF contains the factored form of A.
                   If EQUED is not 'N', the matrix A has been
                   equilibrated with scaling factors given by S.
                   A and AF are not modified. \n
           = 'N':  The matrix A will be copied to AF and factored. \n
           = 'E':  The matrix A will be equilibrated if necessary, then
                   copied to AF and factored. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrices B and X.  NRHS >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the symmetric matrix A, except if FACT = 'F' and EQUED =
          'Y', then A must contain the equilibrated matrix
          diag(S)*A*diag(S).  If UPLO = 'U', the leading N-by-N upper
          triangular part of A contains the upper triangular part of the
          matrix A, and the strictly lower triangular part of A is not
          referenced.  If UPLO = 'L', the leading N-by-N lower triangular
          part of A contains the lower triangular part of the matrix A, and
          the strictly upper triangular part of A is not referenced.  A is
          not modified if FACT = 'F' or 'N', or if FACT = 'E' and EQUED =
          'N' on exit. \n
 \n
          On exit, if FACT = 'E' and EQUED = 'Y', A is overwritten by
          diag(S)*A*diag(S). \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in,out] AF
          AF is REAL array, dimension (LDAF,N) \n
          If FACT = 'F', then AF is an input argument and on entry
          contains the triangular factor U or L from the Cholesky
          factorization A = U**T*U or A = L*L**T, in the same storage
          format as A.  If EQUED .ne. 'N', then AF is the factored
          form of the equilibrated matrix diag(S)*A*diag(S). \n
 \n
          If FACT = 'N', then AF is an output argument and on exit
          returns the triangular factor U or L from the Cholesky
          factorization A = U**T*U or A = L*L**T of the original
          matrix A. \n
 \n
          If FACT = 'E', then AF is an output argument and on exit
          returns the triangular factor U or L from the Cholesky
          factorization A = U**T*U or A = L*L**T of the equilibrated
          matrix A (see the description of A for the form of the
          equilibrated matrix). \n
 * @param[in] LDAF
          LDAF is INTEGER \n
          The leading dimension of the array AF.  LDAF >= max(1,N). \n
 * @param[in,out] EQUED
          EQUED is CHARACTER*1 \n
          Specifies the form of equilibration that was done. \n
           = 'N':  No equilibration (always true if FACT = 'N'). \n
           = 'Y':  Both row and column equilibration, i.e., A has been
                   replaced by diag(S) * A * diag(S). \n
          EQUED is an input argument if FACT = 'F'; otherwise, it is an
          output argument. \n
 * @param[in,out] S
          S is REAL array, dimension (N) \n
          The row scale factors for A.  If EQUED = 'Y', A is multiplied on
          the left and right by diag(S).  S is an input argument if FACT =
          'F'; otherwise, S is an output argument.  If FACT = 'F' and EQUED
          = 'Y', each element of S must be positive.  If S is output, each
          element of S is a power of the radix. If S is input, each element
          of S should be a power of the radix to ensure a reliable solution
          and error estimates. Scaling by powers of the radix does not cause
          rounding errors unless the result underflows or overflows.
          Rounding errors during scaling lead to refining with a matrix that
          is not equivalent to the input matrix, producing error estimates
          that may not be reliable. \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,NRHS) \n
          On entry, the N-by-NRHS right hand side matrix B. \n
          On exit, \n
          if EQUED = 'N', B is not modified; \n
          if EQUED = 'Y', B is overwritten by diag(S)*B; \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out] X
          X is REAL array, dimension (LDX,NRHS) \n
          If INFO = 0, the N-by-NRHS solution matrix X to the original
          system of equations.  Note that A and B are modified on exit if
          EQUED .ne. 'N', and the solution to the equilibrated system is
          inv(diag(S))*X. \n
 * @param[in] LDX
          LDX is INTEGER \n
          The leading dimension of the array X.  LDX >= max(1,N). \n
 * @param[out] RCOND
          RCOND is REAL \n
          Reciprocal scaled condition number.  This is an estimate of the
          reciprocal Skeel condition number of the matrix A after
          equilibration (if done).  If this is less than the machine
          precision (in particular, if it is zero), the matrix is singular
          to working precision.  Note that the error may still be small even
          if this number is very small and the matrix appears ill-
          conditioned. \n
 * @param[out] RPVGRW
          RPVGRW is REAL \n
          Reciprocal pivot growth.  On exit, this contains the reciprocal
          pivot growth factor norm(A)/norm(U). The "max absolute element"
          norm is used. If this is much less than 1, then the stability of
          the LU factorization of the (equilibrated) matrix A could be poor.
          This also means that the solution X, estimated condition numbers,
          and error bounds could be unreliable. If factorization fails with
          0<INFO<=N, then this contains the reciprocal pivot growth factor
          for the leading INFO columns of A. \n
 * @param[out] BERR
          BERR is REAL array, dimension (NRHS) \n
          Componentwise relative backward error. This is the
          componentwise relative backward error of each solution vector X(j)
          (i.e., the smallest relative change in any element of A or B that
          makes X(j) an exact solution). \n
 * @param[in] N_ERR_BNDS
          N_ERR_BNDS is INTEGER \n
          Number of error bounds to return for each right hand side
          and each type (normwise or componentwise).  See ERR_BNDS_NORM and
          ERR_BNDS_COMP below. \n
 * @param[out] ERR_BNDS_NORM \n
          ERR_BNDS_NORM is REAL array, dimension (NRHS, N_ERR_BNDS)
          For each right-hand side, this array contains information about
          various error bounds and condition numbers corresponding to the
          normwise relative error, which is defined as follows: \n
 \n
          Normwise relative error in the ith solution vector: \n
                 max_j (abs(XTRUE(j,i) - X(j,i))) \n
                ------------------------------ \n
                      max_j abs(X(j,i)) \n
 \n
          The array is indexed by the type of error information as described
          below. There currently are up to three pieces of information
          returned. \n
 \n
          The first index in ERR_BNDS_NORM(i,:) corresponds to the ith
          right-hand side. \n
 \n
          The second index in ERR_BNDS_NORM(:,err) contains the following
          three fields: \n
          err = 1 "Trust/don't trust" boolean. Trust the answer if the
                  reciprocal condition number is less than the threshold
                  sqrt(n) * slamch('Epsilon'). \n
 \n
          err = 2 "Guaranteed" error bound: The estimated forward error,
                  almost certainly within a factor of 10 of the true error
                  so long as the next entry is greater than the threshold
                  sqrt(n) * slamch('Epsilon'). This error bound should only
                  be trusted if the previous boolean is true. \n
 \n
          err = 3  Reciprocal condition number: Estimated normwise
                  reciprocal condition number.  Compared with the threshold
                  sqrt(n) * slamch('Epsilon') to determine if the error
                  estimate is "guaranteed". These reciprocal condition
                  numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
                  appropriately scaled matrix Z.
                  Let Z = S*A, where S scales each row by a power of the
                  radix so all absolute row sums of Z are approximately 1. \n
 \n
          See Lapack Working Note 165 for further details and extra
          cautions. \n
 * @param[out] ERR_BNDS_COMP
          ERR_BNDS_COMP is REAL array, dimension (NRHS, N_ERR_BNDS) \n
          For each right-hand side, this array contains information about
          various error bounds and condition numbers corresponding to the
          componentwise relative error, which is defined as follows: \n
 \n
          Componentwise relative error in the ith solution vector: \n
                        abs(XTRUE(j,i) - X(j,i)) \n
                 max_j ---------------------- \n
                             abs(X(j,i)) \n
 \n
          The array is indexed by the right-hand side i (on which the
          componentwise relative error depends), and the type of error
          information as described below. There currently are up to three
          pieces of information returned for each right-hand side. If
          componentwise accuracy is not requested (PARAMS(3) = 0.0), then
          ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS < 3, then at most
          the first (:,N_ERR_BNDS) entries are returned. \n
 \n
          The first index in ERR_BNDS_COMP(i,:) corresponds to the ith
          right-hand side. \n
 \n
          The second index in ERR_BNDS_COMP(:,err) contains the following
          three fields: \n
          err = 1 "Trust/don't trust" boolean. Trust the answer if the
                  reciprocal condition number is less than the threshold
                  sqrt(n) * slamch('Epsilon'). \n
 \n
          err = 2 "Guaranteed" error bound: The estimated forward error,
                  almost certainly within a factor of 10 of the true error
                  so long as the next entry is greater than the threshold
                  sqrt(n) * slamch('Epsilon'). This error bound should only
                  be trusted if the previous boolean is true. \n
 \n
          err = 3  Reciprocal condition number: Estimated componentwise
                  reciprocal condition number.  Compared with the threshold
                  sqrt(n) * slamch('Epsilon') to determine if the error
                  estimate is "guaranteed". These reciprocal condition
                  numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
                  appropriately scaled matrix Z.
                  Let Z = S*(A*diag(x)), where x is the solution for the
                  current right-hand side and S scales each row of
                  A*diag(x) by a power of the radix so all absolute row
                  sums of Z are approximately 1. \n
 \n
          See Lapack Working Note 165 for further details and extra
          cautions. \n
 * @param[in] NPARAMS
          NPARAMS is INTEGER \n
          Specifies the number of parameters set in PARAMS.  If <= 0, the
          PARAMS array is never referenced and default values are used. \n
 * @param[in,out] PARAMS
          PARAMS is REAL array, dimension NPARAMS \n
          Specifies algorithm parameters.  If an entry is < 0.0, then
          that entry will be filled with default value used for that
          parameter.  Only positions up to NPARAMS are accessed; defaults
          are used for higher-numbered parameters. \n
 \n
           PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative
                refinement or not. \n
             Default: 1.0 \n
                = 0.0:  No refinement is performed, and no error bounds are
                        computed. \n
                = 1.0:  Use the double-precision refinement algorithm,
                        possibly with doubled-single computations if the
                        compilation environment does not support DOUBLE
                        PRECISION.
                  (other values are reserved for future use) \n
 \n
           PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual
                computations allowed for refinement. \n
             Default: 10 \n
             Aggressive: Set to 100 to permit convergence using approximate
                         factorizations or factorizations other than LU. If
                         the factorization uses a technique other than
                         Gaussian elimination, the guarantees in
                         err_bnds_norm and err_bnds_comp may no longer be
                         trustworthy. \n
 \n
           PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code
                will attempt to find a solution with small componentwise
                relative error in the double-precision algorithm.  Positive
                is true, 0.0 is false. \n
             Default: 1.0 (attempt componentwise convergence) \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (4*N) \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  Successful exit. The solution to every right-hand side is
           guaranteed. \n
          < 0:  If INFO = -i, the i-th argument had an illegal value \n
          > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization
           has been completed, but the factor U is exactly singular, so
           the solution and error bounds could not be computed. RCOND = 0
           is returned. \n
          = N+J: The solution corresponding to the Jth right-hand side is
           not guaranteed. The solutions corresponding to other right-
           hand sides K with K > J may not be guaranteed as well, but
           only the first such right-hand side is reported. If a small
           componentwise error is not requested (PARAMS(3) = 0.0) then
           the Jth right-hand side is the first with a normwise error
           bound that is not guaranteed (the smallest J such
           that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)
           the Jth right-hand side is the first with either a normwise or
           componentwise error bound that is not guaranteed (the smallest
           J such that either ERR_BNDS_NORM(J,1) = 0.0 or
           ERR_BNDS_COMP(J,1) = 0.0). See the definition of
           ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information
           about all of the right-hand sides check ERR_BNDS_NORM or
           ERR_BNDS_COMP. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer posvxx(char* fact, char* uplo, integer* n, integer* nrhs, T* a, integer* lda, T* af, integer* ldaf, char* equed, T* s, T* b, integer* ldb, T* x, integer* ldx, T* rcond, T* rpvgrw, T* berr, integer* n_err_bnds, T* err_bnds_norm, T* err_bnds_comp, integer* nparams, T* params, float* work, integer* iwork, integer* info)
{
  return posvxx(fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info);
}
template< typename T, typename Ta >
integer posvxx(char* fact, char* uplo, integer* n, integer* nrhs, T* a, integer* lda, T* af, integer* ldaf, char* equed, Ta* s, T* b, integer* ldb, T* x, integer* ldx, Ta* rcond, Ta* rpvgrw, Ta* berr, integer* n_err_bnds, Ta* err_bnds_norm, Ta* err_bnds_comp, integer* nparams, Ta* params, dcomplex* work, double* rwork, integer* info)
{
  return posvxx(fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info);
}

/*! @brief POTRF2 computes the Cholesky factorization of a real symmetric \n
     positive definite matrix A using the recursive algorithm.

 * @details
 * \b Purpose:
    \verbatim
     POTRF2 computes the Cholesky factorization of a real symmetric
     positive definite matrix A using the recursive algorithm.
    
     The factorization has the form
        A = U**T * U,  if UPLO = 'U', or
        A = L  * L**T,  if UPLO = 'L',
     where U is an upper triangular matrix and L is lower triangular.
    
     This is the recursive version of the algorithm. It divides
     the matrix into four submatrices:
    
            [  A11 | A12  ]  where A11 is n1 by n1 and A22 is n2 by n2
        A = [ -----|----- ]  with n1 = n/2
            [  A21 | A22  ]       n2 = n-n1
    
     The subroutine calls itself to factor A11. Update and scale A21
     or A12, update A22 then call itself to factor A22.
    \endverbatim 

  * @param[in] UPLO
           UPLO is CHARACTER*1 \n
           = 'U':  Upper triangle of A is stored; \n
           = 'L':  Lower triangle of A is stored. \n
  * @param[in] N
           N is INTEGER \n
           The order of the matrix A.  N >= 0. \n
  * @param[in,out] A
           A is REAL array, dimension (LDA,N) \n
           On entry, the symmetric matrix A.  If UPLO = 'U', the leading
           N-by-N upper triangular part of A contains the upper
           triangular part of the matrix A, and the strictly lower
           triangular part of A is not referenced.  If UPLO = 'L', the
           leading N-by-N lower triangular part of A contains the lower
           triangular part of the matrix A, and the strictly upper
           triangular part of A is not referenced. \n
  \n
           On exit, if INFO = 0, the factor U or L from the Cholesky
           factorization A = U**T*U or A = L*L**T. \n
  * @param[in] LDA
           LDA is INTEGER \n
           The leading dimension of the array A.  LDA >= max(1,N). \n
  * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, the leading minor of order i is not
                positive definite, and the factorization could not be
                completed. \n

 * @return INTEGER Return value of the function.
 * */  
template< typename T >
integer potrf2(char* uplo, integer* n, T* a, integer* lda, integer* info)
{
  return potrf2(uplo, n, a, lda, info);
}

/*! @brief POTRS solves a system of linear equations A*X = B

 * @details
 * \b Purpose:
    \verbatim
     POTRS solves a system of linear equations A*X = B with a symmetric
     positive definite matrix A using the Cholesky factorization
     A = U**T*U or A = L*L**T computed by SPOTRF.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          The triangular factor U or L from the Cholesky factorization
          A = U**T*U or A = L*L**T, as computed by SPOTRF. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,NRHS) \n
          On entry, the right hand side matrix B.
          On exit, the solution matrix X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */  
template< typename T >
integer potrs(char* uplo, integer* n, integer* nrhs, T* a, integer* lda, T* b, integer* ldb, integer* info)
{
  return potrs(uplo, n, nrhs, a, lda, b, ldb, info);
}

/*! @brief PPCON estimates the reciprocal of the condition number

 * @details
 * \b Purpose:
    \verbatim
     PPCON estimates the reciprocal of the condition number (in the
     1-norm) of a real symmetric positive definite packed matrix using
     the Cholesky factorization A = U**T*U or A = L*L**T computed by
     PPTRF.

     An estimate is obtained for norm(inv(A)), and the reciprocal of the
     condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] AP
          AP is REAL array, dimension (N*(N+1)/2) \n
          The triangular factor U or L from the Cholesky factorization
          A = U**T*U or A = L*L**T, packed columnwise in a linear
          array.  The j-th column of U or L is stored in the array AP
          as follows: \n
          if UPLO = 'U', AP(i + (j-1)*j/2) = U(i,j) for 1<=i<=j; \n
          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = L(i,j) for j<=i<=n. \n
 * @param[in] ANORM
          ANORM is REAL \n
          The 1-norm (or infinity-norm) of the symmetric matrix A. \n
 * @param[out] RCOND
          RCOND is REAL \n
          The reciprocal of the condition number of the matrix A,
          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
          estimate of the 1-norm of inv(A) computed in this routine. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (3*N) \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */  
template< typename T >
integer ppcon(char* uplo, integer* n,  T* ap, T* anorm, T* rcond, T* work, integer* iwork, integer* info)
{
  return ppcon(uplo, n, ap, anorm, rcond, work, iwork, info);
}
template< typename T, typename Ta >
integer ppcon(char* uplo, integer* n,  T* ap, Ta* anorm, Ta* rcond, T* work, Ta* rwork, integer* info)
{
  return ppcon(uplo, n, ap, anorm, rcond, work, rwork, info);
}

/*! @brief PPEQU computes row and column scalings

 * @details
 * \b Purpose:
    \verbatim
     PPEQU computes row and column scalings intended to equilibrate a
     symmetric positive definite matrix A in packed storage and reduce
     its condition number (with respect to the two-norm).  S contains the
     scale factors, S(i)=1/sqrt(A(i,i)), chosen so that the scaled matrix
     B with elements B(i,j)=S(i)*A(i,j)*S(j) has ones on the diagonal.
     This choice of S puts the condition number of B within a factor N of
     the smallest possible condition number over all possible diagonal
     scalings.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] AP
          AP is REAL array, dimension (N*(N+1)/2) \n
          The upper or lower triangle of the symmetric matrix A, packed
          columnwise in a linear array.  The j-th column of A is stored
          in the array AP as follows: \n
          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j; \n
          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n. \n
 * @param[out] S
          S is REAL array, dimension (N) \n
          If INFO = 0, S contains the scale factors for A. \n
 * @param[out] SCOND
          SCOND is REAL \n
          If INFO = 0, S contains the ratio of the smallest S(i) to
          the largest S(i).  If SCOND >= 0.1 and AMAX is neither too
          large nor too small, it is not worth scaling by S. \n
 * @param[out] AMAX
          AMAX is REAL \n
          Absolute value of largest matrix element.  If AMAX is very
          close to overflow or very close to underflow, the matrix
          should be scaled. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, the i-th diagonal element is nonpositive. \n

 * @return INTEGER Return value of the function.
 * */ 
template< typename T >
integer ppequ(char* uplo, integer* n,  T* ap, T* s, T* scond, T* amax, integer* info)
{
  return ppequ(uplo, n, ap, s, scond, amax, info);
}
template< typename T, typename Ta >
integer ppequ(char* uplo, integer* n,  T* ap, Ta* s, Ta* scond, Ta* amax, integer* info)
{
  return ppequ(uplo, n, ap, s, scond, amax, info);
}

/*! @brief PPRFS improves the computed solution to a system of linear equations 

 * @details
 * \b Purpose:
    \verbatim
     PPRFS improves the computed solution to a system of linear
     equations when the coefficient matrix is symmetric positive definite
     and packed, and provides error bounds and backward error estimates
     for the solution.
    \endverbatim

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrices B and X.  NRHS >= 0. \n
 * @param[in] AP
          AP is REAL array, dimension (N*(N+1)/2) \n
          The upper or lower triangle of the symmetric matrix A, packed
          columnwise in a linear array.  The j-th column of A is stored
          in the array AP as follows: \n
          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j; \n
          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n. \n
 * @param[in] AFP
          AFP is REAL array, dimension (N*(N+1)/2) \n
          The triangular factor U or L from the Cholesky factorization
          A = U**T*U or A = L*L**T, as computed by SPPTRF/CPPTRF,
          packed columnwise in a linear array in the same format as A
          (see AP). \n
 * @param[in] B
          B is REAL array, dimension (LDB,NRHS) \n
          The right hand side matrix B. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[in,out] X
          X is REAL array, dimension (LDX,NRHS) \n
          On entry, the solution matrix X, as computed by SPPTRS.
          On exit, the improved solution matrix X. \n
 * @param[in] LDX
          LDX is INTEGER \n
          The leading dimension of the array X.  LDX >= max(1,N). \n
 * @param[out] FERR
          FERR is REAL array, dimension (NRHS) \n
          The estimated forward error bound for each solution vector
          X(j) (the j-th column of the solution matrix X). \n
          If XTRUE is the true solution corresponding to X(j), FERR(j)
          is an estimated upper bound for the magnitude of the largest
          element in (X(j) - XTRUE) divided by the magnitude of the
          largest element in X(j).  The estimate is as reliable as
          the estimate for RCOND, and is almost always a slight
          overestimate of the true error. \n
 * @param[out] BERR
          BERR is REAL array, dimension (NRHS) \n
          The componentwise relative backward error of each solution
          vector X(j) (i.e., the smallest relative change in
          any element of A or B that makes X(j) an exact solution). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (3*N) \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer pprfs(char* uplo, integer* n, integer* nrhs,  T* ap,  T* afp,  T* b, integer* ldb, T* x, integer* ldx, T* ferr, T* berr, T* work, integer* iwork, integer* info)
{
  return pprfs(uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr, work, iwork, info);
}
template< typename T, typename Ta >
integer pprfs(char* uplo, integer* n, integer* nrhs,  T* ap,  T* afp,  T* b, integer* ldb, T* x, integer* ldx, Ta* ferr, Ta* berr, T* work, Ta* rwork, integer* info)
{
  return pprfs(uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr, work, rwork, info);
}

/*! @brief PPSV computes the solution to a real system of linear equations

 * @details
 * \b Purpose:
    \verbatim
     PPSV computes the solution to a real system of linear equations
        A * X = B,
     where A is an N-by-N symmetric positive definite matrix stored in
     packed format and X and B are N-by-NRHS matrices.

     The Cholesky decomposition is used to factor A as
        A = U**T* U,  if UPLO = 'U', or
        A = L * L**T,  if UPLO = 'L',
     where U is an upper triangular matrix and L is a lower triangular
     matrix.  The factored form of A is then used to solve the system of
     equations A * X = B.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in,out] AP
          AP is REAL array, dimension (N*(N+1)/2) \n
          On entry, the upper or lower triangle of the symmetric matrix
          A, packed columnwise in a linear array.  The j-th column of A
          is stored in the array AP as follows: \n
          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j; \n
          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
          See below for further details. \n
 \n
          On exit, if INFO = 0, the factor U or L from the Cholesky
          factorization A = U**T*U or A = L*L**T, in the same storage
          format as A. \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,NRHS) \n
          On entry, the N-by-NRHS right hand side matrix B. \n
          On exit, if INFO = 0, the N-by-NRHS solution matrix X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, the leading minor of order i of A is not
                positive definite, so the factorization could not be
                completed, and the solution has not been computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer ppsv(char* uplo, integer* n, integer* nrhs, T* ap, T* b, integer* ldb, integer* info)
{
  return ppsv(uplo, n, nrhs, ap, b, ldb, info);
}

/*! @brief PPSVX computes the solution to system of linear equations A * X = B for OTHER matrices

 * @details
 * \b Purpose:
    \verbatim
     PPSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to
     compute the solution to a real system of linear equations
        A * X = B,
     where A is an N-by-N symmetric positive definite matrix stored in
     packed format and X and B are N-by-NRHS matrices.

     Error bounds on the solution and a condition estimate are also
     provided.
     
     * \b Description:
       =================
     The following steps are performed:

     1. If FACT = 'E', real scaling factors are computed to equilibrate
        the system:
           diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B
        Whether or not the system will be equilibrated depends on the
        scaling of the matrix A, but if equilibration is used, A is
        overwritten by diag(S)*A*diag(S) and B by diag(S)*B.

     2. If FACT = 'N' or 'E', the Cholesky decomposition is used to
        factor the matrix A (after equilibration if FACT = 'E') as
           A = U**T* U,  if UPLO = 'U', or
           A = L * L**T,  if UPLO = 'L',
        where U is an upper triangular matrix and L is a lower triangular
        matrix.

     3. If the leading i-by-i principal minor is not positive definite,
        then the routine returns with INFO = i. Otherwise, the factored
        form of A is used to estimate the condition number of the matrix
        A.  If the reciprocal of the condition number is less than machine
        precision, INFO = N+1 is returned as a warning, but the routine
        still goes on to solve for X and compute error bounds as
        described below.

     4. The system of equations is solved for X using the factored form
        of A.

     5. Iterative refinement is applied to improve the computed solution
        matrix and calculate error bounds and backward error estimates
        for it.

     6. If equilibration was used, the matrix X is premultiplied by
        diag(S) so that it solves the original system before
        equilibration.
    \endverbatim 

 * @param[in] FACT
          FACT is CHARACTER*1 \n
          Specifies whether or not the factored form of the matrix A is
          supplied on entry, and if not, whether the matrix A should be
          equilibrated before it is factored. \n
          = 'F':  On entry, AFP contains the factored form of A.
                  If EQUED = 'Y', the matrix A has been equilibrated
                  with scaling factors given by S.  AP and AFP will not
                  be modified. \n
          = 'N':  The matrix A will be copied to AFP and factored. \n
          = 'E':  The matrix A will be equilibrated if necessary, then
                  copied to AFP and factored. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrices B and X.  NRHS >= 0. \n
 * @param[in,out] AP
          AP is REAL array, dimension (N*(N+1)/2) \n
          On entry, the upper or lower triangle of the symmetric matrix
          A, packed columnwise in a linear array, except if FACT = 'F'
          and EQUED = 'Y', then A must contain the equilibrated matrix
          diag(S)*A*diag(S).  The j-th column of A is stored in the
          array AP as follows: \n
          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j; \n
          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n. \n
          See below for further details.  A is not modified if
          FACT = 'F' or 'N', or if FACT = 'E' and EQUED = 'N' on exit. \n
 \n
          On exit, if FACT = 'E' and EQUED = 'Y', A is overwritten by
          diag(S)*A*diag(S). \n
 * @param[in,out] AFP
          AFP is REAL array, dimension (N*(N+1)/2) \n
          If FACT = 'F', then AFP is an input argument and on entry
          contains the triangular factor U or L from the Cholesky
          factorization A = U**T*U or A = L*L**T, in the same storage
          format as A.  If EQUED .ne. 'N', then AFP is the factored
          form of the equilibrated matrix A. \n
 \n
          If FACT = 'N', then AFP is an output argument and on exit
          returns the triangular factor U or L from the Cholesky
          factorization A = U**T * U or A = L * L**T of the original
          matrix A. \n
 \n
          If FACT = 'E', then AFP is an output argument and on exit
          returns the triangular factor U or L from the Cholesky
          factorization A = U**T * U or A = L * L**T of the equilibrated
          matrix A (see the description of AP for the form of the
          equilibrated matrix). \n
 * @param[in,out] EQUED
          EQUED is CHARACTER*1 \n
          Specifies the form of equilibration that was done.
          = 'N':  No equilibration (always true if FACT = 'N'). \n
          = 'Y':  Equilibration was done, i.e., A has been replaced by
                  diag(S) * A * diag(S). \n
          EQUED is an input argument if FACT = 'F'; otherwise, it is an
          output argument. \n
 * @param[in,out] S
          S is REAL array, dimension (N) \n
          The scale factors for A; not accessed if EQUED = 'N'.  S is
          an input argument if FACT = 'F'; otherwise, S is an output
          argument.  If FACT = 'F' and EQUED = 'Y', each element of S
          must be positive. \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,NRHS) \n
          On entry, the N-by-NRHS right hand side matrix B.
          On exit, if EQUED = 'N', B is not modified; if EQUED = 'Y',
          B is overwritten by diag(S) * B. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out] X
          X is REAL array, dimension (LDX,NRHS) \n
          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to
          the original system of equations.  Note that if EQUED = 'Y',
          A and B are modified on exit, and the solution to the
          equilibrated system is inv(diag(S))*X. \n
 * @param[in] LDX
          LDX is INTEGER \n
          The leading dimension of the array X.  LDX >= max(1,N). \n
 * @param[out] RCOND
          RCOND is REAL \n
          The estimate of the reciprocal condition number of the matrix
          A after equilibration (if done).  If RCOND is less than the
          machine precision (in particular, if RCOND = 0), the matrix
          is singular to working precision.  This condition is
          indicated by a return code of INFO > 0. \n
 * @param[out] FERR
          FERR is REAL array, dimension (NRHS) \n
          The estimated forward error bound for each solution vector
          X(j) (the j-th column of the solution matrix X).
          If XTRUE is the true solution corresponding to X(j), FERR(j)
          is an estimated upper bound for the magnitude of the largest
          element in (X(j) - XTRUE) divided by the magnitude of the
          largest element in X(j).  The estimate is as reliable as
          the estimate for RCOND, and is almost always a slight
          overestimate of the true error. \n
 * @param[out] BERR
          BERR is REAL array, dimension (NRHS) \n
          The componentwise relative backward error of each solution
          vector X(j) (i.e., the smallest relative change in
          any element of A or B that makes X(j) an exact solution). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (3*N) \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, and i is \n
                <= N:  the leading minor of order i of A is
                       not positive definite, so the factorization
                       could not be completed, and the solution has not
                       been computed. RCOND = 0 is returned. \n
                = N+1: U is nonsingular, but RCOND is less than machine
                       precision, meaning that the matrix is singular
                       to working precision.  Nevertheless, the
                       solution and error bounds are computed because
                       there are a number of situations where the
                       computed solution can be more accurate than the
                       value of RCOND would suggest. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer ppsvx(char* fact, char* uplo, integer* n, integer* nrhs, T* ap, T* afp, char* equed, T* s, T* b, integer* ldb, T* x, integer* ldx, T* rcond, T* ferr, T* berr, T* work, integer* iwork, integer* info)
{
  return ppsvx(fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, iwork, info);
}
template< typename T, typename Ta >
integer ppsvx(char* fact, char* uplo, integer* n, integer* nrhs, T* ap, T* afp, char* equed, Ta* s, T* b, integer* ldb, T* x, integer* ldx, Ta* rcond, Ta* ferr, Ta* berr, T* work, Ta* rwork, integer* info)
{
  return ppsvx(fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, rwork, info);
}

/*! @brief PPTRF computes the Cholesky factorization of a real symmetric matrix

 * @details
 * \b Purpose:
    \verbatim
     PPTRF computes the Cholesky factorization of a real symmetric
     positive definite matrix A stored in packed format.

     The factorization has the form
        A = U**T * U,  if UPLO = 'U', or
        A = L  * L**T,  if UPLO = 'L',
     where U is an upper triangular matrix and L is lower triangular.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] AP
          AP is REAL array, dimension (N*(N+1)/2) \n
          On entry, the upper or lower triangle of the symmetric matrix
          A, packed columnwise in a linear array.  The j-th column of A
          is stored in the array AP as follows: \n
          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j; \n
          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n. \n
          See below for further details. \n
 \n
          On exit, if INFO = 0, the triangular factor U or L from the
          Cholesky factorization A = U**T*U or A = L*L**T, in the same
          storage format as A. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, the leading minor of order i is not
                positive definite, and the factorization could not be
                completed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer pptrf(char* uplo, integer* n, T* ap, integer* info)
{
  return pptrf(uplo, n, ap, info);
}

/*! @brief PPTRI computes the inverse of a real symmetric matrix

 * @details
 * \b Purpose:
    \verbatim
     PPTRI computes the inverse of a real symmetric positive definite
     matrix A using the Cholesky factorization A = U**T*U or A = L*L**T
     computed by PPTRF.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangular factor is stored in AP; \n
          = 'L':  Lower triangular factor is stored in AP. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] AP
          AP is REAL array, dimension (N*(N+1)/2) \n
          On entry, the triangular factor U or L from the Cholesky
          factorization A = U**T*U or A = L*L**T, packed columnwise as
          a linear array. The j-th column of U or L is stored in the
          array AP as follows: \n
          if UPLO = 'U', AP(i + (j-1)*j/2) = U(i,j) for 1<=i<=j; \n
          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = L(i,j) for j<=i<=n. \n
 \n
          On exit, the upper or lower triangle of the (symmetric)
          inverse of A, overwriting the input factor U or L. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, the (i,i) element of the factor U or L is
                zero, and the inverse could not be computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer pptri(char* uplo, integer* n, T* ap, integer* info)
{
  return pptri(uplo, n, ap, info);
}

/*! @brief PPTRS solves a system of linear equations A*X = B with a symmetric matrix

 * @details
 * \b Purpose:
    \verbatim
     PPTRS solves a system of linear equations A*X = B with a symmetric
     positive definite matrix A in packed storage using the Cholesky
     factorization A = U**T*U or A = L*L**T computed by PPTRF.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in] AP
          AP is REAL array, dimension (N*(N+1)/2) \n
          The triangular factor U or L from the Cholesky factorization
          A = U**T*U or A = L*L**T, packed columnwise in a linear
          array.  The j-th column of U or L is stored in the array AP
          as follows: \n
          if UPLO = 'U', AP(i + (j-1)*j/2) = U(i,j) for 1<=i<=j; \n
          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = L(i,j) for j<=i<=n. \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,NRHS) \n
          On entry, the right hand side matrix B.
          On exit, the solution matrix X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer pptrs(char* uplo, integer* n, integer* nrhs,  T* ap, T* b, integer* ldb, integer* info)
{
  return pptrs(uplo, n, nrhs,  ap, b, ldb, info);
}

/*! @brief PSTRF computes the Cholesky factorization with complete pivoting of a real symmetric positive semidefinite matrix.

 * @details
 * \b Purpose:
    \verbatim
     PSTRF computes the Cholesky factorization with complete
     pivoting of a real symmetric positive semidefinite matrix A.

     The factorization has the form
        P**T * A * P = U**T * U ,  if UPLO = 'U',
        P**T * A * P = L  * L**T,  if UPLO = 'L',
     where U is an upper triangular matrix and L is lower triangular, and
     P is stored as vector PIV.

     This algorithm does not attempt to check that A is positive
     semidefinite. This version of the algorithm calls level 3 BLAS.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the upper or lower triangular part of the
          symmetric matrix A is stored. \n
          = 'U':  Upper triangular \n
          = 'L':  Lower triangular \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the symmetric matrix A. If UPLO = 'U', the leading
          n by n upper triangular part of A contains the upper
          triangular part of the matrix A, and the strictly lower
          triangular part of A is not referenced.  If UPLO = 'L', the
          leading n by n lower triangular part of A contains the lower
          triangular part of the matrix A, and the strictly upper
          triangular part of A is not referenced. \n
 \n
          On exit, if INFO = 0, the factor U or L from the Cholesky
          factorization as above. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] PIV
          PIV is INTEGER array, dimension (N) \n
          PIV is such that the nonzero entries are P( PIV(K), K) = 1. \n
 * @param[out] RANK
          RANK is INTEGER \n
          The rank of A given by the number of steps the algorithm
          completed. \n
 * @param[in] TOL
          TOL is REAL \n
          User defined tolerance. If TOL < 0, then N*U*MAX( A(K,K))
          will be used. The algorithm terminates at the (K-1)st step
          if the pivot <= TOL. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (2*N) \n
          Work space. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          < 0: If INFO = -K, the K-th argument had an illegal value, \n
          = 0: algorithm completed successfully, and \n
          > 0: the matrix A is either rank deficient with computed rank
               as returned in RANK, or is not positive semidefinite. See
               Section 7 of LAPACK Working Note #161 for further
               information. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer pstrf(char* uplo, integer* n, T* a, integer* lda, integer* piv, integer* rank, T* tol, T* work, integer* info)
{
  return pstrf(uplo, n, a, lda, piv, rank, tol, work, info);
}
template< typename T, typename Ta >
integer pstrf(char* uplo, integer* n, T* a, integer* lda, integer* piv, integer* rank, Ta* tol, Ta* work, integer* info)
{
  return pstrf(uplo, n, a, lda, piv, rank, tol, work, info);
}

/*! @brief PTCON computes the reciprocal of the condition number

 * @details
 * \b Purpose:
    \verbatim
     PTCON computes the reciprocal of the condition number (in the
     1-norm) of a real symmetric positive definite tridiagonal matrix
     using the factorization A = L*D*L**T or A = U**T*D*U computed by
     SPTTRF.

     Norm(inv(A)) is computed by a direct method, and the reciprocal of
     the condition number is computed as
           RCOND = 1 / (ANORM * norm(inv(A))).
     \endverbatim

 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] D
          D is REAL array, dimension (N) \n
          The n diagonal elements of the diagonal matrix D from the
          factorization of A, as computed by SPTTRF. \n
 * @param[in] E
          E is REAL array, dimension (N-1) \n
          The (n-1) off-diagonal elements of the unit bidiagonal factor
          U or L from the factorization of A,  as computed by SPTTRF. \n
 * @param[in] ANORM
          ANORM is REAL \n
          The 1-norm of the original matrix A. \n
 * @param[out] RCOND
          RCOND is REAL \n
          The reciprocal of the condition number of the matrix A,
          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is the
          1-norm of inv(A) computed in this routine. \n
 * @param[out] RWORK
          RWORK is REAL array, dimension (N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
 
 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer ptcon(integer* n, T* d, T* e, T* anorm, T* rcond, T* rwork, integer* info)
{
  return ptcon(n, d, e, anorm, rcond, rwork, info);
}
template< typename T, typename Ta >
integer ptcon(integer* n, Ta* d, T* e, Ta* anorm, Ta* rcond, Ta* rwork, integer* info)
{
  return ptcon(n, d, e, anorm, rcond, rwork, info);
}

/*! @brief PTEQR computes all eigenvalues and, optionally, eigenvectors of a symmetric matrix

 * @details
 * \b Purpose:
    \verbatim
     PTEQR computes all eigenvalues and, optionally, eigenvectors of a
     symmetric positive definite tridiagonal matrix by first factoring the
     matrix using SPTTRF, and then calling SBDSQR to compute the singular
     values of the bidiagonal factor.

     This routine computes the eigenvalues of the positive definite
     tridiagonal matrix to high relative accuracy.  This means that if the
     eigenvalues range over many orders of magnitude in size, then the
     small eigenvalues and corresponding eigenvectors will be computed
     more accurately than, for example, with the standard QR method.

     The eigenvectors of a full or band symmetric positive definite matrix
     can also be found if SSYTRD, SSPTRD, or SSBTRD has been used to
     reduce this matrix to tridiagonal form. (The reduction to tridiagonal
     form, however, may preclude the possibility of obtaining high
     relative accuracy in the small eigenvalues of the original matrix, if
     these eigenvalues range over many orders of magnitude.)
    \endverbatim 

 * @param[in] COMPZ
          COMPZ is CHARACTER*1 \n
          = 'N':  Compute eigenvalues only. \n
          = 'V':  Compute eigenvectors of original symmetric
                  matrix also.  Array Z contains the orthogonal
                  matrix used to reduce the original matrix to
                  tridiagonal form. \n
          = 'I':  Compute eigenvectors of tridiagonal matrix also. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix.  N >= 0. \n
 * @param[in,out] D
          D is REAL array, dimension (N) \n
          On entry, the n diagonal elements of the tridiagonal
          matrix. \n
          On normal exit, D contains the eigenvalues, in descending
          order. \n
 * @param[in,out] E
          E is REAL array, dimension (N-1) \n
          On entry, the (n-1) subdiagonal elements of the tridiagonal
          matrix.
          On exit, E has been destroyed. \n
 * @param[in,out] Z
          Z is REAL array, dimension (LDZ, N) \n
          On entry, if COMPZ = 'V', the orthogonal matrix used in the
          reduction to tridiagonal form. \n
          On exit, if COMPZ = 'V', the orthonormal eigenvectors of the
          original symmetric matrix; \n
          if COMPZ = 'I', the orthonormal eigenvectors of the
          tridiagonal matrix. \n
          If INFO > 0 on exit, Z contains the eigenvectors associated
          with only the stored eigenvalues. \n
          If  COMPZ = 'N', then Z is not referenced. \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of the array Z.  LDZ >= 1, and if
          COMPZ = 'V' or 'I', LDZ >= max(1,N). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (4*N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n
          > 0:  if INFO = i, and i is: \n
                <= N  the Cholesky factorization of the matrix could
                      not be performed because the i-th principal minor
                      was not positive definite. \n
                > N   the SVD algorithm failed to converge;
                      if INFO = N+i, i off-diagonal elements of the
                      bidiagonal factor did not converge to zero. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer pteqr(char* compz, integer* n, T* d, T* e, T* z, integer* ldz, T* work, integer* info)
{
  return pteqr(compz, n, d, e, z, ldz, work, info);
}
template< typename T, typename Ta >
integer pteqr(char* compz, integer* n, Ta* d, Ta* e, T* z, integer* ldz, Ta* work, integer* info)
{
  return pteqr(compz, n, d, e, z, ldz, work, info);
}

/*! @brief PTRFS improves the computed solution to a system of linear equations

 * @details
 * \b Purpose:
    \verbatim
    PTRFS improves the computed solution to a system of linear
    equations when the coefficient matrix is symmetric positive definite
    and tridiagonal, and provides error bounds and backward error
    estimates for the solution.
    \endverbatim 

 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in] D
          D is REAL array, dimension (N) \n
          The n diagonal elements of the tridiagonal matrix A. \n
 * @param[in] E
          E is REAL array, dimension (N-1) \n
          The (n-1) subdiagonal elements of the tridiagonal matrix A. \n
 * @param[in] DF
          DF is REAL array, dimension (N) \n
          The n diagonal elements of the diagonal matrix D from the
          factorization computed by SPTTRF. \n
 * @param[in] EF
          EF is REAL array, dimension (N-1) \n
          The (n-1) subdiagonal elements of the unit bidiagonal factor
          L from the factorization computed by SPTTRF. \n
 * @param[in] B
          B is REAL array, dimension (LDB,NRHS) \n
          The right hand side matrix B. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[in,out] X
          X is REAL array, dimension (LDX,NRHS) \n
          On entry, the solution matrix X, as computed by SPTTRS.
          On exit, the improved solution matrix X. \n
 * @param[in] LDX
          LDX is INTEGER \n
          The leading dimension of the array X.  LDX >= max(1,N). \n
 * @param[out] FERR
          FERR is REAL array, dimension (NRHS) \n
          The forward error bound for each solution vector
          X(j) (the j-th column of the solution matrix X). \n
          If XTRUE is the true solution corresponding to X(j), FERR(j)
          is an estimated upper bound for the magnitude of the largest
          element in (X(j) - XTRUE) divided by the magnitude of the
          largest element in X(j). \n
 * @param[out] BERR
          BERR is REAL array, dimension (NRHS) \n
          The componentwise relative backward error of each solution
          vector X(j) (i.e., the smallest relative change in
          any element of A or B that makes X(j) an exact solution). \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (N) \n
 * @param[out]	RWORK	
          RWORK is REAL array, dimension (N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
 
 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer ptrfs(integer* n, integer* nrhs, T* d, T* e, T* df, T* ef, T* b, integer* ldb, T* x, integer* ldx, T* ferr, T* berr, T* work, integer* info)
{
  return ptrfs(n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr, work, info);
}
template< typename T, typename Ta >
integer ptrfs(char *uplo, integer* n, integer* nrhs, Ta* d, T* e, Ta* df, T* ef, T* b, integer* ldb, T* x, integer* ldx, Ta* ferr, Ta* berr, T* work, Ta* rwork, integer* info)
{
  return ptrfs(uplo, n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr, work, rwork, info);
}

/*! @brief PTSV computes the solution to system of linear equations A * X = B for PT matrices

 * @details
 * \b Purpose:
    \verbatim
     PTSV computes the solution to a real system of linear equations
     A*X = B, where A is an N-by-N symmetric positive definite tridiagonal
     matrix, and X and B are N-by-NRHS matrices.

     A is factored as A = L*D*L**T, and the factored form of A is then
     used to solve the system of equations.
    \endverbatim 

 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in,out] D
          D is REAL array, dimension (N) \n
          On entry, the n diagonal elements of the tridiagonal matrix
          A.  On exit, the n diagonal elements of the diagonal matrix
          D from the factorization A = L*D*L**T. \n
 * @param[in,out] E
          E is REAL array, dimension (N-1) \n
          On entry, the (n-1) subdiagonal elements of the tridiagonal
          matrix A.  On exit, the (n-1) subdiagonal elements of the
          unit bidiagonal factor L from the L*D*L**T factorization of
          A.  (E can also be regarded as the superdiagonal of the unit
          bidiagonal factor U from the U**T*D*U factorization of A.) \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,NRHS) \n
          On entry, the N-by-NRHS right hand side matrix B.
          On exit, if INFO = 0, the N-by-NRHS solution matrix X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, the leading minor of order i is not
                positive definite, and the solution has not been
                computed.  The factorization has not been completed
                unless i = N. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer ptsv(integer* n, integer* nrhs, T* d, T* e, T* b, integer* ldb, integer* info)
{
  return ptsv(n, nrhs, d, e, b, ldb, info);
}
template< typename T, typename Ta >
integer ptsv(integer* n, integer* nrhs, Ta* d, T* e, T* b, integer* ldb, integer* info)
{
  return ptsv(n, nrhs, d, e, b, ldb, info);
}

/*! @brief PTSVX computes the solution to system of linear equations A * X = B for PT matrices

 * @details
 * \b Purpose:
    \verbatim
     PTSVX uses the factorization A = L*D*L**T to compute the solution
     to a real system of linear equations A*X = B, where A is an N-by-N
     symmetric positive definite tridiagonal matrix and X and B are
     N-by-NRHS matrices.

     Error bounds on the solution and a condition estimate are also
     provided.
    \endverbatim 

 * \b Description:
      ============
    The following steps are performed:

    1. If FACT = 'N', the matrix A is factored as A = L*D*L**T, where L
       is a unit lower bidiagonal matrix and D is diagonal.  The
       factorization can also be regarded as having the form
       A = U**T*D*U.

    2. If the leading i-by-i principal minor is not positive definite,
       then the routine returns with INFO = i. Otherwise, the factored
       form of A is used to estimate the condition number of the matrix
       A.  If the reciprocal of the condition number is less than machine
       precision, INFO = N+1 is returned as a warning, but the routine
       still goes on to solve for X and compute error bounds as
       described below.

    3. The system of equations is solved for X using the factored form
       of A.

    4. Iterative refinement is applied to improve the computed solution
       matrix and calculate error bounds and backward error estimates
       for it.
    \endverbatim 

 * @param[in] FACT \n
          FACT is CHARACTER*1 \n
          Specifies whether or not the factored form of A has been
          supplied on entry. \n
          = 'F':  On entry, DF and EF contain the factored form of A.
                  D, E, DF, and EF will not be modified. \n
          = 'N':  The matrix A will be copied to DF and EF and
                  factored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrices B and X.  NRHS >= 0. \n
 * @param[in] D
          D is REAL array, dimension (N) \n
          The n diagonal elements of the tridiagonal matrix A. \n
 * @param[in] E
          E is REAL array, dimension (N-1) \n
          The (n-1) subdiagonal elements of the tridiagonal matrix A. \n
 * @param[in,out] DF
          DF is REAL array, dimension (N) \n
          If FACT = 'F', then DF is an input argument and on entry
          contains the n diagonal elements of the diagonal matrix D
          from the L*D*L**T factorization of A. \n
          If FACT = 'N', then DF is an output argument and on exit
          contains the n diagonal elements of the diagonal matrix D
          from the L*D*L**T factorization of A. \n
 * @param[in,out] EF
          EF is REAL array, dimension (N-1) \n
          If FACT = 'F', then EF is an input argument and on entry
          contains the (n-1) subdiagonal elements of the unit
          bidiagonal factor L from the L*D*L**T factorization of A. \n
          If FACT = 'N', then EF is an output argument and on exit
          contains the (n-1) subdiagonal elements of the unit
          bidiagonal factor L from the L*D*L**T factorization of A. \n
 * @param[in] B
          B is REAL array, dimension (LDB,NRHS) \n
          The N-by-NRHS right hand side matrix B. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out] X
          X is REAL array, dimension (LDX,NRHS) \n
          If INFO = 0 of INFO = N+1, the N-by-NRHS solution matrix X. \n
 * @param[in] LDX
          LDX is INTEGER \n
          The leading dimension of the array X.  LDX >= max(1,N). \n
 * @param[out] RCOND
          RCOND is REAL \n
          The reciprocal condition number of the matrix A.  If RCOND
          is less than the machine precision (in particular, if
          RCOND = 0), the matrix is singular to working precision.
          This condition is indicated by a return code of INFO > 0. \n
 * @param[out] FERR
          FERR is REAL array, dimension (NRHS) \n
          The forward error bound for each solution vector
          X(j) (the j-th column of the solution matrix X). \n
          If XTRUE is the true solution corresponding to X(j), FERR(j)
          is an estimated upper bound for the magnitude of the largest
          element in (X(j) - XTRUE) divided by the magnitude of the
          largest element in X(j). \n
 * @param[out] BERR
          BERR is REAL array, dimension (NRHS) \n
          The componentwise relative backward error of each solution
          vector X(j) (i.e., the smallest relative change in any
          element of A or B that makes X(j) an exact solution). \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (N) \n
 * @param[out]	RWORK	
          RWORK is REAL array, dimension (N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, and i is \n
                <= N:  the leading minor of order i of A is
                       not positive definite, so the factorization
                       could not be completed, and the solution has not
                       been computed. RCOND = 0 is returned. \n
                = N+1: U is nonsingular, but RCOND is less than machine
                       precision, meaning that the matrix is singular
                       to working precision.  Nevertheless, the
                       solution and error bounds are computed because
                       there are a number of situations where the
                       computed solution can be more accurate than the
                       value of RCOND would suggest. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer ptsvx(char* fact, integer* n, integer* nrhs, T* d,  T* e, T* df, T* ef, T* b, integer* ldb, T* x, integer* ldx, T* rcond, T* ferr, T* berr, T* work, integer* info)
{
  return ptsvx(fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr, work, info);
}
template< typename T, typename Ta >
integer ptsvx(char* fact, integer* n, integer* nrhs, Ta* d, T* e, Ta* df, T* ef, T* b, integer* ldb, T* x, integer* ldx, Ta* rcond, Ta* ferr, Ta* berr, T* work, Ta* rwork, integer* info)
{
  return ptsvx(fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr, work, rwork, info);
}

/*! @brief PTTRF computes the L*D*L**T factorization of a real symmetric matrix

 * @details
 * \b Purpose:
    \verbatim
     PTTRF computes the L*D*L**T factorization of a real symmetric
     positive definite tridiagonal matrix A.  The factorization may also
     be regarded as having the form A = U**T*D*U.
    \endverbatim 

 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] D
          D is REAL array, dimension (N) \n
          On entry, the n diagonal elements of the tridiagonal matrix
          A.  On exit, the n diagonal elements of the diagonal matrix
          D from the L*D*L**T factorization of A. \n
 * @param[in,out] E
          E is REAL array, dimension (N-1) \n
          On entry, the (n-1) subdiagonal elements of the tridiagonal
          matrix A.  On exit, the (n-1) subdiagonal elements of the
          unit bidiagonal factor L from the L*D*L**T factorization of A. \n
          E can also be regarded as the superdiagonal of the unit
          bidiagonal factor U from the U**T*D*U factorization of A. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -k, the k-th argument had an illegal value \n
          > 0: if INFO = k, the leading minor of order k is not
               positive definite; if k < N, the factorization could not
               be completed, while if k = N, the factorization was
               completed, but D(N) <= 0. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer pttrf(integer* n, T* d, T* e, integer* info)
{
  return pttrf(n, d, e, info);
}
template< typename T, typename Ta >
integer pttrf(integer* n, Ta* d, T* e, integer* info)
{
  return pttrf(n, d, e, info);
}

/*! @brief PTTRS solves a tridiagonal system of the form A * X = B

 * @details
 * \b Purpose:
    \verbatim
     PTTRS solves a tridiagonal system of the form
        A * X = B
     using the L*D*L**T factorization of A computed by SPTTRF.  D is a
     diagonal matrix specified in the vector D, L is a unit bidiagonal
     matrix whose subdiagonal is specified in the vector E, and X and B
     are N by NRHS matrices.
    \endverbatim
    
 * @param[in] N
          N is INTEGER \n
          The order of the tridiagonal matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in] D
          D is REAL array, dimension (N) \n
          The n diagonal elements of the diagonal matrix D from the
          L*D*L**T factorization of A. \n
 * @param[in] E
          E is REAL array, dimension (N-1) \n
          The (n-1) subdiagonal elements of the unit bidiagonal factor
          L from the L*D*L**T factorization of A.  E can also be regarded
          as the superdiagonal of the unit bidiagonal factor U from the
          factorization A = U**T*D*U. \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,NRHS) \n
          On entry, the right hand side vectors B for the system of
          linear equations. \n
          On exit, the solution vectors, X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N).  \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -k, the k-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer pttrs(integer* n, integer* nrhs, T* d, T* e, T* b, integer* ldb, integer* info)
{
  return pttrs(n, nrhs, d, e, b, ldb, info);
}
template< typename T, typename Ta >
integer pttrs(char *uplo, integer* n, integer* nrhs, Ta* d, T* e, T* b, integer* ldb, integer* info)
{
  return pttrs(uplo, n, nrhs, d, e, b, ldb, info);
}

/*! @brief SBEV_2STAGE computes the eigenvalues and, optionally, \n
     the left and/or right eigenvectors for OTHER matrices

 * @details
 * \b Purpose:
    \verbatim
    SBEV_2STAGE computes all the eigenvalues and, optionally, eigenvectors of
    a real symmetric band matrix A using the 2stage technique for
    the reduction to tridiagonal.
    \endverbatim 

 * @param[in] JOBZ
          JOBZ is CHARACTER*1 \n
          = 'N':  Compute eigenvalues only; \n
          = 'V':  Compute eigenvalues and eigenvectors.
                  Not available in this release. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] KD
          KD is INTEGER \n
          The number of superdiagonals of the matrix A if UPLO = 'U',
          or the number of subdiagonals if UPLO = 'L'.  KD >= 0. \n
 * @param[in,out] AB
          AB is REAL array, dimension (LDAB, N) \n
          On entry, the upper or lower triangle of the symmetric band
          matrix A, stored in the first KD+1 rows of the array.  The
          j-th column of A is stored in the j-th column of the array AB
          as follows: \n
          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j; \n
          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd). \n
 \n
          On exit, AB is overwritten by values generated during the
          reduction to tridiagonal form.  If UPLO = 'U', the first
          superdiagonal and the diagonal of the tridiagonal matrix T
          are returned in rows KD and KD+1 of AB, and if UPLO = 'L',
          the diagonal and first subdiagonal of T are returned in the
          first two rows of AB. \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          The leading dimension of the array AB.  LDAB >= KD + 1. \n
 * @param[out] W
          W is REAL array, dimension (N) \n
          If INFO = 0, the eigenvalues in ascending order. \n
 * @param[out] Z
          Z is REAL array, dimension (LDZ, N) \n
          If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal
          eigenvectors of the matrix A, with the i-th column of Z
          holding the eigenvector associated with W(i). \n
          If JOBZ = 'N', then Z is not referenced. \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of the array Z.  LDZ >= 1, and if
          JOBZ = 'V', LDZ >= max(1,N). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension LWORK \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The length of the array WORK. LWORK >= 1, when N <= 1; \n
          otherwise   \n
          If JOBZ = 'N' and N > 1, LWORK must be queried.
                                   LWORK = MAX(1, dimension) where
                                   dimension = (2KD+1)*N + KD*NTHREADS + N
                                   where KD is the size of the band.
                                   NTHREADS is the number of threads used when
                                   openMP compilation is enabled, otherwise =1. \n
          If JOBZ = 'V' and N > 1, LWORK must be queried. Not yet available. \n

          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, the algorithm failed to converge; i
                off-diagonal elements of an intermediate tridiagonal
                form did not converge to zero. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sbev_2stage(char* jobz, char* uplo, integer* n, integer* kd, T* ab, integer* ldab, T* w, T* z, integer* ldz, T* work, integer* lwork, integer* info)
{
  return sbev_2stage(jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, lwork, info);
}
template< typename T, typename Ta >
integer hbev_2stage(char* jobz, char* uplo, integer* n, integer* kd, T* ab, integer* ldab, Ta* w, T* z, integer* ldz, T* work, integer* lwork, Ta* rwork, integer* info)
{
  return hbev_2stage(jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, lwork, rwork, info);
}

/*! @brief SBEV computes the eigenvalues and, optionally, the left \n
    and/or right eigenvectors for OTHER matrices

 * @details
 * \b Purpose:
    \verbatim
     SBEV computes all the eigenvalues and, optionally, eigenvectors of
     a real symmetric band matrix A.
    \endverbatim 

 * @param[in] JOBZ \n
          JOBZ is CHARACTER*1 \n
          = 'N':  Compute eigenvalues only; \n
          = 'V':  Compute eigenvalues and eigenvectors. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] KD
          KD is INTEGER \n
          The number of superdiagonals of the matrix A if UPLO = 'U',
          or the number of subdiagonals if UPLO = 'L'.  KD >= 0. \n
 * @param[in,out] AB
          AB is REAL array, dimension (LDAB, N) \n
          On entry, the upper or lower triangle of the symmetric band
          matrix A, stored in the first KD+1 rows of the array.  The
          j-th column of A is stored in the j-th column of the array AB
          as follows: \n
          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j; \n
          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd). \n
 \n
          On exit, AB is overwritten by values generated during the
          reduction to tridiagonal form.  If UPLO = 'U', the first
          superdiagonal and the diagonal of the tridiagonal matrix T
          are returned in rows KD and KD+1 of AB, and if UPLO = 'L',
          the diagonal and first subdiagonal of T are returned in the
          first two rows of AB. \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          The leading dimension of the array AB.  LDAB >= KD + 1. \n
 * @param[out] W
          W is REAL array, dimension (N) \n
          If INFO = 0, the eigenvalues in ascending order. \n
 * @param[out] Z
          Z is REAL array, dimension (LDZ, N) \n
          If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal
          eigenvectors of the matrix A, with the i-th column of Z
          holding the eigenvector associated with W(i). \n
          If JOBZ = 'N', then Z is not referenced. \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of the array Z.  LDZ >= 1, and if
          JOBZ = 'V', LDZ >= max(1,N). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (max(1,3*N-2)) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, the algorithm failed to converge; i
                off-diagonal elements of an intermediate tridiagonal
                form did not converge to zero. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sbev(char* jobz, char* uplo, integer* n, integer* kd, T* ab, integer* ldab, T* w, T* z, integer* ldz, T* work, integer* info)
{
  return sbev(jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, info);
}
template< typename T, typename Ta >
integer hbev(char* jobz, char* uplo, integer* n, integer* kd, T* ab, integer* ldab, Ta* w, T* z, integer* ldz, T* work, Ta* rwork, integer* info)
{
  return hbev(jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, rwork, info);
}

/*! @brief SBEVD_2STAGE computes the eigenvalues and, optionally, the left \n 
    and/or right eigenvectors for OTHER matrices

 * @details
 * \b Purpose:
    \verbatim
     SBEVD_2STAGE computes all the eigenvalues and, optionally, eigenvectors of
     a real symmetric band matrix A using the 2stage technique for
     the reduction to tridiagonal. If eigenvectors are desired, it uses
     a divide and conquer algorithm.

     The divide and conquer algorithm makes very mild assumptions about
     floating point arithmetic. It will work on machines with a guard
     digit in add/subtract, or on those binary machines without guard
     digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
     Cray-2. It could conceivably fail on hexadecimal or decimal machines
     without guard digits, but we know of none.
    \endverbatim 

 * @param[in] JOBZ
          JOBZ is CHARACTER*1 \n
          = 'N':  Compute eigenvalues only; \n
          = 'V':  Compute eigenvalues and eigenvectors.
                  Not available in this release. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] KD
          KD is INTEGER \n
          The number of superdiagonals of the matrix A if UPLO = 'U',
          or the number of subdiagonals if UPLO = 'L'.  KD >= 0. \n
 * @param[in,out] AB
          AB is REAL array, dimension (LDAB, N) \n
          On entry, the upper or lower triangle of the symmetric band
          matrix A, stored in the first KD+1 rows of the array.  The
          j-th column of A is stored in the j-th column of the array AB
          as follows: \n
          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j; \n
          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd). \n
 \n
          On exit, AB is overwritten by values generated during the
          reduction to tridiagonal form.  If UPLO = 'U', the first
          superdiagonal and the diagonal of the tridiagonal matrix T
          are returned in rows KD and KD+1 of AB, and if UPLO = 'L',
          the diagonal and first subdiagonal of T are returned in the
          first two rows of AB. \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          The leading dimension of the array AB.  LDAB >= KD + 1. \n
 * @param[out] W
          W is REAL array, dimension (N) \n
          If INFO = 0, the eigenvalues in ascending order. \n
 * @param[out] Z
          Z is REAL array, dimension (LDZ, N) \n
          If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal
          eigenvectors of the matrix A, with the i-th column of Z
          holding the eigenvector associated with W(i). \n
          If JOBZ = 'N', then Z is not referenced. \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of the array Z.  LDZ >= 1, and if
          JOBZ = 'V', LDZ >= max(1,N). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension LWORK \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The length of the array WORK. LWORK >= 1, when N <= 1; \n
          otherwise   \n
          If JOBZ = 'N' and N > 1, LWORK must be queried.
                                   LWORK = MAX(1, dimension) where
                                   dimension = (2KD+1)*N + KD*NTHREADS + N
                                   where KD is the size of the band.
                                   NTHREADS is the number of threads used when
                                   openMP compilation is enabled, otherwise =1. \n
          If JOBZ = 'V' and N > 1, LWORK must be queried. Not yet available. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal sizes of the WORK and IWORK
          arrays, returns these values as the first entries of the WORK
          and IWORK arrays, and no error message related to LWORK or
          LIWORK is issued by XERBLA. \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (MAX(1,LIWORK)) \n
          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK. \n
 * @param[in]	LIWORK	
          LIWORK is INTEGER \n
          The dimension of the array IWORK. \n
          If JOBZ  = 'N' or N <= 1, LIWORK must be at least 1. \n
          If JOBZ  = 'V' and N > 2, LIWORK must be at least 3 + 5*N. \n
 \n
          If LIWORK = -1, then a workspace query is assumed; the
          routine only calculates the optimal sizes of the WORK and
          IWORK arrays, returns these values as the first entries of
          the WORK and IWORK arrays, and no error message related to
          LWORK or LIWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, the algorithm failed to converge; i
                off-diagonal elements of an intermediate tridiagonal
                form did not converge to zero. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sbevd_2stage(char* jobz, char* uplo, integer* n, integer* kd, T* ab, integer* ldab, T* w, T* z, integer* ldz, T* work, integer* lwork, integer* iwork, integer* liwork, integer* info)
{
  return sbevd_2stage(jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, lwork, iwork, liwork, info);
}
template< typename T, typename Ta >
integer hbevd_2stage(char* jobz, char* uplo, integer* n, integer* kd, T* ab, integer* ldab, Ta* w, T* z, integer* ldz, T* work, integer* lwork, Ta* rwork, integer* lrwork, integer* iwork, integer* liwork, integer* info)
{
  return hbevd_2stage(jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info);
}

/*! @brief SBEVD computes the eigenvalues and, optionally, the left \n 
    and/or right eigenvectors for OTHER matrices

 * @details
 * \b Purpose:
    \verbatim
      SBEVD computes all the eigenvalues and, optionally, eigenvectors of
     a real symmetric band matrix A. If eigenvectors are desired, it uses
     a divide and conquer algorithm.

     The divide and conquer algorithm makes very mild assumptions about
     floating point arithmetic. It will work on machines with a guard
     digit in add/subtract, or on those binary machines without guard
     digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
     Cray-2. It could conceivably fail on hexadecimal or decimal machines
     without guard digits, but we know of none.
    \endverbatim 

 * @param[in] JOBZ
          JOBZ is CHARACTER*1 \n
          = 'N':  Compute eigenvalues only; \n
          = 'V':  Compute eigenvalues and eigenvectors. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] KD
          KD is INTEGER \n
          The number of superdiagonals of the matrix A if UPLO = 'U',
          or the number of subdiagonals if UPLO = 'L'.  KD >= 0. \n
 * @param[in,out] AB
          AB is REAL array, dimension (LDAB, N) \n
          On entry, the upper or lower triangle of the symmetric band
          matrix A, stored in the first KD+1 rows of the array.  The
          j-th column of A is stored in the j-th column of the array AB
          as follows: \n
          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j; \n
          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd). \n
 \n
          On exit, AB is overwritten by values generated during the
          reduction to tridiagonal form.  If UPLO = 'U', the first
          superdiagonal and the diagonal of the tridiagonal matrix T
          are returned in rows KD and KD+1 of AB, and if UPLO = 'L',
          the diagonal and first subdiagonal of T are returned in the
          first two rows of AB. \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          The leading dimension of the array AB.  LDAB >= KD + 1. \n
 * @param[out] W
          W is REAL array, dimension (N) \n
          If INFO = 0, the eigenvalues in ascending order. \n
 * @param[out] Z
          Z is REAL array, dimension (LDZ, N) \n
          If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal
          eigenvectors of the matrix A, with the i-th column of Z
          holding the eigenvector associated with W(i). \n
          If JOBZ = 'N', then Z is not referenced. \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of the array Z.  LDZ >= 1, and if
          JOBZ = 'V', LDZ >= max(1,N). \n
 * @param[out]	WORK	
          WORK is REAL array,
                                         dimension (LWORK) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK. \n
          IF N <= 1,                LWORK must be at least 1. \n
          If JOBZ  = 'N' and N > 2, LWORK must be at least 2*N. \n
          If JOBZ  = 'V' and N > 2, LWORK must be at least
                         ( 1 + 5*N + 2*N**2 ). \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal sizes of the WORK and IWORK
          arrays, returns these values as the first entries of the WORK
          and IWORK arrays, and no error message related to LWORK or
          LIWORK is issued by XERBLA. \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (MAX(1,LIWORK)) \n
          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK. \n
 * @param[in]	LIWORK	
          LIWORK is INTEGER \n
          The dimension of the array IWORK. \n
          If JOBZ  = 'N' or N <= 1, LIWORK must be at least 1. \n
          If JOBZ  = 'V' and N > 2, LIWORK must be at least 3 + 5*N. \n
 \n
          If LIWORK = -1, then a workspace query is assumed; the
          routine only calculates the optimal sizes of the WORK and
          IWORK arrays, returns these values as the first entries of
          the WORK and IWORK arrays, and no error message related to
          LWORK or LIWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, the algorithm failed to converge; i
                off-diagonal elements of an intermediate tridiagonal
                form did not converge to zero. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sbevd(char* jobz, char* uplo, integer* n, integer* kd, T* ab, integer* ldab, T* w, T* z, integer* ldz, T* work, integer* lwork, integer* iwork, integer* liwork, integer* info)
{
  return sbevd(jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, lwork, iwork, liwork, info);
}
template< typename T, typename Ta >
integer hbevd(char* jobz, char* uplo, integer* n, integer* kd, T* ab, integer* ldab, Ta* w, T* z, integer* ldz, T* work, integer* lwork, Ta* rwork, integer* lrwork, integer* iwork, integer* liwork, integer* info)
{
  return hbevd(jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info);
}

/*! @brief SBEVX_2STAGE computes the eigenvalues and, optionally, the left \n
     and/or right eigenvectors for OTHER matrices

 * @details
 * \b Purpose:
    \verbatim
     SBEVX_2STAGE computes selected eigenvalues and, optionally, eigenvectors
     of a real symmetric band matrix A using the 2stage technique for
     the reduction to tridiagonal. Eigenvalues and eigenvectors can
     be selected by specifying either a range of values or a range of
     indices for the desired eigenvalues.
    \endverbatim 

 * @param[in] JOBZ
          JOBZ is CHARACTER*1 \n
          = 'N':  Compute eigenvalues only; \n
          = 'V':  Compute eigenvalues and eigenvectors.
                  Not available in this release. \n
 * @param[in] RANGE
          RANGE is CHARACTER*1 \n
          = 'A': all eigenvalues will be found; \n
          = 'V': all eigenvalues in the half-open interval (VL,VU]
                 will be found; \n
          = 'I': the IL-th through IU-th eigenvalues will be found. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] KD
          KD is INTEGER \n
          The number of superdiagonals of the matrix A if UPLO = 'U',
          or the number of subdiagonals if UPLO = 'L'.  KD >= 0. \n
 * @param[in,out] AB
          AB is REAL array, dimension (LDAB, N) \n
          On entry, the upper or lower triangle of the symmetric band
          matrix A, stored in the first KD+1 rows of the array.  The
          j-th column of A is stored in the j-th column of the array AB
          as follows: \n
          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j; \n
          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd). \n
 \n
          On exit, AB is overwritten by values generated during the
          reduction to tridiagonal form.  If UPLO = 'U', the first
          superdiagonal and the diagonal of the tridiagonal matrix T
          are returned in rows KD and KD+1 of AB, and if UPLO = 'L',
          the diagonal and first subdiagonal of T are returned in the
          first two rows of AB. \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          The leading dimension of the array AB.  LDAB >= KD + 1. \n
 * @param[out] Q
          Q is REAL array, dimension (LDQ, N) \n
          If JOBZ = 'V', the N-by-N orthogonal matrix used in the
                         reduction to tridiagonal form. \n
          If JOBZ = 'N', the array Q is not referenced. \n
 * @param[in] LDQ
          LDQ is INTEGER \n
          The leading dimension of the array Q.  If JOBZ = 'V', then
          LDQ >= max(1,N). \n
 * @param[in] VL
          VL is REAL \n
          If RANGE='V', the lower bound of the interval to
          be searched for eigenvalues. VL < VU.
          Not referenced if RANGE = 'A' or 'I'. \n
 * @param[in] VU
          VU is REAL \n
          If RANGE='V', the upper bound of the interval to
          be searched for eigenvalues. VL < VU.
          Not referenced if RANGE = 'A' or 'I'. \n
 * @param[in] IL
          IL is INTEGER \n
          If RANGE='I', the index of the
          smallest eigenvalue to be returned. \n
          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
          Not referenced if RANGE = 'A' or 'V'. \n
 * @param[in] IU
          IU is INTEGER \n
          If RANGE='I', the index of the
          largest eigenvalue to be returned. \n
          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
          Not referenced if RANGE = 'A' or 'V'. \n
 * @param[in] ABSTOL
          ABSTOL is REAL \n
          The absolute error tolerance for the eigenvalues.
          An approximate eigenvalue is accepted as converged
          when it is determined to lie in an interval [a,b]
          of width less than or equal to \n
 \n
                  ABSTOL + EPS *   max( |a|,|b|) , \n
 \n
          where EPS is the machine precision.  If ABSTOL is less than
          or equal to zero, then  EPS*|T|  will be used in its place,
          where |T| is the 1-norm of the tridiagonal matrix obtained
          by reducing AB to tridiagonal form. \n
 \n
          Eigenvalues will be computed most accurately when ABSTOL is
          set to twice the underflow threshold 2*SLAMCH('S'), not zero.
          If this routine returns with INFO>0, indicating that some
          eigenvectors did not converge, try setting ABSTOL to
          2*SLAMCH('S'). \n
 \n
          See "Computing Small Singular Values of Bidiagonal Matrices
          with Guaranteed High Relative Accuracy," by Demmel and
          Kahan, LAPACK Working Note #3. \n
 * @param[out] M
          M is INTEGER \n
          The total number of eigenvalues found.  0 <= M <= N.
          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1. \n
 * @param[out] W
          W is REAL array, dimension (N) \n
          The first M elements contain the selected eigenvalues in
          ascending order. \n
 * @param[out] Z
          Z is REAL array, dimension (LDZ, max(1,M)) \n
          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
          contain the orthonormal eigenvectors of the matrix A
          corresponding to the selected eigenvalues, with the i-th
          column of Z holding the eigenvector associated with W(i).
          If an eigenvector fails to converge, then that column of Z
          contains the latest approximation to the eigenvector, and the
          index of the eigenvector is returned in IFAIL. \n
          If JOBZ = 'N', then Z is not referenced. \n
          Note: the user must ensure that at least max(1,M) columns are
          supplied in the array Z; if RANGE = 'V', the exact value of M
          is not known in advance and an upper bound must be used. \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of the array Z.  LDZ >= 1, and if
          JOBZ = 'V', LDZ >= max(1,N). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (LWORK) \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The length of the array WORK. LWORK >= 1, when N <= 1; \n
          otherwise   \n
          If JOBZ = 'N' and N > 1, LWORK must be queried.
                                   LWORK = MAX(1, 7*N, dimension) where
                                   dimension = (2KD+1)*N + KD*NTHREADS + 2*N
                                   where KD is the size of the band.
                                   NTHREADS is the number of threads used when
                                   openMP compilation is enabled, otherwise =1. \n
          If JOBZ = 'V' and N > 1, LWORK must be queried. Not yet available \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (5*N) \n
 * @param[out]	IFAIL	
          IFAIL is INTEGER array, dimension (N) \n
          If JOBZ = 'V', then if INFO = 0, the first M elements of
          IFAIL are zero.  If INFO > 0, then IFAIL contains the
          indices of the eigenvectors that failed to converge. \n
          If JOBZ = 'N', then IFAIL is not referenced. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n
          > 0:  if INFO = i, then i eigenvectors failed to converge.
                Their indices are stored in array IFAIL. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sbevx_2stage(char* jobz, char* range, char* uplo, integer* n, integer* kd, T* ab, integer* ldab, T* q, integer* ldq, T* vl, T* vu, integer* il, integer* iu, T* abstol, integer* m, T* w, T* z, integer* ldz, T* work, integer* lwork, integer* iwork, integer* ifail, integer* info)
{
  return sbevx_2stage(jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, iwork, ifail, info);
}
template< typename T, typename Ta >
integer hbevx_2stage(char* jobz, char* range, char* uplo, integer* n, integer* kd, T* ab, integer* ldab, T* q, integer* ldq, Ta* vl, Ta* vu, integer* il, integer* iu, Ta* abstol, integer* m, Ta* w, T* z, integer* ldz, T* work, integer* lwork, Ta* rwork, integer* iwork, integer* ifail, integer* info)
{
  return hbevx_2stage(jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, rwork, iwork, ifail, info);
}

/*! @brief SBEVX computes the eigenvalues and, optionally, the left \n
     and/or right eigenvectors for OTHER matrices

 * @details
 * \b Purpose:
    \verbatim
     SBEVX computes selected eigenvalues and, optionally, eigenvectors
     of a real symmetric band matrix A.  Eigenvalues and eigenvectors can
     be selected by specifying either a range of values or a range of
     indices for the desired eigenvalues.
    \endverbatim 

 * @param[in] JOBZ
          JOBZ is CHARACTER*1 \n
          = 'N':  Compute eigenvalues only; \n
          = 'V':  Compute eigenvalues and eigenvectors. \n
 * @param[in] RANGE
          RANGE is CHARACTER*1 \n
          = 'A': all eigenvalues will be found; \n
          = 'V': all eigenvalues in the half-open interval (VL,VU]
                 will be found; \n
          = 'I': the IL-th through IU-th eigenvalues will be found. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] KD
          KD is INTEGER \n
          The number of superdiagonals of the matrix A if UPLO = 'U',
          or the number of subdiagonals if UPLO = 'L'.  KD >= 0. \n
 * @param[in,out] AB
          AB is REAL array, dimension (LDAB, N) \n
          On entry, the upper or lower triangle of the symmetric band
          matrix A, stored in the first KD+1 rows of the array.  The
          j-th column of A is stored in the j-th column of the array AB
          as follows: \n
          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j; \n
          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd). \n
 \n
          On exit, AB is overwritten by values generated during the
          reduction to tridiagonal form.  If UPLO = 'U', the first
          superdiagonal and the diagonal of the tridiagonal matrix T
          are returned in rows KD and KD+1 of AB, and if UPLO = 'L',
          the diagonal and first subdiagonal of T are returned in the
          first two rows of AB. \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          The leading dimension of the array AB.  LDAB >= KD + 1. \n
 * @param[out] Q
          Q is REAL array, dimension (LDQ, N) \n
          If JOBZ = 'V', the N-by-N orthogonal matrix used in the
                         reduction to tridiagonal form. \n
          If JOBZ = 'N', the array Q is not referenced. \n
 * @param[in] LDQ
          LDQ is INTEGER \n
          The leading dimension of the array Q.  If JOBZ = 'V', then
          LDQ >= max(1,N). \n
 * @param[in] VL
          VL is REAL \n
          If RANGE='V', the lower bound of the interval to
          be searched for eigenvalues. VL < VU.
          Not referenced if RANGE = 'A' or 'I'. \n
 * @param[in] VU
          VU is REAL \n
          If RANGE='V', the upper bound of the interval to
          be searched for eigenvalues. VL < VU.
          Not referenced if RANGE = 'A' or 'I'. \n
 * @param[in] IL
          IL is INTEGER \n
          If RANGE='I', the index of the
          smallest eigenvalue to be returned.
          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
          Not referenced if RANGE = 'A' or 'V'. \n
 * @param[in] IU
          IU is INTEGER \n
          If RANGE='I', the index of the
          largest eigenvalue to be returned. \n
          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
          Not referenced if RANGE = 'A' or 'V'. \n
 * @param[in] ABSTOL
          ABSTOL is REAL \n
          The absolute error tolerance for the eigenvalues.
          An approximate eigenvalue is accepted as converged
          when it is determined to lie in an interval [a,b]
          of width less than or equal to \n
 \n
                  ABSTOL + EPS *   max( |a|,|b|) , \n
 \n
          where EPS is the machine precision.  If ABSTOL is less than
          or equal to zero, then  EPS*|T|  will be used in its place,
          where |T| is the 1-norm of the tridiagonal matrix obtained
          by reducing AB to tridiagonal form. \n
 \n
          Eigenvalues will be computed most accurately when ABSTOL is
          set to twice the underflow threshold 2*SLAMCH('S'), not zero.
          If this routine returns with INFO>0, indicating that some
          eigenvectors did not converge, try setting ABSTOL to
          2*SLAMCH('S'). \n
 \n
          See "Computing Small Singular Values of Bidiagonal Matrices
          with Guaranteed High Relative Accuracy," by Demmel and
          Kahan, LAPACK Working Note #3. \n
 * @param[out] M
          M is INTEGER \n
          The total number of eigenvalues found.  0 <= M <= N.
          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1. \n
 * @param[out] W
          W is REAL array, dimension (N) \n
          The first M elements contain the selected eigenvalues in
          ascending order. \n
 * @param[out] Z
          Z is REAL array, dimension (LDZ, max(1,M)) \n
          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
          contain the orthonormal eigenvectors of the matrix A
          corresponding to the selected eigenvalues, with the i-th
          column of Z holding the eigenvector associated with W(i).
          If an eigenvector fails to converge, then that column of Z
          contains the latest approximation to the eigenvector, and the
          index of the eigenvector is returned in IFAIL. \n
          If JOBZ = 'N', then Z is not referenced. \n
          Note: the user must ensure that at least max(1,M) columns are
          supplied in the array Z; if RANGE = 'V', the exact value of M
          is not known in advance and an upper bound must be used. \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of the array Z.  LDZ >= 1, and if
          JOBZ = 'V', LDZ >= max(1,N). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (7*N) \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (5*N) \n
 * @param[out]	IFAIL	
          IFAIL is INTEGER array, dimension (N) \n
          If JOBZ = 'V', then if INFO = 0, the first M elements of
          IFAIL are zero.  If INFO > 0, then IFAIL contains the
          indices of the eigenvectors that failed to converge. \n
          If JOBZ = 'N', then IFAIL is not referenced. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n
          > 0:  if INFO = i, then i eigenvectors failed to converge.
                Their indices are stored in array IFAIL. \n


 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sbevx(char* jobz, char* range, char* uplo, integer* n, integer* kd, T* ab, integer* ldab, T* q, integer* ldq, T* vl, T* vu, integer* il, integer* iu, T* abstol, integer* m, T* w, T* z, integer* ldz, T* work, integer* iwork, integer* ifail, integer* info)
{
  return sbevx(jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail, info);
}
template< typename T, typename Ta >
integer hbevx(char* jobz, char* range, char* uplo, integer* n, integer* kd, T* ab, integer* ldab, T* q, integer* ldq, Ta* vl, Ta* vu, integer* il, integer* iu, Ta* abstol, integer* m, Ta* w, T* z, integer* ldz, T* work, Ta* rwork, integer* iwork, integer* ifail, integer* info)
{
  return hbevx(jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail, info);
}

/*! @brief SBGST reduces a real symmetric-definite banded generalized eigenproblem  to standard form

 * @details
 * \b Purpose:
    \verbatim
     SBGST reduces a real symmetric-definite banded generalized
     eigenproblem  A*x = lambda*B*x  to standard form  C*y = lambda*y,
     such that C has the same bandwidth as A.

     B must have been previously factorized as S**T*S by SPBSTF, using a
     split Cholesky factorization. A is overwritten by C = X**T*A*X, where
     X = S**(-1)*Q and Q is an orthogonal matrix chosen to preserve the
     bandwidth of A.
    \endverbatim 

 * @param[in] VECT
          VECT is CHARACTER*1 \n
          = 'N':  do not form the transformation matrix X; \n
          = 'V':  form X. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrices A and B.  N >= 0. \n
 * @param[in] KA
          KA is INTEGER \n
          The number of superdiagonals of the matrix A if UPLO = 'U',
          or the number of subdiagonals if UPLO = 'L'.  KA >= 0. \n
 * @param[in] KB
          KB is INTEGER \n
          The number of superdiagonals of the matrix B if UPLO = 'U',
          or the number of subdiagonals if UPLO = 'L'.  KA >= KB >= 0. \n
 * @param[in,out] AB
          AB is REAL array, dimension (LDAB,N) \n
          On entry, the upper or lower triangle of the symmetric band
          matrix A, stored in the first ka+1 rows of the array.  The
          j-th column of A is stored in the j-th column of the array AB
          as follows: \n
          if UPLO = 'U', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j; \n
          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+ka). \n
 \n
          On exit, the transformed matrix X**T*A*X, stored in the same
          format as A. \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          The leading dimension of the array AB.  LDAB >= KA+1. \n
 * @param[in] BB
          BB is REAL array, dimension (LDBB,N) \n
          The banded factor S from the split Cholesky factorization of
          B, as returned by SPBSTF, stored in the first KB+1 rows of
          the array. \n
 * @param[in] LDBB
          LDBB is INTEGER \n
          The leading dimension of the array BB.  LDBB >= KB+1. \n
 * @param[out] X
          X is REAL array, dimension (LDX,N) \n
          If VECT = 'V', the n-by-n matrix X. \n
          If VECT = 'N', the array X is not referenced. \n
 * @param[in] LDX
          LDX is INTEGER \n
          The leading dimension of the array X.
          LDX >= max(1,N) if VECT = 'V'; LDX >= 1 otherwise. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (2*N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sbgst(char* vect, char* uplo, integer* n, integer* ka, integer* kb, T* ab, integer* ldab,  T* bb, integer* ldbb, T* x, integer* ldx, T* work, integer* info)
{
  return sbgst(vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x, ldx, work, info);
}
template< typename T, typename Ta >
integer hbgst(char* vect, char* uplo, integer* n, integer* ka, integer* kb, T* ab, integer* ldab,  T* bb, integer* ldbb, T* x, integer* ldx, T* work, Ta* rwork, integer* info)
{
  return hbgst(vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x, ldx, work, rwork, info);
}

/*! @brief SBGV computes all the eigenvalues, and optionally, the eigenvectors

 * @details
 * \b Purpose:
    \verbatim
     SBGV computes all the eigenvalues, and optionally, the eigenvectors
     of a real generalized symmetric-definite banded eigenproblem, of
     the form A*x=(lambda)*B*x. Here A and B are assumed to be symmetric
     and banded, and B is also positive definite.
    \endverbatim 

 * @param[in] JOBZ
          JOBZ is CHARACTER*1 \n
          = 'N':  Compute eigenvalues only; \n
          = 'V':  Compute eigenvalues and eigenvectors. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangles of A and B are stored; \n
          = 'L':  Lower triangles of A and B are stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrices A and B.  N >= 0. \n
 * @param[in] KA
          KA is INTEGER \n
          The number of superdiagonals of the matrix A if UPLO = 'U',
          or the number of subdiagonals if UPLO = 'L'. KA >= 0. \n
 * @param[in] KB
          KB is INTEGER \n
          The number of superdiagonals of the matrix B if UPLO = 'U',
          or the number of subdiagonals if UPLO = 'L'. KB >= 0. \n
 * @param[in,out] AB
          AB is REAL array, dimension (LDAB, N) \n
          On entry, the upper or lower triangle of the symmetric band
          matrix A, stored in the first ka+1 rows of the array.  The
          j-th column of A is stored in the j-th column of the array AB
          as follows: \n
          if UPLO = 'U', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j; \n
          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+ka). \n
 \n
          On exit, the contents of AB are destroyed. \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          The leading dimension of the array AB.  LDAB >= KA+1. \n
 * @param[in,out] BB
          BB is REAL array, dimension (LDBB, N) \n
          On entry, the upper or lower triangle of the symmetric band
          matrix B, stored in the first kb+1 rows of the array.  The
          j-th column of B is stored in the j-th column of the array BB
          as follows: \n
          if UPLO = 'U', BB(kb+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j; \n
          if UPLO = 'L', BB(1+i-j,j)    = B(i,j) for j<=i<=min(n,j+kb). \n
 \n
          On exit, the factor S from the split Cholesky factorization
          B = S**T*S, as returned by SPBSTF. \n
 * @param[in] LDBB
          LDBB is INTEGER \n
          The leading dimension of the array BB.  LDBB >= KB+1. \n
 * @param[out] W
          W is REAL array, dimension (N) \n
          If INFO = 0, the eigenvalues in ascending order. \n
 * @param[out] Z
          Z is REAL array, dimension (LDZ, N) \n
          If JOBZ = 'V', then if INFO = 0, Z contains the matrix Z of
          eigenvectors, with the i-th column of Z holding the
          eigenvector associated with W(i). The eigenvectors are
          normalized so that Z**T*B*Z = I. \n
          If JOBZ = 'N', then Z is not referenced. \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of the array Z.  LDZ >= 1, and if
          JOBZ = 'V', LDZ >= N. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (3*N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, and i is: \n
             <= N:  the algorithm failed to converge:
                    i off-diagonal elements of an intermediate
                    tridiagonal form did not converge to zero; \n
             > N:   if INFO = N + i, for 1 <= i <= N, then SPBSTF
                    returned INFO = i: B is not positive definite.
                    The factorization of B could not be completed and
                    no eigenvalues or eigenvectors were computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sbgv(char* jobz, char* uplo, integer* n, integer* ka, integer* kb, T* ab, integer* ldab, T* bb, integer* ldbb, T* w, T* z, integer* ldz, float* work, integer* info)
{
  return sbgv(jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work, info);
}
template< typename T, typename Ta >
integer hbgv(char* jobz, char* uplo, integer* n, integer* ka, integer* kb, T* ab, integer* ldab, T* bb, integer* ldbb, Ta* w, T* z, integer* ldz, T* work, Ta* rwork, integer* info)
{
  return hbgv(jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work, rwork, info);
}

/*! @brief SBGVD computes all the eigenvalues, and optionally, the eigenvectors

 * @details
 * \b Purpose:
    \verbatim
     SBGVD computes all the eigenvalues, and optionally, the eigenvectors
     of a real generalized symmetric-definite banded eigenproblem, of the
     form A*x=(lambda)*B*x.  Here A and B are assumed to be symmetric and
     banded, and B is also positive definite.  If eigenvectors are
     desired, it uses a divide and conquer algorithm.

     The divide and conquer algorithm makes very mild assumptions about
     floating point arithmetic. It will work on machines with a guard
     digit in add/subtract, or on those binary machines without guard
     digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
     Cray-2. It could conceivably fail on hexadecimal or decimal machines
     without guard digits, but we know of none.
    \endverbatim 

 * @param[in] JOBZ
          JOBZ is CHARACTER*1 \n
          = 'N':  Compute eigenvalues only; \n
          = 'V':  Compute eigenvalues and eigenvectors. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangles of A and B are stored; \n
          = 'L':  Lower triangles of A and B are stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrices A and B.  N >= 0. \n
 * @param[in] KA
          KA is INTEGER \n
          The number of superdiagonals of the matrix A if UPLO = 'U',
          or the number of subdiagonals if UPLO = 'L'.  KA >= 0. \n
 * @param[in] KB
          KB is INTEGER \n
          The number of superdiagonals of the matrix B if UPLO = 'U',
          or the number of subdiagonals if UPLO = 'L'.  KB >= 0. \n
 * @param[in,out] AB
          AB is REAL array, dimension (LDAB, N) \n
          On entry, the upper or lower triangle of the symmetric band
          matrix A, stored in the first ka+1 rows of the array.  The
          j-th column of A is stored in the j-th column of the array AB
          as follows: \n
          if UPLO = 'U', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j; \n
          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+ka). \n
 \n
          On exit, the contents of AB are destroyed. \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          The leading dimension of the array AB.  LDAB >= KA+1. \n
 * @param[in,out] BB
          BB is REAL array, dimension (LDBB, N) \n
          On entry, the upper or lower triangle of the symmetric band
          matrix B, stored in the first kb+1 rows of the array.  The
          j-th column of B is stored in the j-th column of the array BB
          as follows: \n
          if UPLO = 'U', BB(ka+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j; \n
          if UPLO = 'L', BB(1+i-j,j)    = B(i,j) for j<=i<=min(n,j+kb). \n
 \n
          On exit, the factor S from the split Cholesky factorization
          B = S**T*S, as returned by SPBSTF. \n
 * @param[in] LDBB
          LDBB is INTEGER \n
          The leading dimension of the array BB.  LDBB >= KB+1. \n
 * @param[out] W
          W is REAL array, dimension (N) \n
          If INFO = 0, the eigenvalues in ascending order. \n
 * @param[out] Z
          Z is REAL array, dimension (LDZ, N) \n
          If JOBZ = 'V', then if INFO = 0, Z contains the matrix Z of
          eigenvectors, with the i-th column of Z holding the
          eigenvector associated with W(i).  The eigenvectors are
          normalized so Z**T*B*Z = I. \n
          If JOBZ = 'N', then Z is not referenced. \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of the array Z.  LDZ >= 1, and if
          JOBZ = 'V', LDZ >= max(1,N). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK. \n
          If N <= 1,               LWORK >= 1. \n
          If JOBZ = 'N' and N > 1, LWORK >= 3*N. \n
          If JOBZ = 'V' and N > 1, LWORK >= 1 + 5*N + 2*N**2. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal sizes of the WORK and IWORK
          arrays, returns these values as the first entries of the WORK
          and IWORK arrays, and no error message related to LWORK or
          LIWORK is issued by XERBLA. \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (MAX(1,LIWORK)) \n
          On exit, if LIWORK > 0, IWORK(1) returns the optimal LIWORK. \n
 * @param[in]	LIWORK	
          LIWORK is INTEGER \n
          The dimension of the array IWORK. \n
          If JOBZ  = 'N' or N <= 1, LIWORK >= 1. \n
          If JOBZ  = 'V' and N > 1, LIWORK >= 3 + 5*N. \n
 \n
          If LIWORK = -1, then a workspace query is assumed; the
          routine only calculates the optimal sizes of the WORK and
          IWORK arrays, returns these values as the first entries of
          the WORK and IWORK arrays, and no error message related to
          LWORK or LIWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, and i is: \n
             <= N:  the algorithm failed to converge:
                    i off-diagonal elements of an intermediate
                    tridiagonal form did not converge to zero; \n
             > N:   if INFO = N + i, for 1 <= i <= N, then SPBSTF
                    returned INFO = i: B is not positive definite.
                    The factorization of B could not be completed and
                    no eigenvalues or eigenvectors were computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sbgvd(char* jobz, char* uplo, integer* n, integer* ka, integer* kb, T* ab, integer* ldab, T* bb, integer* ldbb, T* w, T* z, integer* ldz, T* work, integer* lwork, integer* iwork, integer* liwork, integer* info)
{
  return sbgvd(jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work, lwork, iwork, liwork, info);
}
template< typename T, typename Ta >
integer hbgvd(char* jobz, char* uplo, integer* n, integer* ka, integer* kb, T* ab, integer* ldab, T* bb, integer* ldbb, Ta* w, T* z, integer* ldz, T* work, integer* lwork, Ta* rwork, integer* lrwork, integer* iwork, integer* liwork, integer* info)
{
  return hbgvd(jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info);
}

/*! @brief SBGVX computes all the eigenvalues, and optionally, the eigenvectors

 * @details
 * \b Purpose:
    \verbatim
     SBGVX computes selected eigenvalues, and optionally, eigenvectors
     of a real generalized symmetric-definite banded eigenproblem, of
     the form A*x=(lambda)*B*x.  Here A and B are assumed to be symmetric
     and banded, and B is also positive definite.  Eigenvalues and
     eigenvectors can be selected by specifying either all eigenvalues,
     a range of values or a range of indices for the desired eigenvalues.
    \endverbatim 

 * @param[in] JOBZ
          JOBZ is CHARACTER*1 \n
          = 'N':  Compute eigenvalues only; \n
          = 'V':  Compute eigenvalues and eigenvectors. \n
 * @param[in] RANGE
          RANGE is CHARACTER*1 \n
          = 'A': all eigenvalues will be found. \n
          = 'V': all eigenvalues in the half-open interval (VL,VU]
                 will be found. \n
          = 'I': the IL-th through IU-th eigenvalues will be found. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangles of A and B are stored; \n
          = 'L':  Lower triangles of A and B are stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrices A and B.  N >= 0. \n
 * @param[in] KA
          KA is INTEGER \n
          The number of superdiagonals of the matrix A if UPLO = 'U',
          or the number of subdiagonals if UPLO = 'L'.  KA >= 0. \n
 * @param[in] KB
          KB is INTEGER \n
          The number of superdiagonals of the matrix B if UPLO = 'U',
          or the number of subdiagonals if UPLO = 'L'.  KB >= 0. \n
 * @param[in,out] AB
          AB is REAL array, dimension (LDAB, N) \n
          On entry, the upper or lower triangle of the symmetric band
          matrix A, stored in the first ka+1 rows of the array.  The
          j-th column of A is stored in the j-th column of the array AB
          as follows: \n
          if UPLO = 'U', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j; \n
          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+ka). \n
 \n
          On exit, the contents of AB are destroyed. \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          The leading dimension of the array AB.  LDAB >= KA+1. \n
 * @param[in,out] BB
          BB is REAL array, dimension (LDBB, N) \n
          On entry, the upper or lower triangle of the symmetric band
          matrix B, stored in the first kb+1 rows of the array.  The
          j-th column of B is stored in the j-th column of the array BB
          as follows: \n
          if UPLO = 'U', BB(ka+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j; \n
          if UPLO = 'L', BB(1+i-j,j)    = B(i,j) for j<=i<=min(n,j+kb). \n
 \n
          On exit, the factor S from the split Cholesky factorization
          B = S**T*S, as returned by SPBSTF. \n
 * @param[in] LDBB
          LDBB is INTEGER \n
          The leading dimension of the array BB.  LDBB >= KB+1. \n
 * @param[out] Q
          Q is REAL array, dimension (LDQ, N) \n
          If JOBZ = 'V', the n-by-n matrix used in the reduction of
          A*x = (lambda)*B*x to standard form, i.e. C*x = (lambda)*x,
          and consequently C to tridiagonal form. \n
          If JOBZ = 'N', the array Q is not referenced. \n
 * @param[in] LDQ
          LDQ is INTEGER \n
          The leading dimension of the array Q.  If JOBZ = 'N',
          LDQ >= 1. If JOBZ = 'V', LDQ >= max(1,N). \n
 * @param[in] VL
          VL is REAL \n
          If RANGE='V', the lower bound of the interval to
          be searched for eigenvalues. VL < VU.
          Not referenced if RANGE = 'A' or 'I'. \n
 * @param[in] VU
          VU is REAL \n
          If RANGE='V', the upper bound of the interval to
          be searched for eigenvalues. VL < VU.
          Not referenced if RANGE = 'A' or 'I'. \n
 * @param[in] IL
          IL is INTEGER \n
          If RANGE='I', the index of the
          smallest eigenvalue to be returned. \n
          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0. \n
          Not referenced if RANGE = 'A' or 'V'. \n
 * @param[in] IU
          IU is INTEGER \n
          If RANGE='I', the index of the
          largest eigenvalue to be returned. \n
          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0. \n
          Not referenced if RANGE = 'A' or 'V'. \n
 * @param[in] ABSTOL
          ABSTOL is REAL \n
          The absolute error tolerance for the eigenvalues.
          An approximate eigenvalue is accepted as converged
          when it is determined to lie in an interval [a,b]
          of width less than or equal to \n
 \n
                  ABSTOL + EPS *   max( |a|,|b|) , \n
 \n
          where EPS is the machine precision.  If ABSTOL is less than
          or equal to zero, then  EPS*|T|  will be used in its place,
          where |T| is the 1-norm of the tridiagonal matrix obtained
          by reducing A to tridiagonal form. \n
 \n
          Eigenvalues will be computed most accurately when ABSTOL is
          set to twice the underflow threshold 2*SLAMCH('S'), not zero.
          If this routine returns with INFO>0, indicating that some
          eigenvectors did not converge, try setting ABSTOL to
          2*SLAMCH('S'). \n
 * @param[out] M
          M is INTEGER \n
          The total number of eigenvalues found.  0 <= M <= N. \n
          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1. \n
 * @param[out] W
          W is REAL array, dimension (N) \n
          If INFO = 0, the eigenvalues in ascending order. \n
 * @param[out] Z
          Z is REAL array, dimension (LDZ, N) \n
          If JOBZ = 'V', then if INFO = 0, Z contains the matrix Z of
          eigenvectors, with the i-th column of Z holding the
          eigenvector associated with W(i).  The eigenvectors are
          normalized so Z**T*B*Z = I. \n
          If JOBZ = 'N', then Z is not referenced. \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of the array Z.  LDZ >= 1, and if
          JOBZ = 'V', LDZ >= max(1,N). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (7*N) \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (5*N) \n
 * @param[out]	IFAIL	
          IFAIL is INTEGER array, dimension (M) \n
          If JOBZ = 'V', then if INFO = 0, the first M elements of
          IFAIL are zero.  If INFO > 0, then IFAIL contains the
          indices of the eigenvalues that failed to converge. \n
          If JOBZ = 'N', then IFAIL is not referenced. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          <= N: if INFO = i, then i eigenvectors failed to converge.
                  Their indices are stored in IFAIL. \n
          > N:  SPBSTF returned an error code; i.e.,
                if INFO = N + i, for 1 <= i <= N, then the leading
                minor of order i of B is not positive definite.
                The factorization of B could not be completed and
                no eigenvalues or eigenvectors were computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sbgvx(char* jobz, char* range, char* uplo, integer* n, integer* ka, integer* kb, T* ab, integer* ldab, T* bb, integer* ldbb, T* q, integer* ldq, T* vl, T* vu, integer* il, integer* iu, T* abstol, integer* m, T* w, T* z, integer* ldz, T* work, integer* iwork, integer* ifail, integer* info)
{
  return sbgvx(jobz, range, uplo, n, ka, kb, ab, ldab, bb, ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail, info);
}
template< typename T, typename Ta >
integer hbgvx(char* jobz, char* range, char* uplo, integer* n, integer* ka, integer* kb, T* ab, integer* ldab, T* bb, integer* ldbb, T* q, integer* ldq, Ta* vl, Ta* vu, integer* il, integer* iu, Ta* abstol, integer* m, Ta* w, T* z, integer* ldz, T* work, Ta* rwork, integer* iwork, integer* ifail, integer* info)
{
  return hbgvx(jobz, range, uplo, n, ka, kb, ab, ldab, bb, ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail, info);
}

/*! @brief SBTRD reduces a real symmetric band matrix A to symmetric tridiagonal form T

 * @details
 * \b Purpose:
    \verbatim
     SBTRD reduces a real symmetric band matrix A to symmetric
     tridiagonal form T by an orthogonal similarity transformation:
     Q**T * A * Q = T.
    \endverbatim 

 * @param[in] VECT
          VECT is CHARACTER*1 \n
          = 'N':  do not form Q; \n
          = 'V':  form Q; \n
          = 'U':  update a matrix X, by forming X*Q. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] KD
          KD is INTEGER \n
          The number of superdiagonals of the matrix A if UPLO = 'U',
          or the number of subdiagonals if UPLO = 'L'.  KD >= 0. \n
 * @param[in,out] AB
          AB is REAL array, dimension (LDAB,N) \n
          On entry, the upper or lower triangle of the symmetric band
          matrix A, stored in the first KD+1 rows of the array.  The
          j-th column of A is stored in the j-th column of the array AB
          as follows: \n
          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j; \n
          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd). \n
          On exit, the diagonal elements of AB are overwritten by the
          diagonal elements of the tridiagonal matrix T; if KD > 0, the
          elements on the first superdiagonal (if UPLO = 'U') or the
          first subdiagonal (if UPLO = 'L') are overwritten by the
          off-diagonal elements of T; the rest of AB is overwritten by
          values generated during the reduction. \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          The leading dimension of the array AB.  LDAB >= KD+1. \n
 * @param[out] D
          D is REAL array, dimension (N) \n
          The diagonal elements of the tridiagonal matrix T. \n
 * @param[out] E
          E is REAL array, dimension (N-1) \n
          The off-diagonal elements of the tridiagonal matrix T: \n
          E(i) = T(i,i+1) if UPLO = 'U'; E(i) = T(i+1,i) if UPLO = 'L'. \n
 * @param[in,out] Q
          Q is REAL array, dimension (LDQ,N) \n
          On entry, if VECT = 'U', then Q must contain an N-by-N
          matrix X; if VECT = 'N' or 'V', then Q need not be set. \n
 \n
          On exit: \n
          if VECT = 'V', Q contains the N-by-N orthogonal matrix Q; \n
          if VECT = 'U', Q contains the product X*Q; \n
          if VECT = 'N', the array Q is not referenced. \n
 * @param[in] LDQ
          LDQ is INTEGER \n
          The leading dimension of the array Q. \n
          LDQ >= 1, and LDQ >= N if VECT = 'V' or 'U'. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sbtrd(char* vect, char* uplo, integer* n, integer* kd, T* ab, integer* ldab, T* d, T* e, T* q, integer* ldq, T* work, integer* info)
{
  return sbtrd(vect, uplo, n, kd, ab, ldab, d, e, q, ldq, work, info);
}
template< typename T, typename Ta >
integer hbtrd(char* vect, char* uplo, integer* n, integer* kd, T* ab, integer* ldab, Ta* d, Ta* e, T* q, integer* ldq, T* work, integer* info)
{
  return hbtrd(vect, uplo, n, kd, ab, ldab, d, e, q, ldq, work, info);
}

/*! @brief SFRK performs a symmetric rank-k operation for matrix in RFP format

 * @details
 * \b Purpose:
    \verbatim
     Level 3 BLAS like routine for C in RFP Format.

     SSFRK performs one of the symmetric rank--k operations

        C := alpha*A*A**T + beta*C,

     or

        C := alpha*A**T*A + beta*C,

     where alpha and beta are real scalars, C is an n--by--n symmetric
     matrix and A is an n--by--k matrix in the first case and a k--by--n
     matrix in the second case.
    \endverbatim 

 * @param[in] TRANSR
          TRANSR is CHARACTER*1 \n
          = 'N':  The Normal Form of RFP A is stored; \n
          = 'T':  The Transpose Form of RFP A is stored. \n
 * @param[in] UPLO
           UPLO is CHARACTER*1 \n
           On  entry, UPLO specifies whether the upper or lower
           triangular part of the array C is to be referenced as
           follows: \n
              UPLO = 'U' or 'u'   Only the upper triangular part of C
                                  is to be referenced. \n
              UPLO = 'L' or 'l'   Only the lower triangular part of C
                                  is to be referenced. \n
           Unchanged on exit. \n
 * @param[in] TRANS
           TRANS is CHARACTER*1 \n
           On entry, TRANS specifies the operation to be performed as
           follows: \n
              TRANS = 'N' or 'n'   C := alpha*A*A**T + beta*C. \n
              TRANS = 'T' or 't'   C := alpha*A**T*A + beta*C. \n
           Unchanged on exit. \n
 * @param[in] N 
           N is INTEGER \n
           On entry, N specifies the order of the matrix C. N must be
           at least zero. \n
           Unchanged on exit. \n
 * @param[in] K
           K is INTEGER \n
           On entry with TRANS = 'N' or 'n', K specifies the number
           of  columns of the matrix A, and on entry with TRANS = 'T'
           or 't', K specifies the number of rows of the matrix A. K
           must be at least zero. \n
           Unchanged on exit. \n
 * @param[in] ALPHA
           ALPHA is REAL \n
           On entry, ALPHA specifies the scalar alpha.
           Unchanged on exit. \n
 * @param[in] A
           A is REAL array, dimension (LDA,ka) \n
           where KA
           is K  when TRANS = 'N' or 'n', and is N otherwise. Before
           entry with TRANS = 'N' or 'n', the leading N--by--K part of
           the array A must contain the matrix A, otherwise the leading
           K--by--N part of the array A must contain the matrix A.
           Unchanged on exit. \n
 * @param[in] LDA
           LDA is INTEGER \n
           On entry, LDA specifies the first dimension of A as declared
           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
           then  LDA must be at least  max( 1, n), otherwise  LDA must
           be at least  max( 1, k).
           Unchanged on exit. \n
 * @param[in] BETA
           BETA is REAL \n
           On entry, BETA specifies the scalar beta.
           Unchanged on exit. \n
 * @param[in,out] C
           C is REAL array, dimension (NT) \n
           NT = N*(N+1)/2. On entry, the symmetric matrix C in RFP
           Format. RFP Format is described by TRANSR, UPLO and N.  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sfrk(char* transr, char* uplo, char* trans, integer* n, integer* k, T* alpha, T* a, integer* lda, T* beta, T* c)
{
  return sfrk(transr, uplo, trans, n, k, alpha, a, lda, beta, c);
}
template< typename T, typename Ta >
integer hfrk(char* transr, char* uplo, char* trans, integer* n, integer* k, Ta* alpha, T* a, integer* lda, Ta* beta, T* c)
{
  return hfrk(transr, uplo, trans, n, k, alpha, a, lda, beta, c);
}

/*! @brief SPCON estimates the reciprocal of the condition number

 * @details
 * \b Purpose:
    \verbatim
     SPCON estimates the reciprocal of the condition number (in the
     1-norm) of a real symmetric packed matrix A using the factorization
     A = U*D*U**T or A = L*D*L**T computed by SSPTRF.

     An estimate is obtained for norm(inv(A)), and the reciprocal of the
     condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
    \endverbatim

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the details of the factorization are stored
          as an upper or lower triangular matrix. \n
          = 'U':  Upper triangular, form is A = U*D*U**T; \n
          = 'L':  Lower triangular, form is A = L*D*L**T. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] AP
          AP is REAL array, dimension (N*(N+1)/2) \n
          The block diagonal matrix D and the multipliers used to
          obtain the factor U or L as computed by SSPTRF, stored as a
          packed triangular matrix. \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D
          as determined by SSPTRF. \n
 * @param[in] ANORM
          ANORM is REAL \n
          The 1-norm of the original matrix A. \n
 * @param[out] RCOND
          RCOND is REAL \n
          The reciprocal of the condition number of the matrix A,
          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
          estimate of the 1-norm of inv(A) computed in this routine. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (2*N) \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer spcon(char* uplo, integer* n,  T* ap,  integer* ipiv, T* anorm, T* rcond, T* work, integer* iwork, integer* info)
{
  return spcon(uplo, n, ap, ipiv, anorm, rcond, work, iwork, info);
}
template< typename T, typename Ta >
integer spcon(char* uplo, integer* n,  T* ap,  integer* ipiv, Ta* anorm, Ta* rcond, T* work, integer* info)
{
  return spcon(uplo, n, ap, ipiv, anorm, rcond, work, info);
}
template< typename T, typename Ta >
integer hpcon(char* uplo, integer* n,  T* ap,  integer* ipiv, Ta* anorm, Ta* rcond, T* work, integer* info)
{
  return hpcon(uplo, n,  ap,  ipiv, anorm, rcond, work, info);
}

/*! @brief SSPEV computes the eigenvalues and, optionally, the left and/or right eigenvectors for OTHER matrices

 * @details
 * \b Purpose:
    \verbatim
     SSPEV computes all the eigenvalues and, optionally, eigenvectors of a
     real symmetric matrix A in packed storage.
    \endverbatim

 * @param[in] JOBZ
          JOBZ is CHARACTER*1 \n
          = 'N':  Compute eigenvalues only; \n
          = 'V':  Compute eigenvalues and eigenvectors. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] AP
          AP is REAL array, dimension (N*(N+1)/2) \n
          On entry, the upper or lower triangle of the symmetric matrix
          A, packed columnwise in a linear array.  The j-th column of A
          is stored in the array AP as follows: \n
          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j; \n
          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n. \n
 \n
          On exit, AP is overwritten by values generated during the
          reduction to tridiagonal form.  If UPLO = 'U', the diagonal
          and first superdiagonal of the tridiagonal matrix T overwrite
          the corresponding elements of A, and if UPLO = 'L', the
          diagonal and first subdiagonal of T overwrite the
          corresponding elements of A. \n
 * @param[out] W
          W is REAL array, dimension (N) \n
          If INFO = 0, the eigenvalues in ascending order. \n
 * @param[out] Z
          Z is REAL array, dimension (LDZ, N) \n
          If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal
          eigenvectors of the matrix A, with the i-th column of Z
          holding the eigenvector associated with W(i). \n
          If JOBZ = 'N', then Z is not referenced. \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of the array Z.  LDZ >= 1, and if
          JOBZ = 'V', LDZ >= max(1,N). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (3*N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n
          > 0:  if INFO = i, the algorithm failed to converge; i
                off-diagonal elements of an intermediate tridiagonal
                form did not converge to zero. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer spev(char* jobz, char* uplo, integer* n, T* ap, T* w, T* z, integer* ldq, T* work, integer* info)
{
  return spev(jobz, uplo, n, ap, w, z, ldq, work, info);
}
template< typename T, typename Ta >
integer hpev(char* jobz, char* uplo, integer* n, T* ap, Ta* w, T* z, integer* ldq, T* work, Ta* rwork, integer* info)
{
  return hpev(jobz, uplo, n, ap, w, z, ldq, work, rwork, info);
}

/*! @brief SPEVD computes the eigenvalues and, optionally, the left and/or right eigenvectors for OTHER matrices

 * @details
 * \b Purpose:
    \verbatim
     SPEVD computes all the eigenvalues and, optionally, eigenvectors
     of a real symmetric matrix A in packed storage. If eigenvectors are
     desired, it uses a divide and conquer algorithm.

     The divide and conquer algorithm makes very mild assumptions about
     floating point arithmetic. It will work on machines with a guard
     digit in add/subtract, or on those binary machines without guard
     digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
     Cray-2. It could conceivably fail on hexadecimal or decimal machines
     without guard digits, but we know of none.
    \endverbatim 

 * @param[in] JOBZ \n
          JOBZ is CHARACTER*1 \n
          = 'N':  Compute eigenvalues only; \n
          = 'V':  Compute eigenvalues and eigenvectors. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] AP
          AP is REAL array, dimension (N*(N+1)/2) \n
          On entry, the upper or lower triangle of the symmetric matrix
          A, packed columnwise in a linear array.  The j-th column of A
          is stored in the array AP as follows: \n
          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j; \n
          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n. \n
 \n
          On exit, AP is overwritten by values generated during the
          reduction to tridiagonal form.  If UPLO = 'U', the diagonal
          and first superdiagonal of the tridiagonal matrix T overwrite
          the corresponding elements of A, and if UPLO = 'L', the
          diagonal and first subdiagonal of T overwrite the
          corresponding elements of A. \n
 * @param[out] W
          W is REAL array, dimension (N) \n
          If INFO = 0, the eigenvalues in ascending order. \n
 * @param[out] Z
          Z is REAL array, dimension (LDZ, N) \n
          If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal
          eigenvectors of the matrix A, with the i-th column of Z
          holding the eigenvector associated with W(i). \n
          If JOBZ = 'N', then Z is not referenced. \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of the array Z.  LDZ >= 1, and if
          JOBZ = 'V', LDZ >= max(1,N). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the required LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK. \n
          If N <= 1,               LWORK must be at least 1. \n
          If JOBZ = 'N' and N > 1, LWORK must be at least 2*N. \n
          If JOBZ = 'V' and N > 1, LWORK must be at least
                                                 1 + 6*N + N**2. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the required sizes of the WORK and IWORK
          arrays, returns these values as the first entries of the WORK
          and IWORK arrays, and no error message related to LWORK or
          LIWORK is issued by XERBLA. \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (MAX(1,LIWORK)) \n
          On exit, if INFO = 0, IWORK(1) returns the required LIWORK. \n
 * @param[in]	LIWORK	
          LIWORK is INTEGER \n
          The dimension of the array IWORK. \n
          If JOBZ  = 'N' or N <= 1, LIWORK must be at least 1. \n
          If JOBZ  = 'V' and N > 1, LIWORK must be at least 3 + 5*N. \n
 \n
          If LIWORK = -1, then a workspace query is assumed; the
          routine only calculates the required sizes of the WORK and
          IWORK arrays, returns these values as the first entries of
          the WORK and IWORK arrays, and no error message related to
          LWORK or LIWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n
          > 0:  if INFO = i, the algorithm failed to converge; i
                off-diagonal elements of an intermediate tridiagonal
                form did not converge to zero. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer spevd(char* jobz, char* uplo, integer* n, T* ap, T* w, T* z, integer* ldz, T* work, integer* lwork, integer* iwork, integer* liwork, integer* info)
{
  return spevd(jobz, uplo, n, ap, w, z, ldz, work, lwork, iwork, liwork, info);
} 
template< typename T, typename Ta >
integer hpevd(char* jobz, char* uplo, integer* n, T* ap, Ta* w, T* z, integer* ldz, T* work, integer* lwork, Ta* rwork, integer* lrwork, integer* iwork, integer* liwork, integer* info)
{
  return hpevd(jobz, uplo, n, ap, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info);
} 

/*! @brief SPEVX computes the eigenvalues and, optionally, the left and/or right eigenvectors for OTHER matrices

 * @details
 * \b Purpose:
    \verbatim
     SPEVX computes selected eigenvalues and, optionally, eigenvectors
     of a real symmetric matrix A in packed storage.  Eigenvalues/vectors
     can be selected by specifying either a range of values or a range of
     indices for the desired eigenvalues.
    \endverbatim 

 * @param[in] JOBZ
          JOBZ is CHARACTER*1 \n
          = 'N':  Compute eigenvalues only; \n
          = 'V':  Compute eigenvalues and eigenvectors. \n
 * @param[in] RANGE
          RANGE is CHARACTER*1 \n
          = 'A': all eigenvalues will be found; \n
          = 'V': all eigenvalues in the half-open interval (VL,VU]
                 will be found; \n
          = 'I': the IL-th through IU-th eigenvalues will be found. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] AP
          AP is REAL array, dimension (N*(N+1)/2) \n
          On entry, the upper or lower triangle of the symmetric matrix
          A, packed columnwise in a linear array.  The j-th column of A
          is stored in the array AP as follows: \n
          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j; \n
          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n. \n
 \n
          On exit, AP is overwritten by values generated during the
          reduction to tridiagonal form.  If UPLO = 'U', the diagonal
          and first superdiagonal of the tridiagonal matrix T overwrite
          the corresponding elements of A, and if UPLO = 'L', the
          diagonal and first subdiagonal of T overwrite the
          corresponding elements of A. \n
 * @param[in] VL
          VL is REAL \n
          If RANGE='V', the lower bound of the interval to
          be searched for eigenvalues. VL < VU. \n
          Not referenced if RANGE = 'A' or 'I'. \n
 * @param[in] VU
          VU is REAL \n
          If RANGE='V', the upper bound of the interval to
          be searched for eigenvalues. VL < VU. \n
          Not referenced if RANGE = 'A' or 'I'. \n
 * @param[in] IL
          IL is INTEGER \n
          If RANGE='I', the index of the
          smallest eigenvalue to be returned. \n
          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
          Not referenced if RANGE = 'A' or 'V'. \n
 * @param[in] IU
          IU is INTEGER \n
          If RANGE='I', the index of the
          largest eigenvalue to be returned. \n
          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
          Not referenced if RANGE = 'A' or 'V'. \n
 * @param[in] ABSTOL
          ABSTOL is REAL \n
          The absolute error tolerance for the eigenvalues.
          An approximate eigenvalue is accepted as converged
          when it is determined to lie in an interval [a,b]
          of width less than or equal to \n
 \n
                  ABSTOL + EPS *   max( |a|,|b|) , \n
 \n
          where EPS is the machine precision.  If ABSTOL is less than
          or equal to zero, then  EPS*|T|  will be used in its place,
          where |T| is the 1-norm of the tridiagonal matrix obtained
          by reducing AP to tridiagonal form. \n
 \n
          Eigenvalues will be computed most accurately when ABSTOL is
          set to twice the underflow threshold 2*SLAMCH('S'), not zero.
          If this routine returns with INFO>0, indicating that some
          eigenvectors did not converge, try setting ABSTOL to
          2*SLAMCH('S'). \n
 \n
          See "Computing Small Singular Values of Bidiagonal Matrices
          with Guaranteed High Relative Accuracy," by Demmel and
          Kahan, LAPACK Working Note #3. \n
 * @param[out] M
          M is INTEGER \n
          The total number of eigenvalues found.  0 <= M <= N.
          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1. \n
 * @param[out] W
          W is REAL array, dimension (N) \n
          If INFO = 0, the selected eigenvalues in ascending order. \n
 * @param[out] Z
          Z is REAL array, dimension (LDZ, max(1,M)) \n
          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
          contain the orthonormal eigenvectors of the matrix A
          corresponding to the selected eigenvalues, with the i-th
          column of Z holding the eigenvector associated with W(i).
          If an eigenvector fails to converge, then that column of Z
          contains the latest approximation to the eigenvector, and the
          index of the eigenvector is returned in IFAIL. \n
          If JOBZ = 'N', then Z is not referenced. \n
          Note: the user must ensure that at least max(1,M) columns are
          supplied in the array Z; if RANGE = 'V', the exact value of M
          is not known in advance and an upper bound must be used. \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of the array Z.  LDZ >= 1, and if
          JOBZ = 'V', LDZ >= max(1,N). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (8*N) \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (5*N) \n
 * @param[out]	IFAIL	
          IFAIL is INTEGER array, dimension (N) \n
          If JOBZ = 'V', then if INFO = 0, the first M elements of
          IFAIL are zero.  If INFO > 0, then IFAIL contains the
          indices of the eigenvectors that failed to converge. \n
          If JOBZ = 'N', then IFAIL is not referenced. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, then i eigenvectors failed to converge.
                Their indices are stored in array IFAIL. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer spevx(char* jobz, char* range, char* uplo, integer* n, T* ap, T* vl, T* vu, integer* il, integer* iu, T* abstol, integer* m, T* w, T* z, integer* ldz, T* work, integer* iwork, integer* ifail, integer* info)
{
  return spevx(jobz, range, uplo, n, ap, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail, info);
}
template< typename T, typename Ta >
integer spevx(char* jobz, char* range, char* uplo, integer* n, T* ap, Ta* vl, Ta* vu, integer* il, integer* iu, Ta* abstol, integer* m, Ta* w, T* z, integer* ldz, T* work, Ta* rwork, integer* iwork, integer* ifail, integer* info)
{
  return spevx(jobz, range, uplo, n, ap, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail, info);
}

/*! @brief SPGST reduces a real symmetric-definite generalized eigenproblem to standard form

 * @details
 * \b Purpose:
    \verbatim
     SPGST reduces a real symmetric-definite generalized eigenproblem
     to standard form, using packed storage.

     If ITYPE = 1, the problem is A*x = lambda*B*x,
     and A is overwritten by inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T)

     If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
     B*A*x = lambda*x, and A is overwritten by U*A*U**T or L**T*A*L.

     B must have been previously factorized as U**T*U or L*L**T by SPPTRF.
    \endverbatim 

 * @param[in] ITYPE
          ITYPE is INTEGER \n
          = 1: compute inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T); \n
          = 2 or 3: compute U*A*U**T or L**T*A*L. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored and B is factored as
                  U**T*U; \n
          = 'L':  Lower triangle of A is stored and B is factored as
                  L*L**T. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrices A and B.  N >= 0. \n
 * @param[in,out] AP
          AP is REAL array, dimension (N*(N+1)/2) \n
          On entry, the upper or lower triangle of the symmetric matrix
          A, packed columnwise in a linear array.  The j-th column of A
          is stored in the array AP as follows: \n
          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j; \n
          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n. \n
 \n
          On exit, if INFO = 0, the transformed matrix, stored in the
          same format as A. \n
 * @param[in] BP
          BP is REAL array, dimension (N*(N+1)/2) \n
          The triangular factor from the Cholesky factorization of B,
          stored in the same format as A, as returned by SPPTRF. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer spgst(integer* itype, char* uplo, integer* n, T* ap, T* bp, integer* info)
{
  return spgst(itype, uplo, n, ap, bp, info);
}
template< typename T >
integer hpgst(integer* itype, char* uplo, integer* n, T* ap, T* bp, integer* info)
{
  return hpgst(itype, uplo, n, ap, bp, info);
}

/*! @brief SPGV computes all the eigenvalues

 * @details
 * \b Purpose:
    \verbatim
     SPGV computes all the eigenvalues and, optionally, the eigenvectors
     of a real generalized symmetric-definite eigenproblem, of the form
     A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.
     Here A and B are assumed to be symmetric, stored in packed format,
     and B is also positive definite.
    \endverbatim 

 * @param[in] ITYPE
          ITYPE is INTEGER \n
          Specifies the problem type to be solved: \n
          = 1:  A*x = (lambda)*B*x \n
          = 2:  A*B*x = (lambda)*x \n
          = 3:  B*A*x = (lambda)*x \n
 * @param[in] JOBZ
          JOBZ is CHARACTER*1 \n
          = 'N':  Compute eigenvalues only; \n
          = 'V':  Compute eigenvalues and eigenvectors. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangles of A and B are stored; \n
          = 'L':  Lower triangles of A and B are stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrices A and B.  N >= 0. \n
 * @param[in,out] AP
          AP is REAL array, dimension (N*(N+1)/2) \n
          On entry, the upper or lower triangle of the symmetric matrix
          A, packed columnwise in a linear array.  The j-th column of A
          is stored in the array AP as follows: \n
          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j; \n
          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n. \n
 \n
          On exit, the contents of AP are destroyed. \n
 * @param[in,out] BP
          BP is REAL array, dimension (N*(N+1)/2) \n
          On entry, the upper or lower triangle of the symmetric matrix
          B, packed columnwise in a linear array.  The j-th column of B
          is stored in the array BP as follows: \n
          if UPLO = 'U', BP(i + (j-1)*j/2) = B(i,j) for 1<=i<=j; \n
          if UPLO = 'L', BP(i + (j-1)*(2*n-j)/2) = B(i,j) for j<=i<=n. \n
 \n
          On exit, the triangular factor U or L from the Cholesky
          factorization B = U**T*U or B = L*L**T, in the same storage
          format as B. \n
 * @param[out] W
          W is REAL array, dimension (N) \n
          If INFO = 0, the eigenvalues in ascending order. \n
 * @param[out] Z
          Z is REAL array, dimension (LDZ, N) \n
          If JOBZ = 'V', then if INFO = 0, Z contains the matrix Z of
          eigenvectors.  The eigenvectors are normalized as follows:
          if ITYPE = 1 or 2, Z**T*B*Z = I; \n
          if ITYPE = 3, Z**T*inv(B)*Z = I. \n
          If JOBZ = 'N', then Z is not referenced. \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of the array Z.  LDZ >= 1, and if
          JOBZ = 'V', LDZ >= max(1,N). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (3*N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  SPPTRF or SSPEV returned an error code: \n
             <= N:  if INFO = i, SSPEV failed to converge;
                    i off-diagonal elements of an intermediate
                    tridiagonal form did not converge to zero. \n
             > N:   if INFO = n + i, for 1 <= i <= n, then the leading
                    minor of order i of B is not positive definite.
                    The factorization of B could not be completed and
                    no eigenvalues or eigenvectors were computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer spgv(integer* itype, char* jobz, char* uplo, integer* n, T* ap, T* bp, T* w, T* z, integer* ldz, T* work, integer* info)
{
  return spgv(itype, jobz, uplo, n, ap, bp, w, z, ldz, work, info);
} 
template< typename T, typename Ta >
integer hpgv(integer* itype, char* jobz, char* uplo, integer* n, T* ap, T* bp, T* w, T* z, integer* ldz, T* work, Ta* rwork, integer* info)
{
  return hpgv(itype, jobz, uplo, n, ap, bp, w, z, ldz, work, rwork, info);
} 

/*! @brief SPGVD computes all the eigenvalues

 * @details
 * \b Purpose:
    \verbatim
     SPGVD computes all the eigenvalues, and optionally, the eigenvectors
     of a real generalized symmetric-definite eigenproblem, of the form
     A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and
     B are assumed to be symmetric, stored in packed format, and B is also
     positive definite.
     If eigenvectors are desired, it uses a divide and conquer algorithm.

     The divide and conquer algorithm makes very mild assumptions about
     floating point arithmetic. It will work on machines with a guard
     digit in add/subtract, or on those binary machines without guard
     digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
     Cray-2. It could conceivably fail on hexadecimal or decimal machines
     without guard digits, but we know of none.
    \endverbatim 

 * @param[in] ITYPE \n
          ITYPE is INTEGER \n
          Specifies the problem type to be solved: \n
          = 1:  A*x = (lambda)*B*x \n
          = 2:  A*B*x = (lambda)*x \n
          = 3:  B*A*x = (lambda)*x \n
 * @param[in] JOBZ
          JOBZ is CHARACTER*1 \n
          = 'N':  Compute eigenvalues only; \n
          = 'V':  Compute eigenvalues and eigenvectors. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangles of A and B are stored; \n
          = 'L':  Lower triangles of A and B are stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrices A and B.  N >= 0. \n
 * @param[in,out] AP
          AP is REAL array, dimension (N*(N+1)/2) \n
          On entry, the upper or lower triangle of the symmetric matrix
          A, packed columnwise in a linear array.  The j-th column of A
          is stored in the array AP as follows: \n
          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j; \n
          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n. \n
 \n
          On exit, the contents of AP are destroyed. \n
 * @param[in,out] BP
          BP is REAL array, dimension (N*(N+1)/2) \n
          On entry, the upper or lower triangle of the symmetric matrix
          B, packed columnwise in a linear array.  The j-th column of B
          is stored in the array BP as follows: \n
          if UPLO = 'U', BP(i + (j-1)*j/2) = B(i,j) for 1<=i<=j; \n
          if UPLO = 'L', BP(i + (j-1)*(2*n-j)/2) = B(i,j) for j<=i<=n. \n
 \n
          On exit, the triangular factor U or L from the Cholesky
          factorization B = U**T*U or B = L*L**T, in the same storage
          format as B. \n
 * @param[out] W
          W is REAL array, dimension (N) \n
          If INFO = 0, the eigenvalues in ascending order. \n
 * @param[out] Z
          Z is REAL array, dimension (LDZ, N) \n
          If JOBZ = 'V', then if INFO = 0, Z contains the matrix Z of
          eigenvectors.  The eigenvectors are normalized as follows: \n
          if ITYPE = 1 or 2, Z**T*B*Z = I; \n
          if ITYPE = 3, Z**T*inv(B)*Z = I. \n
          If JOBZ = 'N', then Z is not referenced. \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of the array Z.  LDZ >= 1, and if
          JOBZ = 'V', LDZ >= max(1,N). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the required LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK. \n
          If N <= 1,               LWORK >= 1. \n
          If JOBZ = 'N' and N > 1, LWORK >= 2*N. \n
          If JOBZ = 'V' and N > 1, LWORK >= 1 + 6*N + 2*N**2. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the required sizes of the WORK and IWORK
          arrays, returns these values as the first entries of the WORK
          and IWORK arrays, and no error message related to LWORK or
          LIWORK is issued by XERBLA. \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (MAX(1,LIWORK)) \n
          On exit, if INFO = 0, IWORK(1) returns the required LIWORK. \n
 * @param[in]	LIWORK	
          LIWORK is INTEGER \n
          The dimension of the array IWORK. \n
          If JOBZ  = 'N' or N <= 1, LIWORK >= 1. \n
          If JOBZ  = 'V' and N > 1, LIWORK >= 3 + 5*N. \n
 \n
          If LIWORK = -1, then a workspace query is assumed; the
          routine only calculates the required sizes of the WORK and
          IWORK arrays, returns these values as the first entries of
          the WORK and IWORK arrays, and no error message related to
          LWORK or LIWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  SPPTRF or SSPEVD returned an error code: \n
             <= N:  if INFO = i, SSPEVD failed to converge;
                    i off-diagonal elements of an intermediate
                    tridiagonal form did not converge to zero; \n
             > N:   if INFO = N + i, for 1 <= i <= N, then the leading
                    minor of order i of B is not positive definite.
                    The factorization of B could not be completed and
                    no eigenvalues or eigenvectors were computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer spgvd(integer* itype, char* jobz, char* uplo, integer* n, T* ap, T* bp, T* w, T* z, integer* ldz, T* work, integer* lwork, integer* iwork, integer* liwork, integer* info)
{
  return spgvd(itype, jobz, uplo, n, ap, bp, w, z, ldz, work, lwork, iwork, liwork, info);
} 
template< typename T, typename Ta >
integer hpgvd(integer* itype, char* jobz, char* uplo, integer* n, T* ap, T* bp, Ta* w, T* z, integer* ldz, T* work, integer* lwork, Ta* rwork, integer* lrwork, integer* iwork, integer* liwork, integer* info)
{
  return hpgvd(itype, jobz, uplo, n, ap, bp, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info);
}

/*! @brief SPGVX computes all the eigenvalues

 * @details
 * \b Purpose:
    \verbatim
     SPGVX computes selected eigenvalues, and optionally, eigenvectors
     of a real generalized symmetric-definite eigenproblem, of the form
     A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A
     and B are assumed to be symmetric, stored in packed storage, and B
     is also positive definite.  Eigenvalues and eigenvectors can be
     selected by specifying either a range of values or a range of indices
     for the desired eigenvalues.
    \endverbatim 

 * @param[in] ITYPE
          ITYPE is INTEGER \n
          Specifies the problem type to be solved: \n
          = 1:  A*x = (lambda)*B*x \n
          = 2:  A*B*x = (lambda)*x \n
          = 3:  B*A*x = (lambda)*x \n
 * @param[in] JOBZ
          JOBZ is CHARACTER*1 \n
          = 'N':  Compute eigenvalues only; \n
          = 'V':  Compute eigenvalues and eigenvectors. \n
 * @param[in] RANGE
          RANGE is CHARACTER*1 \n
          = 'A': all eigenvalues will be found. \n
          = 'V': all eigenvalues in the half-open interval (VL,VU]
                 will be found. \n
          = 'I': the IL-th through IU-th eigenvalues will be found. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A and B are stored; \n
          = 'L':  Lower triangle of A and B are stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix pencil (A,B).  N >= 0. \n
 * @param[in,out] AP
          AP is REAL array, dimension (N*(N+1)/2) \n
          On entry, the upper or lower triangle of the symmetric matrix
          A, packed columnwise in a linear array.  The j-th column of A
          is stored in the array AP as follows: \n
          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j; \n
          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n. \n
 \n
          On exit, the contents of AP are destroyed. \n
 * @param[in,out] BP
          BP is REAL array, dimension (N*(N+1)/2) \n
          On entry, the upper or lower triangle of the symmetric matrix
          B, packed columnwise in a linear array.  The j-th column of B
          is stored in the array BP as follows: \n
          if UPLO = 'U', BP(i + (j-1)*j/2) = B(i,j) for 1<=i<=j; \n
          if UPLO = 'L', BP(i + (j-1)*(2*n-j)/2) = B(i,j) for j<=i<=n. \n
 \n
          On exit, the triangular factor U or L from the Cholesky
          factorization B = U**T*U or B = L*L**T, in the same storage
          format as B. \n
 * @param[in] VL
          VL is REAL \n
          If RANGE='V', the lower bound of the interval to
          be searched for eigenvalues. VL < VU.
          Not referenced if RANGE = 'A' or 'I'. \n
 * @param[in] VU
          VU is REAL \n
          If RANGE='V', the upper bound of the interval to
          be searched for eigenvalues. VL < VU.
          Not referenced if RANGE = 'A' or 'I'. \n
 * @param[in] IL
          IL is INTEGER \n
          If RANGE='I', the index of the
          smallest eigenvalue to be returned.
          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
          Not referenced if RANGE = 'A' or 'V'. \n
 * @param[in] IU
          IU is INTEGER \n
          If RANGE='I', the index of the
          largest eigenvalue to be returned. \n
          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
          Not referenced if RANGE = 'A' or 'V'.
 * @param[in] ABSTOL
          ABSTOL is REAL \n
          The absolute error tolerance for the eigenvalues.
          An approximate eigenvalue is accepted as converged
          when it is determined to lie in an interval [a,b]
          of width less than or equal to \n
 \n
                  ABSTOL + EPS *   max( |a|,|b|) , \n
 \n
          where EPS is the machine precision.  If ABSTOL is less than
          or equal to zero, then  EPS*|T|  will be used in its place,
          where |T| is the 1-norm of the tridiagonal matrix obtained
          by reducing A to tridiagonal form. \n
 \n
          Eigenvalues will be computed most accurately when ABSTOL is
          set to twice the underflow threshold 2*SLAMCH('S'), not zero.
          If this routine returns with INFO>0, indicating that some
          eigenvectors did not converge, try setting ABSTOL to
          2*SLAMCH('S'). \n
 * @param[out] M
          M is INTEGER \n
          The total number of eigenvalues found.  0 <= M <= N.
          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1. \n
 * @param[out] W
          W is REAL array, dimension (N) \n
          On normal exit, the first M elements contain the selected
          eigenvalues in ascending order. \n
 * @param[out] Z
          Z is REAL array, dimension (LDZ, max(1,M)) \n
          If JOBZ = 'N', then Z is not referenced. \n
          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
          contain the orthonormal eigenvectors of the matrix A
          corresponding to the selected eigenvalues, with the i-th
          column of Z holding the eigenvector associated with W(i).
          The eigenvectors are normalized as follows: \n
          if ITYPE = 1 or 2, Z**T*B*Z = I; \n
          if ITYPE = 3, Z**T*inv(B)*Z = I. \n
 \n
          If an eigenvector fails to converge, then that column of Z
          contains the latest approximation to the eigenvector, and the
          index of the eigenvector is returned in IFAIL.
          Note: the user must ensure that at least max(1,M) columns are
          supplied in the array Z; if RANGE = 'V', the exact value of M
          is not known in advance and an upper bound must be used. \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of the array Z.  LDZ >= 1, and if
          JOBZ = 'V', LDZ >= max(1,N). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (8*N) \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (5*N) \n
 * @param[out]	IFAIL	
          IFAIL is INTEGER array, dimension (N) \n
          If JOBZ = 'V', then if INFO = 0, the first M elements of
          IFAIL are zero.  If INFO > 0, then IFAIL contains the
          indices of the eigenvectors that failed to converge. \n
          If JOBZ = 'N', then IFAIL is not referenced. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  SPPTRF or SSPEVX returned an error code: \n
             <= N:  if INFO = i, SSPEVX failed to converge;
                    i eigenvectors failed to converge.  Their indices
                    are stored in array IFAIL. \n
             > N:   if INFO = N + i, for 1 <= i <= N, then the leading
                    minor of order i of B is not positive definite.
                    The factorization of B could not be completed and
                    no eigenvalues or eigenvectors were computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer spgvx(integer* itype, char* jobz, char* range, char* uplo, integer* n, T* ap, T* bp, T* vl, T* vu, integer* il, integer* iu, T* abstol, integer* m, T* w, T* z, integer* ldz, T* work, integer* iwork, integer* ifail, integer* info)
{
  return spgvx(itype, jobz, range, uplo, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail, info);
}
template< typename T, typename Ta >
integer hpgvx(integer* itype, char* jobz, char* range, char* uplo, integer* n, T* ap, T* bp, Ta* vl, Ta* vu, integer* il, integer* iu, Ta* abstol, integer* m, Ta* w, T* z, integer* ldz, T* work, Ta* rwork, integer* iwork, integer* ifail, integer* info)
{
  return hpgvx(itype, jobz, range, uplo, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail, info);
}

/*! @brief SPSV computes the solution to system of linear equations A * X = B for OTHER matrices

 * @details
 * \b Purpose:
    \verbatim
     SPSV computes the solution to a real system of linear equations
        A * X = B,
     where A is an N-by-N symmetric matrix stored in packed format and X
     and B are N-by-NRHS matrices.

     The diagonal pivoting method is used to factor A as
        A = U * D * U**T,  if UPLO = 'U', or
        A = L * D * L**T,  if UPLO = 'L',
     where U (or L) is a product of permutation and unit upper (lower)
     triangular matrices, D is symmetric and block diagonal with 1-by-1
     and 2-by-2 diagonal blocks.  The factored form of A is then used to
     solve the system of equations A * X = B.
    \endverbatim
    
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in,out] AP
          AP is REAL array, dimension (N*(N+1)/2) \n
          On entry, the upper or lower triangle of the symmetric matrix
          A, packed columnwise in a linear array.  The j-th column of A
          is stored in the array AP as follows: \n
          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j; \n
          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
          See below for further details. \n
 \n
          On exit, the block diagonal matrix D and the multipliers used
          to obtain the factor U or L from the factorization
          A = U*D*U**T or A = L*D*L**T as computed by SSPTRF, stored as
          a packed triangular matrix in the same storage format as A. \n
 * @param[out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D, as
          determined by SSPTRF.  If IPIV(k) > 0, then rows and columns
          k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1
          diagonal block.  If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0,
          then rows and columns k-1 and -IPIV(k) were interchanged and
          D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = 'L' and
          IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and
          -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2
          diagonal block. \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,NRHS) \n
          On entry, the N-by-NRHS right hand side matrix B.
          On exit, if INFO = 0, the N-by-NRHS solution matrix X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization
                has been completed, but the block diagonal matrix D is
                exactly singular, so the solution could not be
                computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer spsv(char* uplo, integer* n, integer* nrhs, T* ap, integer* ipiv, T* b, integer* ldb, integer* info)
{
  return spsv(uplo, n, nrhs, ap, ipiv, b, ldb, info);
}
template< typename T >
integer hpsv(char* uplo, integer* n, integer* nrhs, T* ap, integer* ipiv, T* b, integer* ldb, integer* info)
{
  return hpsv(uplo, n, nrhs, ap, ipiv, b, ldb, info);
}

/*! @brief SPSVX computes the solution to system of linear equations A * X = B for OTHER matrices

 * @details
 * \b Purpose:
    \verbatim
     SPSVX uses the diagonal pivoting factorization A = U*D*U**T or
     A = L*D*L**T to compute the solution to a real system of linear
     equations A * X = B, where A is an N-by-N symmetric matrix stored
     in packed format and X and B are N-by-NRHS matrices.

     Error bounds on the solution and a condition estimate are also
     provided.
     
     * \b Description:
       =================

     The following steps are performed:

     1. If FACT = 'N', the diagonal pivoting method is used to factor A as
           A = U * D * U**T,  if UPLO = 'U', or
           A = L * D * L**T,  if UPLO = 'L',
        where U (or L) is a product of permutation and unit upper (lower)
        triangular matrices and D is symmetric and block diagonal with
        1-by-1 and 2-by-2 diagonal blocks.

     2. If some D(i,i)=0, so that D is exactly singular, then the routine
        returns with INFO = i. Otherwise, the factored form of A is used
        to estimate the condition number of the matrix A.  If the
        reciprocal of the condition number is less than machine precision,
        INFO = N+1 is returned as a warning, but the routine still goes on
        to solve for X and compute error bounds as described below.

     3. The system of equations is solved for X using the factored form
        of A.

     4. Iterative refinement is applied to improve the computed solution
        matrix and calculate error bounds and backward error estimates
        for it.
    \endverbatim 

 * @param[in] FACT
          FACT is CHARACTER*1 \n
          Specifies whether or not the factored form of A has been
          supplied on entry. \n
          = 'F':  On entry, AFP and IPIV contain the factored form of
                  A.  AP, AFP and IPIV will not be modified. \n
          = 'N':  The matrix A will be copied to AFP and factored. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrices B and X.  NRHS >= 0. \n
 * @param[in] AP
          AP is REAL array, dimension (N*(N+1)/2) \n
          The upper or lower triangle of the symmetric matrix A, packed
          columnwise in a linear array.  The j-th column of A is stored
          in the array AP as follows: \n
          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j; \n
          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n. \n
          See below for further details. \n
 * @param[in,out] AFP
          AFP is REAL array, dimension (N*(N+1)/2) \n
          If FACT = 'F', then AFP is an input argument and on entry
          contains the block diagonal matrix D and the multipliers used
          to obtain the factor U or L from the factorization
          A = U*D*U**T or A = L*D*L**T as computed by SSPTRF, stored as
          a packed triangular matrix in the same storage format as A. \n
 \n
          If FACT = 'N', then AFP is an output argument and on exit
          contains the block diagonal matrix D and the multipliers used
          to obtain the factor U or L from the factorization
          A = U*D*U**T or A = L*D*L**T as computed by SSPTRF, stored as
          a packed triangular matrix in the same storage format as A. \n
 * @param[in,out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          If FACT = 'F', then IPIV is an input argument and on entry
          contains details of the interchanges and the block structure
          of D, as determined by SSPTRF. \n
          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
          interchanged and D(k,k) is a 1-by-1 diagonal block. \n
          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block. \n
 \n
          If FACT = 'N', then IPIV is an output argument and on exit
          contains details of the interchanges and the block structure
          of D, as determined by SSPTRF. \n
 * @param[in] B
          B is REAL array, dimension (LDB,NRHS) \n
          The N-by-NRHS right hand side matrix B. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out] X
          X is REAL array, dimension (LDX,NRHS) \n
          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X. \n
 * @param[in] LDX
          LDX is INTEGER \n
          The leading dimension of the array X.  LDX >= max(1,N). \n
 * @param[out] RCOND
          RCOND is REAL \n
          The estimate of the reciprocal condition number of the matrix
          A.  If RCOND is less than the machine precision (in
          particular, if RCOND = 0), the matrix is singular to working
          precision.  This condition is indicated by a return code of
          INFO > 0. \n
 * @param[out] FERR
          FERR is REAL array, dimension (NRHS) \n
          The estimated forward error bound for each solution vector
          X(j) (the j-th column of the solution matrix X).
          If XTRUE is the true solution corresponding to X(j), FERR(j)
          is an estimated upper bound for the magnitude of the largest
          element in (X(j) - XTRUE) divided by the magnitude of the
          largest element in X(j).  The estimate is as reliable as
          the estimate for RCOND, and is almost always a slight
          overestimate of the true error. \n
 * @param[out] BERR
          BERR is REAL array, dimension (NRHS) \n
          The componentwise relative backward error of each solution
          vector X(j) (i.e., the smallest relative change in
          any element of A or B that makes X(j) an exact solution). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (3*N) \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, and i is \n
                <= N:  D(i,i) is exactly zero.  The factorization
                       has been completed but the factor D is exactly
                       singular, so the solution and error bounds could
                       not be computed. RCOND = 0 is returned. \n
                = N+1: D is nonsingular, but RCOND is less than machine
                       precision, meaning that the matrix is singular
                       to working precision.  Nevertheless, the
                       solution and error bounds are computed because
                       there are a number of situations where the
                       computed solution can be more accurate than the
                       value of RCOND would suggest. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer spsvx(char* fact, char* uplo, integer* n, integer* nrhs,  T* ap, T* afp, integer* ipiv,  T* b, integer* ldb, T* x, integer* ldx, T* rcond, T* ferr, T* berr, T* work, integer* iwork, integer* info)
{
  return spsvx(fact, uplo, n, nrhs,  ap, afp, ipiv,  b, ldb, x, ldx, rcond, ferr, berr, work, iwork, info);
}
template< typename T, typename Ta >
integer spsvx(char* fact, char* uplo, integer* n, integer* nrhs,  T* ap, T* afp, integer* ipiv,  T* b, integer* ldb, T* x, integer* ldx, Ta* rcond, Ta* ferr, Ta* berr, T* work, Ta* rwork, integer* info)
{
  return spsvx(fact, uplo, n, nrhs,  ap, afp, ipiv,  b, ldb, x, ldx, rcond, ferr, berr, work, rwork, info);
}
template< typename T, typename Ta >
integer hpsvx(char* fact, char* uplo, integer* n, integer* nrhs,  T* ap, T* afp, integer* ipiv, T* b, integer* ldb, T* x, integer* ldx, Ta* rcond, Ta* ferr, Ta* berr, T* work, Ta* rwork, integer* info)
{
  return hpsvx(fact, uplo, n, nrhs,  ap, afp, ipiv,  b, ldb, x, ldx, rcond, ferr, berr, work, rwork, info);
}

/*! @brief SPTRD reduces a real symmetric matrix A stored in packed form to symmetric tridiagonal form T

 * @details
 * \b Purpose:
    \verbatim
     SPTRD reduces a real symmetric matrix A stored in packed form to
     symmetric tridiagonal form T by an orthogonal similarity
     transformation: Q**T * A * Q = T.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] AP
          AP is REAL array, dimension (N*(N+1)/2) \n
          On entry, the upper or lower triangle of the symmetric matrix
          A, packed columnwise in a linear array.  The j-th column of A
          is stored in the array AP as follows: \n
          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j; \n
          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n. \n
          On exit, if UPLO = 'U', the diagonal and first superdiagonal
          of A are overwritten by the corresponding elements of the
          tridiagonal matrix T, and the elements above the first
          superdiagonal, with the array TAU, represent the orthogonal
          matrix Q as a product of elementary reflectors; if UPLO
          = 'L', the diagonal and first subdiagonal of A are over-
          written by the corresponding elements of the tridiagonal
          matrix T, and the elements below the first subdiagonal, with
          the array TAU, represent the orthogonal matrix Q as a product
          of elementary reflectors. See Further Details. \n
 * @param[out] D
          D is REAL array, dimension (N) \n
          The diagonal elements of the tridiagonal matrix T:
          D(i) = A(i,i). \n
 * @param[out] E
          E is REAL array, dimension (N-1) \n
          The off-diagonal elements of the tridiagonal matrix T: \n
          E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'. \n
 * @param[out] TAU
          TAU is REAL array, dimension (N-1) \n
          The scalar factors of the elementary reflectors (see Further
          Details). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sptrd(char* uplo, integer* n, T* ap, T* d, T* e, T* tau, integer* info)
{
  return sptrd(uplo, n, ap, d, e, tau, info);
}
template< typename T, typename Ta >
integer hptrd(char* uplo, integer* n, T* ap, Ta* d, Ta* e, T* tau, integer* info)
{
  return hptrd(uplo, n, ap, d, e, tau, info);
}

/*! @brief SPTRF computes the factorization of a real symmetric matrix A

 * @details
 * \b Purpose:
    \verbatim
     SPTRF computes the factorization of a real symmetric matrix A stored
     in packed format using the Bunch-Kaufman diagonal pivoting method:

        A = U*D*U**T  or  A = L*D*L**T

     where U (or L) is a product of permutation and unit upper (lower)
     triangular matrices, and D is symmetric and block diagonal with
     1-by-1 and 2-by-2 diagonal blocks.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N 
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] AP
          AP is REAL array, dimension (N*(N+1)/2) \n
          On entry, the upper or lower triangle of the symmetric matrix
          A, packed columnwise in a linear array.  The j-th column of A
          is stored in the array AP as follows: \n
          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j; \n
          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n. \n

          On exit, the block diagonal matrix D and the multipliers used
          to obtain the factor U or L, stored as a packed triangular
          matrix overwriting A (see below for further details). \n
 * @param[out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D.
          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
          interchanged and D(k,k) is a 1-by-1 diagonal block. \n
          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n
          > 0: if INFO = i, D(i,i) is exactly zero.  The factorization
               has been completed, but the block diagonal matrix D is
               exactly singular, and division by zero will occur if it
               is used to solve a system of equations. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sptrf(char* uplo, integer* n, T* ap, integer* ipiv, integer* info)
{
  return sptrf(uplo, n, ap, ipiv, info);
}
template< typename T >
integer hptrf(char* uplo, integer* n, T* ap, integer* ipiv, integer* info)
{
  return hptrf(uplo, n, ap, ipiv, info);
}

/*! @brief SPTRI computes the inverse of a real symmetric indefinite matrix A

 * @details
 * \b Purpose:
    \verbatim
     SPTRI computes the inverse of a real symmetric indefinite matrix
     A in packed storage using the factorization A = U*D*U**T or
     A = L*D*L**T computed by SPTRF.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the details of the factorization are stored
          as an upper or lower triangular matrix. \n
          = 'U':  Upper triangular, form is A = U*D*U**T; \n
          = 'L':  Lower triangular, form is A = L*D*L**T. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] AP
          AP is REAL array, dimension (N*(N+1)/2) \n
          On entry, the block diagonal matrix D and the multipliers
          used to obtain the factor U or L as computed by SSPTRF,
          stored as a packed triangular matrix. \n
 \n
          On exit, if INFO = 0, the (symmetric) inverse of the original
          matrix, stored as a packed triangular matrix. The j-th column
          of inv(A) is stored in the array AP as follows: \n
          if UPLO = 'U', AP(i + (j-1)*j/2) = inv(A)(i,j) for 1<=i<=j; \n
          if UPLO = 'L',
             AP(i + (j-1)*(2n-j)/2) = inv(A)(i,j) for j<=i<=n. \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D
          as determined by SPTRF. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n
          > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its
               inverse could not be computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sptri(char* uplo, integer* n, T* ap,  integer* ipiv, T* work, integer* info)
{
  return sptri(uplo, n, ap, ipiv, work, info);
}
template< typename T >
integer hptri(char* uplo, integer* n, T* ap,  integer* ipiv, T* work, integer* info)
{
  return hptri(uplo, n, ap, ipiv, work, info);
}

/*! @brief SPTRS solves a system of linear equations A*X = B

 * @details
 * \b Purpose:
    \verbatim
     SPTRS solves a system of linear equations A*X = B with a real
     symmetric matrix A stored in packed format using the factorization
     A = U*D*U**T or A = L*D*L**T computed by SSPTRF.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the details of the factorization are stored
          as an upper or lower triangular matrix. \n
          = 'U':  Upper triangular, form is A = U*D*U**T; \n
          = 'L':  Lower triangular, form is A = L*D*L**T. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in] AP
          AP is REAL array, dimension (N*(N+1)/2) \n
          The block diagonal matrix D and the multipliers used to
          obtain the factor U or L as computed by SSPTRF, stored as a
          packed triangular matrix. \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D
          as determined by SSPTRF. \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,NRHS) \n
          On entry, the right hand side matrix B.
          On exit, the solution matrix X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sptrs(char* uplo, integer* n, integer* nrhs,  T* ap,  integer* ipiv, T* b, integer* ldb, integer* info)
{
  return sptrs(uplo, n, nrhs,  ap,  ipiv, b, ldb, info);
}
template< typename T >
integer hptrs(char* uplo, integer* n, integer* nrhs,  T* ap,  integer* ipiv, T* b, integer* ldb, integer* info)
{
  return hptrs(uplo, n, nrhs,  ap,  ipiv, b, ldb, info);
}

/*! @brief STEBZ computes the eigenvalues of a symmetric tridiagonal matrix T

 * @details
 * \b Purpose:
    \verbatim
     STEBZ computes the eigenvalues of a symmetric tridiagonal
     matrix T.  The user may ask for all eigenvalues, all eigenvalues
     in the half-open interval (VL, VU], or the IL-th through IU-th
     eigenvalues.

     To avoid overflow, the matrix must be scaled so that its
     largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest
     accuracy, it should not be much smaller than that.

     See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
     Matrix", Report CS41, Computer Science Dept., Stanford
     University, July 21, 1966.
    \endverbatim 

 * @param[in] RANGE
          RANGE is CHARACTER*1 \n
          = 'A': ("All")   all eigenvalues will be found. \n
          = 'V': ("Value") all eigenvalues in the half-open interval
                           (VL, VU] will be found. \n
          = 'I': ("Index") the IL-th through IU-th eigenvalues (of the
                           entire matrix) will be found. \n
 * @param[in] ORDER
          ORDER is CHARACTER*1 \n
          = 'B': ("By Block") the eigenvalues will be grouped by
                              split-off block (see IBLOCK, ISPLIT) and
                              ordered from smallest to largest within
                              the block. \n
          = 'E': ("Entire matrix")
                              the eigenvalues for the entire matrix
                              will be ordered from smallest to
                              largest. \n
 * @param[in] N
          N is INTEGER \n
          The order of the tridiagonal matrix T.  N >= 0. \n
 * @param[in] VL
          VL is REAL \n
          If RANGE='V', the lower bound of the interval to
          be searched for eigenvalues.  Eigenvalues less than or equal
          to VL, or greater than VU, will not be returned.  VL < VU.
          Not referenced if RANGE = 'A' or 'I'. \n
 * @param[in] VU
          VU is REAL \n
          If RANGE='V', the upper bound of the interval to
          be searched for eigenvalues.  Eigenvalues less than or equal
          to VL, or greater than VU, will not be returned.  VL < VU.
          Not referenced if RANGE = 'A' or 'I'. \n
 * @param[in] IL
          IL is INTEGER \n
          If RANGE='I', the index of the
          smallest eigenvalue to be returned. \n
          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0. \n
          Not referenced if RANGE = 'A' or 'V'. \n
 * @param[in] IU
          IU is INTEGER \n
          If RANGE='I', the index of the
          largest eigenvalue to be returned. \n
          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0. \n
          Not referenced if RANGE = 'A' or 'V'.
 * @param[in] ABSTOL
          ABSTOL is REAL \n
          The absolute tolerance for the eigenvalues.  An eigenvalue
          (or cluster) is considered to be located if it has been
          determined to lie in an interval whose width is ABSTOL or
          less.  If ABSTOL is less than or equal to zero, then ULP*|T|
          will be used, where |T| means the 1-norm of T. \n
 \n
          Eigenvalues will be computed most accurately when ABSTOL is
          set to twice the underflow threshold 2*SLAMCH('S'), not zero. \n
 * @param[in] D
          D is REAL array, dimension (N) \n
          The n diagonal elements of the tridiagonal matrix T. \n
 * @param[in] E
          E is REAL array, dimension (N-1) \n
          The (n-1) off-diagonal elements of the tridiagonal matrix T. \n
 * @param[out] M
          M is INTEGER \n
          The actual number of eigenvalues found. 0 <= M <= N.
          (See also the description of INFO=2,3.) \n
 * @param[out] NSPLIT
          NSPLIT is INTEGER \n
          The number of diagonal blocks in the matrix T.
          1 <= NSPLIT <= N. \n
 * @param[out] W
          W is REAL array, dimension (N) \n
          On exit, the first M elements of W will contain the
          eigenvalues.  (SSTEBZ may use the remaining N-M elements as
          workspace.) \n
 * @param[out] IBLOCK
          IBLOCK is INTEGER array, dimension (N) \n
          At each row/column j where E(j) is zero or small, the
          matrix T is considered to split into a block diagonal
          matrix.  On exit, if INFO = 0, IBLOCK(i) specifies to which
          block (from 1 to the number of blocks) the eigenvalue W(i)
          belongs.  (SSTEBZ may use the remaining N-M elements as
          workspace.) \n
 * @param[out] ISPLIT
          ISPLIT is INTEGER array, dimension (N) \n
          The splitting points, at which T breaks up into submatrices.
          The first submatrix consists of rows/columns 1 to ISPLIT(1),
          the second of rows/columns ISPLIT(1)+1 through ISPLIT(2),
          etc., and the NSPLIT-th consists of rows/columns
          ISPLIT(NSPLIT-1)+1 through ISPLIT(NSPLIT)=N.
          (Only the first NSPLIT elements will actually be used, but
          since the user cannot know a priori what value NSPLIT will
          have, N words must be reserved for ISPLIT.) \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (4*N) \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (3*N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  some or all of the eigenvalues failed to converge or
                were not computed: \n
                =1 or 3: Bisection failed to converge for some
                        eigenvalues; these eigenvalues are flagged by a
                        negative block number.  The effect is that the
                        eigenvalues may not be as accurate as the
                        absolute and relative tolerances.  This is
                        generally caused by unexpectedly inaccurate
                        arithmetic. \n
                =2 or 3: RANGE='I' only: Not all of the eigenvalues
                        IL:IU were found. \n
                        Effect: M < IU+1-IL \n
                        Cause:  non-monotonic arithmetic, causing the
                                Sturm sequence to be non-monotonic. \n
                        Cure:   recalculate, using RANGE='A', and pick
                                out eigenvalues IL:IU.  In some cases,
                                increasing the PARAMETER "FUDGE" may
                                make things work. \n
                = 4:    RANGE='I', and the Gershgorin interval
                        initially used was too small.  No eigenvalues
                        were computed. \n
                        Probable cause: your machine has sloppy
                                        floating-point arithmetic. \n
                        Cure: Increase the PARAMETER "FUDGE",
                              recompile, and try again. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer stebz(char* range, char* order, integer* n, T* vl, T* vu, integer* il, integer* iu, T* abstol, T* d,  T* e, integer* m, integer* nsplit, T* w, integer* iblock, integer* isplit, T* work, integer* iwork, integer* info)
{
  return stebz(range, order, n, vl, vu, il, iu, abstol, d,  e, m, nsplit, w, iblock, isplit, work, iwork, info);
}

/*! @brief STEGR computes selected eigenvalues and, optionally, eigenvectors of a real symmetric tridiagonal matrix T

 * @details
 * \b Purpose:
    \verbatim
     STEGR computes selected eigenvalues and, optionally, eigenvectors
     of a real symmetric tridiagonal matrix T. Any such unreduced matrix has
     a well defined set of pairwise different real eigenvalues, the corresponding
     real eigenvectors are pairwise orthogonal.

     The spectrum may be computed either completely or partially by specifying
     either an interval (VL,VU] or a range of indices IL:IU for the desired
     eigenvalues.

     SSTEGR is a compatibility wrapper around the improved SSTEMR routine.
     See SSTEMR for further details.

     One important change is that the ABSTOL parameter no longer provides any
     benefit and hence is no longer used.

     Note : SSTEGR and SSTEMR work only on machines which follow
     IEEE-754 floating-point standard in their handling of infinities and
     NaNs.  Normal execution may create these exceptiona values and hence
     may abort due to a floating point exception in environments which
     do not conform to the IEEE-754 standard.
    \endverbatim 

 * @param[in] JOBZ
          JOBZ is CHARACTER*1 \n
          = 'N':  Compute eigenvalues only; \n
          = 'V':  Compute eigenvalues and eigenvectors. \n
 * @param[in] RANGE
          RANGE is CHARACTER*1 \n
          = 'A': all eigenvalues will be found. \n
          = 'V': all eigenvalues in the half-open interval (VL,VU]
                 will be found. \n
          = 'I': the IL-th through IU-th eigenvalues will be found. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix.  N >= 0. \n
 * @param[in,out] D
          D is REAL array, dimension (N) \n
          On entry, the N diagonal elements of the tridiagonal matrix
          T. On exit, D is overwritten. \n
 * @param[in,out] E
          E is REAL array, dimension (N) \n
          On entry, the (N-1) subdiagonal elements of the tridiagonal
          matrix T in elements 1 to N-1 of E. E(N) need not be set on
          input, but is used internally as workspace. \n
          On exit, E is overwritten. \n
 * @param[in] VL
          VL is REAL \n
          If RANGE='V', the lower bound of the interval to
          be searched for eigenvalues. VL < VU.
          Not referenced if RANGE = 'A' or 'I'. \n
 * @param[in] VU
          VU is REAL \n
          If RANGE='V', the upper bound of the interval to
          be searched for eigenvalues. VL < VU.
          Not referenced if RANGE = 'A' or 'I'. \n
 * @param[in] IL
          IL is INTEGER \n
          If RANGE='I', the index of the
          smallest eigenvalue to be returned.
          1 <= IL <= IU <= N, if N > 0.
          Not referenced if RANGE = 'A' or 'V'. \n
 * @param[in] IU
          IU is INTEGER \n
          If RANGE='I', the index of the
          largest eigenvalue to be returned.
          1 <= IL <= IU <= N, if N > 0.
          Not referenced if RANGE = 'A' or 'V'. \n
 * @param[in] ABSTOL
          ABSTOL is REAL \n
          Unused.  Was the absolute error tolerance for the
          eigenvalues/eigenvectors in previous versions. \n
 * @param[out] M
          M is INTEGER \n
          The total number of eigenvalues found.  0 <= M <= N.
          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1. \n
 * @param[out] W
          W is REAL array, dimension (N) \n
          The first M elements contain the selected eigenvalues in
          ascending order. \n
 * @param[out] Z
          Z is REAL array, dimension (LDZ, max(1,M)) \n
          If JOBZ = 'V', and if INFO = 0, then the first M columns of Z
          contain the orthonormal eigenvectors of the matrix T
          corresponding to the selected eigenvalues, with the i-th
          column of Z holding the eigenvector associated with W(i). \n
          If JOBZ = 'N', then Z is not referenced. \n
          Note: the user must ensure that at least max(1,M) columns are
          supplied in the array Z; if RANGE = 'V', the exact value of M
          is not known in advance and an upper bound must be used.
          Supplying N columns is always safe. \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of the array Z.  LDZ >= 1, and if
          JOBZ = 'V', then LDZ >= max(1,N). \n
 * @param[out] ISUPPZ
          ISUPPZ is INTEGER array, dimension ( 2*max(1,M)) \n
          The support of the eigenvectors in Z, i.e., the indices
          indicating the nonzero elements in Z. The i-th computed eigenvector
          is nonzero only in elements ISUPPZ( 2*i-1) through
          ISUPPZ( 2*i). This is relevant in the case when the matrix
          is split. ISUPPZ is only accessed when JOBZ is 'V' and N > 0. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (LWORK) \n
          On exit, if INFO = 0, WORK(1) returns the optimal
          (and minimal) LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK. LWORK >= max(1,18*N)
          if JOBZ = 'V', and LWORK >= max(1,12*N) if JOBZ = 'N'. \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (LIWORK) \n
          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK. \n
 * @param[in]	LIWORK	
          LIWORK is INTEGER \n
          The dimension of the array IWORK.  LIWORK >= max(1,10*N)
          if the eigenvectors are desired, and LIWORK >= max(1,8*N)
          if only the eigenvalues are to be computed. \n
          If LIWORK = -1, then a workspace query is assumed; the
          routine only calculates the optimal size of the IWORK array,
          returns this value as the first entry of the IWORK array, and
          no error message related to LIWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          On exit, INFO \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = 1X, internal error in SLARRE,
                if INFO = 2X, internal error in SLARRV.
                Here, the digit X = ABS( IINFO ) < 10, where IINFO is
                the nonzero error code returned by SLARRE or
                SLARRV, respectively. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer stegr(char* jobz, char* range, integer* n, T* d, T* e, T* vl, T* vu, integer* il, integer* iu, T* abstol, integer* m, T* w, T* z, integer* ldz, integer* isuppz, T* work, integer* lwork, integer* iwork, integer* liwork, integer* info)
{
  return stegr(jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork, info);
}
template< typename T, typename Ta >
integer stegr(char* jobz, char* range, integer* n, Ta* d, Ta* e, Ta* vl, Ta* vu, integer* il, integer* iu, Ta* abstol, integer* m, Ta* w, T* z, integer* ldz, integer* isuppz, Ta* work, integer* lwork, integer* iwork, integer* liwork, integer* info)
{
  return stegr(jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork, info);
}

/*! @brief STEIN computes the eigenvectors of a real symmetric tridiagonal matrix T

 * @details
 * \b Purpose:
    \verbatim
     STEIN computes the eigenvectors of a real symmetric tridiagonal
     matrix T corresponding to specified eigenvalues, using inverse
     iteration.

     The maximum number of iterations allowed for each eigenvector is
     specified by an internal parameter MAXITS (currently set to 5).
    \endverbatim 

 * @param[in] N
          N is INTEGER \n
          The order of the matrix.  N >= 0. \n
 * @param[in] D
          D is REAL array, dimension (N) \n
          The n diagonal elements of the tridiagonal matrix T. \n
 * @param[in] E
          E is REAL array, dimension (N-1) \n
          The (n-1) subdiagonal elements of the tridiagonal matrix
          T, in elements 1 to N-1. \n
 * @param[in] M
          M is INTEGER \n
          The number of eigenvectors to be found.  0 <= M <= N. \n
 * @param[in] W
          W is REAL array, dimension (N) \n
          The first M elements of W contain the eigenvalues for
          which eigenvectors are to be computed.  The eigenvalues
          should be grouped by split-off block and ordered from
          smallest to largest within the block.  ( The output array
          W from SSTEBZ with ORDER = 'B' is expected here.) \n
 * @param[in] IBLOCK
          IBLOCK is INTEGER array, dimension (N) \n
          The submatrix indices associated with the corresponding
          eigenvalues in W; IBLOCK(i)=1 if eigenvalue W(i) belongs to
          the first submatrix from the top, =2 if W(i) belongs to
          the second submatrix, etc.  ( The output array IBLOCK
          from SSTEBZ is expected here.) \n
 * @param[in] ISPLIT 
          ISPLIT is INTEGER array, dimension (N) \n
          The splitting points, at which T breaks up into submatrices.
          The first submatrix consists of rows/columns 1 to
          ISPLIT( 1), the second of rows/columns ISPLIT( 1)+1
          through ISPLIT( 2), etc.
          ( The output array ISPLIT from SSTEBZ is expected here.) \n
 * @param[out] Z
          Z is REAL array, dimension (LDZ, M) \n
          The computed eigenvectors.  The eigenvector associated
          with the eigenvalue W(i) is stored in the i-th column of
          Z.  Any vector which fails to converge is set to its current
          iterate after MAXITS iterations. \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of the array Z.  LDZ >= max(1,N). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (5*N) \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (N) \n
 * @param[out]	IFAIL	
          IFAIL is INTEGER array, dimension (M) \n
          On normal exit, all elements of IFAIL are zero.
          If one or more eigenvectors fail to converge after
          MAXITS iterations, then their indices are stored in
          array IFAIL. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0: successful exit. \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n
          > 0: if INFO = i, then i eigenvectors failed to converge
               in MAXITS iterations.  Their indices are stored in
               array IFAIL. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer stein(integer* n,  T* d,  T* e, integer* m, T* w, integer* iblock, integer* isplit, T* z, integer* ldz, T* work, integer* iwork, integer* ifail, integer* info)
{
  return stein(n, d,  e, m,  w, iblock, isplit, z, ldz, work, iwork, ifail, info);
}
template< typename T, typename Ta >
integer stein(integer* n,  Ta* d,  Ta* e, integer* m, Ta* w, integer* iblock, integer* isplit, T* z, integer* ldz, Ta* work, integer* iwork, integer* ifail, integer* info)
{
  return stein(n, d, e, m, w, iblock, isplit, z, ldz, work, iwork, ifail, info);
}

/*! @brief STERF computes all eigenvalues of a symmetric tridiagonal matrix

 * @details
 * \b Purpose:
    \verbatim
     STERF computes all eigenvalues of a symmetric tridiagonal matrix
     using the Pal-Walker-Kahan variant of the QL or QR algorithm.
    \endverbatim 

 * @param[in] N
          N is INTEGER \n
          The order of the matrix.  N >= 0. \n
 * @param[in,out] D
          D is REAL array, dimension (N) \n
          On entry, the n diagonal elements of the tridiagonal matrix.
          On exit, if INFO = 0, the eigenvalues in ascending order. \n
 * @param[in,out] E
          E is REAL array, dimension (N-1) \n
          On entry, the (n-1) subdiagonal elements of the tridiagonal
          matrix.
          On exit, E has been destroyed. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  the algorithm failed to find all of the eigenvalues in
                a total of 30*N iterations; if INFO = i, then i
                elements of E have not converged to zero. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sterf(integer* n, T* d, T* e, integer* info)
{
  return sterf(n, d, e, info);
}

/*! @brief STEV computes the eigenvalues and, optionally, the left and/or right eigenvectors for OTHER matrices

 * @details
 * \b Purpose:
    \verbatim
     STEV computes all eigenvalues and, optionally, eigenvectors of a
     real symmetric tridiagonal matrix A.
    \endverbatim 

 * @param[in] JOBZ
          JOBZ is CHARACTER*1 \n
          = 'N':  Compute eigenvalues only; \n
          = 'V':  Compute eigenvalues and eigenvectors. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix.  N >= 0. \n
 * @param[in,out] D
          D is REAL array, dimension (N) \n
          On entry, the n diagonal elements of the tridiagonal matrix
          A.
          On exit, if INFO = 0, the eigenvalues in ascending order. \n
 * @param[in,out] E
          E is REAL array, dimension (N-1) \n
          On entry, the (n-1) subdiagonal elements of the tridiagonal
          matrix A, stored in elements 1 to N-1 of E.
          On exit, the contents of E are destroyed. \n
 * @param[out] Z
          Z is REAL array, dimension (LDZ, N) \n
          If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal
          eigenvectors of the matrix A, with the i-th column of Z
          holding the eigenvector associated with D(i). \n
          If JOBZ = 'N', then Z is not referenced. \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of the array Z.  LDZ >= 1, and if
          JOBZ = 'V', LDZ >= max(1,N). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (max(1,2*N-2))
          If JOBZ = 'N', WORK is not referenced. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, the algorithm failed to converge; i
                off-diagonal elements of E did not converge to zero. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer stev(char* jobz, integer* n, T* d, T* e, T* z, integer* ldz, T* work, integer* info)
{
  return stev(jobz, n, d, e, z, ldz, work, info);
}

/*! @brief STEVD computes the eigenvalues and, optionally, the left and/or right eigenvectors for OTHER matrices

 * @details
 * \b Purpose:
    \verbatim
     STEVD computes all eigenvalues and, optionally, eigenvectors of a
     real symmetric tridiagonal matrix. If eigenvectors are desired, it
     uses a divide and conquer algorithm.

     The divide and conquer algorithm makes very mild assumptions about
     floating point arithmetic. It will work on machines with a guard
     digit in add/subtract, or on those binary machines without guard
     digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
     Cray-2. It could conceivably fail on hexadecimal or decimal machines
     without guard digits, but we know of none.
    \endverbatim 

 * @param[in] JOBZ
          JOBZ is CHARACTER*1 \n
          = 'N':  Compute eigenvalues only; \n
          = 'V':  Compute eigenvalues and eigenvectors. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix.  N >= 0. \n
 * @param[in,out] D
          D is REAL array, dimension (N) \n
          On entry, the n diagonal elements of the tridiagonal matrix
          A.
          On exit, if INFO = 0, the eigenvalues in ascending order. \n
 * @param[in,out] E
          E is REAL array, dimension (N-1) \n
          On entry, the (n-1) subdiagonal elements of the tridiagonal
          matrix A, stored in elements 1 to N-1 of E.
          On exit, the contents of E are destroyed. \n
 * @param[out] Z
          Z is REAL array, dimension (LDZ, N) \n
          If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal
          eigenvectors of the matrix A, with the i-th column of Z
          holding the eigenvector associated with D(i). \n
          If JOBZ = 'N', then Z is not referenced. \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of the array Z.  LDZ >= 1, and if
          JOBZ = 'V', LDZ >= max(1,N). \n
 * @param[out]	WORK	
          WORK is REAL array,
                                         dimension (LWORK) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK. \n
          If JOBZ  = 'N' or N <= 1 then LWORK must be at least 1. \n
          If JOBZ  = 'V' and N > 1 then LWORK must be at least
                         ( 1 + 4*N + N**2 ). \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal sizes of the WORK and IWORK
          arrays, returns these values as the first entries of the WORK
          and IWORK arrays, and no error message related to LWORK or
          LIWORK is issued by XERBLA. \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (MAX(1,LIWORK)) \n
          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK. \n
 * @param[in]	LIWORK	
          LIWORK is INTEGER \n
          The dimension of the array IWORK. \n
          If JOBZ  = 'N' or N <= 1 then LIWORK must be at least 1. \n
          If JOBZ  = 'V' and N > 1 then LIWORK must be at least 3+5*N. \n
 \n
          If LIWORK = -1, then a workspace query is assumed; the
          routine only calculates the optimal sizes of the WORK and
          IWORK arrays, returns these values as the first entries of
          the WORK and IWORK arrays, and no error message related to
          LWORK or LIWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, the algorithm failed to converge; i
                off-diagonal elements of E did not converge to zero. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer stevd(char* jobz, integer* n, T* d, T* e, T* z, integer* ldz, T* work, integer* lwork, integer* iwork, integer* liwork, integer* info)
{
  return stevd(jobz, n, d, e, z, ldz, work, lwork, iwork, liwork, info);
}

/*! @brief STEVR computes the eigenvalues and, optionally, the left and/or right eigenvectors for OTHER matrices

 * @details
 * \b Purpose:
    \verbatim
     STEVR computes selected eigenvalues and, optionally, eigenvectors
     of a real symmetric tridiagonal matrix T.  Eigenvalues and
     eigenvectors can be selected by specifying either a range of values
     or a range of indices for the desired eigenvalues.

     Whenever possible, SSTEVR calls SSTEMR to compute the
     eigenspectrum using Relatively Robust Representations.  SSTEMR
     computes eigenvalues by the dqds algorithm, while orthogonal
     eigenvectors are computed from various "good" L D L^T representations
     (also known as Relatively Robust Representations). Gram-Schmidt
     orthogonalization is avoided as far as possible. More specifically,
     the various steps of the algorithm are as follows. For the i-th
     unreduced block of T,
        (a) Compute T - sigma_i = L_i D_i L_i^T, such that L_i D_i L_i^T
             is a relatively robust representation,
        (b) Compute the eigenvalues, lambda_j, of L_i D_i L_i^T to high
            relative accuracy by the dqds algorithm,
        (c) If there is a cluster of close eigenvalues, "choose" sigma_i
            close to the cluster, and go to step (a),
        (d) Given the approximate eigenvalue lambda_j of L_i D_i L_i^T,
            compute the corresponding eigenvector by forming a
            rank-revealing twisted factorization.
     The desired accuracy of the output can be specified by the input
     parameter ABSTOL.

     For more details, see "A new O(n^2) algorithm for the symmetric
     tridiagonal eigenvalue/eigenvector problem", by Inderjit Dhillon,
     Computer Science Division Technical Report No. UCB//CSD-97-971,
     UC Berkeley, May 1997.

     Note 1 : SSTEVR calls SSTEMR when the full spectrum is requested
     on machines which conform to the ieee-754 floating point standard.
     SSTEVR calls SSTEBZ and SSTEIN on non-ieee machines and
     when partial spectrum requests are made.

     Normal execution of SSTEMR may create NaNs and infinities and
     hence may abort due to a floating point exception in environments
     which do not handle NaNs and infinities in the ieee standard default
     manner.
    \endverbatim 

 * @param[in] JOBZ
          JOBZ is CHARACTER*1 \n
          = 'N':  Compute eigenvalues only; \n
          = 'V':  Compute eigenvalues and eigenvectors. \n
 * @param[in] RANGE
          RANGE is CHARACTER*1 \n
          = 'A': all eigenvalues will be found. \n
          = 'V': all eigenvalues in the half-open interval (VL,VU]
                 will be found. \n
          = 'I': the IL-th through IU-th eigenvalues will be found. \n
          For RANGE = 'V' or 'I' and IU - IL < N - 1, SSTEBZ and
          SSTEIN are called \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix.  N >= 0. \n
 * @param[in,out] D
          D is REAL array, dimension (N) \n
          On entry, the n diagonal elements of the tridiagonal matrix
          A. \n
          On exit, D may be multiplied by a constant factor chosen
          to avoid over/underflow in computing the eigenvalues. \n
 * @param[in,out] E
          E is REAL array, dimension (max(1,N-1)) \n
          On entry, the (n-1) subdiagonal elements of the tridiagonal
          matrix A in elements 1 to N-1 of E. \n
          On exit, E may be multiplied by a constant factor chosen
          to avoid over/underflow in computing the eigenvalues. \n
 * @param[in] VL
          VL is REAL \n
          If RANGE='V', the lower bound of the interval to
          be searched for eigenvalues. VL < VU.
          Not referenced if RANGE = 'A' or 'I'. \n
 * @param[in] VU
          VU is REAL \n
          If RANGE='V', the upper bound of the interval to
          be searched for eigenvalues. VL < VU.
          Not referenced if RANGE = 'A' or 'I'. \n
 * @param[in] IL
          IL is INTEGER \n
          If RANGE='I', the index of the
          smallest eigenvalue to be returned. \n
          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0. \n
          Not referenced if RANGE = 'A' or 'V'. \n
 * @param[in] IU
          IU is INTEGER \n
          If RANGE='I', the index of the
          largest eigenvalue to be returned. \n
          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0. \n
          Not referenced if RANGE = 'A' or 'V'. \n
 * @param[in] ABSTOL
          ABSTOL is REAL \n
          The absolute error tolerance for the eigenvalues.
          An approximate eigenvalue is accepted as converged
          when it is determined to lie in an interval [a,b]
          of width less than or equal to \n
 \n
                  ABSTOL + EPS *   max( |a|,|b|) , \n
 \n
          where EPS is the machine precision.  If ABSTOL is less than
          or equal to zero, then  EPS*|T|  will be used in its place,
          where |T| is the 1-norm of the tridiagonal matrix obtained
          by reducing A to tridiagonal form. \n
 \n
          See "Computing Small Singular Values of Bidiagonal Matrices
          with Guaranteed High Relative Accuracy," by Demmel and
          Kahan, LAPACK Working Note #3. \n
 \n
          If high relative accuracy is important, set ABSTOL to
          SLAMCH( 'Safe minimum').  Doing so will guarantee that
          eigenvalues are computed to high relative accuracy when
          possible in future releases.  The current code does not
          make any guarantees about high relative accuracy, but
          future releases will. See J. Barlow and J. Demmel,
          "Computing Accurate Eigensystems of Scaled Diagonally
          Dominant Matrices", LAPACK Working Note #7, for a discussion
          of which matrices define their eigenvalues to high relative
          accuracy. \n
 * @param[out] M
          M is INTEGER \n
          The total number of eigenvalues found.  0 <= M <= N.
          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1. \n
 * @param[out] W
          W is REAL array, dimension (N) \n
          The first M elements contain the selected eigenvalues in
          ascending order. \n
 * @param[out] Z
          Z is REAL array, dimension (LDZ, max(1,M)) \n
          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
          contain the orthonormal eigenvectors of the matrix A
          corresponding to the selected eigenvalues, with the i-th
          column of Z holding the eigenvector associated with W(i).
          Note: the user must ensure that at least max(1,M) columns are
          supplied in the array Z; if RANGE = 'V', the exact value of M
          is not known in advance and an upper bound must be used. \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of the array Z.  LDZ >= 1, and if
          JOBZ = 'V', LDZ >= max(1,N). \n
 * @param[out] ISUPPZ
          ISUPPZ is INTEGER array, dimension ( 2*max(1,M)) \n
          The support of the eigenvectors in Z, i.e., the indices
          indicating the nonzero elements in Z. The i-th eigenvector
          is nonzero only in elements ISUPPZ( 2*i-1) through
          ISUPPZ( 2*i).
          Implemented only for RANGE = 'A' or 'I' and IU - IL = N - 1 \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal (and
          minimal) LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK.  LWORK >= 20*N. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal sizes of the WORK and IWORK
          arrays, returns these values as the first entries of the WORK
          and IWORK arrays, and no error message related to LWORK or
          LIWORK is issued by XERBLA. \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (MAX(1,LIWORK)) \n
          On exit, if INFO = 0, IWORK(1) returns the optimal (and
          minimal) LIWORK. \n
 * @param[in]	LIWORK	
          LIWORK is INTEGER \n
          The dimension of the array IWORK.  LIWORK >= 10*N. \n
 \n
          If LIWORK = -1, then a workspace query is assumed; the
          routine only calculates the optimal sizes of the WORK and
          IWORK arrays, returns these values as the first entries of
          the WORK and IWORK arrays, and no error message related to
          LWORK or LIWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  Internal error \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer stevr(char* jobz, char* range, integer* n, T* d, T* e, T* vl, T* vu, integer* il, integer* iu, T* abstol, integer* m, T* w, T* z, integer* ldz, integer* isuppz, T* work, integer* lwork, integer* iwork, integer* liwork, integer* info)
{
  return stevr(jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork, info);
}

/*! @brief STEVX computes the eigenvalues and, optionally, the left and/or right eigenvectors for OTHER matrices

 * @details
 * \b Purpose:
    \verbatim
     STEVX computes selected eigenvalues and, optionally, eigenvectors
     of a real symmetric tridiagonal matrix A.  Eigenvalues and
     eigenvectors can be selected by specifying either a range of values
     or a range of indices for the desired eigenvalues.
    \endverbatim

 * @param[in] JOBZ
          JOBZ is CHARACTER*1 \n
          = 'N':  Compute eigenvalues only; \n
          = 'V':  Compute eigenvalues and eigenvectors. \n
 * @param[in] RANGE
          RANGE is CHARACTER*1 \n
          = 'A': all eigenvalues will be found. \n
          = 'V': all eigenvalues in the half-open interval (VL,VU]
                 will be found. \n
          = 'I': the IL-th through IU-th eigenvalues will be found. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix.  N >= 0. \n
 * @param[in,out] D
          D is REAL array, dimension (N) \n
          On entry, the n diagonal elements of the tridiagonal matrix
          A. \n
          On exit, D may be multiplied by a constant factor chosen
          to avoid over/underflow in computing the eigenvalues. \n
 * @param[in,out] E
          E is REAL array, dimension (max(1,N-1)) \n
          On entry, the (n-1) subdiagonal elements of the tridiagonal
          matrix A in elements 1 to N-1 of E. \n
          On exit, E may be multiplied by a constant factor chosen
          to avoid over/underflow in computing the eigenvalues. \n
 * @param[in] VL
          VL is REAL \n
          If RANGE='V', the lower bound of the interval to
          be searched for eigenvalues. VL < VU. \n
          Not referenced if RANGE = 'A' or 'I'. \n
 * @param[in] VU
          VU is REAL \n
          If RANGE='V', the upper bound of the interval to
          be searched for eigenvalues. VL < VU. \n
          Not referenced if RANGE = 'A' or 'I'. \n
 * @param[in] IL
          IL is INTEGER \n
          If RANGE='I', the index of the
          smallest eigenvalue to be returned. \n
          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0. \n
          Not referenced if RANGE = 'A' or 'V'. \n
 * @param[in] IU
          IU is INTEGER \n
          If RANGE='I', the index of the
          largest eigenvalue to be returned. \n
          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0. \n
          Not referenced if RANGE = 'A' or 'V'. \n
 * @param[in] ABSTOL
          ABSTOL is REAL \n
          The absolute error tolerance for the eigenvalues.
          An approximate eigenvalue is accepted as converged
          when it is determined to lie in an interval [a,b]
          of width less than or equal to \n
 \n
                  ABSTOL + EPS *   max( |a|,|b|) , \n
 \n
          where EPS is the machine precision.  If ABSTOL is less
          than or equal to zero, then  EPS*|T|  will be used in
          its place, where |T| is the 1-norm of the tridiagonal
          matrix. \n
 \n
          Eigenvalues will be computed most accurately when ABSTOL is
          set to twice the underflow threshold 2*SLAMCH('S'), not zero.
          If this routine returns with INFO>0, indicating that some
          eigenvectors did not converge, try setting ABSTOL to
          2*SLAMCH('S'). \n
 \n
          See "Computing Small Singular Values of Bidiagonal Matrices
          with Guaranteed High Relative Accuracy," by Demmel and
          Kahan, LAPACK Working Note #3. \n
 * @param[out] M
          M is INTEGER \n
          The total number of eigenvalues found.  0 <= M <= N.
          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1. \n
 * @param[out] W
          W is REAL array, dimension (N) \n
          The first M elements contain the selected eigenvalues in
          ascending order. \n
 * @param[out] Z
          Z is REAL array, dimension (LDZ, max(1,M)) \n
          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
          contain the orthonormal eigenvectors of the matrix A
          corresponding to the selected eigenvalues, with the i-th
          column of Z holding the eigenvector associated with W(i).
          If an eigenvector fails to converge (INFO > 0), then that
          column of Z contains the latest approximation to the
          eigenvector, and the index of the eigenvector is returned
          in IFAIL. \n
          If JOBZ = 'N', then Z is not referenced.
          Note: the user must ensure that at least max(1,M) columns are
          supplied in the array Z; if RANGE = 'V', the exact value of M
          is not known in advance and an upper bound must be used. \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of the array Z.  LDZ >= 1, and if
          JOBZ = 'V', LDZ >= max(1,N). \n
* @param[out]	WORK	
          WORK is REAL array, dimension (5*N) \n
* @param[out]	IWORK	
          IWORK is INTEGER array, dimension (5*N) \n
* @param[out]	IFAIL	
          IFAIL is INTEGER array, dimension (N) \n
          If JOBZ = 'V', then if INFO = 0, the first M elements of
          IFAIL are zero.  If INFO > 0, then IFAIL contains the
          indices of the eigenvectors that failed to converge. \n
          If JOBZ = 'N', then IFAIL is not referenced. \n
* @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, then i eigenvectors failed to converge.
                Their indices are stored in array IFAIL. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer stevx(char* jobz, char* range, integer* n, T* d, T* e, T* vl, T* vu, integer* il, integer* iu, T* abstol, integer* m, T* w, T* z, integer* ldz, float* work, integer* iwork, integer* ifail, integer* info)
{
  return stevx(jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail, info);
}

/*! @brief SYCON_3 estimates the reciprocal of the condition number of a real symmetric matrix A

 * @details
 * \b Purpose:
    \verbatim
     SYCON_3 estimates the reciprocal of the condition number (in the
     1-norm) of a real symmetric matrix A using the factorization
     computed by DSYTRF_RK or DSYTRF_BK:

        A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),

     where U (or L) is unit upper (or lower) triangular matrix,
     U**T (or L**T) is the transpose of U (or L), P is a permutation
     matrix, P**T is the transpose of P, and D is symmetric and block
     diagonal with 1-by-1 and 2-by-2 diagonal blocks.

     An estimate is obtained for norm(inv(A)), and the reciprocal of the
     condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
     This routine uses BLAS3 solver SSYTRS_3.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the details of the factorization are
          stored as an upper or lower triangular matrix: \n
          = 'U':  Upper triangular, form is A = P*U*D*(U**T)*(P**T); \n
          = 'L':  Lower triangular, form is A = P*L*D*(L**T)*(P**T). \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          Diagonal of the block diagonal matrix D and factors U or L
          as computed by SSYTRF_RK and SSYTRF_BK: \n
            a) ONLY diagonal elements of the symmetric block diagonal
               matrix D on the diagonal of A, i.e. D(k,k) = A(k,k);
               (superdiagonal (or subdiagonal) elements of D
                should be provided on entry in array E), and \n
            b) If UPLO = 'U': factor U in the superdiagonal part of A.
               If UPLO = 'L': factor L in the subdiagonal part of A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] E
          E is REAL array, dimension (N) \n
          On entry, contains the superdiagonal (or subdiagonal)
          elements of the symmetric block diagonal matrix D
          with 1-by-1 or 2-by-2 diagonal blocks, where
          If UPLO = 'U': E(i) = D(i-1,i),i=2:N, E(1) not referenced;
          If UPLO = 'L': E(i) = D(i+1,i),i=1:N-1, E(N) not referenced. \n

          NOTE: For 1-by-1 diagonal block D(k), where
          1 <= k <= N, the element E(k) is not referenced in both
          UPLO = 'U' or UPLO = 'L' cases. \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D
          as determined by SSYTRF_RK or SSYTRF_BK. \n
 * @param[in] ANORM
          ANORM is REAL \n
          The 1-norm of the original matrix A. \n
 * @param[out] RCOND
          RCOND is REAL \n
          The reciprocal of the condition number of the matrix A,
          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
          estimate of the 1-norm of inv(A) computed in this routine. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (2*N) \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sycon_3(char* uplo, integer* n, T* a, integer* lda, T* e, integer* ipiv, T* anorm, T* rcond, T* work, integer* iwork, integer* info)
{
  return sycon_3(uplo, n, a, lda, e, ipiv, anorm, rcond, work, iwork, info);
}
template< typename T, typename Ta >
integer sycon_3(char* uplo, integer* n, T* a, integer* lda, T* e, integer* ipiv, Ta* anorm, Ta* rcond, T* work, integer* info)
{
  return sycon_3(uplo, n, a, lda, e, ipiv, anorm, rcond, work, info);
}

/*! @brief SYCON estimates the reciprocal of the condition number of a real symmetric matrix A

 * @details
 * \b Purpose:
    \verbatim
     SYCON estimates the reciprocal of the condition number (in the
     1-norm) of a real symmetric matrix A using the factorization
     A = U*D*U**T or A = L*D*L**T computed by SYTRF.

     An estimate is obtained for norm(inv(A)), and the reciprocal of the
     condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the details of the factorization are stored
          as an upper or lower triangular matrix. \n
          = 'U':  Upper triangular, form is A = U*D*U**T; \n
          = 'L':  Lower triangular, form is A = L*D*L**T. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          The block diagonal matrix D and the multipliers used to
          obtain the factor U or L as computed by SSYTRF. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D
          as determined by SSYTRF. \n
 * @param[in] ANORM
          ANORM is REAL \n
          The 1-norm of the original matrix A. \n
 * @param[out] RCOND
          RCOND is REAL \n
          The reciprocal of the condition number of the matrix A,
          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
          estimate of the 1-norm of inv(A) computed in this routine. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (2*N) \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sycon(char* uplo, integer* n,  T* a, integer* lda,  integer* ipiv, T* anorm, T* rcond, T* work, integer* iwork, integer* info)
{
  return sycon(uplo, n, a, lda,  ipiv, anorm, rcond, work, iwork, info);
}
template< typename T, typename Ta >
integer sycon(char* uplo, integer* n,  T* a, integer* lda,  integer* ipiv, Ta* anorm, Ta* rcond, T* work, integer* info)
{
  return sycon(uplo, n, a, lda,  ipiv, anorm, rcond, work, info);
}

/*! @brief SYCONV convert A given by TRF into L and D and vice-versa

 * @details
 * \b Purpose:
    \verbatim
     SYCONV convert A given by TRF into L and D and vice-versa.
     Get Non-diag elements of D (returned in workspace) and
     apply or reverse permutation done in TRF.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the details of the factorization are stored
          as an upper or lower triangular matrix. \n
          = 'U':  Upper triangular, form is A = U*D*U**T; \n
          = 'L':  Lower triangular, form is A = L*D*L**T. \n
 * @param[in] WAY
          WAY is CHARACTER*1 \n
          = 'C': Convert \n
          = 'R': Revert \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          The block diagonal matrix D and the multipliers used to
          obtain the factor U or L as computed by SSYTRF. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D
          as determined by SSYTRF. \n
 * @param[out] E
          E is REAL array, dimension (N) \n
          E stores the supdiagonal/subdiagonal of the symmetric 1-by-1
          or 2-by-2 block diagonal matrix D in LDLT. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer syconv(char* uplo, char* way, integer* n, T* a, integer* lda, integer* ipiv, T* work, integer* info)
{
  return syconv(uplo, way, n, a, lda, ipiv, work, info);
}

/*! @brief SYEQUB computes row and column scalings intended to equilibrate a symmetric matrix A

 * @details
 * \b Purpose:
    \verbatim
     SYEQUB computes row and column scalings intended to equilibrate a
     symmetric matrix A (with respect to the Euclidean norm) and reduce
     its condition number. The scale factors S are computed by the BIN
     algorithm (see references) so that the scaled matrix B with elements
     B(i,j) = S(i)*A(i,j)*S(j) has a condition number within a factor N of
     the smallest possible condition number over all possible diagonal
     scalings.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A. N >= 0. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          The N-by-N symmetric matrix whose scaling factors are to be
          computed. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A. LDA >= max(1,N). \n
 * @param[out] S
          S is REAL array, dimension (N) \n
          If INFO = 0, S contains the scale factors for A. \n
 * @param[out] SCOND
          SCOND is REAL \n
          If INFO = 0, S contains the ratio of the smallest S(i) to
          the largest S(i). If SCOND >= 0.1 and AMAX is neither too
          large nor too small, it is not worth scaling by S. \n
 * @param[out] AMAX
          AMAX is REAL \n
          Largest absolute value of any matrix element. If AMAX is
          very close to overflow or very close to underflow, the
          matrix should be scaled. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (2*N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, the i-th diagonal element is nonpositive. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer syequb(char* uplo, integer* n,  T* a, integer* lda, T* s, T* scond, T* amax, T* work, integer* info)
{
  return syequb(uplo, n, a, lda, s, scond, amax, work, info);
}
template< typename T, typename Ta >
integer syequb(char* uplo, integer* n,  T* a, integer* lda, Ta* s, Ta* scond, Ta* amax, T* work, integer* info)
{
  return syequb(uplo, n, a, lda, s, scond, amax, work, info);
}

/*! @brief SYEV_2STAGE computes the eigenvalues and, optionally, the left \n
     and/or right eigenvectors for SY matrices
 * @details
 * \b Purpose:
    \verbatim
     SYEV_2STAGE computes all eigenvalues and, optionally, eigenvectors of a
     real symmetric matrix A using the 2stage technique for
     the reduction to tridiagonal.
    \endverbatim  

  * @param[in] JOBZ
           JOBZ is CHARACTER*1 \n
           = 'N':  Compute eigenvalues only; \n
           = 'V':  Compute eigenvalues and eigenvectors.
                   Not available in this release. \n
  * @param[in] UPLO
           UPLO is CHARACTER*1 \n
           = 'U':  Upper triangle of A is stored; \n
           = 'L':  Lower triangle of A is stored. \n
  * @param[in] N
           N is INTEGER \n
           The order of the matrix A.  N >= 0. \n
  * @param[in,out] A
           A is REAL array, dimension (LDA, N) \n
           On entry, the symmetric matrix A.  If UPLO = 'U', the
           leading N-by-N upper triangular part of A contains the
           upper triangular part of the matrix A.  If UPLO = 'L',
           the leading N-by-N lower triangular part of A contains
           the lower triangular part of the matrix A. \n
           On exit, if JOBZ = 'V', then if INFO = 0, A contains the
           orthonormal eigenvectors of the matrix A.
           If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
           or the upper triangle (if UPLO='U') of A, including the
           diagonal, is destroyed. \n
  * @param[in] LDA
           LDA is INTEGER \n
           The leading dimension of the array A.  LDA >= max(1,N). \n
  * @param[out] W
           W is REAL array, dimension (N) \n
           If INFO = 0, the eigenvalues in ascending order. \n
  * @param[out]	WORK	
          WORK is REAL array, dimension LWORK \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
  * @param[in]	LWORK	
          LWORK is INTEGER \n
          The length of the array WORK. LWORK >= 1, when N <= 1; \n
          otherwise   \n
          If JOBZ = 'N' and N > 1, LWORK must be queried.
                                   LWORK = MAX(1, dimension) where \n
                                   dimension = max(stage1,stage2) + (KD+1)*N + 2*N \n
                                             = N*KD + N*max(KD+1,FACTOPTNB) 
                                               + max(2*KD*KD, KD*NTHREADS) 
                                               + (KD+1)*N + 2*N \n
                                   where KD is the blocking size of the reduction,
                                   FACTOPTNB is the blocking used by the QR or LQ
                                   algorithm, usually FACTOPTNB=128 is a good choice
                                   NTHREADS is the number of threads used when
                                   openMP compilation is enabled, otherwise =1. \n
          If JOBZ = 'V' and N > 1, LWORK must be queried. Not yet available \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
  * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, the algorithm failed to converge; i
                off-diagonal elements of an intermediate tridiagonal
                form did not converge to zero. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer syev_2stage(char* jobz, char* uplo, integer* n, T* a, integer* lda, T* w, T* work, integer* lwork, integer* info)
{
  return syev_2stage(jobz, uplo, n, a, lda, w, work, lwork, info);
}

/*! @brief SYEVD_2STAGE computes the eigenvalues and, optionally, the left \n
     and/or right eigenvectors for SY matrices
 * @details
 * \b Purpose:
    \verbatim
     SYEVD_2STAGE computes all eigenvalues and, optionally, eigenvectors of a
     real symmetric matrix A using the 2stage technique for
     the reduction to tridiagonal. If eigenvectors are desired, it uses a
     divide and conquer algorithm.

     The divide and conquer algorithm makes very mild assumptions about
     floating point arithmetic. It will work on machines with a guard
     digit in add/subtract, or on those binary machines without guard
     digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
     Cray-2. It could conceivably fail on hexadecimal or decimal machines
     without guard digits, but we know of none.
    \endverbatim
    
 * @param[in] JOBZ
          JOBZ is CHARACTER*1 \n
          = 'N':  Compute eigenvalues only; \n
          = 'V':  Compute eigenvalues and eigenvectors.
                  Not available in this release. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA, N) \n
          On entry, the symmetric matrix A.  If UPLO = 'U', the
          leading N-by-N upper triangular part of A contains the
          upper triangular part of the matrix A.  If UPLO = 'L',
          the leading N-by-N lower triangular part of A contains
          the lower triangular part of the matrix A. \n
          On exit, if JOBZ = 'V', then if INFO = 0, A contains the
          orthonormal eigenvectors of the matrix A. \n
          If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
          or the upper triangle (if UPLO='U') of A, including the
          diagonal, is destroyed. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] W
          W is REAL array, dimension (N) \n
          If INFO = 0, the eigenvalues in ascending order. \n
 * @param[out]	WORK	
          WORK is REAL array,
                                         dimension (LWORK) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK. \n
          If N <= 1,               LWORK must be at least 1. \n
          If JOBZ = 'N' and N > 1, LWORK must be queried.
                                   LWORK = MAX(1, dimension) where
                                   dimension = max(stage1,stage2) + (KD+1)*N + 2*N+1
                                             = N*KD + N*max(KD+1,FACTOPTNB) 
                                               + max(2*KD*KD, KD*NTHREADS) 
                                               + (KD+1)*N + 2*N+1
                                   where KD is the blocking size of the reduction,
                                   FACTOPTNB is the blocking used by the QR or LQ
                                   algorithm, usually FACTOPTNB=128 is a good choice
                                   NTHREADS is the number of threads used when
                                   openMP compilation is enabled, otherwise =1. \n
          If JOBZ = 'V' and N > 1, LWORK must be at least
                                                1 + 6*N + 2*N**2. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal sizes of the WORK and IWORK
          arrays, returns these values as the first entries of the WORK
          and IWORK arrays, and no error message related to LWORK or
          LIWORK is issued by XERBLA. \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (MAX(1,LIWORK)) \n
          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK. \n
 * @param[in]	LIWORK	
          LIWORK is INTEGER \n
          The dimension of the array IWORK. \n
          If N <= 1,                LIWORK must be at least 1. \n
          If JOBZ  = 'N' and N > 1, LIWORK must be at least 1. \n
          If JOBZ  = 'V' and N > 1, LIWORK must be at least 3 + 5*N. \n
 \n
          If LIWORK = -1, then a workspace query is assumed; the
          routine only calculates the optimal sizes of the WORK and
          IWORK arrays, returns these values as the first entries of
          the WORK and IWORK arrays, and no error message related to
          LWORK or LIWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i and JOBZ = 'N', then the algorithm failed
                to converge; i off-diagonal elements of an intermediate
                tridiagonal form did not converge to zero;
                if INFO = i and JOBZ = 'V', then the algorithm failed
                to compute an eigenvalue while working on the submatrix
                lying in rows and columns INFO/(N+1) through
                mod(INFO,N+1). \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer syevd_2stage(char* jobz, char* uplo, integer* n, T* a, integer* lda, T* w, T* work, integer* lwork, integer* iwork, integer* liwork, integer* info)
{
  return syevd_2stage(jobz, uplo, n, a, lda, w, work, lwork, iwork, liwork, info);
}

/*! @brief SYEVR_2STAGE computes the eigenvalues and, optionally, the left \n
     and/or right eigenvectors for SY matrices
 * @details
 * \b Purpose:
    \verbatim
     SYEVR_2STAGE computes selected eigenvalues and, optionally, eigenvectors
     of a real symmetric matrix A using the 2stage technique for
     the reduction to tridiagonal.  Eigenvalues and eigenvectors can be
     selected by specifying either a range of values or a range of
     indices for the desired eigenvalues.

     SYEVR_2STAGE first reduces the matrix A to tridiagonal form T with a call
     to SYTRD.  Then, whenever possible, SYEVR_2STAGE calls STEMR to compute
     the eigenspectrum using Relatively Robust Representations.  STEMR
     computes eigenvalues by the dqds algorithm, while orthogonal
     eigenvectors are computed from various "good" L D L^T representations
     (also known as Relatively Robust Representations). Gram-Schmidt
     orthogonalization is avoided as far as possible. More specifically,
     the various steps of the algorithm are as follows.

     For each unreduced block (submatrix) of T,
        (a) Compute T - sigma I  = L D L^T, so that L and D
            define all the wanted eigenvalues to high relative accuracy.
            This means that small relative changes in the entries of D and L
            cause only small relative changes in the eigenvalues and
            eigenvectors. The standard (unfactored) representation of the
            tridiagonal matrix T does not have this property in general.
        (b) Compute the eigenvalues to suitable accuracy.
            If the eigenvectors are desired, the algorithm attains full
            accuracy of the computed eigenvalues only right before
            the corresponding vectors have to be computed, see steps c) and d).
        (c) For each cluster of close eigenvalues, select a new
            shift close to the cluster, find a new factorization, and refine
            the shifted eigenvalues to suitable accuracy.
        (d) For each eigenvalue with a large enough relative separation compute
            the corresponding eigenvector by forming a rank revealing twisted
            factorization. Go back to (c) for any clusters that remain.

     The desired accuracy of the output can be specified by the input
     parameter ABSTOL.

     For more details, see SSTEMR's documentation and:
     - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations
       to compute orthogonal eigenvectors of symmetric tridiagonal matrices,"
       Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
     - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and
       Relative Gaps," SIAM Journal on Matrix Analysis and Applications, Vol. 25,
       2004.  Also LAPACK Working Note 154.
     - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric
       tridiagonal eigenvalue/eigenvector problem",
       Computer Science Division Technical Report No. UCB/CSD-97-971,
       UC Berkeley, May 1997.


     Note 1 : SSYEVR_2STAGE calls SSTEMR when the full spectrum is requested
     on machines which conform to the ieee-754 floating point standard.
     SSYEVR_2STAGE calls SSTEBZ and SSTEIN on non-ieee machines and
     when partial spectrum requests are made.

     Normal execution of SSTEMR may create NaNs and infinities and
     hence may abort due to a floating point exception in environments
     which do not handle NaNs and infinities in the ieee standard default
     manner.
    \endverbatim 

 * @param[in] JOBZ
          JOBZ is CHARACTER*1 \n
          = 'N':  Compute eigenvalues only; \n
          = 'V':  Compute eigenvalues and eigenvectors.
                  Not available in this release. \n
 * @param[in] RANGE
          RANGE is CHARACTER*1 \n
          = 'A': all eigenvalues will be found. \n
          = 'V': all eigenvalues in the half-open interval (VL,VU]
                 will be found. \n
          = 'I': the IL-th through IU-th eigenvalues will be found.
          For RANGE = 'V' or 'I' and IU - IL < N - 1, SSTEBZ and
          SSTEIN are called \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA, N) \n
          On entry, the symmetric matrix A.  If UPLO = 'U', the
          leading N-by-N upper triangular part of A contains the
          upper triangular part of the matrix A.  If UPLO = 'L',
          the leading N-by-N lower triangular part of A contains
          the lower triangular part of the matrix A. \n
          On exit, the lower triangle (if UPLO='L') or the upper
          triangle (if UPLO='U') of A, including the diagonal, is
          destroyed. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] VL
          VL is REAL \n
          If RANGE='V', the lower bound of the interval to
          be searched for eigenvalues. VL < VU.
          Not referenced if RANGE = 'A' or 'I'. \n
 * @param[in] VU
          VU is REAL \n
          If RANGE='V', the upper bound of the interval to
          be searched for eigenvalues. VL < VU.
          Not referenced if RANGE = 'A' or 'I'. \n
 * @param[in] IL
          IL is INTEGER \n
          If RANGE='I', the index of the
          smallest eigenvalue to be returned.
          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
          Not referenced if RANGE = 'A' or 'V'. \n
 * @param[in] IU
          IU is INTEGER \n
          If RANGE='I', the index of the
          largest eigenvalue to be returned. \n
          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0. \n
          Not referenced if RANGE = 'A' or 'V'. \n
 * @param[in] ABSTOL
          ABSTOL is REAL \n
          The absolute error tolerance for the eigenvalues.
          An approximate eigenvalue is accepted as converged
          when it is determined to lie in an interval [a,b]
          of width less than or equal to \n
 \n
                  ABSTOL + EPS *   max( |a|,|b|) , \n
 \n
          where EPS is the machine precision.  If ABSTOL is less than
          or equal to zero, then  EPS*|T|  will be used in its place,
          where |T| is the 1-norm of the tridiagonal matrix obtained
          by reducing A to tridiagonal form. \n
 \n
          See "Computing Small Singular Values of Bidiagonal Matrices
          with Guaranteed High Relative Accuracy," by Demmel and
          Kahan, LAPACK Working Note #3. \n
 \n
          If high relative accuracy is important, set ABSTOL to
          SLAMCH( 'Safe minimum').  Doing so will guarantee that
          eigenvalues are computed to high relative accuracy when
          possible in future releases.  The current code does not
          make any guarantees about high relative accuracy, but
          future releases will. See J. Barlow and J. Demmel,
          "Computing Accurate Eigensystems of Scaled Diagonally
          Dominant Matrices", LAPACK Working Note #7, for a discussion
          of which matrices define their eigenvalues to high relative
          accuracy. \n
 * @param[out] M
          M is INTEGER \n
          The total number of eigenvalues found.  0 <= M <= N.
          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1. \n
 * @param[out] W
          W is REAL array, dimension (N) \n
          The first M elements contain the selected eigenvalues in
          ascending order. \n
 * @param[out] Z
          Z is REAL array, dimension (LDZ, max(1,M)) \n
          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
          contain the orthonormal eigenvectors of the matrix A
          corresponding to the selected eigenvalues, with the i-th
          column of Z holding the eigenvector associated with W(i). \n
          If JOBZ = 'N', then Z is not referenced. \n
          Note: the user must ensure that at least max(1,M) columns are
          supplied in the array Z; if RANGE = 'V', the exact value of M
          is not known in advance and an upper bound must be used.
          Supplying N columns is always safe. \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of the array Z.  LDZ >= 1, and if
          JOBZ = 'V', LDZ >= max(1,N). \n
 * @param[out] ISUPPZ
          ISUPPZ is INTEGER array, dimension ( 2*max(1,M)) \n
          The support of the eigenvectors in Z, i.e., the indices
          indicating the nonzero elements in Z. The i-th eigenvector
          is nonzero only in elements ISUPPZ( 2*i-1) through
          ISUPPZ( 2*i). This is an output of SSTEMR (tridiagonal
          matrix). The support of the eigenvectors of A is typically 
          1:N because of the orthogonal transformations applied by SORMTR.
          Implemented only for RANGE = 'A' or 'I' and IU - IL = N - 1 \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK. \n
          If JOBZ = 'N' and N > 1, LWORK must be queried.
                                   LWORK = MAX(1, 26*N, dimension) where
                                   dimension = max(stage1,stage2) + (KD+1)*N + 5*N
                                             = N*KD + N*max(KD+1,FACTOPTNB) 
                                               + max(2*KD*KD, KD*NTHREADS) 
                                               + (KD+1)*N + 5*N
                                   where KD is the blocking size of the reduction,
                                   FACTOPTNB is the blocking used by the QR or LQ
                                   algorithm, usually FACTOPTNB=128 is a good choice
                                   NTHREADS is the number of threads used when
                                   openMP compilation is enabled, otherwise =1. \n
          If JOBZ = 'V' and N > 1, LWORK must be queried. Not yet available \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (MAX(1,LIWORK)) \n
          On exit, if INFO = 0, IWORK(1) returns the optimal LWORK. \n
 * @param[in]	LIWORK	
          LIWORK is INTEGER \n
          The dimension of the array IWORK.  LIWORK >= max(1,10*N). \n
 \n
          If LIWORK = -1, then a workspace query is assumed; the
          routine only calculates the optimal size of the IWORK array,
          returns this value as the first entry of the IWORK array, and
          no error message related to LIWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  Internal error \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer syevr_2stage(char* jobz, char* range, char* uplo, integer* n, T* a, integer* lda, T* vl, T* vu, integer* il, integer* iu, T* abstol, integer* m, T* w, T* z, integer* ldz, integer* isuppz, T* work, integer* lwork, integer* iwork, integer* liwork, integer* info)
{
  return syevr_2stage(jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork, info);
}

/*! @brief SYEVX_2STAGE  computes the eigenvalues and, optionally, the left \n
     and/or right eigenvectors for SY matrices
 * @details
 * \b Purpose:
    \verbatim
     SYEVX_2STAGE computes selected eigenvalues and, optionally, eigenvectors
     of a real symmetric matrix A using the 2stage technique for
     the reduction to tridiagonal.  Eigenvalues and eigenvectors can be
     selected by specifying either a range of values or a range of indices
     for the desired eigenvalues.
    \endverbatim 

 * @param[in] JOBZ
          JOBZ is CHARACTER*1 \n
          = 'N':  Compute eigenvalues only; \n
          = 'V':  Compute eigenvalues and eigenvectors.
                  Not available in this release. \n
 * @param[in] RANGE
          RANGE is CHARACTER*1 \n
          = 'A': all eigenvalues will be found. \n
          = 'V': all eigenvalues in the half-open interval (VL,VU]
                 will be found. \n
          = 'I': the IL-th through IU-th eigenvalues will be found. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA, N) \n
          On entry, the symmetric matrix A.  If UPLO = 'U', the
          leading N-by-N upper triangular part of A contains the
          upper triangular part of the matrix A.  If UPLO = 'L',
          the leading N-by-N lower triangular part of A contains
          the lower triangular part of the matrix A. \n
          On exit, the lower triangle (if UPLO='L') or the upper
          triangle (if UPLO='U') of A, including the diagonal, is
          destroyed. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] VL
          VL is REAL \n
          If RANGE='V', the lower bound of the interval to
          be searched for eigenvalues. VL < VU.
          Not referenced if RANGE = 'A' or 'I'. \n
 * @param[in] VU
          VU is REAL \n
          If RANGE='V', the upper bound of the interval to
          be searched for eigenvalues. VL < VU.
          Not referenced if RANGE = 'A' or 'I'. \n
 * @param[in] IL
          IL is INTEGER \n
          If RANGE='I', the index of the
          smallest eigenvalue to be returned. \n
          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0. \n
          Not referenced if RANGE = 'A' or 'V'. \n
 * @param[in] IU
          IU is INTEGER \n
          If RANGE='I', the index of the
          largest eigenvalue to be returned. \n
          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0. \n
          Not referenced if RANGE = 'A' or 'V'. \n
 * @param[in] ABSTOL
          ABSTOL is REAL
          The absolute error tolerance for the eigenvalues.
          An approximate eigenvalue is accepted as converged
          when it is determined to lie in an interval [a,b]
          of width less than or equal to \n
 \n
                  ABSTOL + EPS *   max( |a|,|b|) , \n
 \n
          where EPS is the machine precision.  If ABSTOL is less than
          or equal to zero, then  EPS*|T|  will be used in its place,
          where |T| is the 1-norm of the tridiagonal matrix obtained
          by reducing A to tridiagonal form. \n
 \n
          Eigenvalues will be computed most accurately when ABSTOL is
          set to twice the underflow threshold 2*SLAMCH('S'), not zero.
          If this routine returns with INFO>0, indicating that some
          eigenvectors did not converge, try setting ABSTOL to
          2*SLAMCH('S'). \n
 \n
          See "Computing Small Singular Values of Bidiagonal Matrices
          with Guaranteed High Relative Accuracy," by Demmel and
          Kahan, LAPACK Working Note #3. \n
 * @param[out] M
          M is INTEGER \n
          The total number of eigenvalues found.  0 <= M <= N.
          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1. \n
 * @param[out] W
          W is REAL array, dimension (N) \n
          On normal exit, the first M elements contain the selected
          eigenvalues in ascending order. \n
 * @param[out] Z
          Z is REAL array, dimension (LDZ, max(1,M)) \n
          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
          contain the orthonormal eigenvectors of the matrix A
          corresponding to the selected eigenvalues, with the i-th
          column of Z holding the eigenvector associated with W(i).
          If an eigenvector fails to converge, then that column of Z
          contains the latest approximation to the eigenvector, and the
          index of the eigenvector is returned in IFAIL. \n
          If JOBZ = 'N', then Z is not referenced.
          Note: the user must ensure that at least max(1,M) columns are
          supplied in the array Z; if RANGE = 'V', the exact value of M
          is not known in advance and an upper bound must be used. \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of the array Z.  LDZ >= 1, and if
          JOBZ = 'V', LDZ >= max(1,N). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The length of the array WORK. LWORK >= 1, when N <= 1; \n
          otherwise   \n
          If JOBZ = 'N' and N > 1, LWORK must be queried.
                                   LWORK = MAX(1, 8*N, dimension) where
                                   dimension = max(stage1,stage2) + (KD+1)*N + 3*N
                                             = N*KD + N*max(KD+1,FACTOPTNB) 
                                               + max(2*KD*KD, KD*NTHREADS) 
                                               + (KD+1)*N + 3*N
                                   where KD is the blocking size of the reduction,
                                   FACTOPTNB is the blocking used by the QR or LQ
                                   algorithm, usually FACTOPTNB=128 is a good choice
                                   NTHREADS is the number of threads used when
                                   openMP compilation is enabled, otherwise =1. \n
          If JOBZ = 'V' and N > 1, LWORK must be queried. Not yet available \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (5*N) \n
 * @param[out]	IFAIL	
          IFAIL is INTEGER array, dimension (N) \n
          If JOBZ = 'V', then if INFO = 0, the first M elements of
          IFAIL are zero.  If INFO > 0, then IFAIL contains the
          indices of the eigenvectors that failed to converge. \n
          If JOBZ = 'N', then IFAIL is not referenced. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, then i eigenvectors failed to converge.
                Their indices are stored in array IFAIL. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer syevx_2stage(char* jobz, char* range, char* uplo, integer* n, T* a, integer* lda, T* vl, T* vu, integer* il, integer* iu, T* abstol, integer* m, T* w, T* z, integer* ldz, T* work, integer* lwork, integer* iwork, integer* ifail, integer* info)
{
  return syevx_2stage(jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, iwork, ifail, info);
}

/*! @brief SYEVX  computes the eigenvalues and, optionally, the left \n
     and/or right eigenvectors for SY matrices
 * @details
 * \b Purpose:
    \verbatim
     SYEVX computes selected eigenvalues and, optionally, eigenvectors
     of a real symmetric matrix A.  Eigenvalues and eigenvectors can be
     selected by specifying either a range of values or a range of indices
     for the desired eigenvalues.
    \endverbatim 

 * @param[in] JOBZ
          JOBZ is CHARACTER*1 \n
          = 'N':  Compute eigenvalues only; \n
          = 'V':  Compute eigenvalues and eigenvectors. \n
 * @param[in] RANGE
          RANGE is CHARACTER*1 \n
          = 'A': all eigenvalues will be found. \n
          = 'V': all eigenvalues in the half-open interval (VL,VU]
                 will be found. \n
          = 'I': the IL-th through IU-th eigenvalues will be found. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA, N) \n
          On entry, the symmetric matrix A.  If UPLO = 'U', the
          leading N-by-N upper triangular part of A contains the
          upper triangular part of the matrix A.  If UPLO = 'L',
          the leading N-by-N lower triangular part of A contains
          the lower triangular part of the matrix A. \n
          On exit, the lower triangle (if UPLO='L') or the upper
          triangle (if UPLO='U') of A, including the diagonal, is
          destroyed. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] VL
          VL is REAL \n
          If RANGE='V', the lower bound of the interval to
          be searched for eigenvalues. VL < VU. \n
          Not referenced if RANGE = 'A' or 'I'. \n
 * @param[in] VU
          VU is REAL \n
          If RANGE='V', the upper bound of the interval to
          be searched for eigenvalues. VL < VU. \n
          Not referenced if RANGE = 'A' or 'I'. \n
 * @param[in] IL
          IL is INTEGER \n
          If RANGE='I', the index of the
          smallest eigenvalue to be returned. \n
          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0. \n
          Not referenced if RANGE = 'A' or 'V'. \n
 * @param[in] IU
          IU is INTEGER \n
          If RANGE='I', the index of the
          largest eigenvalue to be returned. \n
          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0. \n
          Not referenced if RANGE = 'A' or 'V'. \n
 * @param[in] ABSTOL
          ABSTOL is REAL \n
          The absolute error tolerance for the eigenvalues.
          An approximate eigenvalue is accepted as converged
          when it is determined to lie in an interval [a,b]
          of width less than or equal to \n
 \n
                  ABSTOL + EPS *   max( |a|,|b|) , \n
 \n
          where EPS is the machine precision.  If ABSTOL is less than
          or equal to zero, then  EPS*|T|  will be used in its place,
          where |T| is the 1-norm of the tridiagonal matrix obtained
          by reducing A to tridiagonal form. \n
 \n
          Eigenvalues will be computed most accurately when ABSTOL is
          set to twice the underflow threshold 2*SLAMCH('S'), not zero.
          If this routine returns with INFO>0, indicating that some
          eigenvectors did not converge, try setting ABSTOL to
          2*SLAMCH('S'). \n
 \n
          See "Computing Small Singular Values of Bidiagonal Matrices
          with Guaranteed High Relative Accuracy," by Demmel and
          Kahan, LAPACK Working Note #3. \n
 * @param[out] M
          M is INTEGER \n
          The total number of eigenvalues found.  0 <= M <= N.
          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1. \n
 * @param[out] W
          W is REAL array, dimension (N) \n
          On normal exit, the first M elements contain the selected
          eigenvalues in ascending order. \n
 * @param[out] Z
          Z is REAL array, dimension (LDZ, max(1,M)) \n
          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
          contain the orthonormal eigenvectors of the matrix A
          corresponding to the selected eigenvalues, with the i-th
          column of Z holding the eigenvector associated with W(i).
          If an eigenvector fails to converge, then that column of Z
          contains the latest approximation to the eigenvector, and the
          index of the eigenvector is returned in IFAIL. \n
          If JOBZ = 'N', then Z is not referenced. \n
          Note: the user must ensure that at least max(1,M) columns are
          supplied in the array Z; if RANGE = 'V', the exact value of M
          is not known in advance and an upper bound must be used. \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of the array Z.  LDZ >= 1, and if
          JOBZ = 'V', LDZ >= max(1,N). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The length of the array WORK.  LWORK >= 1, when N <= 1;
          otherwise 8*N. \n
          For optimal efficiency, LWORK >= (NB+3)*N,
          where NB is the max of the blocksize for SSYTRD and SORMTR
          returned by ILAENV. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (5*N) \n
 * @param[out]	IFAIL	
          IFAIL is INTEGER array, dimension (N) \n
          If JOBZ = 'V', then if INFO = 0, the first M elements of
          IFAIL are zero.  If INFO > 0, then IFAIL contains the
          indices of the eigenvectors that failed to converge. \n
          If JOBZ = 'N', then IFAIL is not referenced. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, then i eigenvectors failed to converge.
                Their indices are stored in array IFAIL. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer syevx(char* jobz, char* range, char* uplo, integer* n, T* a, integer* lda, T* vl, T* vu, integer* il, integer* iu, T* abstol, integer* m, T* w, T* z, integer* ldz, T* work, integer* lwork, integer* iwork, integer* ifail, integer* info)
{
  return syevx(jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, iwork, ifail, info);
}

/*! @brief SYGV_2STAGE  computes all the eigenvalues, the eigenvectors \n
     of a real generalized symmetric-definite eigenproblem
 * @details
 * \b Purpose:
    \verbatim
     SYGV_2STAGE computes all the eigenvalues, and optionally, the eigenvectors
     of a real generalized symmetric-definite eigenproblem, of the form
     A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.
     Here A and B are assumed to be symmetric and B is also
     positive definite.
     This routine use the 2stage technique for the reduction to tridiagonal
     which showed higher performance on recent architecture and for large
     sizes N>2000.
    \endverbatim 

 * @param[in] ITYPE
          ITYPE is INTEGER \n
          Specifies the problem type to be solved: \n
          = 1:  A*x = (lambda)*B*x \n
          = 2:  A*B*x = (lambda)*x \n
          = 3:  B*A*x = (lambda)*x \n
 * @param[in] JOBZ
          JOBZ is CHARACTER*1 \n
          = 'N':  Compute eigenvalues only; \n
          = 'V':  Compute eigenvalues and eigenvectors.
                  Not available in this release. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangles of A and B are stored; \n
          = 'L':  Lower triangles of A and B are stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrices A and B.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA, N) \n
          On entry, the symmetric matrix A.  If UPLO = 'U', the
          leading N-by-N upper triangular part of A contains the
          upper triangular part of the matrix A.  If UPLO = 'L',
          the leading N-by-N lower triangular part of A contains
          the lower triangular part of the matrix A. \n
 \n
          On exit, if JOBZ = 'V', then if INFO = 0, A contains the
          matrix Z of eigenvectors.  The eigenvectors are normalized
          as follows: \n
          if ITYPE = 1 or 2, Z**T*B*Z = I; \n
          if ITYPE = 3, Z**T*inv(B)*Z = I. \n
          If JOBZ = 'N', then on exit the upper triangle (if UPLO='U')
          or the lower triangle (if UPLO='L') of A, including the
          diagonal, is destroyed. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in,out] B
          B is REAL array, dimension (LDB, N) \n
          On entry, the symmetric positive definite matrix B.
          If UPLO = 'U', the leading N-by-N upper triangular part of B
          contains the upper triangular part of the matrix B.
          If UPLO = 'L', the leading N-by-N lower triangular part of B
          contains the lower triangular part of the matrix B. \n
 \n
          On exit, if INFO <= N, the part of B containing the matrix is
          overwritten by the triangular factor U or L from the Cholesky
          factorization B = U**T*U or B = L*L**T. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out] W
          W is REAL array, dimension (N) \n
          If INFO = 0, the eigenvalues in ascending order. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The length of the array WORK. LWORK >= 1, when N <= 1; \n
          otherwise   \n
          If JOBZ = 'N' and N > 1, LWORK must be queried.
                                   LWORK = MAX(1, dimension) where
                                   dimension = max(stage1,stage2) + (KD+1)*N + 2*N
                                             = N*KD + N*max(KD+1,FACTOPTNB) 
                                               + max(2*KD*KD, KD*NTHREADS) 
                                               + (KD+1)*N + 2*N
                                   where KD is the blocking size of the reduction,
                                   FACTOPTNB is the blocking used by the QR or LQ
                                   algorithm, usually FACTOPTNB=128 is a good choice
                                   NTHREADS is the number of threads used when
                                   openMP compilation is enabled, otherwise =1. \n
          If JOBZ = 'V' and N > 1, LWORK must be queried. Not yet available \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  SPOTRF or SSYEV returned an error code: \n
             <= N:  if INFO = i, SSYEV failed to converge;
                    i off-diagonal elements of an intermediate
                    tridiagonal form did not converge to zero; \n
             > N:   if INFO = N + i, for 1 <= i <= N, then the leading
                    minor of order i of B is not positive definite.
                    The factorization of B could not be completed and
                    no eigenvalues or eigenvectors were computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sygv_2stage(integer* itype, char* jobz, char* uplo, integer* n, T* a, integer* lda, T* b, integer* ldb, T* w, T* work, integer* lwork, integer* info)
{
  return sygv_2stage(itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, info);
}

/*! @brief SYGV  computes all the eigenvalues, the eigenvectors \n
     of a real generalized symmetric-definite eigenproblem
 * @details
 * \b Purpose:
    \verbatim
     SYGV computes all the eigenvalues, and optionally, the eigenvectors
     of a real generalized symmetric-definite eigenproblem, of the form
     A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.
     Here A and B are assumed to be symmetric and B is also
     positive definite.
    \endverbatim 

 * @param[in] ITYPE
          ITYPE is INTEGER \n
          Specifies the problem type to be solved: \n
          = 1:  A*x = (lambda)*B*x \n
          = 2:  A*B*x = (lambda)*x \n
          = 3:  B*A*x = (lambda)*x \n
 * @param[in] JOBZ
          JOBZ is CHARACTER*1 \n
          = 'N':  Compute eigenvalues only; \n
          = 'V':  Compute eigenvalues and eigenvectors. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangles of A and B are stored; \n
          = 'L':  Lower triangles of A and B are stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrices A and B.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA, N) \n
          On entry, the symmetric matrix A.  If UPLO = 'U', the
          leading N-by-N upper triangular part of A contains the
          upper triangular part of the matrix A.  If UPLO = 'L',
          the leading N-by-N lower triangular part of A contains
          the lower triangular part of the matrix A. \n
 \n
          On exit, if JOBZ = 'V', then if INFO = 0, A contains the
          matrix Z of eigenvectors.  The eigenvectors are normalized
          as follows: \n
          if ITYPE = 1 or 2, Z**T*B*Z = I; \n
          if ITYPE = 3, Z**T*inv(B)*Z = I. \n
          If JOBZ = 'N', then on exit the upper triangle (if UPLO='U')
          or the lower triangle (if UPLO='L') of A, including the
          diagonal, is destroyed. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in,out] B
          B is REAL array, dimension (LDB, N) \n
          On entry, the symmetric positive definite matrix B. \n
          If UPLO = 'U', the leading N-by-N upper triangular part of B
          contains the upper triangular part of the matrix B. \n
          If UPLO = 'L', the leading N-by-N lower triangular part of B
          contains the lower triangular part of the matrix B. \n
 \n
          On exit, if INFO <= N, the part of B containing the matrix is
          overwritten by the triangular factor U or L from the Cholesky
          factorization B = U**T*U or B = L*L**T. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out] W
          W is REAL array, dimension (N) \n
          If INFO = 0, the eigenvalues in ascending order. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The length of the array WORK.  LWORK >= max(1,3*N-1).
          For optimal efficiency, LWORK >= (NB+2)*N,
          where NB is the blocksize for SSYTRD returned by ILAENV. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  SPOTRF or SSYEV returned an error code: \n
             <= N:  if INFO = i, SSYEV failed to converge;
                    i off-diagonal elements of an intermediate
                    tridiagonal form did not converge to zero; \n
             > N:   if INFO = N + i, for 1 <= i <= N, then the leading
                    minor of order i of B is not positive definite.
                    The factorization of B could not be completed and
                    no eigenvalues or eigenvectors were computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sygv(integer* itype, char* jobz, char* uplo, integer* n, T* a, integer* lda, T* b, integer* ldb, T* w, T* work, integer* lwork, integer* info)
{
  return sygv(itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, info);
}

/*! @brief SYGVD  computes all the eigenvalues, the eigenvectors \n
     of a real generalized symmetric-definite eigenproblem
 * @details
 * \b Purpose:
    \verbatim
     SYGVD computes all the eigenvalues, and optionally, the eigenvectors
     of a real generalized symmetric-definite eigenproblem, of the form
     A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and
     B are assumed to be symmetric and B is also positive definite.
     If eigenvectors are desired, it uses a divide and conquer algorithm.

     The divide and conquer algorithm makes very mild assumptions about
     floating point arithmetic. It will work on machines with a guard
     digit in add/subtract, or on those binary machines without guard
     digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
     Cray-2. It could conceivably fail on hexadecimal or decimal machines
     without guard digits, but we know of none.
    \endverbatim 

 * @param[in] ITYPE
          ITYPE is INTEGER \n
          Specifies the problem type to be solved: \n
          = 1:  A*x = (lambda)*B*x \n
          = 2:  A*B*x = (lambda)*x \n
          = 3:  B*A*x = (lambda)*x \n
 * @param[in] JOBZ
          JOBZ is CHARACTER*1 \n
          = 'N':  Compute eigenvalues only; \n
          = 'V':  Compute eigenvalues and eigenvectors. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangles of A and B are stored; \n
          = 'L':  Lower triangles of A and B are stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrices A and B.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA, N) \n
          On entry, the symmetric matrix A.  If UPLO = 'U', the
          leading N-by-N upper triangular part of A contains the
          upper triangular part of the matrix A.  If UPLO = 'L',
          the leading N-by-N lower triangular part of A contains
          the lower triangular part of the matrix A. \n
 \n
          On exit, if JOBZ = 'V', then if INFO = 0, A contains the
          matrix Z of eigenvectors.  The eigenvectors are normalized
          as follows: \n
          if ITYPE = 1 or 2, Z**T*B*Z = I; \n
          if ITYPE = 3, Z**T*inv(B)*Z = I. \n
          If JOBZ = 'N', then on exit the upper triangle (if UPLO='U')
          or the lower triangle (if UPLO='L') of A, including the
          diagonal, is destroyed. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in,out] B
          B is REAL array, dimension (LDB, N) \n
          On entry, the symmetric matrix B.  If UPLO = 'U', the
          leading N-by-N upper triangular part of B contains the
          upper triangular part of the matrix B.  If UPLO = 'L',
          the leading N-by-N lower triangular part of B contains
          the lower triangular part of the matrix B. \n
 \n
          On exit, if INFO <= N, the part of B containing the matrix is
          overwritten by the triangular factor U or L from the Cholesky
          factorization B = U**T*U or B = L*L**T. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out] W
          W is REAL array, dimension (N) \n
          If INFO = 0, the eigenvalues in ascending order.
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK. \n
          If N <= 1,               LWORK >= 1. \n
          If JOBZ = 'N' and N > 1, LWORK >= 2*N+1. \n
          If JOBZ = 'V' and N > 1, LWORK >= 1 + 6*N + 2*N**2. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal sizes of the WORK and IWORK
          arrays, returns these values as the first entries of the WORK
          and IWORK arrays, and no error message related to LWORK or
          LIWORK is issued by XERBLA. \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (MAX(1,LIWORK)) \n
          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK. \n
 * @param[in]	LIWORK	
          LIWORK is INTEGER \n
          The dimension of the array IWORK. \n
          If N <= 1,                LIWORK >= 1. \n
          If JOBZ  = 'N' and N > 1, LIWORK >= 1. \n
          If JOBZ  = 'V' and N > 1, LIWORK >= 3 + 5*N. \n
 \n
          If LIWORK = -1, then a workspace query is assumed; the
          routine only calculates the optimal sizes of the WORK and
          IWORK arrays, returns these values as the first entries of
          the WORK and IWORK arrays, and no error message related to
          LWORK or LIWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  SPOTRF or SSYEVD returned an error code: \n
             <= N:  if INFO = i and JOBZ = 'N', then the algorithm
                    failed to converge; i off-diagonal elements of an
                    intermediate tridiagonal form did not converge to
                    zero;
                    if INFO = i and JOBZ = 'V', then the algorithm
                    failed to compute an eigenvalue while working on
                    the submatrix lying in rows and columns INFO/(N+1)
                    through mod(INFO,N+1); \n
             > N:   if INFO = N + i, for 1 <= i <= N, then the leading
                    minor of order i of B is not positive definite.
                    The factorization of B could not be completed and
                    no eigenvalues or eigenvectors were computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sygvd(integer* itype, char* jobz, char* uplo, integer* n, T* a, integer* lda, T* b, integer* ldb, T* w, T* work, integer* lwork, integer* iwork, integer* liwork, integer* info)
{
  return sygvd(itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, iwork, liwork, info);
}

/*! @brief SYGVX computes selected eigenvalues, the eigenvectors \n
     of a real generalized symmetric-definite eigenproblem
 * @details
 * \b Purpose:
    \verbatim
     SYGVX computes selected eigenvalues, and optionally, eigenvectors
     of a real generalized symmetric-definite eigenproblem, of the form
     A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A
     and B are assumed to be symmetric and B is also positive definite.
     Eigenvalues and eigenvectors can be selected by specifying either a
     range of values or a range of indices for the desired eigenvalues.
    \endverbatim 

 * @param[in] ITYPE
          ITYPE is INTEGER \n
          Specifies the problem type to be solved: \n
          = 1:  A*x = (lambda)*B*x \n
          = 2:  A*B*x = (lambda)*x \n
          = 3:  B*A*x = (lambda)*x \n
 * @param[in] JOBZ
          JOBZ is CHARACTER*1 \n
          = 'N':  Compute eigenvalues only; \n
          = 'V':  Compute eigenvalues and eigenvectors. \n
 * @param[in] RANGE
          RANGE is CHARACTER*1 \n
          = 'A': all eigenvalues will be found. \n
          = 'V': all eigenvalues in the half-open interval (VL,VU]
                 will be found. \n
          = 'I': the IL-th through IU-th eigenvalues will be found. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A and B are stored; \n
          = 'L':  Lower triangle of A and B are stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix pencil (A,B).  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA, N) \n
          On entry, the symmetric matrix A.  If UPLO = 'U', the
          leading N-by-N upper triangular part of A contains the
          upper triangular part of the matrix A.  If UPLO = 'L',
          the leading N-by-N lower triangular part of A contains
          the lower triangular part of the matrix A. \n
 \n
          On exit, the lower triangle (if UPLO='L') or the upper
          triangle (if UPLO='U') of A, including the diagonal, is
          destroyed. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in,out] B
          B is REAL array, dimension (LDB, N) \n
          On entry, the symmetric matrix B.  If UPLO = 'U', the
          leading N-by-N upper triangular part of B contains the
          upper triangular part of the matrix B.  If UPLO = 'L',
          the leading N-by-N lower triangular part of B contains
          the lower triangular part of the matrix B. \n
 \n
          On exit, if INFO <= N, the part of B containing the matrix is
          overwritten by the triangular factor U or L from the Cholesky
          factorization B = U**T*U or B = L*L**T. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[in] VL
          VL is REAL \n
          If RANGE='V', the lower bound of the interval to
          be searched for eigenvalues. VL < VU. \n
          Not referenced if RANGE = 'A' or 'I'. \n
 * @param[in] VU
          VU is REAL \n
          If RANGE='V', the upper bound of the interval to
          be searched for eigenvalues. VL < VU. \n
          Not referenced if RANGE = 'A' or 'I'. \n
 * @param[in] IL
          IL is INTEGER \n
          If RANGE='I', the index of the
          smallest eigenvalue to be returned. \n
          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0. \n
          Not referenced if RANGE = 'A' or 'V'. \n
 * @param[in] IU
          IU is INTEGER \n
          If RANGE='I', the index of the
          largest eigenvalue to be returned. \n
          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0. \n
          Not referenced if RANGE = 'A' or 'V'. \n
 * @param[in] ABSTOL
          ABSTOL is REAL \n
          The absolute error tolerance for the eigenvalues.
          An approximate eigenvalue is accepted as converged
          when it is determined to lie in an interval [a,b]
          of width less than or equal to \n
 \n
                  ABSTOL + EPS *   max( |a|,|b|) , \n
 \n
          where EPS is the machine precision.  If ABSTOL is less than
          or equal to zero, then  EPS*|T|  will be used in its place,
          where |T| is the 1-norm of the tridiagonal matrix obtained
          by reducing C to tridiagonal form, where C is the symmetric
          matrix of the standard symmetric problem to which the
          generalized problem is transformed. \n
 \n
          Eigenvalues will be computed most accurately when ABSTOL is
          set to twice the underflow threshold 2*DLAMCH('S'), not zero.
          If this routine returns with INFO>0, indicating that some
          eigenvectors did not converge, try setting ABSTOL to
          2*SLAMCH('S'). \n
 * @param[out] M
          M is INTEGER \n
          The total number of eigenvalues found.  0 <= M <= N.
          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1. \n
 * @param[out] W
          W is REAL array, dimension (N) \n
          On normal exit, the first M elements contain the selected
          eigenvalues in ascending order. \n
 * @param[out] Z
          Z is REAL array, dimension (LDZ, max(1,M)) \n
          If JOBZ = 'N', then Z is not referenced. \n
          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
          contain the orthonormal eigenvectors of the matrix A
          corresponding to the selected eigenvalues, with the i-th
          column of Z holding the eigenvector associated with W(i). \n
          The eigenvectors are normalized as follows: \n
          if ITYPE = 1 or 2, Z**T*B*Z = I; \n
          if ITYPE = 3, Z**T*inv(B)*Z = I. \n
 \n
          If an eigenvector fails to converge, then that column of Z
          contains the latest approximation to the eigenvector, and the
          index of the eigenvector is returned in IFAIL. \n
          Note: the user must ensure that at least max(1,M) columns are
          supplied in the array Z; if RANGE = 'V', the exact value of M
          is not known in advance and an upper bound must be used. \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of the array Z.  LDZ >= 1, and if
          JOBZ = 'V', LDZ >= max(1,N). \n
 * @param[out] IFAIL
          IFAIL is INTEGER array, dimension (N) \n
          If JOBZ = 'V', then if INFO = 0, the first M elements of
          IFAIL are zero.  If INFO > 0, then IFAIL contains the
          indices of the eigenvectors that failed to converge. \n
          If JOBZ = 'N', then IFAIL is not referenced. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The length of the array WORK.  LWORK >= max(1,8*N). \n
          For optimal efficiency, LWORK >= (NB+3)*N,
          where NB is the blocksize for SSYTRD returned by ILAENV. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (5*N) \n
 * @param[out]	IFAIL	
          IFAIL is INTEGER array, dimension (N) \n
          If JOBZ = 'V', then if INFO = 0, the first M elements of
          IFAIL are zero.  If INFO > 0, then IFAIL contains the
          indices of the eigenvectors that failed to converge. \n
          If JOBZ = 'N', then IFAIL is not referenced. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  SPOTRF or SSYEVX returned an error code: \n
             <= N:  if INFO = i, SSYEVX failed to converge;
                    i eigenvectors failed to converge.  Their indices
                    are stored in array IFAIL. \n
             > N:   if INFO = N + i, for 1 <= i <= N, then the leading
                    minor of order i of B is not positive definite.
                    The factorization of B could not be completed and
                    no eigenvalues or eigenvectors were computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sygvx(integer* itype, char* jobz, char* range, char* uplo, integer* n, T* a, integer* lda, T* b, integer* ldb, T* vl, T* vu, integer* il, integer* iu, T* abstol, integer* m, T* w, T* z, integer* ldz, T* work, integer* lwork, integer* iwork, integer* ifail, integer* info)
{
  return sygvx(itype, jobz, range, uplo, n, a, lda, b, ldb, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, iwork, ifail, info);
}

/*! @brief SYRFS improves the computed solution to a system of linear equations

 * @details
 * \b Purpose:
    \verbatim
     SYRFS improves the computed solution to a system of linear
     equations when the coefficient matrix is symmetric indefinite, and
     provides error bounds and backward error estimates for the solution.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrices B and X.  NRHS >= 0. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          The symmetric matrix A.  If UPLO = 'U', the leading N-by-N
          upper triangular part of A contains the upper triangular part
          of the matrix A, and the strictly lower triangular part of A
          is not referenced.  If UPLO = 'L', the leading N-by-N lower
          triangular part of A contains the lower triangular part of
          the matrix A, and the strictly upper triangular part of A is
          not referenced. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] AF
          AF is REAL array, dimension (LDAF,N) \n
          The factored form of the matrix A.  AF contains the block
          diagonal matrix D and the multipliers used to obtain the
          factor U or L from the factorization A = U*D*U**T or
          A = L*D*L**T as computed by SSYTRF. \n
 * @param[in] LDAF
          LDAF is INTEGER \n
          The leading dimension of the array AF.  LDAF >= max(1,N). \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D
          as determined by SSYTRF. \n
 * @param[in] B
          B is REAL array, dimension (LDB,NRHS) \n
          The right hand side matrix B. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[in,out] X
          X is REAL array, dimension (LDX,NRHS) \n
          On entry, the solution matrix X, as computed by SSYTRS.
          On exit, the improved solution matrix X. \n
 * @param[in] LDX
          LDX is INTEGER \n
          The leading dimension of the array X.  LDX >= max(1,N). \n
 * @param[out] FERR
          FERR is REAL array, dimension (NRHS) \n
          The estimated forward error bound for each solution vector
          X(j) (the j-th column of the solution matrix X).
          If XTRUE is the true solution corresponding to X(j), FERR(j)
          is an estimated upper bound for the magnitude of the largest
          element in (X(j) - XTRUE) divided by the magnitude of the
          largest element in X(j).  The estimate is as reliable as
          the estimate for RCOND, and is almost always a slight
          overestimate of the true error. \n
 * @param[out] BERR
          BERR is REAL array, dimension (NRHS) \n
          The componentwise relative backward error of each solution
          vector X(j) (i.e., the smallest relative change in
          any element of A or B that makes X(j) an exact solution). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (3*N) \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer syrfs(char* uplo, integer* n, integer* nrhs,  T* a, integer* lda,  T* af, integer* ldaf,  integer* ipiv,  T* b, integer* ldb, T* x, integer* ldx, T* ferr, T* berr, T* work, integer* iwork, integer* info)
{
  return syrfs(uplo, n, nrhs,  a, lda,  af, ldaf,  ipiv,  b, ldb, x, ldx, ferr, berr, work, iwork, info);
}
template< typename T, typename Ta >
integer syrfs(char* uplo, integer* n, integer* nrhs,  T* a, integer* lda,  T* af, integer* ldaf,  integer* ipiv,  T* b, integer* ldb, T* x, integer* ldx, Ta* ferr, Ta* berr, T* work, Ta* rwork, integer* info)
{
  return syrfs(uplo, n, nrhs,  a, lda,  af, ldaf,  ipiv,  b, ldb, x, ldx, ferr, berr, work, rwork, info);
}

/*! @brief SYRFSX improves the computed solution to a system of linear equations

 * @details
 * \b Purpose:
    \verbatim
    SYRFSX improves the computed solution to a system of linear
    equations when the coefficient matrix is symmetric indefinite, and
    provides error bounds and backward error estimates for the
    solution.  In addition to normwise error bound, the code provides
    maximum componentwise error bound if possible.  See comments for
    ERR_BNDS_NORM and ERR_BNDS_COMP for details of the error bounds.

    The original system of linear equations may have been equilibrated
    before calling this routine, as described by arguments EQUED and S
    below. In this case, the solution and error bounds returned are
    for the original unequilibrated system.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] EQUED
          EQUED is CHARACTER*1 \n
          Specifies the form of equilibration that was done to A
          before calling this routine. This is needed to compute
          the solution and error bounds correctly. \n
            = 'N':  No equilibration \n
            = 'Y':  Both row and column equilibration, i.e., A has been
                    replaced by diag(S) * A * diag(S).
                    The right hand side B has been changed accordingly. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrices B and X.  NRHS >= 0. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          The symmetric matrix A.  If UPLO = 'U', the leading N-by-N
          upper triangular part of A contains the upper triangular
          part of the matrix A, and the strictly lower triangular
          part of A is not referenced.  If UPLO = 'L', the leading
          N-by-N lower triangular part of A contains the lower
          triangular part of the matrix A, and the strictly upper
          triangular part of A is not referenced. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] AF
          AF is REAL array, dimension (LDAF,N) \n
          The factored form of the matrix A.  AF contains the block
          diagonal matrix D and the multipliers used to obtain the
          factor U or L from the factorization A = U*D*U**T or A =
          L*D*L**T as computed by SSYTRF. \n
 * @param[in] LDAF
          LDAF is INTEGER \n
          The leading dimension of the array AF.  LDAF >= max(1,N). \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D
          as determined by SSYTRF. \n
 * @param[in,out] S
          S is REAL array, dimension (N) \n
          The scale factors for A.  If EQUED = 'Y', A is multiplied on
          the left and right by diag(S).  S is an input argument if FACT =
          'F'; otherwise, S is an output argument.  If FACT = 'F' and EQUED
          = 'Y', each element of S must be positive.  If S is output, each
          element of S is a power of the radix. If S is input, each element
          of S should be a power of the radix to ensure a reliable solution
          and error estimates. Scaling by powers of the radix does not cause
          rounding errors unless the result underflows or overflows.
          Rounding errors during scaling lead to refining with a matrix that
          is not equivalent to the input matrix, producing error estimates
          that may not be reliable. \n
 * @param[in] B
          B is REAL array, dimension (LDB,NRHS) \n
          The right hand side matrix B. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[in,out] X
          X is REAL array, dimension (LDX,NRHS) \n
          On entry, the solution matrix X, as computed by SGETRS.
          On exit, the improved solution matrix X. \n
 * @param[in] LDX
          LDX is INTEGER \n
          The leading dimension of the array X.  LDX >= max(1,N). \n
 * @param[out] RCOND
          RCOND is REAL \n
          Reciprocal scaled condition number.  This is an estimate of the
          reciprocal Skeel condition number of the matrix A after
          equilibration (if done).  If this is less than the machine
          precision (in particular, if it is zero), the matrix is singular
          to working precision.  Note that the error may still be small even
          if this number is very small and the matrix appears ill-
          conditioned. \n
 * @param[out] BERR
          BERR is REAL array, dimension (NRHS) \n
          Componentwise relative backward error.  This is the
          componentwise relative backward error of each solution vector X(j)
          (i.e., the smallest relative change in any element of A or B that
          makes X(j) an exact solution). \n
 * @param[in] N_ERR_BNDS
          N_ERR_BNDS is INTEGER \n
          Number of error bounds to return for each right hand side
          and each type (normwise or componentwise).  See ERR_BNDS_NORM and
          ERR_BNDS_COMP below. \n
 * @param[out] ERR_BNDS_NORM
          ERR_BNDS_NORM is REAL array, dimension (NRHS, N_ERR_BNDS) \n
          For each right-hand side, this array contains information about
          various error bounds and condition numbers corresponding to the
          normwise relative error, which is defined as follows: \n
 \n
          Normwise relative error in the ith solution vector: \n
                 max_j (abs(XTRUE(j,i) - X(j,i))) \n
                ------------------------------ \n
                      max_j abs(X(j,i)) \n
 \n
          The array is indexed by the type of error information as described
          below. There currently are up to three pieces of information
          returned. \n
 \n
          The first index in ERR_BNDS_NORM(i,:) corresponds to the ith
          right-hand side. \n
 \n
          The second index in ERR_BNDS_NORM(:,err) contains the following
          three fields: \n
          err = 1 "Trust/don't trust" boolean. Trust the answer if the
                  reciprocal condition number is less than the threshold
                  sqrt(n) * slamch('Epsilon'). \n
 \n
          err = 2 "Guaranteed" error bound: The estimated forward error,
                  almost certainly within a factor of 10 of the true error
                  so long as the next entry is greater than the threshold
                  sqrt(n) * slamch('Epsilon'). This error bound should only
                  be trusted if the previous boolean is true. \n
 \n
          err = 3  Reciprocal condition number: Estimated normwise
                  reciprocal condition number.  Compared with the threshold
                  sqrt(n) * slamch('Epsilon') to determine if the error
                  estimate is "guaranteed". These reciprocal condition
                  numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
                  appropriately scaled matrix Z.
                  Let Z = S*A, where S scales each row by a power of the
                  radix so all absolute row sums of Z are approximately 1. \n
 \n
          See Lapack Working Note 165 for further details and extra
          cautions. \n
 * @param[out] ERR_BNDS_COMP
          ERR_BNDS_COMP is REAL array, dimension (NRHS, N_ERR_BNDS) \n
          For each right-hand side, this array contains information about
          various error bounds and condition numbers corresponding to the
          componentwise relative error, which is defined as follows: \n
 \n
          Componentwise relative error in the ith solution vector: \n
                        abs(XTRUE(j,i) - X(j,i)) \n
                 max_j ---------------------- \n
                             abs(X(j,i)) \n
 \n
          The array is indexed by the right-hand side i (on which the
          componentwise relative error depends), and the type of error
          information as described below. There currently are up to three
          pieces of information returned for each right-hand side. If
          componentwise accuracy is not requested (PARAMS(3) = 0.0), then
          ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS < 3, then at most
          the first (:,N_ERR_BNDS) entries are returned. \n
 \n
          The first index in ERR_BNDS_COMP(i,:) corresponds to the ith
          right-hand side. \n
 \n
          The second index in ERR_BNDS_COMP(:,err) contains the following
          three fields: \n
          err = 1 "Trust/don't trust" boolean. Trust the answer if the
                  reciprocal condition number is less than the threshold
                  sqrt(n) * slamch('Epsilon'). \n
 \n
          err = 2 "Guaranteed" error bound: The estimated forward error,
                  almost certainly within a factor of 10 of the true error
                  so long as the next entry is greater than the threshold
                  sqrt(n) * slamch('Epsilon'). This error bound should only
                  be trusted if the previous boolean is true. \n
 \n
          err = 3  Reciprocal condition number: Estimated componentwise
                  reciprocal condition number.  Compared with the threshold
                  sqrt(n) * slamch('Epsilon') to determine if the error
                  estimate is "guaranteed". These reciprocal condition
                  numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
                  appropriately scaled matrix Z.
                  Let Z = S*(A*diag(x)), where x is the solution for the
                  current right-hand side and S scales each row of
                  A*diag(x) by a power of the radix so all absolute row
                  sums of Z are approximately 1. \n
 \n
          See Lapack Working Note 165 for further details and extra
          cautions. \n
 * @param[in] NPARAMS
          NPARAMS is INTEGER \n
          Specifies the number of parameters set in PARAMS.  If <= 0, the
          PARAMS array is never referenced and default values are used. \n
 * @param[in,out] PARAMS
          PARAMS is REAL array, dimension NPARAMS \n
          Specifies algorithm parameters.  If an entry is < 0.0, then
          that entry will be filled with default value used for that
          parameter.  Only positions up to NPARAMS are accessed; defaults
          are used for higher-numbered parameters. \n
 \n
          PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative
              refinement or not. \n
           Default: 1.0 \n
              = 0.0:  No refinement is performed, and no error bounds are
                      computed. \n
              = 1.0:  Use the double-precision refinement algorithm,
                      possibly with doubled-single computations if the
                      compilation environment does not support DOUBLE
                      PRECISION. \n
                (other values are reserved for future use) \n
 \n
          PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual
              computations allowed for refinement. \n
           Default: 10 \n
           Aggressive: Set to 100 to permit convergence using approximate
                       factorizations or factorizations other than LU. If
                       the factorization uses a technique other than
                       Gaussian elimination, the guarantees in
                       err_bnds_norm and err_bnds_comp may no longer be
                       trustworthy. \n
 \n
          PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code
              will attempt to find a solution with small componentwise
              relative error in the double-precision algorithm.  Positive
              is true, 0.0 is false. \n
           Default: 1.0 (attempt componentwise convergence) \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (4*N) \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
           = 0:  Successful exit. The solution to every right-hand side is
             guaranteed. \n
           < 0:  If INFO = -i, the i-th argument had an illegal value \n
           > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization
             has been completed, but the factor U is exactly singular, so
             the solution and error bounds could not be computed. RCOND = 0
             is returned. \n
           = N+J: The solution corresponding to the Jth right-hand side is
             not guaranteed. The solutions corresponding to other right-
             hand sides K with K > J may not be guaranteed as well, but
             only the first such right-hand side is reported. If a small
             componentwise error is not requested (PARAMS(3) = 0.0) then
             the Jth right-hand side is the first with a normwise error
             bound that is not guaranteed (the smallest J such
             that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)
             the Jth right-hand side is the first with either a normwise or
             componentwise error bound that is not guaranteed (the smallest
             J such that either ERR_BNDS_NORM(J,1) = 0.0 or
             ERR_BNDS_COMP(J,1) = 0.0). See the definition of
             ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information
             about all of the right-hand sides check ERR_BNDS_NORM or
             ERR_BNDS_COMP. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer syrfsx(char* uplo, char* equed, integer* n, integer* nrhs, T* a, integer* lda, T* af, integer* ldaf, integer* ipiv, T* s, T* b, integer* ldb, T* x, integer* ldx, T* rcond, T* berr, integer* n_err_bnds, T* err_bnds_norm, T* err_bnds_comp, integer* nparams, T* params, T* work, integer* iwork, integer* info)
{
  return syrfsx(uplo, equed, n, nrhs, a, lda,  af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info);
}
template< typename T, typename Ta >
integer syrfsx(char* uplo, char* equed, integer* n, integer* nrhs, T* a, integer* lda, T* af, integer* ldaf, integer* ipiv, Ta* s, T* b, integer* ldb, T* x, integer* ldx, Ta* rcond, Ta* berr, integer* n_err_bnds, Ta* err_bnds_norm, Ta* err_bnds_comp, integer* nparams, Ta* params, T* work, Ta* rwork, integer* info)
{
  return syrfsx(uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info);
}

/*! @brief SYSV_AA_2STAGE computes the solution to system of linear equations A * X = B for SY matrices

 * @details
 * \b Purpose:
    \verbatim
     SYSV_AA_2STAGE computes the solution to a real system of
     linear equations
        A * X = B,
     where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     matrices.

     Aasen's 2-stage algorithm is used to factor A as
        A = U**T * T * U,  if UPLO = 'U', or
        A = L * T * L**T,  if UPLO = 'L',
     where U (or L) is a product of permutation and unit upper (lower)
     triangular matrices, and T is symmetric and band. The matrix T is
     then LU-factored with partial pivoting. The factored form of A
     is then used to solve the system of equations A * X = B.

     This is the blocked version of the algorithm, calling Level 3 BLAS.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
          N-by-N upper triangular part of A contains the upper
          triangular part of the matrix A, and the strictly lower
          triangular part of A is not referenced.  If UPLO = 'L', the
          leading N-by-N lower triangular part of A contains the lower
          triangular part of the matrix A, and the strictly upper
          triangular part of A is not referenced. \n
 \n
          On exit, L is stored below (or above) the subdiaonal blocks,
          when UPLO  is 'L' (or 'U'). \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] TB
          TB is REAL array, dimension (LTB) \n
          On exit, details of the LU factorization of the band matrix. \n
 * @param[in] LTB
          LTB is INTEGER \n
          The size of the array TB. LTB >= 4*N, internally
          used to select NB such that LTB >= (3*NB+1)*N. \n
 \n
          If LTB = -1, then a workspace query is assumed; the
          routine only calculates the optimal size of LTB, 
          returns this value as the first entry of TB, and
          no error message related to LTB is issued by XERBLA. \n
 * @param[out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          On exit, it contains the details of the interchanges, i.e.,
          the row and column k of A were interchanged with the
          row and column IPIV(k). \n
 * @param[out] IPIV2
          IPIV2 is INTEGER array, dimension (N) \n
          On exit, it contains the details of the interchanges, i.e.,
          the row and column k of T were interchanged with the
          row and column IPIV(k). \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,NRHS)
          On entry, the right hand side matrix B.
          On exit, the solution matrix X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out]	WORK	
          WORK is REAL workspace of size LWORK \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The size of WORK. LWORK >= N, internally used to select NB
          such that LWORK >= N*NB. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the
          routine only calculates the optimal size of the WORK array,
          returns this value as the first entry of the WORK array, and
          no error message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n
          > 0:  if INFO = i, band LU factorization failed on i-th column \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sysv_aa_2stage(char* uplo, integer* n, integer* nrhs, T* a, integer* lda, T* tb, integer* ltb, integer* ipiv, integer* ipiv2, T* b, integer* ldb, T* work, integer* lwork, integer* info)
{
  return sysv_aa_2stage(uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb, work, lwork, info);
}

/*! @brief SYSV_AA computes the solution to system of linear equations A * X = B for SY matrices

 * @details
 * \b Purpose:
    \verbatim
    SYSV computes the solution to a real system of linear equations
       A * X = B,
    where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
    matrices.

    Aasen's algorithm is used to factor A as
       A = U**T * T * U,  if UPLO = 'U', or
       A = L * T * L**T,  if UPLO = 'L',
    where U (or L) is a product of permutation and unit upper (lower)
    triangular matrices, and T is symmetric tridiagonal. The factored
    form of A is then used to solve the system of equations A * X = B.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
          N-by-N upper triangular part of A contains the upper
          triangular part of the matrix A, and the strictly lower
          triangular part of A is not referenced.  If UPLO = 'L', the
          leading N-by-N lower triangular part of A contains the lower
          triangular part of the matrix A, and the strictly upper
          triangular part of A is not referenced. \n
 \n
          On exit, if INFO = 0, the tridiagonal matrix T and the
          multipliers used to obtain the factor U or L from the
          factorization A = U**T*T*U or A = L*T*L**T as computed by
          SSYTRF. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          On exit, it contains the details of the interchanges, i.e.,
          the row and column k of A were interchanged with the
          row and column IPIV(k). \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,NRHS) \n
          On entry, the N-by-NRHS right hand side matrix B.
          On exit, if INFO = 0, the N-by-NRHS solution matrix X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The length of WORK.  LWORK >= MAX(1,2*N,3*N-2), and for
          the best performance, LWORK >= MAX(1,N*NB), where NB is
          the optimal blocksize for SSYTRF_AA. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n
          > 0: if INFO = i, D(i,i) is exactly zero.  The factorization
               has been completed, but the block diagonal matrix D is
               exactly singular, so the solution could not be computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sysv_aa(char* uplo, integer* n, integer* nrhs, T* a, integer* lda, integer* ipiv, T* b, integer* ldb, T* work, integer* lwork, integer* info)
{
  return sysv_aa(uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork, info);
}

/*! @brief SSYSV_RK computes the solution to system of linear equations A * X = B for SY matrices

 * @details
 * \b Purpose:
    \verbatim
     SYSV_RK computes the solution to a real system of linear
     equations A * X = B, where A is an N-by-N symmetric matrix
     and X and B are N-by-NRHS matrices.

     The bounded Bunch-Kaufman (rook) diagonal pivoting method is used
     to factor A as
        A = P*U*D*(U**T)*(P**T),  if UPLO = 'U', or
        A = P*L*D*(L**T)*(P**T),  if UPLO = 'L',
     where U (or L) is unit upper (or lower) triangular matrix,
     U**T (or L**T) is the transpose of U (or L), P is a permutation
     matrix, P**T is the transpose of P, and D is symmetric and block
     diagonal with 1-by-1 and 2-by-2 diagonal blocks.

     SSYTRF_RK is called to compute the factorization of a real
     symmetric matrix.  The factored form of A is then used to solve
     the system of equations A * X = B by calling BLAS3 routine SYTRS_3.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the upper or lower triangular part of the
          symmetric matrix A is stored: \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the symmetric matrix A. \n
            If UPLO = 'U': the leading N-by-N upper triangular part
            of A contains the upper triangular part of the matrix A,
            and the strictly lower triangular part of A is not
            referenced. \n
 \n
            If UPLO = 'L': the leading N-by-N lower triangular part
            of A contains the lower triangular part of the matrix A,
            and the strictly upper triangular part of A is not
            referenced. \n
 \n
          On exit, if INFO = 0, diagonal of the block diagonal
          matrix D and factors U or L  as computed by SSYTRF_RK: \n
            a) ONLY diagonal elements of the symmetric block diagonal
               matrix D on the diagonal of A, i.e. D(k,k) = A(k,k);
               (superdiagonal (or subdiagonal) elements of D
                are stored on exit in array E), and \n
            b) If UPLO = 'U': factor U in the superdiagonal part of A.
               If UPLO = 'L': factor L in the subdiagonal part of A. \n
 \n
          For more info see the description of DSYTRF_RK routine. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] E
          E is REAL array, dimension (N) \n
          On exit, contains the output computed by the factorization
          routine DSYTRF_RK, i.e. the superdiagonal (or subdiagonal)
          elements of the symmetric block diagonal matrix D
          with 1-by-1 or 2-by-2 diagonal blocks, where \n
          If UPLO = 'U': E(i) = D(i-1,i), i=2:N, E(1) is set to 0; \n
          If UPLO = 'L': E(i) = D(i+1,i), i=1:N-1, E(N) is set to 0. \n
 \n
          NOTE: For 1-by-1 diagonal block D(k), where
          1 <= k <= N, the element E(k) is set to 0 in both
          UPLO = 'U' or UPLO = 'L' cases. \n
 \n
          For more info see the description of DSYTRF_RK routine. \n
 * @param[out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D,
          as determined by SSYTRF_RK. \n
 \n
          For more info see the description of DSYTRF_RK routine. \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,NRHS) \n
          On entry, the N-by-NRHS right hand side matrix B.
          On exit, if INFO = 0, the N-by-NRHS solution matrix X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension ( MAX(1,LWORK) ). \n
          Work array used in the factorization stage.
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The length of WORK.  LWORK >= 1. For best performance
          of factorization stage LWORK >= max(1,N*NB), where NB is
          the optimal blocksize for DSYTRF_RK. \n
 \n
          If LWORK = -1, then a workspace query is assumed;
          the routine only calculates the optimal size of the WORK
          array for factorization stage, returns this value as
          the first entry of the WORK array, and no error message
          related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: If INFO = -k, the k-th argument had an illegal value \n\
          > 0: If INFO = k, the matrix A is singular, because:
                 If UPLO = 'U': column k in the upper
                 triangular part of A contains all zeros.
                 If UPLO = 'L': column k in the lower
                 triangular part of A contains all zeros. \n
 \n
               Therefore D(k,k) is exactly zero, and superdiagonal
               elements of column k of U (or subdiagonal elements of
               column k of L ) are all zeros. The factorization has
               been completed, but the block diagonal matrix D is
               exactly singular, and division by zero will occur if
               it is used to solve a system of equations. \n
 \n
               NOTE: INFO only stores the first occurrence of
               a singularity, any subsequent occurrence of singularity
               is not stored in INFO even though the factorization
               always completes. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sysv_rk(char* uplo, integer* n, integer* nrhs, T* a, integer* lda, T* e, integer* ipiv, T* b, integer* ldb, T* work, integer* lwork, integer* info)
{
  return sysv_rk(uplo, n, nrhs, a, lda, e, ipiv, b, ldb, work, lwork, info);
}

/*! @brief SSYSV_ROOK computes the solution to system of linear equations A * X = B for SY matrices

 * @details
 * \b Purpose:
    \verbatim
     SYSV_ROOK computes the solution to a real system of linear
     equations
        A * X = B,
     where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     matrices.

     The diagonal pivoting method is used to factor A as
        A = U * D * U**T,  if UPLO = 'U', or
        A = L * D * L**T,  if UPLO = 'L',
     where U (or L) is a product of permutation and unit upper (lower)
     triangular matrices, and D is symmetric and block diagonal with
     1-by-1 and 2-by-2 diagonal blocks.

     SSYTRF_ROOK is called to compute the factorization of a real
     symmetric matrix A using the bounded Bunch-Kaufman ("rook") diagonal
     pivoting method.

     The factored form of A is then used to solve the system
     of equations A * X = B by calling SYTRS_ROOK.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
          N-by-N upper triangular part of A contains the upper
          triangular part of the matrix A, and the strictly lower
          triangular part of A is not referenced.  If UPLO = 'L', the
          leading N-by-N lower triangular part of A contains the lower
          triangular part of the matrix A, and the strictly upper
          triangular part of A is not referenced. \n
 \n
          On exit, if INFO = 0, the block diagonal matrix D and the
          multipliers used to obtain the factor U or L from the
          factorization A = U*D*U**T or A = L*D*L**T as computed by
          SSYTRF_ROOK. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D,
          as determined by SSYTRF_ROOK. \n
 \n
          If UPLO = 'U': \n
               If IPIV(k) > 0, then rows and columns k and IPIV(k)
               were interchanged and D(k,k) is a 1-by-1 diagonal block.
 \n
               If IPIV(k) < 0 and IPIV(k-1) < 0, then rows and
               columns k and -IPIV(k) were interchanged and rows and
               columns k-1 and -IPIV(k-1) were inerchaged,
               D(k-1:k,k-1:k) is a 2-by-2 diagonal block. \n
 \n
          If UPLO = 'L': \n
               If IPIV(k) > 0, then rows and columns k and IPIV(k)
               were interchanged and D(k,k) is a 1-by-1 diagonal block.
 \n
               If IPIV(k) < 0 and IPIV(k+1) < 0, then rows and
               columns k and -IPIV(k) were interchanged and rows and
               columns k+1 and -IPIV(k+1) were inerchaged,
               D(k:k+1,k:k+1) is a 2-by-2 diagonal block. \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,NRHS) \n
          On entry, the N-by-NRHS right hand side matrix B. \n
          On exit, if INFO = 0, the N-by-NRHS solution matrix X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The length of WORK.  LWORK >= 1, and for best performance
          LWORK >= max(1,N*NB), where NB is the optimal blocksize for
          SSYTRF_ROOK. \n
 \n
          TRS will be done with Level 2 BLAS \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n
          > 0: if INFO = i, D(i,i) is exactly zero.  The factorization
               has been completed, but the block diagonal matrix D is
               exactly singular, so the solution could not be computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sysv_rook(char* uplo, integer* n, integer* nrhs, T* a, integer* lda, integer* ipiv, T* b, integer* ldb, T* work, integer* lwork, integer* info)
{
  return sysv_rook(uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork, info);
}

/*! @brief SYSV computes the solution to system of linear equations A * X = B for SY matrices

 * @details
 * \b Purpose:
    \verbatim
     SYSV computes the solution to a real system of linear equations
        A * X = B,
     where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     matrices.

     The diagonal pivoting method is used to factor A as
        A = U * D * U**T,  if UPLO = 'U', or
        A = L * D * L**T,  if UPLO = 'L',
     where U (or L) is a product of permutation and unit upper (lower)
     triangular matrices, and D is symmetric and block diagonal with
     1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then
     used to solve the system of equations A * X = B.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
          N-by-N upper triangular part of A contains the upper
          triangular part of the matrix A, and the strictly lower
          triangular part of A is not referenced.  If UPLO = 'L', the
          leading N-by-N lower triangular part of A contains the lower
          triangular part of the matrix A, and the strictly upper
          triangular part of A is not referenced. \n
 \n
          On exit, if INFO = 0, the block diagonal matrix D and the
          multipliers used to obtain the factor U or L from the
          factorization A = U*D*U**T or A = L*D*L**T as computed by
          SSYTRF. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D, as
          determined by SSYTRF.  If IPIV(k) > 0, then rows and columns
          k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1
          diagonal block.  If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0,
          then rows and columns k-1 and -IPIV(k) were interchanged and
          D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = 'L' and
          IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and
          -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2
          diagonal block. \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,NRHS) \n
          On entry, the N-by-NRHS right hand side matrix B.
          On exit, if INFO = 0, the N-by-NRHS solution matrix X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out] WORK
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The length of WORK.  LWORK >= 1, and for best performance
          LWORK >= max(1,N*NB), where NB is the optimal blocksize for
          SSYTRF. \n
          for LWORK < N, TRS will be done with Level BLAS 2 \n
          for LWORK >= N, TRS will be done with Level BLAS 3 \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n
          > 0: if INFO = i, D(i,i) is exactly zero.  The factorization
               has been completed, but the block diagonal matrix D is
               exactly singular, so the solution could not be computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sysv(char* uplo, integer* n, integer* nrhs, T* a, integer* lda, integer* ipiv, T* b, integer* ldb, T* work, integer* lwork, integer* info)
{
  return sysv(uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork, info);
}

/*! @brief SYSVX computes the solution to system of linear equations A * X = B for SY matrices

 * @details
 * \b Purpose:
    \verbatim
     SYSVX uses the diagonal pivoting factorization to compute the
     solution to a real system of linear equations A * X = B,
     where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     matrices.

     Error bounds on the solution and a condition estimate are also
     provided.

     * \b Description:
         ==============
     The following steps are performed:

     1. If FACT = 'N', the diagonal pivoting method is used to factor A.
        The form of the factorization is
           A = U * D * U**T,  if UPLO = 'U', or
           A = L * D * L**T,  if UPLO = 'L',
        where U (or L) is a product of permutation and unit upper (lower)
        triangular matrices, and D is symmetric and block diagonal with
        1-by-1 and 2-by-2 diagonal blocks.

     2. If some D(i,i)=0, so that D is exactly singular, then the routine
        returns with INFO = i. Otherwise, the factored form of A is used
        to estimate the condition number of the matrix A.  If the
        reciprocal of the condition number is less than machine precision,
        INFO = N+1 is returned as a warning, but the routine still goes on
        to solve for X and compute error bounds as described below.

     3. The system of equations is solved for X using the factored form
        of A.

     4. Iterative refinement is applied to improve the computed solution
        matrix and calculate error bounds and backward error estimates
        for it.
     \endverbatim

 * @param[in] FACT
          FACT is CHARACTER*1 \n
          Specifies whether or not the factored form of A has been
          supplied on entry. \n
          = 'F':  On entry, AF and IPIV contain the factored form of
                  A.  AF and IPIV will not be modified. \n
          = 'N':  The matrix A will be copied to AF and factored. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrices B and X.  NRHS >= 0. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          The symmetric matrix A.  If UPLO = 'U', the leading N-by-N
          upper triangular part of A contains the upper triangular part
          of the matrix A, and the strictly lower triangular part of A
          is not referenced.  If UPLO = 'L', the leading N-by-N lower
          triangular part of A contains the lower triangular part of
          the matrix A, and the strictly upper triangular part of A is
          not referenced. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in,out] AF
          AF is REAL array, dimension (LDAF,N) \n
          If FACT = 'F', then AF is an input argument and on entry
          contains the block diagonal matrix D and the multipliers used
          to obtain the factor U or L from the factorization
          A = U*D*U**T or A = L*D*L**T as computed by SSYTRF. \n
 \n
          If FACT = 'N', then AF is an output argument and on exit
          returns the block diagonal matrix D and the multipliers used
          to obtain the factor U or L from the factorization
          A = U*D*U**T or A = L*D*L**T. \n
 * @param[in] LDAF
          LDAF is INTEGER \n
          The leading dimension of the array AF.  LDAF >= max(1,N). \n
 * @param[in,out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          If FACT = 'F', then IPIV is an input argument and on entry
          contains details of the interchanges and the block structure
          of D, as determined by SSYTRF. \n
          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
          interchanged and D(k,k) is a 1-by-1 diagonal block.
          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block. \n
 \n
          If FACT = 'N', then IPIV is an output argument and on exit
          contains details of the interchanges and the block structure
          of D, as determined by SSYTRF. \n
 * @param[in] B
          B is REAL array, dimension (LDB,NRHS) \n
          The N-by-NRHS right hand side matrix B. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out] X
          X is REAL array, dimension (LDX,NRHS) \n
          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X. \n
 * @param[in] LDX
          LDX is INTEGER \n
          The leading dimension of the array X.  LDX >= max(1,N). \n
 * @param[out] RCOND
          RCOND is REAL \n
          The estimate of the reciprocal condition number of the matrix
          A.  If RCOND is less than the machine precision (in
          particular, if RCOND = 0), the matrix is singular to working
          precision.  This condition is indicated by a return code of
          INFO > 0. \n
 * @param[out] FERR
          FERR is REAL array, dimension (NRHS) \n
          The estimated forward error bound for each solution vector
          X(j) (the j-th column of the solution matrix X).
          If XTRUE is the true solution corresponding to X(j), FERR(j)
          is an estimated upper bound for the magnitude of the largest
          element in (X(j) - XTRUE) divided by the magnitude of the
          largest element in X(j).  The estimate is as reliable as
          the estimate for RCOND, and is almost always a slight
          overestimate of the true error. \n
 * @param[out] BERR
          BERR is REAL array, dimension (NRHS) \n
          The componentwise relative backward error of each solution
          vector X(j) (i.e., the smallest relative change in
          any element of A or B that makes X(j) an exact solution). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The length of WORK.  LWORK >= max(1,3*N), and for best
          performance, when FACT = 'N', LWORK >= max(1,3*N,N*NB), where
          NB is the optimal blocksize for SSYTRF. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n
          > 0: if INFO = i, and i is \n
                <= N:  D(i,i) is exactly zero.  The factorization
                       has been completed but the factor D is exactly
                       singular, so the solution and error bounds could
                       not be computed. RCOND = 0 is returned. \n
                = N+1: D is nonsingular, but RCOND is less than machine
                       precision, meaning that the matrix is singular
                       to working precision.  Nevertheless, the
                       solution and error bounds are computed because
                       there are a number of situations where the
                       computed solution can be more accurate than the
                       value of RCOND would suggest. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sysvx(char* fact, char* uplo, integer* n, integer* nrhs,  T* a, integer* lda, T* af, integer* ldaf, integer* ipiv,  T* b, integer* ldb, T* x, integer* ldx, T* rcond, T* ferr, T* berr, T* work, integer* lwork, integer* iwork, integer* info)
{
  return sysvx(fact, uplo, n, nrhs,  a, lda, af, ldaf, ipiv,  b, ldb, x, ldx, rcond, ferr, berr, work, lwork, iwork, info);
}
template< typename T, typename Ta >
integer sysvx(char* fact, char* uplo, integer* n, integer* nrhs,  T* a, integer* lda, T* af, integer* ldaf, integer* ipiv,  T* b, integer* ldb, T* x, integer* ldx, Ta* rcond, Ta* ferr, Ta* berr, T* work, integer* lwork, Ta* rwork, integer* info)
{
  return sysvx(fact, uplo, n, nrhs,  a, lda, af, ldaf, ipiv,  b, ldb, x, ldx, rcond, ferr, berr, work, lwork, rwork, info);
}

/*! @brief  SYSVXX uses the diagonal pivoting factorization to compute the \n
    solution to a real system of linear equations

 * @details
 * \b Purpose:
    \verbatim
    SYSVXX uses the diagonal pivoting factorization to compute the
    solution to a real system of linear equations A * X = B, where A
    is an N-by-N symmetric matrix and X and B are N-by-NRHS matrices.

    If requested, both normwise and maximum componentwise error bounds
    are returned. SSYSVXX will return a solution with a tiny
    guaranteed error (O(eps) where eps is the working machine
    precision) unless the matrix is very ill-conditioned, in which
    case a warning is returned. Relevant condition numbers also are
    calculated and returned.

    SSYSVXX accepts user-provided factorizations and equilibration
    factors; see the definitions of the FACT and EQUED options.
    Solving with refinement and using a factorization from a previous
    SSYSVXX call will also produce a solution with either O(eps)
    errors or warnings, but we cannot make that claim for general
    user-provided factorizations and equilibration factors if they
    differ from what SYSVXX would itself produce.
 
 * \b Description:
      ============
    The following steps are performed:

    1. If FACT = 'E', real scaling factors are computed to equilibrate
    the system:

      diag(S)*A*diag(S)     *inv(diag(S))*X = diag(S)*B

    Whether or not the system will be equilibrated depends on the
    scaling of the matrix A, but if equilibration is used, A is
    overwritten by diag(S)*A*diag(S) and B by diag(S)*B.

    2. If FACT = 'N' or 'E', the LU decomposition is used to factor
    the matrix A (after equilibration if FACT = 'E') as

       A = U * D * U**T,  if UPLO = 'U', or
       A = L * D * L**T,  if UPLO = 'L',

    where U (or L) is a product of permutation and unit upper (lower)
    triangular matrices, and D is symmetric and block diagonal with
    1-by-1 and 2-by-2 diagonal blocks.

    3. If some D(i,i)=0, so that D is exactly singular, then the
    routine returns with INFO = i. Otherwise, the factored form of A
    is used to estimate the condition number of the matrix A (see
    argument RCOND).  If the reciprocal of the condition number is
    less than machine precision, the routine still goes on to solve
    for X and compute error bounds as described below.

    4. The system of equations is solved for X using the factored form
    of A.

    5. By default (unless PARAMS(LA_LINRX_ITREF_I) is set to zero),
    the routine will use iterative refinement to try to get a small
    error and error bounds.  Refinement calculates the residual to at
    least twice the working precision.

    6. If equilibration was used, the matrix X is premultiplied by
    diag(R) so that it solves the original system before
    equilibration.
    \endverbatim

 * @param[in] FACT
          FACT is CHARACTER*1 \n
          Specifies whether or not the factored form of the matrix A is
          supplied on entry, and if not, whether the matrix A should be
          equilibrated before it is factored. \n
           = 'F':  On entry, AF and IPIV contain the factored form of A.
                   If EQUED is not 'N', the matrix A has been
                   equilibrated with scaling factors given by S.
                   A, AF, and IPIV are not modified. \n
           = 'N':  The matrix A will be copied to AF and factored. \n
           = 'E':  The matrix A will be equilibrated if necessary, then
                     copied to AF and factored. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrices B and X.  NRHS >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          The symmetric matrix A.  If UPLO = 'U', the leading N-by-N
          upper triangular part of A contains the upper triangular
          part of the matrix A, and the strictly lower triangular
          part of A is not referenced.  If UPLO = 'L', the leading
          N-by-N lower triangular part of A contains the lower
          triangular part of the matrix A, and the strictly upper
          triangular part of A is not referenced. \n
 \n
          On exit, if FACT = 'E' and EQUED = 'Y', A is overwritten by
          diag(S)*A*diag(S). \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in,out] AF
          AF is REAL array, dimension (LDAF,N) \n
          If FACT = 'F', then AF is an input argument and on entry
          contains the block diagonal matrix D and the multipliers
          used to obtain the factor U or L from the factorization A =
          U*D*U**T or A = L*D*L**T as computed by SSYTRF. \n
 \n
          If FACT = 'N', then AF is an output argument and on exit
          returns the block diagonal matrix D and the multipliers
          used to obtain the factor U or L from the factorization A =
          U*D*U**T or A = L*D*L**T. \n
 * @param[in] LDAF
          LDAF is INTEGER \n
          The leading dimension of the array AF.  LDAF >= max(1,N). \n
 * @param[in,out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          If FACT = 'F', then IPIV is an input argument and on entry
          contains details of the interchanges and the block
          structure of D, as determined by SSYTRF.  If IPIV(k) > 0,
          then rows and columns k and IPIV(k) were interchanged and
          D(k,k) is a 1-by-1 diagonal block.  If UPLO = 'U' and
          IPIV(k) = IPIV(k-1) < 0, then rows and columns k-1 and
          -IPIV(k) were interchanged and D(k-1:k,k-1:k) is a 2-by-2
          diagonal block.  If UPLO = 'L' and IPIV(k) = IPIV(k+1) < 0,
          then rows and columns k+1 and -IPIV(k) were interchanged
          and D(k:k+1,k:k+1) is a 2-by-2 diagonal block. \n
 \n
          If FACT = 'N', then IPIV is an output argument and on exit
          contains details of the interchanges and the block
          structure of D, as determined by SSYTRF. \n
 * @param[in,out] EQUED
          EQUED is CHARACTER*1 \n
          Specifies the form of equilibration that was done. \n
           = 'N':  No equilibration (always true if FACT = 'N'). \n
           = 'Y':  Both row and column equilibration, i.e., A has been
                   replaced by diag(S) * A * diag(S). \n
          EQUED is an input argument if FACT = 'F'; otherwise, it is an
          output argument. \n
 * @param[in,out] S
          S is REAL array, dimension (N) \n
          The scale factors for A.  If EQUED = 'Y', A is multiplied on
          the left and right by diag(S).  S is an input argument if FACT =
          'F'; otherwise, S is an output argument.  If FACT = 'F' and EQUED
          = 'Y', each element of S must be positive.  If S is output, each
          element of S is a power of the radix. If S is input, each element
          of S should be a power of the radix to ensure a reliable solution
          and error estimates. Scaling by powers of the radix does not cause
          rounding errors unless the result underflows or overflows.
          Rounding errors during scaling lead to refining with a matrix that
          is not equivalent to the input matrix, producing error estimates
          that may not be reliable. \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,NRHS) \n
          On entry, the N-by-NRHS right hand side matrix B. \n
          On exit,
          if EQUED = 'N', B is not modified; \n
          if EQUED = 'Y', B is overwritten by diag(S)*B; \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out] X
          X is REAL array, dimension (LDX,NRHS) \n
          If INFO = 0, the N-by-NRHS solution matrix X to the original
          system of equations.  Note that A and B are modified on exit if
          EQUED .ne. 'N', and the solution to the equilibrated system is
          inv(diag(S))*X. \n
 * @param[in] LDX
          LDX is INTEGER \n
          The leading dimension of the array X.  LDX >= max(1,N). \n
 * @param[out] RCOND
          RCOND is REAL \n
          Reciprocal scaled condition number.  This is an estimate of the
          reciprocal Skeel condition number of the matrix A after
          equilibration (if done).  If this is less than the machine
          precision (in particular, if it is zero), the matrix is singular
          to working precision.  Note that the error may still be small even
          if this number is very small and the matrix appears ill-
          conditioned. \n
 * @param[out] RPVGRW
          RPVGRW is REAL \n
          Reciprocal pivot growth.  On exit, this contains the reciprocal
          pivot growth factor norm(A)/norm(U). The "max absolute element"
          norm is used.  If this is much less than 1, then the stability of
          the LU factorization of the (equilibrated) matrix A could be poor.
          This also means that the solution X, estimated condition numbers,
          and error bounds could be unreliable. If factorization fails with
          0<INFO<=N, then this contains the reciprocal pivot growth factor
          for the leading INFO columns of A. \n
 * @param[out] BERR
          BERR is REAL array, dimension (NRHS) \n
          Componentwise relative backward error.  This is the
          componentwise relative backward error of each solution vector X(j)
          (i.e., the smallest relative change in any element of A or B that
          makes X(j) an exact solution). \n
 * @param[in] N_ERR_BNDS
          N_ERR_BNDS is INTEGER \n
          Number of error bounds to return for each right hand side
          and each type (normwise or componentwise).  See ERR_BNDS_NORM and
          ERR_BNDS_COMP below. \n
 * @param[out] ERR_BNDS_NORM
          ERR_BNDS_NORM is REAL array, dimension (NRHS, N_ERR_BNDS)
          For each right-hand side, this array contains information about
          various error bounds and condition numbers corresponding to the
          normwise relative error, which is defined as follows: \n
 \n
          Normwise relative error in the ith solution vector: \n
                 max_j (abs(XTRUE(j,i) - X(j,i))) \n
                ------------------------------ \n
                      max_j abs(X(j,i)) \n
 \n
          The array is indexed by the type of error information as described
          below. There currently are up to three pieces of information
          returned. \n
 \n
          The first index in ERR_BNDS_NORM(i,:) corresponds to the ith
          right-hand side. \n
 \n
          The second index in ERR_BNDS_NORM(:,err) contains the following
          three fields: \n
          err = 1 "Trust/don't trust" boolean. Trust the answer if the
                  reciprocal condition number is less than the threshold
                  sqrt(n) * slamch('Epsilon'). \n
 \n
          err = 2 "Guaranteed" error bound: The estimated forward error,
                  almost certainly within a factor of 10 of the true error
                  so long as the next entry is greater than the threshold
                  sqrt(n) * slamch('Epsilon'). This error bound should only
                  be trusted if the previous boolean is true. \n
 \n
          err = 3  Reciprocal condition number: Estimated normwise
                  reciprocal condition number.  Compared with the threshold
                  sqrt(n) * slamch('Epsilon') to determine if the error
                  estimate is "guaranteed". These reciprocal condition
                  numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
                  appropriately scaled matrix Z.
                  Let Z = S*A, where S scales each row by a power of the
                  radix so all absolute row sums of Z are approximately 1. \n
 \n
          See Lapack Working Note 165 for further details and extra
          cautions. \n
 * @param[out] ERR_BNDS_COMP
          ERR_BNDS_COMP is REAL array, dimension (NRHS, N_ERR_BNDS)
          For each right-hand side, this array contains information about
          various error bounds and condition numbers corresponding to the
          componentwise relative error, which is defined as follows: \n
 \n
          Componentwise relative error in the ith solution vector: \n
                        abs(XTRUE(j,i) - X(j,i)) \n
                 max_j ---------------------- \n
                             abs(X(j,i)) \n
 \n
          The array is indexed by the right-hand side i (on which the
          componentwise relative error depends), and the type of error
          information as described below. There currently are up to three
          pieces of information returned for each right-hand side. If
          componentwise accuracy is not requested (PARAMS(3) = 0.0), then
          ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS < 3, then at most
          the first (:,N_ERR_BNDS) entries are returned. \n
 \n
          The first index in ERR_BNDS_COMP(i,:) corresponds to the ith
          right-hand side. \n
 \n
          The second index in ERR_BNDS_COMP(:,err) contains the following
          three fields: \n
          err = 1 "Trust/don't trust" boolean. Trust the answer if the
                  reciprocal condition number is less than the threshold
                  sqrt(n) * slamch('Epsilon'). \n
 \n
          err = 2 "Guaranteed" error bound: The estimated forward error,
                  almost certainly within a factor of 10 of the true error
                  so long as the next entry is greater than the threshold
                  sqrt(n) * slamch('Epsilon'). This error bound should only
                  be trusted if the previous boolean is true. \n
 \n
          err = 3  Reciprocal condition number: Estimated componentwise
                  reciprocal condition number.  Compared with the threshold
                  sqrt(n) * slamch('Epsilon') to determine if the error
                  estimate is "guaranteed". These reciprocal condition
                  numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
                  appropriately scaled matrix Z.
                  Let Z = S*(A*diag(x)), where x is the solution for the
                  current right-hand side and S scales each row of
                  A*diag(x) by a power of the radix so all absolute row
                  sums of Z are approximately 1. \n
 \n
          See Lapack Working Note 165 for further details and extra
          cautions. \n
 * @param[in] NPARAMS
          NPARAMS is INTEGER \n
          Specifies the number of parameters set in PARAMS.  If <= 0, the
          PARAMS array is never referenced and default values are used. \n
 * @param[in,out] PARAMS
          PARAMS is REAL array, dimension NPARAMS \n
          Specifies algorithm parameters.  If an entry is < 0.0, then
          that entry will be filled with default value used for that
          parameter.  Only positions up to NPARAMS are accessed; defaults
          are used for higher-numbered parameters. \n
 \n
           PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative
                refinement or not. \n
             Default: 1.0 \n
                = 0.0:  No refinement is performed, and no error bounds are
                        computed. \n
                = 1.0:  Use the double-precision refinement algorithm,
                        possibly with doubled-single computations if the
                        compilation environment does not support DOUBLE
                        PRECISION. \n
                  (other values are reserved for future use) \n
 \n
           PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual
                computations allowed for refinement. \n
             Default: 10 \n
             Aggressive: Set to 100 to permit convergence using approximate
                         factorizations or factorizations other than LU. If
                         the factorization uses a technique other than
                         Gaussian elimination, the guarantees in
                         err_bnds_norm and err_bnds_comp may no longer be
                         trustworthy. \n
 \n
           PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code
                will attempt to find a solution with small componentwise
                relative error in the double-precision algorithm.  Positive
                is true, 0.0 is false. \n
             Default: 1.0 (attempt componentwise convergence) \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (4*N) \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  Successful exit. The solution to every right-hand side is
           guaranteed. \n
          < 0:  If INFO = -i, the i-th argument had an illegal value \n
          > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization
           has been completed, but the factor U is exactly singular, so
           the solution and error bounds could not be computed. RCOND = 0
           is returned. \n
          = N+J: The solution corresponding to the Jth right-hand side is
           not guaranteed. The solutions corresponding to other right-
           hand sides K with K > J may not be guaranteed as well, but
           only the first such right-hand side is reported. If a small
           componentwise error is not requested (PARAMS(3) = 0.0) then
           the Jth right-hand side is the first with a normwise error
           bound that is not guaranteed (the smallest J such
           that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)
           the Jth right-hand side is the first with either a normwise or
           componentwise error bound that is not guaranteed (the smallest
           J such that either ERR_BNDS_NORM(J,1) = 0.0 or
           ERR_BNDS_COMP(J,1) = 0.0). See the definition of
           ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information
           about all of the right-hand sides check ERR_BNDS_NORM or
           ERR_BNDS_COMP. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T > 
integer sysvxx(char* fact, char* uplo, integer* n, integer* nrhs, T* a, integer* lda, T* af, integer* ldaf, integer* ipiv, char* equed, T* s, T* b, integer* ldb, T* x, integer* ldx, T* rcond, T* rpvgrw, T* berr, integer* n_err_bnds, T* err_bnds_norm, T* err_bnds_comp, integer* nparams, T* params, T* work, integer* iwork, integer* info)
{
  return sysvxx(fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info);
}
template< typename T, typename Ta > 
integer sysvxx(char* fact, char* uplo, integer* n, integer* nrhs, T* a, integer* lda, T* af, integer* ldaf, integer* ipiv, char* equed, Ta* s, T* b, integer* ldb, T* x, integer* ldx, Ta* rcond, Ta* rpvgrw, Ta* berr, integer* n_err_bnds, Ta* err_bnds_norm, Ta* err_bnds_comp, integer* nparams, Ta* params, T* work, Ta* rwork, integer* info)
{
  return sysvxx(fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info);
}

/*! @brief  SYSWAPR applies an elementary permutation on the rows and columns of a symmetric matrix.

 * @details
 * \b Purpose:
    \verbatim
     SYSWAPR applies an elementary permutation on the rows and the columns of
     a symmetric matrix.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the details of the factorization are stored
          as an upper or lower triangular matrix. \n
          = 'U':  Upper triangular, form is A = U*D*U**T; \n
          = 'L':  Lower triangular, form is A = L*D*L**T. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the NB diagonal matrix D and the multipliers
          used to obtain the factor U or L as computed by SSYTRF. \n
 \n
          On exit, if INFO = 0, the (symmetric) inverse of the original
          matrix.  If UPLO = 'U', the upper triangular part of the
          inverse is formed and the part of A below the diagonal is not
          referenced; if UPLO = 'L' the lower triangular part of the
          inverse is formed and the part of A above the diagonal is
          not referenced. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] I1
          I1 is INTEGER \n
          Index of the first row to swap \n
 * @param[in] I2
          I2 is INTEGER \n
          Index of the second row to swap \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer syswapr(char* uplo, integer* n, T* a, integer* lda, integer* i1, integer* i2)
{
  return syswapr(uplo, n, a, lda, i1, i2);
}

/*! @brief  SYTRF_AA_2STAGE computes the factorization of a real symmetric matrix A using the Aasen's algorithm

 * @details
 * \b Purpose:
    \verbatim
     SYTRF_AA_2STAGE computes the factorization of a real symmetric matrix A
     using the Aasen's algorithm.  The form of the factorization is

        A = U**T*T*U  or  A = L*T*L**T

     where U (or L) is a product of permutation and unit upper (lower)
     triangular matrices, and T is a symmetric band matrix with the
     bandwidth of NB (NB is internally selected and stored in TB( 1), and T is 
     LU factorized with partial pivoting).

     This is the blocked version of the algorithm, calling Level 3 BLAS.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
          N-by-N upper triangular part of A contains the upper
          triangular part of the matrix A, and the strictly lower
          triangular part of A is not referenced.  If UPLO = 'L', the
          leading N-by-N lower triangular part of A contains the lower
          triangular part of the matrix A, and the strictly upper
          triangular part of A is not referenced. \n
 \n
          On exit, L is stored below (or above) the subdiaonal blocks,
          when UPLO  is 'L' (or 'U'). \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] TB
          TB is REAL array, dimension (LTB) \n
          On exit, details of the LU factorization of the band matrix. \n
 * @param[in] LTB
          LTB is INTEGER \n
          The size of the array TB. LTB >= 4*N, internally
          used to select NB such that LTB >= (3*NB+1)*N. \n
 \n
          If LTB = -1, then a workspace query is assumed; the
          routine only calculates the optimal size of LTB, 
          returns this value as the first entry of TB, and
          no error message related to LTB is issued by XERBLA. \n
 * @param[out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          On exit, it contains the details of the interchanges, i.e.,
          the row and column k of A were interchanged with the
          row and column IPIV(k). \n
 * @param[out] IPIV2
          IPIV2 is INTEGER array, dimension (N) \n
          On exit, it contains the details of the interchanges, i.e.,
          the row and column k of T were interchanged with the
          row and column IPIV(k). \n
 * @param[out]	WORK	
          WORK is REAL workspace of size LWORK \n
 * @param[in]	LWORK	
          LWORK is INTEGER
          The size of WORK. LWORK >= N, internally used to select NB
          such that LWORK >= N*NB. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the
          routine only calculates the optimal size of the WORK array,
          returns this value as the first entry of the WORK array, and
          no error message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n
          > 0:  if INFO = i, band LU factorization failed on i-th column \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sytrf_aa_2stage(char* uplo, integer* n, T* a, integer* lda, T* tb, integer* ltb, integer* ipiv, integer* ipiv2, T* work, integer* lwork, integer* info)
{
  return sytrf_aa_2stage(uplo, n, a, lda, tb, ltb, ipiv, ipiv2, work, lwork, info);
}

/*! @brief SYTRF_AA computes the factorization of a real symmetric matrix A using the Aasen's algorithm

 * @details
 * \b Purpose:
    \verbatim
     SYTRF_AA computes the factorization of a real symmetric matrix A
     using the Aasen's algorithm.  The form of the factorization is

        A = U**T*T*U  or  A = L*T*L**T

     where U (or L) is a product of permutation and unit upper (lower)
     triangular matrices, and T is a symmetric tridiagonal matrix.

     This is the blocked version of the algorithm, calling Level 3 BLAS.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
          N-by-N upper triangular part of A contains the upper
          triangular part of the matrix A, and the strictly lower
          triangular part of A is not referenced.  If UPLO = 'L', the
          leading N-by-N lower triangular part of A contains the lower
          triangular part of the matrix A, and the strictly upper
          triangular part of A is not referenced. \n
 \n
          On exit, the tridiagonal matrix is stored in the diagonals
          and the subdiagonals of A just below (or above) the diagonals,
          and L is stored below (or above) the subdiaonals, when UPLO
          is 'L' (or 'U'). \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          On exit, it contains the details of the interchanges, i.e.,
          the row and column k of A were interchanged with the
          row and column IPIV(k). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The length of WORK.  LWORK >= MAX(1,2*N). For optimum performance
          LWORK >= N*(1+NB), where NB is the optimal blocksize. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sytrf_aa(char* uplo, integer* n, T* a, integer* lda, integer* ipiv, T* work, integer* lwork, integer* info)
{
  return sytrf_aa(uplo, n, a, lda, ipiv, work, lwork, info);
}

/*! @brief SYTRF_RK computes the factorization of a real symmetric indefinite matrix \n
     using the bounded Bunch-Kaufman (rook) diagonal pivoting method (BLAS3 blocked algorithm).
 * @details
 * \b Purpose:
    \verbatim
     SYTRF_RK computes the factorization of a real symmetric matrix A
     using the bounded Bunch-Kaufman (rook) diagonal pivoting method:

        A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),

     where U (or L) is unit upper (or lower) triangular matrix,
     U**T (or L**T) is the transpose of U (or L), P is a permutation
     matrix, P**T is the transpose of P, and D is symmetric and block
     diagonal with 1-by-1 and 2-by-2 diagonal blocks.

     This is the blocked version of the algorithm, calling Level 3 BLAS.
     For more information see Further Details section.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the upper or lower triangular part of the
          symmetric matrix A is stored: \n
          = 'U':  Upper triangular \n
          = 'L':  Lower triangular \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the symmetric matrix A. \n
            If UPLO = 'U': the leading N-by-N upper triangular part
            of A contains the upper triangular part of the matrix A,
            and the strictly lower triangular part of A is not
            referenced. \n
 \n
            If UPLO = 'L': the leading N-by-N lower triangular part
            of A contains the lower triangular part of the matrix A,
            and the strictly upper triangular part of A is not
            referenced. \n
 \n
          On exit, contains: \n
            a) ONLY diagonal elements of the symmetric block diagonal
               matrix D on the diagonal of A, i.e. D(k,k) = A(k,k);
               (superdiagonal (or subdiagonal) elements of D
                are stored on exit in array E), and \n
            b) If UPLO = 'U': factor U in the superdiagonal part of A.
               If UPLO = 'L': factor L in the subdiagonal part of A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] E
          E is REAL array, dimension (N) \n
          On exit, contains the superdiagonal (or subdiagonal)
          elements of the symmetric block diagonal matrix D
          with 1-by-1 or 2-by-2 diagonal blocks, where \n
          If UPLO = 'U': E(i) = D(i-1,i), i=2:N, E(1) is set to 0; \n
          If UPLO = 'L': E(i) = D(i+1,i), i=1:N-1, E(N) is set to 0. \n
 \n
          NOTE: For 1-by-1 diagonal block D(k), where
          1 <= k <= N, the element E(k) is set to 0 in both
          UPLO = 'U' or UPLO = 'L' cases. \n
 * @param[out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          IPIV describes the permutation matrix P in the factorization
          of matrix A as follows. The absolute value of IPIV(k)
          represents the index of row and column that were
          interchanged with the k-th row and column. The value of UPLO
          describes the order in which the interchanges were applied.
          Also, the sign of IPIV represents the block structure of
          the symmetric block diagonal matrix D with 1-by-1 or 2-by-2
          diagonal blocks which correspond to 1 or 2 interchanges
          at each factorization step. For more info see Further
          Details section. \n
 \n
          If UPLO = 'U',
          ( in factorization order, k decreases from N to 1): \n
            a) A single positive entry IPIV(k) > 0 means:
               D(k,k) is a 1-by-1 diagonal block.
               If IPIV(k) != k, rows and columns k and IPIV(k) were
               interchanged in the matrix A(1:N,1:N);
               If IPIV(k) = k, no interchange occurred. \n
 \n
            b) A pair of consecutive negative entries
               IPIV(k) < 0 and IPIV(k-1) < 0 means:
               D(k-1:k,k-1:k) is a 2-by-2 diagonal block.
               (NOTE: negative entries in IPIV appear ONLY in pairs). \n
               1) If -IPIV(k) != k, rows and columns
                  k and -IPIV(k) were interchanged
                  in the matrix A(1:N,1:N).
                  If -IPIV(k) = k, no interchange occurred. \n
               2) If -IPIV(k-1) != k-1, rows and columns
                  k-1 and -IPIV(k-1) were interchanged
                  in the matrix A(1:N,1:N).
                  If -IPIV(k-1) = k-1, no interchange occurred. \n
 \n
            c) In both cases a) and b), always ABS( IPIV(k)) <= k. \n
 \n
            d) NOTE: Any entry IPIV(k) is always NONZERO on output. \n
 \n
          If UPLO = 'L',
          ( in factorization order, k increases from 1 to N): \n
            a) A single positive entry IPIV(k) > 0 means:
               D(k,k) is a 1-by-1 diagonal block.
               If IPIV(k) != k, rows and columns k and IPIV(k) were
               interchanged in the matrix A(1:N,1:N).
               If IPIV(k) = k, no interchange occurred. \n
 \n
            b) A pair of consecutive negative entries
               IPIV(k) < 0 and IPIV(k+1) < 0 means:
               D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
               (NOTE: negative entries in IPIV appear ONLY in pairs). \n
               1) If -IPIV(k) != k, rows and columns
                  k and -IPIV(k) were interchanged
                  in the matrix A(1:N,1:N).
                  If -IPIV(k) = k, no interchange occurred. \n
               2) If -IPIV(k+1) != k+1, rows and columns
                  k-1 and -IPIV(k-1) were interchanged
                  in the matrix A(1:N,1:N).
                  If -IPIV(k+1) = k+1, no interchange occurred. \n
 \n
            c) In both cases a) and b), always ABS( IPIV(k)) >= k. \n
 \n
            d) NOTE: Any entry IPIV(k) is always NONZERO on output. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension ( MAX(1,LWORK) ). \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The length of WORK.  LWORK >=1.  For best performance
          LWORK >= N*NB, where NB is the block size returned
          by ILAENV. \n
 \n
          If LWORK = -1, then a workspace query is assumed;
          the routine only calculates the optimal size of the WORK
          array, returns this value as the first entry of the WORK
          array, and no error message related to LWORK is issued
          by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: If INFO = -k, the k-th argument had an illegal value \n
          > 0: If INFO = k, the matrix A is singular, because:
                 If UPLO = 'U': column k in the upper
                 triangular part of A contains all zeros.
                 If UPLO = 'L': column k in the lower
                 triangular part of A contains all zeros. \n
 \n
               Therefore D(k,k) is exactly zero, and superdiagonal
               elements of column k of U (or subdiagonal elements of
               column k of L ) are all zeros. The factorization has
               been completed, but the block diagonal matrix D is
               exactly singular, and division by zero will occur if
               it is used to solve a system of equations. \n
 \n
               NOTE: INFO only stores the first occurrence of
               a singularity, any subsequent occurrence of singularity
               is not stored in INFO even though the factorization
               always completes. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sytrf_rk(char* uplo, integer* n, T* a, integer* lda, T* e, integer* ipiv, T* work, integer* lwork, integer* info)
{
  return sytrf_rk(uplo, n, a, lda, e, ipiv, work, lwork, info);
}

/*! @brief SYTRF_ROOK computes the factorization of a real symmetric matrix A \n
     using the bounded Bunch-Kaufman ("rook") diagonal pivoting method.
 * @details
 * \b Purpose:
    \verbatim
     SYTRF_ROOK computes the factorization of a real symmetric matrix A
     using the bounded Bunch-Kaufman ("rook") diagonal pivoting method.
     The form of the factorization is

        A = U*D*U**T  or  A = L*D*L**T

     where U (or L) is a product of permutation and unit upper (lower)
     triangular matrices, and D is symmetric and block diagonal with
     1-by-1 and 2-by-2 diagonal blocks.

     This is the blocked version of the algorithm, calling Level 3 BLAS.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
          N-by-N upper triangular part of A contains the upper
          triangular part of the matrix A, and the strictly lower
          triangular part of A is not referenced.  If UPLO = 'L', the
          leading N-by-N lower triangular part of A contains the lower
          triangular part of the matrix A, and the strictly upper
          triangular part of A is not referenced. \n
 \n
          On exit, the block diagonal matrix D and the multipliers used
          to obtain the factor U or L (see below for further details). \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D. \n
 \n
          If UPLO = 'U': \n
               If IPIV(k) > 0, then rows and columns k and IPIV(k)
               were interchanged and D(k,k) is a 1-by-1 diagonal block. \n
 \n
               If IPIV(k) < 0 and IPIV(k-1) < 0, then rows and
               columns k and -IPIV(k) were interchanged and rows and
               columns k-1 and -IPIV(k-1) were inerchaged,
               D(k-1:k,k-1:k) is a 2-by-2 diagonal block. \n
 \n
          If UPLO = 'L': \n
               If IPIV(k) > 0, then rows and columns k and IPIV(k)
               were interchanged and D(k,k) is a 1-by-1 diagonal block. \n
 \n
               If IPIV(k) < 0 and IPIV(k+1) < 0, then rows and
               columns k and -IPIV(k) were interchanged and rows and
               columns k+1 and -IPIV(k+1) were inerchaged,
               D(k:k+1,k:k+1) is a 2-by-2 diagonal block. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)). \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The length of WORK.  LWORK >=1.  For best performance
          LWORK >= N*NB, where NB is the block size returned by ILAENV. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization
                has been completed, but the block diagonal matrix D is
                exactly singular, and division by zero will occur if it
                is used to solve a system of equations. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sytrf_rook(char* uplo, integer* n, T* a, integer* lda, integer* ipiv, T* work, integer* lwork, integer* info)
{
  return sytrf_rook(uplo, n, a, lda, ipiv, work, lwork, info);
}

/*! @brief SYTRF computes the factorization of a real symmetric matrix A \n
     using the Bunch-Kaufman diagonal pivoting method
 * @details
 * \b Purpose:
    \verbatim
     SYTRF computes the factorization of a real symmetric matrix A using
     the Bunch-Kaufman diagonal pivoting method.  The form of the
     factorization is

        A = U**T*D*U  or  A = L*D*L**T

     where U (or L) is a product of permutation and unit upper (lower)
     triangular matrices, and D is symmetric and block diagonal with
     1-by-1 and 2-by-2 diagonal blocks.

     This is the blocked version of the algorithm, calling Level 3 BLAS.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
          N-by-N upper triangular part of A contains the upper
          triangular part of the matrix A, and the strictly lower
          triangular part of A is not referenced.  If UPLO = 'L', the
          leading N-by-N lower triangular part of A contains the lower
          triangular part of the matrix A, and the strictly upper
          triangular part of A is not referenced. \n
 \n
          On exit, the block diagonal matrix D and the multipliers used
          to obtain the factor U or L (see below for further details). \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D.
          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
          interchanged and D(k,k) is a 1-by-1 diagonal block. \n
          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The length of WORK.  LWORK >=1.  For best performance
          LWORK >= N*NB, where NB is the block size returned by ILAENV. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization
                has been completed, but the block diagonal matrix D is
                exactly singular, and division by zero will occur if it
                is used to solve a system of equations. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sytrf(char* uplo, integer* n, T* a, integer* lda, integer* ipiv, T* work, integer* lwork, integer* info)
{
  return sytrf(uplo, n, a, lda, ipiv, work, lwork, info);
}

/*! @brief SYTRI_3 computes the inverse of a real symmetric indefinite  \n
     matrix A using the factorization computed by SYTRF_RK or SYTRF_BK
 * @details
 * \b Purpose:
    \verbatim
     SYTRI_3 computes the inverse of a real symmetric indefinite
     matrix A using the factorization computed by SYTRF_RK or SYTRF_BK:

         A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),

     where U (or L) is unit upper (or lower) triangular matrix,
     U**T (or L**T) is the transpose of U (or L), P is a permutation
     matrix, P**T is the transpose of P, and D is symmetric and block
     diagonal with 1-by-1 and 2-by-2 diagonal blocks.

     SYTRI_3 sets the leading dimension of the workspace  before calling
     SYTRI_3X that actually computes the inverse.  This is the blocked
     version of the algorithm, calling Level 3 BLAS.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the details of the factorization are
          stored as an upper or lower triangular matrix. \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, diagonal of the block diagonal matrix D and
          factors U or L as computed by SSYTRF_RK and SSYTRF_BK: \n
            a) ONLY diagonal elements of the symmetric block diagonal
               matrix D on the diagonal of A, i.e. D(k,k) = A(k,k);
               (superdiagonal (or subdiagonal) elements of D
                should be provided on entry in array E), and \n
            b) If UPLO = 'U': factor U in the superdiagonal part of A.
               If UPLO = 'L': factor L in the subdiagonal part of A. \n
 \n
          On exit, if INFO = 0, the symmetric inverse of the original
          matrix. \n
             If UPLO = 'U': the upper triangular part of the inverse
             is formed and the part of A below the diagonal is not
             referenced; \n
             If UPLO = 'L': the lower triangular part of the inverse
             is formed and the part of A above the diagonal is not
             referenced. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] E
          E is REAL array, dimension (N) \n
          On entry, contains the superdiagonal (or subdiagonal)
          elements of the symmetric block diagonal matrix D
          with 1-by-1 or 2-by-2 diagonal blocks, where \n
          If UPLO = 'U': E(i) = D(i-1,i),i=2:N, E(1) not referenced; \n
          If UPLO = 'L': E(i) = D(i+1,i),i=1:N-1, E(N) not referenced. \n
 \n
          NOTE: For 1-by-1 diagonal block D(k), where
          1 <= k <= N, the element E(k) is not referenced in both
          UPLO = 'U' or UPLO = 'L' cases. \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D
          as determined by SSYTRF_RK or SSYTRF_BK. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (N+NB+1)*(NB+3). \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The length of WORK. LWORK >= (N+NB+1)*(NB+3). \n
 \n
          If LDWORK = -1, then a workspace query is assumed;
          the routine only calculates the optimal size of the optimal
          size of the WORK array, returns this value as the first
          entry of the WORK array, and no error message related to
          LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n
          > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its
               inverse could not be computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sytri_3(char* uplo, integer* n, T* a, integer* lda,  T* e,  integer* ipiv, T* work, integer* lwork, integer* info)
{
  return sytri_3(uplo, n, a, lda, e, ipiv, work, lwork, info);
}

/*! @brief SYTRI computes the inverse of a real symmetric indefinite matrix A \n
    using the factorization A = U*D*U**T or A = L*D*L**T computed by SYTRF
 * @details
 * \b Purpose:
    \verbatim    
    SYTRI computes the inverse of a real symmetric indefinite matrix
    A using the factorization A = U*D*U**T or A = L*D*L**T computed by
    SYTRF.
    \endverbatim 
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the details of the factorization are stored
          as an upper or lower triangular matrix. \n
          = 'U':  Upper triangular, form is A = U*D*U**T; \n
          = 'L':  Lower triangular, form is A = L*D*L**T. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the block diagonal matrix D and the multipliers
          used to obtain the factor U or L as computed by SSYTRF. \n
 \n
          On exit, if INFO = 0, the (symmetric) inverse of the original
          matrix.  If UPLO = 'U', the upper triangular part of the
          inverse is formed and the part of A below the diagonal is not
          referenced; if UPLO = 'L' the lower triangular part of the
          inverse is formed and the part of A above the diagonal is
          not referenced. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D
          as determined by SYTRF. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n
          > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its
               inverse could not be computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sytri(char* uplo, integer* n, T* a, integer* lda,  integer* ipiv, T* work, integer* info)
{
  return sytri(uplo, n, a, lda, ipiv, work, info);
}

/*! @brief SYTRI2 computes the inverse of a REAL symmetric indefinite matrix \n
     A using the factorization
 * @details
 * \b Purpose:
    \verbatim    
     SYTRI2 computes the inverse of a REAL symmetric indefinite matrix
     A using the factorization A = U*D*U**T or A = L*D*L**T computed by
     SYTRF. SYTRI2 sets the LEADING DIMENSION of the workspace
     before calling SYTRI2X that actually computes the inverse.
    \endverbatim     

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the details of the factorization are stored
          as an upper or lower triangular matrix. \n
          = 'U':  Upper triangular, form is A = U*D*U**T; \n
          = 'L':  Lower triangular, form is A = L*D*L**T. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the block diagonal matrix D and the multipliers
          used to obtain the factor U or L as computed by SSYTRF. \n
 \n
          On exit, if INFO = 0, the (symmetric) inverse of the original
          matrix.  If UPLO = 'U', the upper triangular part of the
          inverse is formed and the part of A below the diagonal is not
          referenced; if UPLO = 'L' the lower triangular part of the
          inverse is formed and the part of A above the diagonal is
          not referenced. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D
          as determined by SYTRF. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (N+NB+1)*(NB+3) \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK.
          WORK is size >= (N+NB+1)*(NB+3) \n
          If LWORK = -1, then a workspace query is assumed; the routine
           calculates: \n
              - the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, \n
              - and no error message related to LWORK is issued by XERBLA.
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n
          > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its
               inverse could not be computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sytri2(char* uplo, integer* n, T* a, integer* lda,  integer* ipiv, T* work, integer* lwork, integer* info)
{
  return sytri2(uplo, n, a, lda, ipiv, work, lwork, info);
}

/*! @brief SYTRI2X computes the inverse of a real symmetric indefinite matrix
     A using the factorization A = U*D*U**T or A = L*D*L**T computed by
     SYTRF.
 * @details
 * \b Purpose:
    \verbatim 
     SYTRI2X computes the inverse of a real symmetric indefinite matrix
     A using the factorization A = U*D*U**T or A = L*D*L**T computed by
     SYTRF.
    \endverbatim

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the details of the factorization are stored
          as an upper or lower triangular matrix. \n
          = 'U':  Upper triangular, form is A = U*D*U**T; \n
          = 'L':  Lower triangular, form is A = L*D*L**T. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the NNB diagonal matrix D and the multipliers
          used to obtain the factor U or L as computed by SSYTRF. \n
 \n
          On exit, if INFO = 0, the (symmetric) inverse of the original
          matrix.  If UPLO = 'U', the upper triangular part of the
          inverse is formed and the part of A below the diagonal is not
          referenced; if UPLO = 'L' the lower triangular part of the
          inverse is formed and the part of A above the diagonal is
          not referenced. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the NNB structure of D
          as determined by SYTRF. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n
          > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its
               inverse could not be computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sytri2x(char* uplo, integer* n, T* a, integer* lda,  integer* ipiv, float* work, integer* nb, integer* info)
{
  return sytri2x(uplo, n, a, lda, ipiv, work, nb, info);
}

/*! @brief SYTRS_3 solves a system of linear equations A * X = B with a real \n
     symmetric matrix A
 * @details
 * \b Purpose:
    \verbatim 
     SYTRS_3 solves a system of linear equations A * X = B with a real
     symmetric matrix A using the factorization computed
     by SSYTRF_RK or SSYTRF_BK:

        A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),

     where U (or L) is unit upper (or lower) triangular matrix,
     U**T (or L**T) is the transpose of U (or L), P is a permutation
     matrix, P**T is the transpose of P, and D is symmetric and block
     diagonal with 1-by-1 and 2-by-2 diagonal blocks.

     This algorithm is using Level 3 BLAS.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the details of the factorization are
          stored as an upper or lower triangular matrix: \n
          = 'U':  Upper triangular, form is A = P*U*D*(U**T)*(P**T); \n
          = 'L':  Lower triangular, form is A = P*L*D*(L**T)*(P**T). \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          Diagonal of the block diagonal matrix D and factors U or L
          as computed by SSYTRF_RK and SSYTRF_BK: \n
            a) ONLY diagonal elements of the symmetric block diagonal
               matrix D on the diagonal of A, i.e. D(k,k) = A(k,k);
               (superdiagonal (or subdiagonal) elements of D
                should be provided on entry in array E), and \n
            b) If UPLO = 'U': factor U in the superdiagonal part of A.
               If UPLO = 'L': factor L in the subdiagonal part of A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] E
          E is REAL array, dimension (N) \n
          On entry, contains the superdiagonal (or subdiagonal)
          elements of the symmetric block diagonal matrix D
          with 1-by-1 or 2-by-2 diagonal blocks, where \n
          If UPLO = 'U': E(i) = D(i-1,i),i=2:N, E(1) not referenced; \n
          If UPLO = 'L': E(i) = D(i+1,i),i=1:N-1, E(N) not referenced. \n
 \n
          NOTE: For 1-by-1 diagonal block D(k), where
          1 <= k <= N, the element E(k) is not referenced in both
          UPLO = 'U' or UPLO = 'L' cases. \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D
          as determined by SSYTRF_RK or SSYTRF_BK. \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,NRHS) \n
          On entry, the right hand side matrix B.
          On exit, the solution matrix X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sytrs_3(char* uplo, integer* n, integer* nrhs,  T* a, integer* lda,  T* e,  integer* ipiv, T* b, integer* ldb, integer* info)
{
  return sytrs_3(uplo, n, nrhs, a, lda, e, ipiv, b, ldb, info);
}

/*! @brief SYTRS_AA_2STAGE solves a system of linear equations A*X = B with a real \n
     symmetric matrix A
 * @details
 * \b Purpose:
    \verbatim 
     SYTRS_AA_2STAGE solves a system of linear equations A*X = B with a real
     symmetric matrix A using the factorization A = U**T*T*U or
     A = L*T*L**T computed by SYTRF_AA_2STAGE.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the details of the factorization are stored
          as an upper or lower triangular matrix. \n
          = 'U':  Upper triangular, form is A = U**T*T*U; \n
          = 'L':  Lower triangular, form is A = L*T*L**T. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          Details of factors computed by SSYTRF_AA_2STAGE. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] TB
          TB is REAL array, dimension (LTB) \n
          Details of factors computed by SSYTRF_AA_2STAGE. \n
 * @param[in] LTB
          LTB is INTEGER \n
          The size of the array TB. LTB >= 4*N. \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges as computed by
          SSYTRF_AA_2STAGE. \n
 * @param[in] IPIV2
          IPIV2 is INTEGER array, dimension (N) \n
          Details of the interchanges as computed by
          SSYTRF_AA_2STAGE. \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,NRHS) \n
          On entry, the right hand side matrix B.
          On exit, the solution matrix X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sytrs_aa_2stage(char* uplo, integer* n, integer* nrhs, T* a, integer* lda, T* tb, integer* ltb, integer* ipiv, integer* ipiv2, T* b, integer* ldb, integer* info)
{
  return sytrs_aa_2stage(uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb, info);
}

/*! @brief SYTRS_AA solves a system of linear equations A*X = B with a real  \n
     symmetric matrix A
 * @details
 * \b Purpose:
    \verbatim 
     SYTRS_AA solves a system of linear equations A*X = B with a real
     symmetric matrix A using the factorization A = U**T*T*U or
     A = L*T*L**T computed by SYTRF_AA.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the details of the factorization are stored
          as an upper or lower triangular matrix. \n
          = 'U':  Upper triangular, form is A = U**T*T*U; \n
          = 'L':  Lower triangular, form is A = L*T*L**T. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          Details of factors computed by SSYTRF_AA. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges as computed by SSYTRF_AA. \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,NRHS) \n
          On entry, the right hand side matrix B.
          On exit, the solution matrix X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK. LWORK >= max(1,3*N-2). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sytrs_aa(char* uplo, integer* n, integer* nrhs,  T* a, integer* lda,  integer* ipiv, T* b, integer* ldb, T* work, integer* lwork, integer* info)
{
  return sytrs_aa(uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork, info);
}

/*! @brief SYTRS_ROOK solves a system of linear equations A*X = B with a \n
    real symmetric matrix A
 * @details
 * \b Purpose:
    \verbatim 
     SYTRS_ROOK solves a system of linear equations A*X = B with
     a real symmetric matrix A using the factorization A = U*D*U**T or
     A = L*D*L**T computed by SYTRF_ROOK.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the details of the factorization are stored
          as an upper or lower triangular matrix. \n
          = 'U':  Upper triangular, form is A = U*D*U**T; \n
          = 'L':  Lower triangular, form is A = L*D*L**T. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          The block diagonal matrix D and the multipliers used to
          obtain the factor U or L as computed by SSYTRF_ROOK. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D
          as determined by SSYTRF_ROOK. \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,NRHS) \n
          On entry, the right hand side matrix B.
          On exit, the solution matrix X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sytrs_rook(char* uplo, integer* n, integer* nrhs,  T* a, integer* lda, integer* ipiv, T* b, integer* ldb, integer* info)
{
  return sytrs_rook(uplo, n, nrhs, a, lda, ipiv, b, ldb, info);
}

/*! @brief SYTRS solves a system of linear equations A*X = B with a real \n
     symmetric matrix A 
 * @details
 * \b Purpose:
    \verbatim 
     SYTRS solves a system of linear equations A*X = B with a real
     symmetric matrix A using the factorization A = U*D*U**T or
     A = L*D*L**T computed by SYTRF.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the details of the factorization are stored
          as an upper or lower triangular matrix. \n
          = 'U':  Upper triangular, form is A = U*D*U**T; \n
          = 'L':  Lower triangular, form is A = L*D*L**T. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          The block diagonal matrix D and the multipliers used to
          obtain the factor U or L as computed by SSYTRF. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D
          as determined by SSYTRF. \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,NRHS) \n
          On entry, the right hand side matrix B.
          On exit, the solution matrix X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sytrs(char* uplo, integer* n, integer* nrhs,  T* a, integer* lda,  integer* ipiv, T* b, integer* ldb, integer* info)
{
  return sytrs(uplo, n, nrhs, a, lda, ipiv, b, ldb, info);
}

/*! @brief SYTRS2 solves a system of linear equations A*X = B with a real \n
     symmetric matrix A 
 * @details
 * \b Purpose:
    \verbatim 
     SYTRS2 solves a system of linear equations A*X = B with a real
     symmetric matrix A using the factorization A = U*D*U**T or
     A = L*D*L**T computed by SSYTRF and converted by SSYCONV.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the details of the factorization are stored
          as an upper or lower triangular matrix. \n
          = 'U':  Upper triangular, form is A = U*D*U**T; \n
          = 'L':  Lower triangular, form is A = L*D*L**T. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          The block diagonal matrix D and the multipliers used to
          obtain the factor U or L as computed by SSYTRF.
          Note that A is input / output. This might be counter-intuitive,
          and one may think that A is input only. A is input / output. This
          is because, at the start of the subroutine, we permute A in a
          "better" form and then we permute A back to its original form at
          the end. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D
          as determined by SSYTRF. \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,NRHS) \n
          On entry, the right hand side matrix B.
          On exit, the solution matrix X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sytrs2(char* uplo, integer* n, integer* nrhs, T* a, integer* lda,  integer* ipiv, T* b, integer* ldb, T* work, integer* info)
{
  return sytrs2(uplo, n, nrhs, a, lda,  ipiv, b, ldb, work, info);
}

/*! @brief HGEQZ computes the eigenvalues of a real matrix pair (H,T).

 * @details
 * \b Purpose:
    \verbatim 
     HGEQZ computes the eigenvalues of a real matrix pair (H,T),
     where H is an upper Hessenberg matrix and T is upper triangular,
     using the double-shift QZ method.
     Matrix pairs of this type are produced by the reduction to
     generalized upper Hessenberg form of a real matrix pair (A,B):

        A = Q1*H*Z1**T,  B = Q1*T*Z1**T,

     as computed by SGGHRD.

     If JOB='S', then the Hessenberg-triangular pair (H,T) is
     also reduced to generalized Schur form,

        H = Q*S*Z**T,  T = Q*P*Z**T,

     where Q and Z are orthogonal matrices, P is an upper triangular
     matrix, and S is a quasi-triangular matrix with 1-by-1 and 2-by-2
     diagonal blocks.

     The 1-by-1 blocks correspond to real eigenvalues of the matrix pair
     (H,T) and the 2-by-2 blocks correspond to complex conjugate pairs of
     eigenvalues.

     Additionally, the 2-by-2 upper triangular diagonal blocks of P
     corresponding to 2-by-2 blocks of S are reduced to positive diagonal
     form, i.e., if S(j+1,j) is non-zero, then P(j+1,j) = P(j,j+1) = 0,
     P(j,j) > 0, and P(j+1,j+1) > 0.

     Optionally, the orthogonal matrix Q from the generalized Schur
     factorization may be postmultiplied into an input matrix Q1, and the
     orthogonal matrix Z may be postmultiplied into an input matrix Z1.
     If Q1 and Z1 are the orthogonal matrices from SGGHRD that reduced
     the matrix pair (A,B) to generalized upper Hessenberg form, then the
     output matrices Q1*Q and Z1*Z are the orthogonal factors from the
     generalized Schur factorization of (A,B):

        A = (Q1*Q)*S*(Z1*Z)**T,  B = (Q1*Q)*P*(Z1*Z)**T.

     To avoid overflow, eigenvalues of the matrix pair (H,T) (equivalently,
     of (A,B)) are computed as a pair of values (alpha,beta), where alpha is
     complex and beta real.
     If beta is nonzero, lambda = alpha / beta is an eigenvalue of the
     generalized nonsymmetric eigenvalue problem (GNEP)
        A*x = lambda*B*x
     and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
     alternate form of the GNEP
        mu*A*y = B*y.
     Real eigenvalues can be read directly from the generalized Schur
     form:
       alpha = S(i,i), beta = P(i,i).

     Ref: C.B. Moler & G.W. Stewart, "An Algorithm for Generalized Matrix
          Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
          pp. 241--256.
    \endverbatim  

 * @param[in] JOB
          JOB is CHARACTER*1 \n
          = 'E': Compute eigenvalues only; \n
          = 'S': Compute eigenvalues and the Schur form. \n
 * @param[in] COMPQ
          COMPQ is CHARACTER*1 \n
          = 'N': Left Schur vectors (Q) are not computed; \n
          = 'I': Q is initialized to the unit matrix and the matrix Q
                 of left Schur vectors of (H,T) is returned; \n
          = 'V': Q must contain an orthogonal matrix Q1 on entry and
                 the product Q1*Q is returned. \n
 * @param[in] COMPZ
          COMPZ is CHARACTER*1 \n
          = 'N': Right Schur vectors (Z) are not computed; \n
          = 'I': Z is initialized to the unit matrix and the matrix Z
                 of right Schur vectors of (H,T) is returned; \n
          = 'V': Z must contain an orthogonal matrix Z1 on entry and
                 the product Z1*Z is returned. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrices H, T, Q, and Z.  N >= 0. \n
 * @param[in] ILO
          ILO is INTEGER \n
 * @param[in] IHI
          IHI is INTEGER \n
          ILO and IHI mark the rows and columns of H which are in
          Hessenberg form.  It is assumed that A is already upper
          triangular in rows and columns 1:ILO-1 and IHI+1:N.
          If N > 0, 1 <= ILO <= IHI <= N; if N = 0, ILO=1 and IHI=0. \n
 * @param[in,out] H
          H is REAL array, dimension (LDH, N) \n
          On entry, the N-by-N upper Hessenberg matrix H. \n
          On exit, if JOB = 'S', H contains the upper quasi-triangular
          matrix S from the generalized Schur factorization.
          If JOB = 'E', the diagonal blocks of H match those of S, but
          the rest of H is unspecified. \n
 * @param[in] LDH
          LDH is INTEGER \n
          The leading dimension of the array H.  LDH >= max( 1, N). \n
 * @param[in,out] T
          T is REAL array, dimension (LDT, N) \n
          On entry, the N-by-N upper triangular matrix T. \n
          On exit, if JOB = 'S', T contains the upper triangular
          matrix P from the generalized Schur factorization;
          2-by-2 diagonal blocks of P corresponding to 2-by-2 blocks of S
          are reduced to positive diagonal form, i.e., if H(j+1,j) is
          non-zero, then T(j+1,j) = T(j,j+1) = 0, T(j,j) > 0, and
          T(j+1,j+1) > 0. \n
          If JOB = 'E', the diagonal blocks of T match those of P, but
          the rest of T is unspecified. \n
 * @param[in] LDT
          LDT is INTEGER \n
          The leading dimension of the array T.  LDT >= max( 1, N). \n
 * @param[out] ALPHAR
          ALPHAR is REAL array, dimension (N) \n
          The real parts of each scalar alpha defining an eigenvalue
          of GNEP. \n
 * @param[out] ALPHAI
          ALPHAI is REAL array, dimension (N) \n
          The imaginary parts of each scalar alpha defining an
          eigenvalue of GNEP. \n
          If ALPHAI(j) is zero, then the j-th eigenvalue is real; if
          positive, then the j-th and (j+1)-st eigenvalues are a
          complex conjugate pair, with ALPHAI(j+1) = -ALPHAI(j). \n
 * @param[out] BETA
          BETA is REAL array, dimension (N) \n
          The scalars beta that define the eigenvalues of GNEP.
          Together, the quantities alpha = (ALPHAR(j),ALPHAI(j)) and
          beta = BETA(j) represent the j-th eigenvalue of the matrix
          pair (A,B), in one of the forms lambda = alpha/beta or
          mu = beta/alpha.  Since either lambda or mu may overflow,
          they should not, in general, be computed. \n
 * @param[in,out] Q
          Q is REAL array, dimension (LDQ, N) \n
          On entry, if COMPQ = 'V', the orthogonal matrix Q1 used in
          the reduction of (A,B) to generalized Hessenberg form.
          On exit, if COMPQ = 'I', the orthogonal matrix of left Schur
          vectors of (H,T), and if COMPQ = 'V', the orthogonal matrix
          of left Schur vectors of (A,B).
          Not referenced if COMPQ = 'N'. \n
 * @param[in] LDQ
          LDQ is INTEGER \n
          The leading dimension of the array Q.  LDQ >= 1.
          If COMPQ='V' or 'I', then LDQ >= N. \n
 * @param[in,out] Z
          Z is REAL array, dimension (LDZ, N) \n
          On entry, if COMPZ = 'V', the orthogonal matrix Z1 used in
          the reduction of (A,B) to generalized Hessenberg form.
          On exit, if COMPZ = 'I', the orthogonal matrix of
          right Schur vectors of (H,T), and if COMPZ = 'V', the
          orthogonal matrix of right Schur vectors of (A,B).
          Not referenced if COMPZ = 'N'. \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of the array Z.  LDZ >= 1.
          If COMPZ='V' or 'I', then LDZ >= N. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO >= 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER
          The dimension of the array WORK.  LWORK >= max(1,N). \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n
          = 1,...,N: the QZ iteration did not converge.  (H,T) is not
                     in Schur form, but ALPHAR(i), ALPHAI(i), and
                     BETA(i), i=INFO+1,...,N should be correct. \n
          = N+1,...,2*N: the shift calculation failed.  (H,T) is not
                     in Schur form, but ALPHAR(i), ALPHAI(i), and
                     BETA(i), i=INFO-N+1,...,N should be correct. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer hgeqz(char* job, char* compq, char* compz, integer* n, integer* ilo, integer* ihi, T* h, integer* ldh, T* t, integer* ldt, T* alphar, T* alphai, T* beta, T* q, integer* ldq, T* z, integer* ldz, T* work, integer* lwork, integer* info)
{
  return hgeqz(job, compq, compz, n, ilo, ihi, h, ldh, t, ldt, alphar, alphai, beta, q, ldq, z, ldz, work, lwork, info);
}
template< typename T, typename Ta >
integer hgeqz(char* job, char* compq, char* compz, integer* n, integer* ilo, integer* ihi, T* h, integer* ldh, T* t, integer* ldt, T* alpha, T* beta, T* q, integer* ldq, T* z, integer* ldz, T* work, integer* lwork, Ta* rwork, integer* info)
{
  return hgeqz(job, compq, compz, n, ilo, ihi, h, ldh, t, ldt, alpha, beta, q, ldq, z, ldz, work, lwork, rwork, info);
}

/*! @brief HSEIN uses inverse iteration to find specified right and/or left \n
     eigenvectors of a real upper Hessenberg matrix H 

 * @details
 * \b Purpose:
    \verbatim 
     HSEIN uses inverse iteration to find specified right and/or left
     eigenvectors of a real upper Hessenberg matrix H.

     The right eigenvector x and the left eigenvector y of the matrix H
     corresponding to an eigenvalue w are defined by:

                  H * x = w * x,     y**h * H = w * y**h

     where y**h denotes the conjugate transpose of the vector y.
    \endverbatim  

 * @param[in] SIDE
          SIDE is CHARACTER*1 \n
          = 'R': compute right eigenvectors only; \n
          = 'L': compute left eigenvectors only; \n
          = 'B': compute both right and left eigenvectors. \n
 * @param[in] EIGSRC
          EIGSRC is CHARACTER*1 \n
          Specifies the source of eigenvalues supplied in (WR,WI): \n
          = 'Q': the eigenvalues were found using SHSEQR; thus, if
                 H has zero subdiagonal elements, and so is
                 block-triangular, then the j-th eigenvalue can be
                 assumed to be an eigenvalue of the block containing
                 the j-th row/column.  This property allows SHSEIN to
                 perform inverse iteration on just one diagonal block. \n
          = 'N': no assumptions are made on the correspondence
                 between eigenvalues and diagonal blocks.  In this
                 case, SHSEIN must always perform inverse iteration
                 using the whole matrix H. \n
 * @param[in] INITV
          INITV is CHARACTER*1 \n
          = 'N': no initial vectors are supplied; \n
          = 'U': user-supplied initial vectors are stored in the arrays
                 VL and/or VR. \n
 * @param[in,out] SELECT
          SELECT is LOGICAL array, dimension (N) \n
          Specifies the eigenvectors to be computed. To select the
          real eigenvector corresponding to a real eigenvalue WR(j),
          SELECT(j) must be set to .TRUE.. To select the complex
          eigenvector corresponding to a complex eigenvalue
          (WR(j),WI(j)), with complex conjugate (WR(j+1),WI(j+1)),
          either SELECT(j) or SELECT(j+1) or both must be set to
          .TRUE.; then on exit SELECT(j) is .TRUE. and SELECT(j+1) is
          .FALSE.. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix H.  N >= 0. \n
 * @param[in] H
          H is REAL array, dimension (LDH,N) \n
          The upper Hessenberg matrix H.
          If a NaN is detected in H, the routine will return with INFO=-6. \n
 * @param[in] LDH
          LDH is INTEGER \n
          The leading dimension of the array H.  LDH >= max(1,N). \n
 * @param[in,out] WR
          WR is REAL array, dimension (N) \n
 * @param[in] WI
          WI is REAL array, dimension (N) \n
          On entry, the real and imaginary parts of the eigenvalues of
          H; a complex conjugate pair of eigenvalues must be stored in
          consecutive elements of WR and WI. \n
          On exit, WR may have been altered since close eigenvalues
          are perturbed slightly in searching for independent
          eigenvectors. \n
 * @param[in,out] VL
          VL is REAL array, dimension (LDVL,MM) \n
          On entry, if INITV = 'U' and SIDE = 'L' or 'B', VL must
          contain starting vectors for the inverse iteration for the
          left eigenvectors; the starting vector for each eigenvector
          must be in the same column(s) in which the eigenvector will
          be stored. \n
          On exit, if SIDE = 'L' or 'B', the left eigenvectors
          specified by SELECT will be stored consecutively in the
          columns of VL, in the same order as their eigenvalues. A
          complex eigenvector corresponding to a complex eigenvalue is
          stored in two consecutive columns, the first holding the real
          part and the second the imaginary part.
          If SIDE = 'R', VL is not referenced. \n
 * @param[in] LDVL
          LDVL is INTEGER \n
          The leading dimension of the array VL. \n
          LDVL >= max(1,N) if SIDE = 'L' or 'B'; LDVL >= 1 otherwise. \n
 * @param[in,out] VR
          VR is REAL array, dimension (LDVR,MM) \n
          On entry, if INITV = 'U' and SIDE = 'R' or 'B', VR must
          contain starting vectors for the inverse iteration for the
          right eigenvectors; the starting vector for each eigenvector
          must be in the same column(s) in which the eigenvector will
          be stored. \n
          On exit, if SIDE = 'R' or 'B', the right eigenvectors
          specified by SELECT will be stored consecutively in the
          columns of VR, in the same order as their eigenvalues. A
          complex eigenvector corresponding to a complex eigenvalue is
          stored in two consecutive columns, the first holding the real
          part and the second the imaginary part.
          If SIDE = 'L', VR is not referenced. \n
 * @param[in] LDVR
          LDVR is INTEGER \n
          The leading dimension of the array VR.
          LDVR >= max(1,N) if SIDE = 'R' or 'B'; LDVR >= 1 otherwise. \n
 * @param[in] MM
          MM is INTEGER \n
          The number of columns in the arrays VL and/or VR. MM >= M. \n
 * @param[out] M
          M is INTEGER \n
          The number of columns in the arrays VL and/or VR required to
          store the eigenvectors; each selected real eigenvector
          occupies one column and each selected complex eigenvector
          occupies two columns. \n
 * @param[out] IFAILL
          IFAILL is INTEGER array, dimension (MM) \n
          If SIDE = 'L' or 'B', IFAILL(i) = j > 0 if the left
          eigenvector in the i-th column of VL (corresponding to the
          eigenvalue w(j)) failed to converge; IFAILL(i) = 0 if the
          eigenvector converged satisfactorily. If the i-th and (i+1)th
          columns of VL hold a complex eigenvector, then IFAILL(i) and
          IFAILL(i+1) are set to the same value. \n
          If SIDE = 'R', IFAILL is not referenced. \n
 * @param[out] IFAILR
          IFAILR is INTEGER array, dimension (MM) \n
          If SIDE = 'R' or 'B', IFAILR(i) = j > 0 if the right
          eigenvector in the i-th column of VR (corresponding to the
          eigenvalue w(j)) failed to converge; IFAILR(i) = 0 if the
          eigenvector converged satisfactorily. If the i-th and (i+1)th
          columns of VR hold a complex eigenvector, then IFAILR(i) and
          IFAILR(i+1) are set to the same value. \n
          If SIDE = 'L', IFAILR is not referenced. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension ((N+2)*N) \n
 * @param[out]	IFAILL	
          IFAILL is INTEGER array, dimension (MM) \n
          If SIDE = 'L' or 'B', IFAILL(i) = j > 0 if the left
          eigenvector in the i-th column of VL (corresponding to the
          eigenvalue w(j)) failed to converge; IFAILL(i) = 0 if the
          eigenvector converged satisfactorily. If the i-th and (i+1)th
          columns of VL hold a complex eigenvector, then IFAILL(i) and
          IFAILL(i+1) are set to the same value. \n
          If SIDE = 'R', IFAILL is not referenced. \n
 * @param[out]	IFAILR	
          IFAILR is INTEGER array, dimension (MM) \n
          If SIDE = 'R' or 'B', IFAILR(i) = j > 0 if the right
          eigenvector in the i-th column of VR (corresponding to the
          eigenvalue w(j)) failed to converge; IFAILR(i) = 0 if the
          eigenvector converged satisfactorily. If the i-th and (i+1)th
          columns of VR hold a complex eigenvector, then IFAILR(i) and
          IFAILR(i+1) are set to the same value. \n
          If SIDE = 'L', IFAILR is not referenced. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, i is the number of eigenvectors which
                failed to converge; see IFAILL and IFAILR for further
                details. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer hsein(char* job, char* eigsrc, char* initv, logical* select, integer* n, T* h, integer* ldh, T* wr,  T* wi, T* vl, integer* ldvl, T* vr, integer* ldvr, integer* mm, integer* m, T* work, integer* ifaill, integer* ifailr, integer* info)
{
  return hsein(job, eigsrc, initv, select, n, h, ldh, wr, wi, vl, ldvl, vr, ldvr, mm, m, work, ifaill, ifailr, info);
}
template< typename T, typename Ta >
integer hsein(char* job, char* eigsrc, char* initv, logical* select, integer* n, T* h, integer* ldh, T* w, T* vl, integer* ldvl, T* vr, integer* ldvr, integer* mm, integer* m, T* work, Ta* rwork, integer* ifaill, integer* ifailr, integer* info)
{
  return hsein(job, eigsrc, initv, select, n, h, ldh, w, vl, ldvl, vr, ldvr, mm, m, work, rwork, ifaill, ifailr, info);
}

/*! @brief HSEQR computes the eigenvalues of a Hessenberg matrix H

 * @details
 * \b Purpose:
    \verbatim 
    HSEQR computes the eigenvalues of a Hessenberg matrix H
    and, optionally, the matrices T and Z from the Schur decomposition
    H = Z T Z**T, where T is an upper quasi-triangular matrix (the
    Schur form), and Z is the orthogonal matrix of Schur vectors.

    Optionally Z may be postmultiplied into an input orthogonal
    matrix Q so that this routine can give the Schur factorization
    of a matrix A which has been reduced to the Hessenberg form H
    by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.
    \endverbatim  

 * @param[in] JOB
          JOB is CHARACTER*1 \n
           = 'E':  compute eigenvalues only; \n
           = 'S':  compute eigenvalues and the Schur form T. \n
 * @param[in] COMPZ
          COMPZ is CHARACTER*1 \n
           = 'N':  no Schur vectors are computed; \n
           = 'I':  Z is initialized to the unit matrix and the matrix Z
                   of Schur vectors of H is returned; \n
           = 'V':  Z must contain an orthogonal matrix Q on entry, and
                   the product Q*Z is returned. \n
 * @param[in] N
          N is INTEGER \n
           The order of the matrix H.  N >= 0. \n
 * @param[in] ILO
          ILO is INTEGER \n
 * @param[in] IHI
          IHI is INTEGER \n
          It is assumed that H is already upper triangular in rows
          and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
          set by a previous call to SGEBAL, and then passed to ZGEHRD
          when the matrix output by SGEBAL is reduced to Hessenberg
          form. Otherwise ILO and IHI should be set to 1 and N
          respectively.  If N > 0, then 1 <= ILO <= IHI <= N.
          If N = 0, then ILO = 1 and IHI = 0. \n
 * @param[in,out] H
          H is REAL array, dimension (LDH,N) \n
          On entry, the upper Hessenberg matrix H. \n
          On exit, if INFO = 0 and JOB = 'S', then H contains the
          upper quasi-triangular matrix T from the Schur decomposition
          (the Schur form); 2-by-2 diagonal blocks (corresponding to
          complex conjugate pairs of eigenvalues) are returned in
          standard form, with H(i,i) = H(i+1,i+1) and
          H(i+1,i)*H(i,i+1) < 0. If INFO = 0 and JOB = 'E', the
          contents of H are unspecified on exit.  (The output value of
          H when INFO > 0 is given under the description of INFO
          below.) \n
 \n
          Unlike earlier versions of SHSEQR, this subroutine may
          explicitly H(i,j) = 0 for i > j and j = 1, 2, ... ILO-1
          or j = IHI+1, IHI+2, ... N. \n
 * @param[in] LDH
          LDH is INTEGER \n
          The leading dimension of the array H. LDH >= max(1,N). \n
 * @param[out] WR
          WR is REAL array, dimension (N) \n
 * @param[out] WI
          WI is REAL array, dimension (N) \n
          The real and imaginary parts, respectively, of the computed
          eigenvalues. If two eigenvalues are computed as a complex
          conjugate pair, they are stored in consecutive elements of
          WR and WI, say the i-th and (i+1)th, with WI(i) > 0 and
          WI(i+1) < 0. If JOB = 'S', the eigenvalues are stored in
          the same order as on the diagonal of the Schur form returned
          in H, with WR(i) = H(i,i) and, if H(i:i+1,i:i+1) is a 2-by-2
          diagonal block, WI(i) = sqrt(-H(i+1,i)*H(i,i+1)) and
          WI(i+1) = -WI(i). \n
 * @param[in,out] Z
          Z is REAL array, dimension (LDZ,N) \n
          If COMPZ = 'N', Z is not referenced. \n
          If COMPZ = 'I', on entry Z need not be set and on exit, \n
          if INFO = 0, Z contains the orthogonal matrix Z of the Schur
          vectors of H.  If COMPZ = 'V', on entry Z must contain an
          N-by-N matrix Q, which is assumed to be equal to the unit
          matrix except for the submatrix Z(ILO:IHI,ILO:IHI). \n On exit,
          if INFO = 0, Z contains Q*Z.
          Normally Q is the orthogonal matrix generated by SORGHR
          after the call to SGEHRD which formed the Hessenberg matrix
          H. (The output value of Z when INFO > 0 is given under
          the description of INFO below.) \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of the array Z.  if COMPZ = 'I' or
          COMPZ = 'V', then LDZ >= MAX(1,N).  Otherwise, LDZ >= 1. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (LWORK) \n
          On exit, if INFO = 0, WORK(1) returns an estimate of
          the optimal value for LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK.  LWORK >= max(1,N)
          is sufficient and delivers very good and sometimes
          optimal performance.  However, LWORK as large as 11*N
          may be required for optimal performance.  A workspace
          query is recommended to determine the optimal workspace
          size. \n
\n
          If LWORK = -1, then SHSEQR does a workspace query.
          In this case, SHSEQR checks the input parameters and
          estimates the optimal workspace size for the given
          values of N, ILO and IHI.  The estimate is returned
          in WORK(1).  No error message related to LWORK is
          issued by XERBLA.  Neither H nor Z are accessed. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
             = 0:  successful exit \n
             < 0:  if INFO = -i, the i-th argument had an illegal
                    value \n
             > 0:  if INFO = i, SHSEQR failed to compute all of
                the eigenvalues.  Elements 1:ilo-1 and i+1:n of WR
                and WI contain those eigenvalues which have been
                successfully computed.  (Failures are rare.) \n
 \n
                If INFO > 0 and JOB = 'E', then on exit, the
                remaining unconverged eigenvalues are the eigen-
                values of the upper Hessenberg matrix rows and
                columns ILO through INFO of the final, output
                value of H. \n
 \n
                If INFO > 0 and JOB   = 'S', then on exit
 \n
           (*)  (initial value of H)*U  = U*(final value of H)
 \n
                where U is an orthogonal matrix.  The final
                value of H is upper Hessenberg and quasi-triangular
                in rows and columns INFO+1 through IHI.
 \n
                If INFO > 0 and COMPZ = 'V', then on exit
 \n
                  (final value of Z)  =  (initial value of Z)*U
 \n
                where U is the orthogonal matrix in (*) (regard-
                less of the value of JOB.)
 \n
                If INFO > 0 and COMPZ = 'I', then on exit
                      (final value of Z)  = U
                where U is the orthogonal matrix in (*) (regard-
                less of the value of JOB.)
 \n
                If INFO > 0 and COMPZ = 'N', then Z is not
                accessed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer hseqr(char* job, char* compz, integer* n, integer* ilo, integer* ihi, T* h, integer* ldh, T* wr, T* wi, T* z, integer* ldz, T* work, integer* lwork, integer* info)
{
  return hseqr(job, compz, n, ilo, ihi, h, ldh, wr, wi, z, ldz, work, lwork, info);
}
template< typename T >
integer hseqr(char* job, char* compz, integer* n, integer* ilo, integer* ihi, T* h, integer* ldh, T* w, T* z, integer* ldz, T* work, integer* lwork, integer* info)
{
  return hseqr(job, compz, n, ilo, ihi, h, ldh, w, z, ldz, work, lwork, info);
}

/*! @brief TBCON estimates the reciprocal of the condition number of a  \n
     triangular band matrix A

 * @details
 * \b Purpose:
    \verbatim 
     TBCON estimates the reciprocal of the condition number of a
     triangular band matrix A, in either the 1-norm or the infinity-norm.

     The norm of A is computed and an estimate is obtained for
     norm(inv(A)), then the reciprocal of the condition number is
     computed as
        RCOND = 1 / ( norm(A) * norm(inv(A))).
    \endverbatim  

 * @param[in] NORM
          NORM is CHARACTER*1 \n
          Specifies whether the 1-norm condition number or the
          infinity-norm condition number is required: \n
          = '1' or 'O':  1-norm; \n
          = 'I':         Infinity-norm. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  A is upper triangular; \n
          = 'L':  A is lower triangular. \n
 * @param[in] DIAG
          DIAG is CHARACTER*1 \n
          = 'N':  A is non-unit triangular; \n
          = 'U':  A is unit triangular. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] KD
          KD is INTEGER \n
          The number of superdiagonals or subdiagonals of the
          triangular band matrix A.  KD >= 0. \n
 * @param[in] AB
          AB is REAL array, dimension (LDAB,N) \n
          The upper or lower triangular band matrix A, stored in the
          first kd+1 rows of the array. The j-th column of A is stored
          in the j-th column of the array AB as follows: \n
          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j; \n
          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd). \n
          If DIAG = 'U', the diagonal elements of A are not referenced
          and are assumed to be 1. \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          The leading dimension of the array AB.  LDAB >= KD+1. \n
 * @param[out] RCOND
          RCOND is REAL \n
          The reciprocal of the condition number of the matrix A,
          computed as RCOND = 1/(norm(A) * norm(inv(A))). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (3*N) \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer tbcon(char* norm, char* uplo, char* diag, integer* n, integer* kd,  T* ab, integer* ldab, T* rcond, T* work, integer* iwork, integer* info)
{
  return tbcon(norm, uplo, diag, n, kd,  ab, ldab, rcond, work, iwork, info);
}
template< typename T, typename Ta >
integer tbcon(char* norm, char* uplo, char* diag, integer* n, integer* kd,  T* ab, integer* ldab, Ta* rcond, T* work, Ta* rwork, integer* info)
{
  return tbcon(norm, uplo, diag, n, kd,  ab, ldab, rcond, work, rwork, info);
}

/*! @brief TBRFS provides error bounds and backward error estimates for the  \n
     solution to a system of linear equations

 * @details
 * \b Purpose:
    \verbatim 
     TBRFS provides error bounds and backward error estimates for the
     solution to a system of linear equations with a triangular band
     coefficient matrix.

     The solution matrix X must be computed by STBTRS or some other
     means before entering this routine.  STBRFS does not do iterative
     refinement because doing so cannot improve the backward error.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  A is upper triangular; \n
          = 'L':  A is lower triangular. \n
 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          Specifies the form of the system of equations: \n
          = 'N':  A * X = B  (No transpose) \n
          = 'T':  A**T * X = B  (Transpose) \n
          = 'C':  A**H * X = B  (Conjugate transpose = Transpose) \n
 * @param[in] DIAG
          DIAG is CHARACTER*1 \n
          = 'N':  A is non-unit triangular; \n
          = 'U':  A is unit triangular. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] KD
          KD is INTEGER \n
          The number of superdiagonals or subdiagonals of the
          triangular band matrix A.  KD >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrices B and X.  NRHS >= 0. \n
 * @param[in] AB
          AB is REAL array, dimension (LDAB,N) \n
          The upper or lower triangular band matrix A, stored in the
          first kd+1 rows of the array. The j-th column of A is stored
          in the j-th column of the array AB as follows: \n
          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j; \n
          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd). \n
          If DIAG = 'U', the diagonal elements of A are not referenced
          and are assumed to be 1. \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          The leading dimension of the array AB.  LDAB >= KD+1. \n
 * @param[in] B
          B is REAL array, dimension (LDB,NRHS) \n
          The right hand side matrix B. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[in] X
          X is REAL array, dimension (LDX,NRHS) \n
          The solution matrix X. \n
 * @param[in] LDX
          LDX is INTEGER \n
          The leading dimension of the array X.  LDX >= max(1,N). \n
 * @param[out] FERR
          FERR is REAL array, dimension (NRHS) \n
          The estimated forward error bound for each solution vector
          X(j) (the j-th column of the solution matrix X). \n
          If XTRUE is the true solution corresponding to X(j), FERR(j)
          is an estimated upper bound for the magnitude of the largest
          element in (X(j) - XTRUE) divided by the magnitude of the
          largest element in X(j).  The estimate is as reliable as
          the estimate for RCOND, and is almost always a slight
          overestimate of the true error. \n
 * @param[out] BERR
          BERR is REAL array, dimension (NRHS) \n
          The componentwise relative backward error of each solution
          vector X(j) (i.e., the smallest relative change in
          any element of A or B that makes X(j) an exact solution). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (3*N) \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer tbrfs(char* uplo, char* trans, char* diag, integer* n, integer* kd, integer* nrhs,  T* ab, integer* ldab,  T* b, integer* ldb,  T* x, integer* ldx, T* ferr, T* berr, T* work, integer* iwork, integer* info)
{
  return tbrfs(uplo, trans, diag, n, kd, nrhs,  ab, ldab,  b, ldb,  x, ldx, ferr, berr, work, iwork, info);
}
template< typename T, typename Ta >
integer tbrfs(char* uplo, char* trans, char* diag, integer* n, integer* kd, integer* nrhs,  T* ab, integer* ldab,  T* b, integer* ldb,  T* x, integer* ldx, Ta* ferr, Ta* berr, T* work, Ta* rwork, integer* info)
{
  return tbrfs(uplo, trans, diag, n, kd, nrhs,  ab, ldab,  b, ldb,  x, ldx, ferr, berr, work, rwork, info);
}

/*! @brief TBTRS solves a triangular system of the form A * X = B  or  A**T * X = B

 * @details
 * \b Purpose:
    \verbatim 
     TBTRS solves a triangular system of the form

        A * X = B  or  A**T * X = B,

     where A is a triangular band matrix of order N, and B is an
     N-by NRHS matrix.  A check is made to verify that A is nonsingular.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  A is upper triangular; \n
          = 'L':  A is lower triangular. \n
 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          Specifies the form the system of equations: \n
          = 'N':  A * X = B  (No transpose) \n
          = 'T':  A**T * X = B  (Transpose) \n
          = 'C':  A**H * X = B  (Conjugate transpose = Transpose) \n
 * @param[in] DIAG
          DIAG is CHARACTER*1 \n
          = 'N':  A is non-unit triangular; \n
          = 'U':  A is unit triangular. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] KD
          KD is INTEGER \n
          The number of superdiagonals or subdiagonals of the
          triangular band matrix A.  KD >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in] AB
          AB is REAL array, dimension (LDAB,N) \n
          The upper or lower triangular band matrix A, stored in the
          first kd+1 rows of AB.  The j-th column of A is stored
          in the j-th column of the array AB as follows: \n
          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j; \n
          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd). \n
          If DIAG = 'U', the diagonal elements of A are not referenced
          and are assumed to be 1. \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          The leading dimension of the array AB.  LDAB >= KD+1. \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,NRHS) \n
          On entry, the right hand side matrix B.
          On exit, if INFO = 0, the solution matrix X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, the i-th diagonal element of A is zero,
                indicating that the matrix is singular and the
                solutions X have not been computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer tbtrs(char* uplo, char* trans, char* diag, integer* n, integer* kd, integer* nrhs,  T* ab, integer* ldab, T* b, integer* ldb, integer* info)
{
  return tbtrs(uplo, trans, diag, n, kd, nrhs,  ab, ldab, b, ldb, info);
}

/*! @brief TFSM solves a matrix equation (one operand is a triangular matrix in RFP format).

 * @details
 * \b Purpose:
    \verbatim 
     TFSM  solves the matrix equation

        op( A)*X = alpha*B  or  X*op( A) = alpha*B

     where alpha is a scalar, X and B are m by n matrices, A is a unit, or
     non-unit,  upper or lower triangular matrix  and  op( A)  is one  of

        op( A) = A   or   op( A) = A**T.

     A is in Rectangular Full Packed (RFP) Format.

     The matrix X is overwritten on B.
    \endverbatim  

 * @param[in] TRANSR
          TRANSR is CHARACTER*1 \n
          = 'N':  The Normal Form of RFP A is stored; \n
          = 'T':  The Transpose Form of RFP A is stored. \n
 * @param[in] SIDE
          SIDE is CHARACTER*1 \n
          On entry, SIDE specifies whether op( A) appears on the left
          or right of X as follows: \n
            SIDE = 'L' or 'l'   op( A)*X = alpha*B. \n
            SIDE = 'R' or 'r'   X*op( A) = alpha*B. \n
          Unchanged on exit. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          On entry, UPLO specifies whether the RFP matrix A came from
          an upper or lower triangular matrix as follows: \n
          UPLO = 'U' or 'u' RFP A came from an upper triangular matrix \n
          UPLO = 'L' or 'l' RFP A came from a  lower triangular matrix \n
          Unchanged on exit. \n
 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          On entry, TRANS  specifies the form of op( A) to be used
          in the matrix multiplication as follows: \n
            TRANS  = 'N' or 'n'   op( A) = A. \n
            TRANS  = 'T' or 't'   op( A) = A'. \n
          Unchanged on exit. \n
 * @param[in] DIAG
          DIAG is CHARACTER*1 \n
          On entry, DIAG specifies whether or not RFP A is unit
          triangular as follows: \n
            DIAG = 'U' or 'u'   A is assumed to be unit triangular. \n
            DIAG = 'N' or 'n'   A is not assumed to be unit
                                triangular. \n
          Unchanged on exit. \n
 * @param[in] M
          M is INTEGER \n
          On entry, M specifies the number of rows of B. M must be at
          least zero.
          Unchanged on exit. \n
 * @param[in] N
          N is INTEGER \n
          On entry, N specifies the number of columns of B.  N must be
          at least zero. \n
          Unchanged on exit. \n
 * @param[in] ALPHA
          ALPHA is REAL \n
          On entry,  ALPHA specifies the scalar  alpha. When  alpha is
          zero then  A is not referenced and  B need not be set before
          entry. \n
          Unchanged on exit. \n
 * @param[in] A
          A is REAL array, dimension (NT) \n
          NT = N*(N+1)/2. On entry, the matrix A in RFP Format.
          RFP Format is described by TRANSR, UPLO and N as follows:
          If TRANSR='N' then RFP A is (0:N,0:K-1) when N is even;
          K=N/2. RFP A is (0:N-1,0:K) when N is odd; K=N/2. If
          TRANSR = 'T' then RFP is the transpose of RFP A as
          defined when TRANSR = 'N'. The contents of RFP A are defined
          by UPLO as follows: If UPLO = 'U' the RFP A contains the NT
          elements of upper packed A either in normal or
          transpose Format. If UPLO = 'L' the RFP A contains
          the NT elements of lower packed A either in normal or
          transpose Format. The LDA of RFP A is (N+1)/2 when
          TRANSR = 'T'. When TRANSR is 'N' the LDA is N+1 when N is
          even and is N when is odd. \n
          See the Note below for more details. Unchanged on exit. \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,N) \n
          Before entry,  the leading  m by n part of the array  B must
          contain  the  right-hand  side  matrix  B,  and  on exit  is
          overwritten by the solution matrix  X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          On entry, LDB specifies the first dimension of B as declared
          in  the  calling  (sub)  program.   LDB  must  be  at  least
          max( 1, m). \n
          Unchanged on exit. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer tfsm(char* transr, char* side, char* uplo, char* trans, char* diag, integer* m, integer* n, T* alpha,  T* a, T* b, integer* ldb)
{
  return tfsm(transr, side, uplo, trans, diag, m, n, alpha, a, b, ldb);
}

/*! @brief TFTRI computes the inverse of a triangular matrix A stored in RFP format

 * @details
 * \b Purpose:
    \verbatim 
     TFTRI computes the inverse of a triangular matrix A stored in RFP
     format.

     This is a Level 3 BLAS version of the algorithm.
    \endverbatim  

 * @param[in] TRANSR
          TRANSR is CHARACTER*1 \n
          = 'N':  The Normal TRANSR of RFP A is stored; \n
          = 'T':  The Transpose TRANSR of RFP A is stored. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  A is upper triangular; \n
          = 'L':  A is lower triangular. \n
 * @param[in] DIAG
          DIAG is CHARACTER*1 \n
          = 'N':  A is non-unit triangular; \n
          = 'U':  A is unit triangular. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (NT); \n
          NT=N*(N+1)/2. On entry, the triangular factor of a Hermitian
          Positive Definite matrix A in RFP format. RFP format is
          described by TRANSR, UPLO, and N as follows: If TRANSR = 'N'
          then RFP A is (0:N,0:k-1) when N is even; k=N/2. RFP A is
          (0:N-1,0:k) when N is odd; k=N/2. IF TRANSR = 'T' then RFP is
          the transpose of RFP A as defined when
          TRANSR = 'N'. The contents of RFP A are defined by UPLO as
          follows: If UPLO = 'U' the RFP A contains the nt elements of
          upper packed A; If UPLO = 'L' the RFP A contains the nt
          elements of lower packed A. The LDA of RFP A is (N+1)/2 when
          TRANSR = 'T'. When TRANSR is 'N' the LDA is N+1 when N is
          even and N is odd. See the Note below for more details. \n
 \n
          On exit, the (triangular) inverse of the original matrix, in
          the same storage format. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n
          > 0: if INFO = i, A(i,i) is exactly zero.  The triangular
               matrix is singular and its inverse can not be computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer tftri(char* transr, char* uplo, char* diag, integer* n, T* a, integer* info)
{
  return tftri(transr, uplo, diag, n, a, info);
}

/*! @brief TFTTP copies a triangular matrix from the rectangular full \n
     packed format (TF) to the standard packed format (TP).

 * @details
 * \b Purpose:
    \verbatim 
     TFTTP copies a triangular matrix A from rectangular full packed
     format (TF) to standard packed format (TP).
    \endverbatim  

 * @param[in] TRANSR
          TRANSR is CHARACTER*1 \n
          = 'N':  ARF is in Normal format; \n
          = 'T':  ARF is in Transpose format; \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  A is upper triangular; \n
          = 'L':  A is lower triangular. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A. N >= 0. \n
 * @param[in] ARF
          ARF is REAL array, dimension ( N*(N+1)/2), \n
          On entry, the upper or lower triangular matrix A stored in
          RFP format. For a further discussion see Notes below. \n
 * @param[out] AP
          AP is REAL array, dimension ( N*(N+1)/2), \n
          On exit, the upper or lower triangular matrix A, packed
          columnwise in a linear array. The j-th column of A is stored
          in the array AP as follows: \n
          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j; \n
          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer tfttp(char* transr, char* uplo, integer* n,  T* arf, T* ap, integer* info)
{
  return tfttp(transr, uplo, n,  arf, ap, info);
}

/*! @brief TFTTR copies a triangular matrix from the rectangular full \n
     packed format (TF) to the standard full format (TR).
 * @details
 * \b Purpose:
    \verbatim 
     TFTTR copies a triangular matrix A from rectangular full packed
     format (TF) to standard full format (TR).
    \endverbatim  

 * @param[in] TRANSR
          TRANSR is CHARACTER*1 \n
          = 'N':  ARF is in Normal format; \n
          = 'T':  ARF is in Transpose format. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  A is upper triangular; \n
          = 'L':  A is lower triangular. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrices ARF and A. N >= 0. \n
 * @param[in] ARF
          ARF is REAL array, dimension (N*(N+1)/2). \n
          On entry, the upper (if UPLO = 'U') or lower (if UPLO = 'L')
          matrix A in RFP format. See the "Notes" below for more
          details. \n
 * @param[out] A
          A is REAL array, dimension (LDA,N) \n
          On exit, the triangular matrix A.  If UPLO = 'U', the
          leading N-by-N upper triangular part of the array A contains
          the upper triangular matrix, and the strictly lower
          triangular part of A is not referenced.  If UPLO = 'L', the
          leading N-by-N lower triangular part of the array A contains
          the lower triangular matrix, and the strictly upper
          triangular part of A is not referenced. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer tfttr(char* transr, char* uplo, integer* n,  T* arf, T* a, integer* lda, integer* info)
{
  return tfttr(transr, uplo, n, arf, a, lda, info);
}
/*! @brief TGEVC computes some or all of the right and/or left eigenvectors  \n
     of a pair of real matrices
 * @details
 * \b Purpose:
    \verbatim 
     TGEVC computes some or all of the right and/or left eigenvectors of
     a pair of real matrices (S,P), where S is a quasi-triangular matrix
     and P is upper triangular.  Matrix pairs of this type are produced by
     the generalized Schur factorization of a matrix pair (A,B):

        A = Q*S*Z**T,  B = Q*P*Z**T

     as computed by SGGHRD + SHGEQZ.

     The right eigenvector x and the left eigenvector y of (S,P)
     corresponding to an eigenvalue w are defined by:

        S*x = w*P*x,  (y**H)*S = w*(y**H)*P,

     where y**H denotes the conjugate tranpose of y.
     The eigenvalues are not input to this routine, but are computed
     directly from the diagonal blocks of S and P.

     This routine returns the matrices X and/or Y of right and left
     eigenvectors of (S,P), or the products Z*X and/or Q*Y,
     where Z and Q are input matrices.
     If Q and Z are the orthogonal factors from the generalized Schur
     factorization of a matrix pair (A,B), then Z*X and Q*Y
     are the matrices of right and left eigenvectors of (A,B).
    \endverbatim 
 
 * @param[in] SIDE
          SIDE is CHARACTER*1 \n
          = 'R': compute right eigenvectors only; \n
          = 'L': compute left eigenvectors only; \n
          = 'B': compute both right and left eigenvectors. \n
 * @param[in] HOWMNY
          HOWMNY is CHARACTER*1 \n
          = 'A': compute all right and/or left eigenvectors; \n
          = 'B': compute all right and/or left eigenvectors,
                 backtransformed by the matrices in VR and/or VL; \n
          = 'S': compute selected right and/or left eigenvectors,
                 specified by the logical array SELECT. \n
 * @param[in] SELECT
          SELECT is LOGICAL array, dimension (N) \n
          If HOWMNY='S', SELECT specifies the eigenvectors to be
          computed.  If w(j) is a real eigenvalue, the corresponding
          real eigenvector is computed if SELECT(j) is .TRUE..
          If w(j) and w(j+1) are the real and imaginary parts of a
          complex eigenvalue, the corresponding complex eigenvector
          is computed if either SELECT(j) or SELECT(j+1) is .TRUE.,
          and on exit SELECT(j) is set to .TRUE. and SELECT(j+1) is
          set to .FALSE.. \n
          Not referenced if HOWMNY = 'A' or 'B'. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrices S and P.  N >= 0. \n
 * @param[in] S
          S is REAL array, dimension (LDS,N) \n
          The upper quasi-triangular matrix S from a generalized Schur
          factorization, as computed by SHGEQZ. \n
 * @param[in] LDS
          LDS is INTEGER \n
          The leading dimension of array S.  LDS >= max(1,N). \n
 * @param[in] P
          P is REAL array, dimension (LDP,N) \n
          The upper triangular matrix P from a generalized Schur
          factorization, as computed by SHGEQZ.
          2-by-2 diagonal blocks of P corresponding to 2-by-2 blocks
          of S must be in positive diagonal form. \n
 * @param[in] LDP
          LDP is INTEGER \n
          The leading dimension of array P.  LDP >= max(1,N). \n
 * @param[in,out] VL
          VL is REAL array, dimension (LDVL,MM) \n
          On entry, if SIDE = 'L' or 'B' and HOWMNY = 'B', VL must
          contain an N-by-N matrix Q (usually the orthogonal matrix Q
          of left Schur vectors returned by SHGEQZ). \n
          On exit, if SIDE = 'L' or 'B', VL contains: \n
          if HOWMNY = 'A', the matrix Y of left eigenvectors of (S,P); \n
          if HOWMNY = 'B', the matrix Q*Y; \n
          if HOWMNY = 'S', the left eigenvectors of (S,P) specified by
                      SELECT, stored consecutively in the columns of
                      VL, in the same order as their eigenvalues. \n
 \n
          A complex eigenvector corresponding to a complex eigenvalue
          is stored in two consecutive columns, the first holding the
          real part, and the second the imaginary part. \n
 \n
          Not referenced if SIDE = 'R'. \n
 * @param[in] LDVL
          LDVL is INTEGER \n
          The leading dimension of array VL.  LDVL >= 1, and if
          SIDE = 'L' or 'B', LDVL >= N. \n
 * @param[in,out] VR
          VR is REAL array, dimension (LDVR,MM) \n
          On entry, if SIDE = 'R' or 'B' and HOWMNY = 'B', VR must
          contain an N-by-N matrix Z (usually the orthogonal matrix Z
          of right Schur vectors returned by SHGEQZ). \n
 \n
          On exit, if SIDE = 'R' or 'B', VR contains: \n
          if HOWMNY = 'A', the matrix X of right eigenvectors of (S,P); \n
          if HOWMNY = 'B' or 'b', the matrix Z*X; \n
          if HOWMNY = 'S' or 's', the right eigenvectors of (S,P)
                      specified by SELECT, stored consecutively in the
                      columns of VR, in the same order as their
                      eigenvalues. \n
 \n
          A complex eigenvector corresponding to a complex eigenvalue
          is stored in two consecutive columns, the first holding the
          real part and the second the imaginary part. \n
 \n
          Not referenced if SIDE = 'L'. \n
 * @param[in] LDVR
          LDVR is INTEGER \n
          The leading dimension of the array VR.  LDVR >= 1, and if
          SIDE = 'R' or 'B', LDVR >= N. \n
 * @param[in] MM
          MM is INTEGER \n
          The number of columns in the arrays VL and/or VR. MM >= M. \n
 * @param[out] M
          M is INTEGER \n
          The number of columns in the arrays VL and/or VR actually
          used to store the eigenvectors. If HOWMNY = 'A' or 'B', M
          is set to N. Each selected real eigenvector occupies one
          column and each selected complex eigenvector occupies two
          columns. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (6*N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n
          > 0:  the 2-by-2 block (INFO:INFO+1) does not have a complex
                eigenvalue. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer tgevc(char* side, char* howmny,  logical* select, integer* n,  T* s, integer* lds,  T* p, integer* ldp, T* vl, integer* ldvl, T* vr, integer* ldvr, integer* mm, integer* m, T* work, integer* info)
{
  return tgevc(side, howmny,  select, n,  s, lds,  p, ldp, vl, ldvl, vr, ldvr, mm, m, work, info);
}

template< typename T, typename Ta >
integer tgevc(char* side, char* howmny,  logical* select, integer* n,  T* s, integer* lds,  T* p, integer* ldp, T* vl, integer* ldvl, T* vr, integer* ldvr, integer* mm, integer* m, T* work, Ta* rwork, integer* info)
{
  return tgevc(side, howmny,  select, n,  s, lds,  p, ldp, vl, ldvl, vr, ldvr, mm, m, work, rwork, info);
}
/*! @brief TGEXC reorders the generalized real Schur decomposition of a real matrix pair

 * @details
 * \b Purpose:
    \verbatim 
     TGEXC reorders the generalized real Schur decomposition of a real
     matrix pair (A,B) using an orthogonal equivalence transformation

                    (A, B) = Q * (A, B) * Z**T,

     so that the diagonal block of (A, B) with row index IFST is moved
     to row ILST.

     (A, B) must be in generalized real Schur canonical form (as returned
     by SGGES), i.e. A is block upper triangular with 1-by-1 and 2-by-2
     diagonal blocks. B is upper triangular.

     Optionally, the matrices Q and Z of generalized Schur vectors are
     updated.

            Q(in) * A(in) * Z(in)**T = Q(out) * A(out) * Z(out)**T
            Q(in) * B(in) * Z(in)**T = Q(out) * B(out) * Z(out)**T
    \endverbatim 

 * @param[in] WANTQ
          WANTQ is LOGICAL \n
          .TRUE. : update the left transformation matrix Q; \n
          .FALSE.: do not update Q. \n
 * @param[in] WANTZ
          WANTZ is LOGICAL \n
          .TRUE. : update the right transformation matrix Z; \n
          .FALSE.: do not update Z. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrices A and B. N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the matrix A in generalized real Schur canonical
          form. \n
          On exit, the updated matrix A, again in generalized
          real Schur canonical form. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A. LDA >= max(1,N). \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,N) \n
          On entry, the matrix B in generalized real Schur canonical
          form (A,B). \n
          On exit, the updated matrix B, again in generalized
          real Schur canonical form (A,B). \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B. LDB >= max(1,N). \n
 * @param[in,out] Q
          Q is REAL array, dimension (LDQ,N) \n
          On entry, if WANTQ = .TRUE., the orthogonal matrix Q.
          On exit, the updated matrix Q. \n
          If WANTQ = .FALSE., Q is not referenced. \n
 * @param[in] LDQ
          LDQ is INTEGER \n
          The leading dimension of the array Q. LDQ >= 1.
          If WANTQ = .TRUE., LDQ >= N. \n
 * @param[in,out] Z
          Z is REAL array, dimension (LDZ,N) \n
          On entry, if WANTZ = .TRUE., the orthogonal matrix Z.
          On exit, the updated matrix Z. \n
          If WANTZ = .FALSE., Z is not referenced. \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of the array Z. LDZ >= 1.
          If WANTZ = .TRUE., LDZ >= N. \n
 * @param[in,out] IFST
          IFST is INTEGER \n
 * @param[in,out] ILST
          ILST is INTEGER \n
          Specify the reordering of the diagonal blocks of (A, B).
          The block with row index IFST is moved to row ILST, by a
          sequence of swapping between adjacent blocks.
          On exit, if IFST pointed on entry to the second row of
          a 2-by-2 block, it is changed to point to the first row;
          ILST always points to the first row of the block in its
          final position (which may differ from its input value by
          +1 or -1). 1 <= IFST, ILST <= N. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK.
          LWORK >= 1 when N <= 1, otherwise LWORK >= 4*N + 16. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
           =0:  successful exit. \n
           <0:  if INFO = -i, the i-th argument had an illegal value. \n
           =1:  The transformed matrix pair (A, B) would be too far
                from generalized Schur form; the problem is ill-
                conditioned. (A, B) may have been partially reordered,
                and ILST points to the first row of the current
                position of the block being moved. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer tgexc(logical* wantq, logical* wantz, integer* n, T* a, integer* lda, T* b, integer* ldb, T* q, integer* ldq, T* z, integer* ldz, integer* ifst, integer* ilst, integer* info)
{
  return tgexc(wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, ifst, ilst, info);
}

template< typename T, typename Ta >
integer tgexc(logical* wantq, logical* wantz, integer* n, T* a, integer* lda, T* b, integer* ldb, T* q, integer* ldq, T* z, integer* ldz, integer* ifst, integer* ilst, Ta* work, integer* lwork, integer* info)
{
  return tgexc(wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, ifst, ilst, work, lwork, info);
}

/*! @brief TGSEN reorders the generalized real Schur decomposition of a real matrix pair

 * @details
 * \b Purpose:
    \verbatim 
     TGSEN reorders the generalized real Schur decomposition of a real
     matrix pair (A, B) (in terms of an orthonormal equivalence trans-
     formation Q**T * (A, B) * Z), so that a selected cluster of eigenvalues
     appears in the leading diagonal blocks of the upper quasi-triangular
     matrix A and the upper triangular B. The leading columns of Q and
     Z form orthonormal bases of the corresponding left and right eigen-
     spaces (deflating subspaces). (A, B) must be in generalized real
     Schur canonical form (as returned by SGGES), i.e. A is block upper
     triangular with 1-by-1 and 2-by-2 diagonal blocks. B is upper
     triangular.

     STGSEN also computes the generalized eigenvalues

                 w(j) = (ALPHAR(j) + i*ALPHAI(j))/BETA(j)

     of the reordered matrix pair (A, B).

     Optionally, STGSEN computes the estimates of reciprocal condition
     numbers for eigenvalues and eigenspaces. These are Difu[(A11,B11),
     (A22,B22)] and Difl[(A11,B11), (A22,B22)], i.e. the separation(s)
     between the matrix pairs (A11, B11) and (A22,B22) that correspond to
     the selected cluster and the eigenvalues outside the cluster, resp.,
     and norms of "projections" onto left and right eigenspaces w.r.t.
     the selected cluster in the (1,1)-block.
    \endverbatim  

 * @param[in] IJOB
          IJOB is INTEGER \n
          Specifies whether condition numbers are required for the
          cluster of eigenvalues (PL and PR) or the deflating subspaces
          (Difu and Difl): \n
           =0: Only reorder w.r.t. SELECT. No extras. \n
           =1: Reciprocal of norms of "projections" onto left and right
               eigenspaces w.r.t. the selected cluster (PL and PR). \n
           =2: Upper bounds on Difu and Difl. F-norm-based estimate
               (DIF(1:2)). \n
           =3: Estimate of Difu and Difl. 1-norm-based estimate
               (DIF(1:2)).
               About 5 times as expensive as IJOB = 2. \n
           =4: Compute PL, PR and DIF (i.e. 0, 1 and 2 above): Economic
               version to get it all. \n
           =5: Compute PL, PR and DIF (i.e. 0, 1 and 3 above) \n
 * @param[in] WANTQ
          WANTQ is LOGICAL \n
          .TRUE. : update the left transformation matrix Q; \n
          .FALSE.: do not update Q. \n
 * @param[in] WANTZ
          WANTZ is LOGICAL \n
          .TRUE. : update the right transformation matrix Z; \n
          .FALSE.: do not update Z. \n
 * @param[in] SELECT
          SELECT is LOGICAL array, dimension (N) \n
          SELECT specifies the eigenvalues in the selected cluster.
          To select a real eigenvalue w(j), SELECT(j) must be set to
          .TRUE.. To select a complex conjugate pair of eigenvalues
          w(j) and w(j+1), corresponding to a 2-by-2 diagonal block,
          either SELECT(j) or SELECT(j+1) or both must be set to
          .TRUE.; a complex conjugate pair of eigenvalues must be
          either both included in the cluster or both excluded. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrices A and B. N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension(LDA,N) \n
          On entry, the upper quasi-triangular matrix A, with (A, B) in
          generalized real Schur canonical form.
          On exit, A is overwritten by the reordered matrix A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A. LDA >= max(1,N). \n
 * @param[in,out] B
          B is REAL array, dimension(LDB,N) \n
          On entry, the upper triangular matrix B, with (A, B) in
          generalized real Schur canonical form. \n
          On exit, B is overwritten by the reordered matrix B. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B. LDB >= max(1,N). \n
 * @param[out] ALPHAR
          ALPHAR is REAL array, dimension (N) \n
 * @param[out] ALPHAI
          ALPHAI is REAL array, dimension (N) \n
 * @param[out] BETA
          BETA is REAL array, dimension (N) \n
          On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will
          be the generalized eigenvalues.  ALPHAR(j) + ALPHAI(j)*i
          and BETA(j),j=1,...,N  are the diagonals of the complex Schur
          form (S,T) that would result if the 2-by-2 diagonal blocks of
          the real generalized Schur form of (A,B) were further reduced
          to triangular form using complex unitary transformations.
          If ALPHAI(j) is zero, then the j-th eigenvalue is real; if
          positive, then the j-th and (j+1)-st eigenvalues are a
          complex conjugate pair, with ALPHAI(j+1) negative. \n
 * @param[in,out] Q
          Q is REAL array, dimension (LDQ,N) \n
          On entry, if WANTQ = .TRUE., Q is an N-by-N matrix. \n
          On exit, Q has been postmultiplied by the left orthogonal
          transformation matrix which reorder (A, B); The leading M
          columns of Q form orthonormal bases for the specified pair of
          left eigenspaces (deflating subspaces). \n
          If WANTQ = .FALSE., Q is not referenced. \n
 * @param[in] LDQ
          LDQ is INTEGER \n
          The leading dimension of the array Q.  LDQ >= 1; \n
          and if WANTQ = .TRUE., LDQ >= N. \n
 * @param[in,out] Z
          Z is REAL array, dimension (LDZ,N) \n
          On entry, if WANTZ = .TRUE., Z is an N-by-N matrix. \n
          On exit, Z has been postmultiplied by the left orthogonal
          transformation matrix which reorder (A, B); The leading M
          columns of Z form orthonormal bases for the specified pair of
          left eigenspaces (deflating subspaces). \n
          If WANTZ = .FALSE., Z is not referenced. \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of the array Z. LDZ >= 1;
          If WANTZ = .TRUE., LDZ >= N. \n
 * @param[out] M
          M is INTEGER \n
          The dimension of the specified pair of left and right eigen-
          spaces (deflating subspaces). 0 <= M <= N. \n
 * @param[out] PL
          PL is REAL \n
 * @param[out] PR
          PR is REAL \n
          If IJOB = 1, 4 or 5, PL, PR are lower bounds on the
          reciprocal of the norm of "projections" onto left and right
          eigenspaces with respect to the selected cluster. \n
          0 < PL, PR <= 1. \n
          If M = 0 or M = N, PL = PR  = 1. \n
          If IJOB = 0, 2 or 3, PL and PR are not referenced. \n
 * @param[out] DIF
          DIF is REAL array, dimension (2). \n
          If IJOB >= 2, DIF(1:2) store the estimates of Difu and Difl.
          If IJOB = 2 or 4, DIF(1:2) are F-norm-based upper bounds on
          Difu and Difl. If IJOB = 3 or 5, DIF(1:2) are 1-norm-based
          estimates of Difu and Difl. \n
          If M = 0 or N, DIF(1:2) = F-norm([A, B]). \n
          If IJOB = 0 or 1, DIF is not referenced. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK. LWORK >=  4*N+16. \n
          If IJOB = 1, 2 or 4, LWORK >= MAX(4*N+16, 2*M*(N-M)). \n
          If IJOB = 3 or 5, LWORK >= MAX(4*N+16, 4*M*(N-M)). \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (MAX(1,LIWORK)) \n
          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK. \n
 * @param[in]	LIWORK	
          LIWORK is INTEGER \n
          The dimension of the array IWORK. LIWORK >= 1. \n
          If IJOB = 1, 2 or 4, LIWORK >=  N+6. \n
          If IJOB = 3 or 5, LIWORK >= MAX(2*M*(N-M), N+6). \n
 \n
          If LIWORK = -1, then a workspace query is assumed; the
          routine only calculates the optimal size of the IWORK array,
          returns this value as the first entry of the IWORK array, and
          no error message related to LIWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
            =0: Successful exit. \n
            <0: If INFO = -i, the i-th argument had an illegal value. \n
            =1: Reordering of (A, B) failed because the transformed
                matrix pair (A, B) would be too far from generalized
                Schur form; the problem is very ill-conditioned.
                (A, B) may have been partially reordered.
                If requested, 0 is returned in DIF(*), PL and PR. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer tgsen(integer* ijob, logical* wantq, logical* wantz,  logical* select, integer* n, T* a, integer* lda, T* b, integer* ldb, T* alphar, T* alphai, T* beta, T* q, integer* ldq, T* z, integer* ldz, integer* m, T* pl, T* pr, T* dif, T* work, integer* lwork, integer* iwork, integer* liwork, integer* info)
{
  return tgsen(ijob, wantq, wantz, select, n, a, lda, b, ldb, alphar, alphai, beta, q, ldq, z, ldz, m, pl, pr, dif, work, lwork, iwork, liwork, info);
}
template< typename T, typename Ta >
integer tgsen(integer* ijob, logical* wantq, logical* wantz,  logical* select, integer* n, T* a, integer* lda, T* b, integer* ldb, T* alpha, T* beta, T* q, integer* ldq, T* z, integer* ldz, integer* m, Ta* pl, Ta* pr, Ta* dif, T* work, integer* lwork, integer* iwork, integer* liwork, integer* info)
{
  return tgsen(ijob, wantq, wantz, select, n, a, lda, b, ldb, alpha, beta, q, ldq, z, ldz, m, pl, pr, dif, work, lwork, iwork, liwork, info);
}

/*! @brief TGSJA computes the generalized singular value decomposition (GSVD)  \n
     of two real upper triangular (or trapezoidal) matrices A and B.

 * @details
 * \b Purpose:
    \verbatim 
     TGSJA computes the generalized singular value decomposition (GSVD)
     of two real upper triangular (or trapezoidal) matrices A and B.

     On entry, it is assumed that matrices A and B have the following
     forms, which may be obtained by the preprocessing subroutine SGGSVP
     from a general M-by-N matrix A and P-by-N matrix B:

                  N-K-L  K    L
        A =    K ( 0    A12  A13) if M-K-L >= 0;
               L ( 0     0   A23)
           M-K-L ( 0     0    0 )

                N-K-L  K    L
        A =  K ( 0    A12  A13) if M-K-L < 0;
           M-K ( 0     0   A23)

                N-K-L  K    L
        B =  L ( 0     0   B13)
           P-L ( 0     0    0 )

     where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
     upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,
     otherwise A23 is (M-K)-by-L upper trapezoidal.

     On exit,

            U**T *A*Q = D1*( 0 R),    V**T *B*Q = D2*( 0 R),

     where U, V and Q are orthogonal matrices.
     R is a nonsingular upper triangular matrix, and D1 and D2 are
     ``diagonal'' matrices, which are of the following structures:

     If M-K-L >= 0,

                         K  L
            D1 =     K ( I  0)
                     L ( 0  C)
                 M-K-L ( 0  0)

                       K  L
            D2 = L   ( 0  S)
                 P-L ( 0  0)

                    N-K-L  K    L
       ( 0 R) = K (  0   R11  R12) K
                 L (  0    0   R22) L

     where

       C = diag( ALPHA(K+1), ... , ALPHA(K+L)),
       S = diag( BETA(K+1),  ... , BETA(K+L)),
       C**2 + S**2 = I.

       R is stored in A(1:K+L,N-K-L+1:N) on exit.

     If M-K-L < 0,

                    K M-K K+L-M
         D1 =   K ( I  0    0  )
              M-K ( 0  C    0  )

                      K M-K K+L-M
         D2 =   M-K ( 0  S    0  )
              K+L-M ( 0  0    I  )
                P-L ( 0  0    0  )

                    N-K-L  K   M-K  K+L-M
     ( 0 R) =    K ( 0    R11  R12  R13 )
               M-K ( 0     0   R22  R23 )
             K+L-M ( 0     0    0   R33 )

     where
     C = diag( ALPHA(K+1), ... , ALPHA(M)),
     S = diag( BETA(K+1),  ... , BETA(M)),
     C**2 + S**2 = I.

     R = ( R11 R12 R13) is stored in A(1:M, N-K-L+1:N) and R33 is stored
         (  0  R22 R23)
     in B(M-K+1:L,N+M-K-L+1:N) on exit.

     The computation of the orthogonal transformation matrices U, V or Q
     is optional.  These matrices may either be formed explicitly, or they
     may be postmultiplied into input matrices U1, V1, or Q1.
    \endverbatim  

 * @param[in] JOBU
          JOBU is CHARACTER*1 \n
          = 'U':  U must contain an orthogonal matrix U1 on entry, and
                  the product U1*U is returned; \n
          = 'I':  U is initialized to the unit matrix, and the
                  orthogonal matrix U is returned; \n
          = 'N':  U is not computed. \n
 * @param[in] JOBV
          JOBV is CHARACTER*1 \n
          = 'V':  V must contain an orthogonal matrix V1 on entry, and
                  the product V1*V is returned; \n
          = 'I':  V is initialized to the unit matrix, and the
                  orthogonal matrix V is returned; \n
          = 'N':  V is not computed. \n
 * @param[in] JOBQ
          JOBQ is CHARACTER*1 \n
          = 'Q':  Q must contain an orthogonal matrix Q1 on entry, and
                  the product Q1*Q is returned; \n
          = 'I':  Q is initialized to the unit matrix, and the
                  orthogonal matrix Q is returned; \n
          = 'N':  Q is not computed. \n
 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M >= 0. \n
 * @param[in] P
          P is INTEGER \n
          The number of rows of the matrix B.  P >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrices A and B.  N >= 0. \n
 * @param[in] K
          K is INTEGER \n
 * @param[in] L
          L is INTEGER \n
          K and L specify the subblocks in the input matrices A and B:
          A23 = A(K+1:MIN(K+L,M),N-L+1:N) and B13 = B(1:L,N-L+1:N)
          of A and B, whose GSVD is going to be computed by STGSJA.
          See Further Details. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the M-by-N matrix A.
          On exit, A(N-K+1:N,1:MIN(K+L,M)) contains the triangular
          matrix R or part of R.  See Purpose for details. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A. LDA >= max(1,M). \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,N) \n
          On entry, the P-by-N matrix B.
          On exit, if necessary, B(M-K+1:L,N+M-K-L+1:N) contains
          a part of R.  See Purpose for details. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B. LDB >= max(1,P). \n
 * @param[in] TOLA
          TOLA is REAL \n
 * @param[in] TOLB
          TOLB is REAL \n
          TOLA and TOLB are the convergence criteria for the Jacobi-
          Kogbetliantz iteration procedure. Generally, they are the
          same as used in the preprocessing step, say \n
              TOLA = max(M,N)*norm(A)*MACHEPS, \n
              TOLB = max(P,N)*norm(B)*MACHEPS. \n
 * @param[out] ALPHA
          ALPHA is REAL array, dimension (N) \n
 * @param[out] BETA
          BETA is REAL array, dimension (N) \n
          On exit, ALPHA and BETA contain the generalized singular
          value pairs of A and B; \n
            ALPHA(1:K) = 1, \n
            BETA(1:K)  = 0, \n
          and if M-K-L >= 0, \n
            ALPHA(K+1:K+L) = diag(C), \n
            BETA(K+1:K+L)  = diag(S), \n
          or if M-K-L < 0, \n
            ALPHA(K+1:M)= C, ALPHA(M+1:K+L)= 0 \n
            BETA(K+1:M) = S, BETA(M+1:K+L) = 1. \n
          Furthermore, if K+L < N, \n
            ALPHA(K+L+1:N) = 0 and \n
            BETA(K+L+1:N)  = 0. \n
 * @param[in,out] U
          U is REAL array, dimension (LDU,M) \n
          On entry, if JOBU = 'U', U must contain a matrix U1 (usually
          the orthogonal matrix returned by SGGSVP). \n
          On exit, \n
          if JOBU = 'I', U contains the orthogonal matrix U; \n
          if JOBU = 'U', U contains the product U1*U. \n
          If JOBU = 'N', U is not referenced. \n
 * @param[in] LDU
          LDU is INTEGER \n
          The leading dimension of the array U. LDU >= max(1,M) if
          JOBU = 'U'; LDU >= 1 otherwise. \n
 * @param[in,out] V
          V is REAL array, dimension (LDV,P) \n
          On entry, if JOBV = 'V', V must contain a matrix V1 (usually
          the orthogonal matrix returned by SGGSVP). \n
          On exit, \n
          if JOBV = 'I', V contains the orthogonal matrix V; \n
          if JOBV = 'V', V contains the product V1*V. \n
          If JOBV = 'N', V is not referenced. \n
 * @param[in] LDV
          LDV is INTEGER \n
          The leading dimension of the array V. LDV >= max(1,P) if
          JOBV = 'V'; LDV >= 1 otherwise. \n
 * @param[in,out] Q
          Q is REAL array, dimension (LDQ,N) \n
          On entry, if JOBQ = 'Q', Q must contain a matrix Q1 (usually
          the orthogonal matrix returned by SGGSVP). \n
          On exit, \n
          if JOBQ = 'I', Q contains the orthogonal matrix Q; \n
          if JOBQ = 'Q', Q contains the product Q1*Q. \n
          If JOBQ = 'N', Q is not referenced. \n
 * @param[in] LDQ
          LDQ is INTEGER \n
          The leading dimension of the array Q. LDQ >= max(1,N) if
          JOBQ = 'Q'; LDQ >= 1 otherwise. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (2*N) \n
 * @param[out]	NCYCLE	
          NCYCLE is INTEGER \n
          The number of cycles required for convergence. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n
          = 1:  the procedure does not converge after MAXIT cycles. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer tgsja(char* jobu, char* jobv, char* jobq, integer* m, integer* p, integer* n, integer* k, integer* l, T* a, integer* lda, T* b, integer* ldb, T* tola, T* tolb, T* alpha, T* beta, T* u, integer* ldu, T* v, integer* ldv, T* q, integer* ldq, T* work, integer* ncycle, integer* info)
{
  return tgsja(jobu, jobv, jobq, m, p, n, k, l, a, lda, b, ldb, tola, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, work, ncycle, info);
}
template< typename T, typename Ta >
integer tgsja(char* jobu, char* jobv, char* jobq, integer* m, integer* p, integer* n, integer* k, integer* l, T* a, integer* lda, T* b, integer* ldb, Ta* tola, Ta* tolb, Ta* alpha, Ta* beta, T* u, integer* ldu, T* v, integer* ldv, T* q, integer* ldq, T* work, integer* ncycle, integer* info)
{
  return tgsja(jobu, jobv, jobq, m, p, n, k, l, a, lda, b, ldb, tola, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, work, ncycle, info);
}

/*! @brief TGSNA estimates reciprocal condition numbers for specified  \n
     eigenvalues and/or eigenvectors of a matrix pair
 * @details
 * \b Purpose:
    \verbatim 
     TGSNA estimates reciprocal condition numbers for specified
     eigenvalues and/or eigenvectors of a matrix pair (A, B) in
     generalized real Schur canonical form (or of any matrix pair
     (Q*A*Z**T, Q*B*Z**T) with orthogonal matrices Q and Z, where
     Z**T denotes the transpose of Z.

     (A, B) must be in generalized real Schur form (as returned by SGGES),
     i.e. A is block upper triangular with 1-by-1 and 2-by-2 diagonal
     blocks. B is upper triangular.
    \endverbatim 

 * @param[in] JOB
          JOB is CHARACTER*1 \n
          Specifies whether condition numbers are required for
          eigenvalues (S) or eigenvectors (DIF): \n
          = 'E': for eigenvalues only (S); \n
          = 'V': for eigenvectors only (DIF); \n
          = 'B': for both eigenvalues and eigenvectors (S and DIF). \n
 * @param[in] HOWMNY
          HOWMNY is CHARACTER*1 \n
          = 'A': compute condition numbers for all eigenpairs; \n
          = 'S': compute condition numbers for selected eigenpairs
                 specified by the array SELECT. \n
 * @param[in] SELECT
          SELECT is LOGICAL array, dimension (N) \n
          If HOWMNY = 'S', SELECT specifies the eigenpairs for which
          condition numbers are required. To select condition numbers
          for the eigenpair corresponding to a real eigenvalue w(j),
          SELECT(j) must be set to .TRUE.. To select condition numbers
          corresponding to a complex conjugate pair of eigenvalues w(j)
          and w(j+1), either SELECT(j) or SELECT(j+1) or both, must be
          set to .TRUE.. \n
          If HOWMNY = 'A', SELECT is not referenced. \n
 * @param[in] N
          N is INTEGER \n
          The order of the square matrix pair (A, B). N >= 0. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          The upper quasi-triangular matrix A in the pair (A,B). \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A. LDA >= max(1,N). \n
 * @param[in] B
          B is REAL array, dimension (LDB,N) \n
          The upper triangular matrix B in the pair (A,B). \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B. LDB >= max(1,N). \n
 * @param[in] VL
          VL is REAL array, dimension (LDVL,M) \n
          If JOB = 'E' or 'B', VL must contain left eigenvectors of
          (A, B), corresponding to the eigenpairs specified by HOWMNY
          and SELECT. The eigenvectors must be stored in consecutive
          columns of VL, as returned by STGEVC. \n
          If JOB = 'V', VL is not referenced. \n
 * @param[in] LDVL
          LDVL is INTEGER \n
          The leading dimension of the array VL. LDVL >= 1.
          If JOB = 'E' or 'B', LDVL >= N. \n
 * @param[in] VR
          VR is REAL array, dimension (LDVR,M) \n
          If JOB = 'E' or 'B', VR must contain right eigenvectors of
          (A, B), corresponding to the eigenpairs specified by HOWMNY
          and SELECT. The eigenvectors must be stored in consecutive
          columns ov VR, as returned by STGEVC. \n
          If JOB = 'V', VR is not referenced. \n
 * @param[in] LDVR
          LDVR is INTEGER \n
          The leading dimension of the array VR. LDVR >= 1.
          If JOB = 'E' or 'B', LDVR >= N. \n
 * @param[out] S
          S is REAL array, dimension (MM) \n
          If JOB = 'E' or 'B', the reciprocal condition numbers of the
          selected eigenvalues, stored in consecutive elements of the
          array. For a complex conjugate pair of eigenvalues two
          consecutive elements of S are set to the same value. Thus
          S(j), DIF(j), and the j-th columns of VL and VR all
          correspond to the same eigenpair (but not in general the
          j-th eigenpair, unless all eigenpairs are selected). \n
          If JOB = 'V', S is not referenced. \n
 * @param[out] DIF
          DIF is REAL array, dimension (MM) \n
          If JOB = 'V' or 'B', the estimated reciprocal condition
          numbers of the selected eigenvectors, stored in consecutive
          elements of the array. For a complex eigenvector two
          consecutive elements of DIF are set to the same value. If
          the eigenvalues cannot be reordered to compute DIF(j), DIF(j)
          is set to 0; this can only occur when the true value would be
          very small anyway. \n
          If JOB = 'E', DIF is not referenced. \n
 * @param[in] MM
          MM is INTEGER \n
          The number of elements in the arrays S and DIF. MM >= M. \n
 * @param[out] M
          M is INTEGER \n
          The number of elements of the arrays S and DIF used to store
          the specified condition numbers; for each selected real
          eigenvalue one element is used, and for each selected complex
          conjugate pair of eigenvalues, two elements are used.
          If HOWMNY = 'A', M is set to N. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK. LWORK >= max(1,N).
          If JOB = 'V' or 'B' LWORK >= 2*N*(N+2)+16. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (N + 6)
          If JOB = 'E', IWORK is not referenced. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          =0: Successful exit \n
          <0: If INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer tgsna(char* job, char* howmny,  logical* select, integer* n,  T* a, integer* lda,  T* b, integer* ldb,  T* vl, integer* ldvl,  T* vr, integer* ldvr, T* s, T* dif, integer* mm, integer* m, T* work, integer* lwork, integer* iwork, integer* info)
{
  return tgsna(job, howmny, select, n, a, lda, b, ldb, vl, ldvl, vr, ldvr, s, dif, mm, m, work, lwork, iwork, info);
}
template< typename T, typename Ta >
integer tgsna(char* job, char* howmny,  logical* select, integer* n,  T* a, integer* lda,  T* b, integer* ldb,  T* vl, integer* ldvl,  T* vr, integer* ldvr, Ta* s, Ta* dif, integer* mm, integer* m, T* work, integer* lwork, integer* iwork, integer* info)
{
  return tgsna(job, howmny, select, n, a, lda, b, ldb, vl, ldvl, vr, ldvr, s, dif, mm, m, work, lwork, iwork, info);
}

/*! @brief TGSYL solves the generalized Sylvester equation

 * @details
 * \b Purpose:
    \verbatim 
     TGSYL solves the generalized Sylvester equation:

                 A * R - L * B = scale * C                 (1)
                 D * R - L * E = scale * F

     where R and L are unknown m-by-n matrices, (A, D), (B, E) and
     (C, F) are given matrix pairs of size m-by-m, n-by-n and m-by-n,
     respectively, with real entries. (A, D) and (B, E) must be in
     generalized (real) Schur canonical form, i.e. A, B are upper quasi
     triangular and D, E are upper triangular.

     The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1 is an output
     scaling factor chosen to avoid overflow.

     In matrix notation (1) is equivalent to solve  Zx = scale b, where
     Z is defined as

                Z = [ kron(In, A)  -kron(B**T, Im) ]         (2)
                    [ kron(In, D)  -kron(E**T, Im) ].

     Here Ik is the identity matrix of size k and X**T is the transpose of
     X. kron(X, Y) is the Kronecker product between the matrices X and Y.

     If TRANS = 'T', STGSYL solves the transposed system Z**T*y = scale*b,
     which is equivalent to solve for R and L in

                 A**T * R + D**T * L = scale * C           (3)
                 R * B**T + L * E**T = scale * -F

     This case (TRANS = 'T') is used to compute an one-norm-based estimate
     of Dif[(A,D), (B,E)], the separation between the matrix pairs (A,D)
     and (B,E), using SLACON.

     If IJOB >= 1, STGSYL computes a Frobenius norm-based estimate
     of Dif[(A,D),(B,E)]. That is, the reciprocal of a lower bound on the
     reciprocal of the smallest singular value of Z. See [1-2] for more
     information.

     This is a level 3 BLAS algorithm.
    \endverbatim  

 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          = 'N': solve the generalized Sylvester equation (1).
          = 'T': solve the 'transposed' system (3). \n
 * @param[in] IJOB
          IJOB is INTEGER \n
          Specifies what kind of functionality to be performed. \n
          = 0: solve (1) only. \n
          = 1: The functionality of 0 and 3. \n
          = 2: The functionality of 0 and 4. \n
          = 3: Only an estimate of Dif[(A,D), (B,E)] is computed.
               (look ahead strategy IJOB  = 1 is used). \n
          = 4: Only an estimate of Dif[(A,D), (B,E)] is computed.
               ( SGECON on sub-systems is used). \n
          Not referenced if TRANS = 'T'. \n
 * @param[in] M
          M is INTEGER \n
          The order of the matrices A and D, and the row dimension of
          the matrices C, F, R and L. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrices B and E, and the column dimension
          of the matrices C, F, R and L. \n
 * @param[in] A
          A is REAL array, dimension (LDA, M) \n
          The upper quasi triangular matrix A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A. LDA >= max(1, M). \n
 * @param[in] B
          B is REAL array, dimension (LDB, N) \n
          The upper quasi triangular matrix B. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B. LDB >= max(1, N). \n
 * @param[in,out] C
          C is REAL array, dimension (LDC, N) \n
          On entry, C contains the right-hand-side of the first matrix
          equation in (1) or (3). \n
          On exit, if IJOB = 0, 1 or 2, C has been overwritten by
          the solution R. If IJOB = 3 or 4 and TRANS = 'N', C holds R,
          the solution achieved during the computation of the
          Dif-estimate. \n
 * @param[in] LDC
          LDC is INTEGER \n
          The leading dimension of the array C. LDC >= max(1, M). \n
 * @param[in] D
          D is REAL array, dimension (LDD, M) \n
          The upper triangular matrix D. \n
 * @param[in] LDD
          LDD is INTEGER \n
          The leading dimension of the array D. LDD >= max(1, M). \n
 * @param[in] E
          E is REAL array, dimension (LDE, N) \n
          The upper triangular matrix E. \n
 * @param[in] LDE
          LDE is INTEGER \n
          The leading dimension of the array E. LDE >= max(1, N). \n
 * @param[in,out] F
          F is REAL array, dimension (LDF, N) \n
          On entry, F contains the right-hand-side of the second matrix
          equation in (1) or (3). \n
          On exit, if IJOB = 0, 1 or 2, F has been overwritten by
          the solution L. If IJOB = 3 or 4 and TRANS = 'N', F holds L,
          the solution achieved during the computation of the
          Dif-estimate. \n
 * @param[in] LDF
          LDF is INTEGER \n
          The leading dimension of the array F. LDF >= max(1, M). \n
 * @param[out] DIF
          DIF is REAL \n
          On exit DIF is the reciprocal of a lower bound of the
          reciprocal of the Dif-function, i.e. DIF is an upper bound of
          Dif[(A,D), (B,E)] = sigma_min(Z), where Z as in (2).
          IF IJOB = 0 or TRANS = 'T', DIF is not touched. \n
 * @param[out] SCALE
          SCALE is REAL \n
          On exit SCALE is the scaling factor in (1) or (3).
          If 0 < SCALE < 1, C and F hold the solutions R and L, resp.,
          to a slightly perturbed system but the input matrices A, B, D
          and E have not been changed. If SCALE = 0, C and F hold the
          solutions R and L, respectively, to the homogeneous system
          with C = F = 0. Normally, SCALE = 1. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK. LWORK > = 1.
          If IJOB = 1 or 2 and TRANS = 'N', LWORK >= max(1,2*M*N). \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (M+N+6) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
            =0: successful exit \n
            <0: If INFO = -i, the i-th argument had an illegal value. \n
            >0: (A, D) and (B, E) have common or close eigenvalues. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer tgsyl(char* trans, integer* ijob, integer* m, integer* n,  T* a, integer* lda,  T* b, integer* ldb, T* c, integer* ldc,  T* d, integer* ldd,  T* e, integer* lde, T* f, integer* ldf, T* scale, T* dif, T* work, integer* lwork, integer* iwork, integer* info)
{
  return tgsyl(trans, ijob, m, n,  a, lda,  b, ldb, c, ldc,  d, ldd,  e, lde, f, ldf, scale, dif, work, lwork, iwork, info);
}
template< typename T, typename Ta >
integer tgsyl(char* trans, integer* ijob, integer* m, integer* n,  T* a, integer* lda,  T* b, integer* ldb, T* c, integer* ldc,  T* d, integer* ldd,  T* e, integer* lde, T* f, integer* ldf, Ta* scale, Ta* dif, T* work, integer* lwork, integer* iwork, integer* info)
{
  return tgsyl(trans, ijob, m, n,  a, lda,  b, ldb, c, ldc,  d, ldd,  e, lde, f, ldf, scale, dif, work, lwork, iwork, info);
}

/*! @brief TPCON estimates the reciprocal of the condition number of a packed
    triangular matrix A
 * @details
 * \b Purpose:
    \verbatim 
     TPCON estimates the reciprocal of the condition number of a packed
     triangular matrix A, in either the 1-norm or the infinity-norm.

     The norm of A is computed and an estimate is obtained for
     norm(inv(A)), then the reciprocal of the condition number is
     computed as
        RCOND = 1 / ( norm(A) * norm(inv(A))).
    \endverbatim 

 * @param[in] NORM
          NORM is CHARACTER*1 \n
          Specifies whether the 1-norm condition number or the
          infinity-norm condition number is required: \n
          = '1' or 'O':  1-norm; \n
          = 'I':         Infinity-norm. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  A is upper triangular; \n
          = 'L':  A is lower triangular. \n
 * @param[in] DIAG
          DIAG is CHARACTER*1 \n
          = 'N':  A is non-unit triangular; \n
          = 'U':  A is unit triangular. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] AP
          AP is REAL array, dimension (N*(N+1)/2) \n
          The upper or lower triangular matrix A, packed columnwise in
          a linear array.  The j-th column of A is stored in the array
          AP as follows: \n
          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j; \n
          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n. \n
          If DIAG = 'U', the diagonal elements of A are not referenced
          and are assumed to be 1. \n
 * @param[out] RCOND
          RCOND is REAL \n
          The reciprocal of the condition number of the matrix A,
          computed as RCOND = 1/(norm(A) * norm(inv(A))). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (3*N) \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer tpcon(char* norm, char* uplo, char* diag, integer* n,  T* ap, T* rcond, T* work, integer* iwork, integer* info)
{
  return tpcon(norm, uplo, diag, n, ap, rcond, work, iwork, info);
}
template< typename T, typename Ta >
integer tpcon(char* norm, char* uplo, char* diag, integer* n,  T* ap, Ta* rcond, T* work, Ta* rwork, integer* info)
{
  return tpcon(norm, uplo, diag, n, ap, rcond, work, rwork, info);
}

/*! @brief TPMQRT applies a real orthogonal matrix Q obtained from a   \n
     triangular-pentagonal
 * @details
 * \b Purpose:
    \verbatim 
    TPMQRT applies a real orthogonal matrix Q obtained from a
    "triangular-pentagonal" real block reflector H to a general
    real matrix C, which consists of two blocks A and B.
    \endverbatim  

 * @param[in] SIDE
          SIDE is CHARACTER*1 \n
          = 'L': apply Q or Q^T from the Left; \n
          = 'R': apply Q or Q^T from the Right. \n
 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          = 'N':  No transpose, apply Q; \n
          = 'T':  Transpose, apply Q^T. \n
 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix B. M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix B. N >= 0. \n
 * @param[in] K
          K is INTEGER \n
          The number of elementary reflectors whose product defines
          the matrix Q. \n
 * @param[in] L
          L is INTEGER \n
          The order of the trapezoidal part of V.
          K >= L >= 0.  See Further Details. \n
 * @param[in] NB
          NB is INTEGER \n
          The block size used for the storage of T.  K >= NB >= 1.
          This must be the same value of NB used to generate T
          in CTPQRT. \n
 * @param[in] V
          V is REAL array, dimension (LDV,K) \n
          The i-th column must contain the vector which defines the
          elementary reflector H(i), for i = 1,2,...,k, as returned by
          CTPQRT in B.  See Further Details. \n
 * @param[in] LDV
          LDV is INTEGER \n
          The leading dimension of the array V. \n
          If SIDE = 'L', LDV >= max(1,M); \n
          if SIDE = 'R', LDV >= max(1,N). \n
 * @param[in] T
          T is REAL array, dimension (LDT,K) \n
          The upper triangular factors of the block reflectors
          as returned by CTPQRT, stored as a NB-by-K matrix. \n
 * @param[in] LDT
          LDT is INTEGER \n
          The leading dimension of the array T.  LDT >= NB. \n
 * @param[in,out] A
          A is REAL array, dimension \n
          (LDA,N) if SIDE = 'L' or \n
          (LDA,K) if SIDE = 'R' \n
          On entry, the K-by-N or M-by-K matrix A.
          On exit, A is overwritten by the corresponding block of
          Q*C or Q^T*C or C*Q or C*Q^T.  See Further Details. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A \n
          If SIDE = 'L', LDC >= max(1,K); \n
          If SIDE = 'R', LDC >= max(1,M). \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,N) \n
          On entry, the M-by-N matrix B. \n
          On exit, B is overwritten by the corresponding block of
          Q*C or Q^T*C or C*Q or C*Q^T.  See Further Details. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.
          LDB >= max(1,M). \n
 * @param[out]	WORK	
          WORK is REAL array. The dimension of WORK is
           N*NB if SIDE = 'L', or  M*NB if SIDE = 'R'. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer tpmqrt(char* side, char* trans, integer* m, integer* n, integer* k, integer* l, integer* nb,  T* v, integer* ldv,  T* t, integer* ldt, T* a, integer* lda, T* b, integer* ldb, T* work, integer* info)
{
  return tpmqrt(side, trans, m, n, k, l, nb,  v, ldv,  t, ldt, a, lda, b, ldb, work, info);
}

/*! @brief TPQRT computes a blocked QR factorization of a real
     triangular-pentagonal matrix
 * @details
 * \b Purpose:
    \verbatim 
     TPQRT computes a blocked QR factorization of a real
     "triangular-pentagonal" matrix C, which is composed of a
     triangular block A and pentagonal block B, using the compact
     WY representation for Q.
    \endverbatim  

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix B. \n
          M >= 0.
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix B, and the order of the
          triangular matrix A.
          N >= 0. \n
 * @param[in] L
          L is INTEGER \n
          The number of rows of the upper trapezoidal part of B.
          MIN(M,N) >= L >= 0.  See Further Details. \n
 * @param[in] NB
          NB is INTEGER \n
          The block size to be used in the blocked QR.  N >= NB >= 1. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the upper triangular N-by-N matrix A.
          On exit, the elements on and above the diagonal of the array
          contain the upper triangular matrix R. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,N) \n
          On entry, the pentagonal M-by-N matrix B.  The first M-L rows
          are rectangular, and the last L rows are upper trapezoidal. \n
          On exit, B contains the pentagonal matrix V.  See Further Details. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,M). \n
 * @param[out] T
          T is REAL array, dimension (LDT,N) \n
          The upper triangular block reflectors stored in compact form
          as a sequence of upper triangular blocks.  See Further Details. \n
 * @param[in] LDT
          LDT is INTEGER \n
          The leading dimension of the array T.  LDT >= NB. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (NB*N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer tpqrt(integer* m, integer* n, integer* l, integer* nb, T* a, integer* lda, T* b, integer* ldb, T* t, integer* ldt, T* work, integer* info)
{
  return tpqrt(m, n, l, nb, a, lda, b, ldb, t, ldt, work, info);
}

/*! @brief TPQRT2 computes a QR factorization of a real or complex    \n
     "triangular-pentagonal" matrix, which is composed of a triangular block \n
     and a pentagonal block, using the compact WY representation for Q
 * @details
 * \b Purpose:
    \verbatim 
     TPQRT2 computes a QR factorization of a real "triangular-pentagonal"
     matrix C, which is composed of a triangular block A and pentagonal block B,
     using the compact WY representation for Q.
    \endverbatim  

 * @param[in] M
          M is INTEGER \n
          The total number of rows of the matrix B.
          M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix B, and the order of
          the triangular matrix A.
          N >= 0. \n
 * @param[in] L
          L is INTEGER \n
          The number of rows of the upper trapezoidal part of B.
          MIN(M,N) >= L >= 0.  See Further Details. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the upper triangular N-by-N matrix A.
          On exit, the elements on and above the diagonal of the array
          contain the upper triangular matrix R. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,N) \n
          On entry, the pentagonal M-by-N matrix B.  The first M-L rows
          are rectangular, and the last L rows are upper trapezoidal.
          On exit, B contains the pentagonal matrix V.  See Further Details. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,M). \n
 * @param[out] T
          T is REAL array, dimension (LDT,N) \n
          The N-by-N upper triangular factor T of the block reflector.
          See Further Details. \n
 * @param[in] LDT
          LDT is INTEGER \n
          The leading dimension of the array T.  LDT >= max(1,N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer tpqrt2(integer* m, integer* n, integer* l, T* a, integer* lda, T* b, integer* ldb, T* t, integer* ldt, integer* info)
{
  return tpqrt2(m, n, l, a, lda, b, ldb, t, ldt, info);
}

/*! @brief TPRFB applies a real or complex "triangular-pentagonal" blocked  \n
     reflector to a real or complex matrix, which is composed of two blocks.
 * @details
 * \b Purpose:
    \verbatim 
     TPRFB applies a real "triangular-pentagonal" block reflector H or its
     conjugate transpose H^H to a real matrix C, which is composed of two
     blocks A and B, either from the left or right.
    \endverbatim 
 
 * @param[in] SIDE
          SIDE is CHARACTER*1 \n
          = 'L': apply H or H^H from the Left \n
          = 'R': apply H or H^H from the Right \n
 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          = 'N': apply H (No transpose) \n
          = 'C': apply H^H (Conjugate transpose) \n
 * @param[in] DIRECT
          DIRECT is CHARACTER*1 \n
          Indicates how H is formed from a product of elementary
          reflectors \n
          = 'F': H = H(1) H(2) . . . H(k) (Forward) \n
          = 'B': H = H(k) . . . H(2) H(1) (Backward) \n
 * @param[in] STOREV
          STOREV is CHARACTER*1 \n
          Indicates how the vectors which define the elementary
          reflectors are stored: \n
          = 'C': Columns \n
          = 'R': Rows \n
 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix B.
          M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix B.
          N >= 0. \n
 * @param[in] K
          K is INTEGER \n
          The order of the matrix T, i.e. the number of elementary
          reflectors whose product defines the block reflector.
          K >= 0. \n
 * @param[in] L
          L is INTEGER \n
          The order of the trapezoidal part of V.
          K >= L >= 0.  See Further Details. \n
 * @param[in] V
          V is REAL array, dimension \n
                                (LDV,K) if STOREV = 'C' \n
                                (LDV,M) if STOREV = 'R' and SIDE = 'L' \n
                                (LDV,N) if STOREV = 'R' and SIDE = 'R' \n
          The pentagonal matrix V, which contains the elementary reflectors
          H(1), H(2), ..., H(K).  See Further Details. \n
 * @param[in] LDV
          LDV is INTEGER \n
          The leading dimension of the array V. \n
          If STOREV = 'C' and SIDE = 'L', LDV >= max(1,M); \n
          if STOREV = 'C' and SIDE = 'R', LDV >= max(1,N); \n
          if STOREV = 'R', LDV >= K. \n
 * @param[in] T
          T is REAL array, dimension (LDT,K) \n
          The triangular K-by-K matrix T in the representation of the
          block reflector. \n
 * @param[in] LDT
          LDT is INTEGER \n
          The leading dimension of the array T.
          LDT >= K. \n
 * @param[in,out] A
          A is REAL array, dimension
          (LDA,N) if SIDE = 'L' or (LDA,K) if SIDE = 'R' \n
          On entry, the K-by-N or M-by-K matrix A. \n
          On exit, A is overwritten by the corresponding block of
          H*C or H^H*C or C*H or C*H^H.  See Further Details. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A. \n
          If SIDE = 'L', LDA >= max(1,K); \n
          If SIDE = 'R', LDA >= max(1,M). \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,N) \n
          On entry, the M-by-N matrix B.
          On exit, B is overwritten by the corresponding block of
          H*C or H^H*C or C*H or C*H^H.  See Further Details. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.
          LDB >= max(1,M). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension \n
          (LDWORK,N) if SIDE = 'L', \n
          (LDWORK,K) if SIDE = 'R'. \n
 * @param[in]	LDWORK	
          LDWORK is INTEGER \n
          The leading dimension of the array WORK. \n
          If SIDE = 'L', LDWORK >= K; \n
          if SIDE = 'R', LDWORK >= M. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer tprfb(char* side, char* trans, char* direct, char* storev, integer* m, integer* n, integer* k, integer* l,  T* v, integer* ldv,  T* t, integer* ldt, T* a, integer* lda, T* b, integer* ldb, T* work, integer* ldwork)
{
  return tprfb(side, trans, direct, storev, m, n, k, l,  v, ldv,  t, ldt, a, lda, b, ldb, work, ldwork);
}

/*! @brief TPRFS provides error bounds and backward error estimates \n
     for the solution to a system of linear equations
 * @details
 * \b Purpose:
    \verbatim 
     TPRFS provides error bounds and backward error estimates for the
     solution to a system of linear equations with a triangular packed
     coefficient matrix.

     The solution matrix X must be computed by STPTRS or some other
     means before entering this routine.  STPRFS does not do iterative
     refinement because doing so cannot improve the backward error.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  A is upper triangular; \n
          = 'L':  A is lower triangular. \n
 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          Specifies the form of the system of equations: \n
          = 'N':  A * X = B  (No transpose) \n
          = 'T':  A**T * X = B  (Transpose) \n
          = 'C':  A**H * X = B  (Conjugate transpose = Transpose) \n
 * @param[in] DIAG
          DIAG is CHARACTER*1 \n
          = 'N':  A is non-unit triangular; \n
          = 'U':  A is unit triangular. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrices B and X.  NRHS >= 0. \n
 * @param[in] AP
          AP is REAL array, dimension (N*(N+1)/2) \n
          The upper or lower triangular matrix A, packed columnwise in
          a linear array.  The j-th column of A is stored in the array
          AP as follows: \n
          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j; \n
          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n. \n
          If DIAG = 'U', the diagonal elements of A are not referenced
          and are assumed to be 1. \n
 * @param[in] B
          B is REAL array, dimension (LDB,NRHS) \n
          The right hand side matrix B. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[in] X
          X is REAL array, dimension (LDX,NRHS) \n
          The solution matrix X. \n
 * @param[in] LDX
          LDX is INTEGER \n
          The leading dimension of the array X.  LDX >= max(1,N). \n
 * @param[out] FERR
          FERR is REAL array, dimension (NRHS) \n
          The estimated forward error bound for each solution vector
          X(j) (the j-th column of the solution matrix X). \n
          If XTRUE is the true solution corresponding to X(j), FERR(j)
          is an estimated upper bound for the magnitude of the largest
          element in (X(j) - XTRUE) divided by the magnitude of the
          largest element in X(j).  The estimate is as reliable as
          the estimate for RCOND, and is almost always a slight
          overestimate of the true error. \n
 * @param[out] BERR
          BERR is REAL array, dimension (NRHS) \n
          The componentwise relative backward error of each solution
          vector X(j) (i.e., the smallest relative change in
          any element of A or B that makes X(j) an exact solution). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (3*N) \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer tprfs(char* uplo, char* trans, char* diag, integer* n, integer* nrhs,  T* ap,  T* b, integer* ldb,  T* x, integer* ldx, T* ferr, T* berr, T* work, integer* iwork, integer* info)
{
  return tprfs(uplo, trans, diag, n, nrhs,  ap,  b, ldb,  x, ldx, ferr, berr, work, iwork, info);
}
template< typename T, typename Ta >
integer tprfs(char* uplo, char* trans, char* diag, integer* n, integer* nrhs,  T* ap,  T* b, integer* ldb,  T* x, integer* ldx, Ta* ferr, Ta* berr, T* work, Ta* rwork, integer* info)
{
  return tprfs(uplo, trans, diag, n, nrhs,  ap,  b, ldb,  x, ldx, ferr, berr, work, rwork, info);
}

/*! @brief TPTRI computes the inverse of a real upper or lower triangular \n
     matrix A
 * @details
 * \b Purpose:
    \verbatim 
     TPTRI computes the inverse of a real upper or lower triangular
     matrix A stored in packed format.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  A is upper triangular; \n
          = 'L':  A is lower triangular. \n
 * @param[in] DIAG
          DIAG is CHARACTER*1 \n
          = 'N':  A is non-unit triangular; \n
          = 'U':  A is unit triangular. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] AP
          AP is REAL array, dimension (N*(N+1)/2) \n
          On entry, the upper or lower triangular matrix A, stored
          columnwise in a linear array.  The j-th column of A is stored
          in the array AP as follows: \n
          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j; \n
          if UPLO = 'L', AP(i + (j-1)*((2*n-j)/2) = A(i,j) for j<=i<=n. \n
          See below for further details.
          On exit, the (triangular) inverse of the original matrix, in
          the same packed storage format. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, A(i,i) is exactly zero.  The triangular
                matrix is singular and its inverse can not be computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer tptri(char* uplo, char* diag, integer* n, T* ap, integer* info)
{
  return tptri(uplo, diag, n, ap, info);
}

/*! @brief TPTRS solves a triangular system of the form A * X = B  or  A**T * X = B

 * @details
 * \b Purpose:
    \verbatim 
     TPTRS solves a triangular system of the form

        A * X = B  or  A**T * X = B,

     where A is a triangular matrix of order N stored in packed format,
     and B is an N-by-NRHS matrix.  A check is made to verify that A is
     nonsingular.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  A is upper triangular; \n
          = 'L':  A is lower triangular. \n
 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          Specifies the form of the system of equations: \n
          = 'N':  A * X = B  (No transpose) \n
          = 'T':  A**T * X = B  (Transpose) \n
          = 'C':  A**H * X = B  (Conjugate transpose = Transpose) \n
 * @param[in] DIAG
          DIAG is CHARACTER*1 \n
          = 'N':  A is non-unit triangular; \n
          = 'U':  A is unit triangular. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in] AP
          AP is REAL array, dimension (N*(N+1)/2) \n
          The upper or lower triangular matrix A, packed columnwise in
          a linear array.  The j-th column of A is stored in the array
          AP as follows: \n
          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j; \n
          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n. \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,NRHS) \n
          On entry, the right hand side matrix B.
          On exit, if INFO = 0, the solution matrix X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, the i-th diagonal element of A is zero,
                indicating that the matrix is singular and the
                solutions X have not been computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer tptrs(char* uplo, char* trans, char* diag, integer* n, integer* nrhs,  T* ap, T* b, integer* ldb, integer* info)
{
  return tptrs(uplo, trans, diag, n, nrhs,  ap, b, ldb, info);
}

/*! @brief TPTTF copies a triangular matrix from the standard packed \n
     format (TP) to the rectangular full packed format (TF).
 * @details
 * \b Purpose:
    \verbatim 
     TPTTF copies a triangular matrix A from standard packed format (TP)
     to rectangular full packed format (TF).
    \endverbatim  

 * @param[in] TRANSR
          TRANSR is CHARACTER*1 \n
          = 'N':  ARF in Normal format is wanted; \n
          = 'T':  ARF in Conjugate-transpose format is wanted. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  A is upper triangular; \n
          = 'L':  A is lower triangular. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] AP
          AP is REAL array, dimension ( N*(N+1)/2), \n
          On entry, the upper or lower triangular matrix A, packed
          columnwise in a linear array. The j-th column of A is stored
          in the array AP as follows: \n
          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j; \n
          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n. \n
 * @param[out] ARF
          ARF is REAL array, dimension ( N*(N+1)/2), \n
          On exit, the upper or lower triangular matrix A stored in
          RFP format. For a further discussion see Notes below. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer tpttf(char* transr, char* uplo, integer* n,  T* ap, T* arf, integer* info)
{
  return tpttf(transr, uplo, n,  ap, arf, info);
}

/*! @brief TPTTR copies a triangular matrix from the standard    \n
     packed format (TP) to the standard full format (TR).
 * @details
 * \b Purpose:
    \verbatim 
     TPTTR copies a triangular matrix A from standard packed format (TP)
     to standard full format (TR).
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  A is upper triangular. \n
          = 'L':  A is lower triangular. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A. N >= 0. \n
 * @param[in] AP
          AP is REAL array, dimension ( N*(N+1)/2), \n
          On entry, the upper or lower triangular matrix A, packed
          columnwise in a linear array. The j-th column of A is stored
          in the array AP as follows: \n
          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j; \n
          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n. \n
 * @param[out] A
          A is REAL array, dimension ( LDA, N) \n
          On exit, the triangular matrix A.  If UPLO = 'U', the leading
          N-by-N upper triangular part of A contains the upper
          triangular part of the matrix A, and the strictly lower
          triangular part of A is not referenced.  If UPLO = 'L', the
          leading N-by-N lower triangular part of A contains the lower
          triangular part of the matrix A, and the strictly upper
          triangular part of A is not referenced. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer tpttr(char* uplo, integer* n,  T* ap, T* a, integer* lda, integer* info)
{
  return tpttr(uplo, n,  ap, a, lda, info);
}

/*! @brief TRCON estimates the reciprocal of the condition number of a triangular matrix A

 * @details
 * \b Purpose:
    \verbatim 
     TRCON estimates the reciprocal of the condition number of a
     triangular matrix A, in either the 1-norm or the infinity-norm.

     The norm of A is computed and an estimate is obtained for
     norm(inv(A)), then the reciprocal of the condition number is
     computed as
        RCOND = 1 / ( norm(A) * norm(inv(A))).
    \endverbatim  

 * @param[in] NORM
          NORM is CHARACTER*1 \n
          Specifies whether the 1-norm condition number or the
          infinity-norm condition number is required: \n
          = '1' or 'O':  1-norm; \n
          = 'I':         Infinity-norm. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  A is upper triangular; \n
          = 'L':  A is lower triangular. \n
 * @param[in] DIAG
          DIAG is CHARACTER*1 \n
          = 'N':  A is non-unit triangular; \n
          = 'U':  A is unit triangular. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          The triangular matrix A.  If UPLO = 'U', the leading N-by-N
          upper triangular part of the array A contains the upper
          triangular matrix, and the strictly lower triangular part of
          A is not referenced.  If UPLO = 'L', the leading N-by-N lower
          triangular part of the array A contains the lower triangular
          matrix, and the strictly upper triangular part of A is not
          referenced.  If DIAG = 'U', the diagonal elements of A are
          also not referenced and are assumed to be 1. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] RCOND
          RCOND is REAL \n
          The reciprocal of the condition number of the matrix A,
          computed as RCOND = 1/(norm(A) * norm(inv(A))). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (3*N) \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer trcon(char* norm, char* uplo, char* diag, integer* n,  T* a, integer* lda, T* rcond, T* work, integer* iwork, integer* info)
{
  return trcon(norm, uplo, diag, n,  a, lda, rcond, work, iwork, info);
}
template< typename T, typename Ta >
integer trcon(char* norm, char* uplo, char* diag, integer* n,  T* a, integer* lda, Ta* rcond, T* work, Ta* rwork, integer* info)
{
  return trcon(norm, uplo, diag, n,  a, lda, rcond, work, rwork, info);
}
/*! @brief TREVC computes some or all of the right and/or left eigenvectors of  \n
     a real upper quasi-triangular matrix T.

 * @details
 * \b Purpose:
    \verbatim 
     TREVC computes some or all of the right and/or left eigenvectors of
     a real upper quasi-triangular matrix T.
     Matrices of this type are produced by the Schur factorization of
     a real general matrix:  A = Q*T*Q**T, as computed by SHSEQR.

     The right eigenvector x and the left eigenvector y of T corresponding
     to an eigenvalue w are defined by:

        T*x = w*x,     (y**H)*T = w*(y**H)

     where y**H denotes the conjugate transpose of y.
     The eigenvalues are not input to this routine, but are read directly
     from the diagonal blocks of T.

     This routine returns the matrices X and/or Y of right and left
     eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
     input matrix.  If Q is the orthogonal factor that reduces a matrix
     A to Schur form T, then Q*X and Q*Y are the matrices of right and
     left eigenvectors of A.
    \endverbatim 

 * @param[in] SIDE
          SIDE is CHARACTER*1 \n
          = 'R':  compute right eigenvectors only; \n
          = 'L':  compute left eigenvectors only; \n
          = 'B':  compute both right and left eigenvectors. \n
 * @param[in] HOWMNY
          HOWMNY is CHARACTER*1 \n
          = 'A':  compute all right and/or left eigenvectors; \n
          = 'B':  compute all right and/or left eigenvectors,
                  backtransformed by the matrices in VR and/or VL; \n
          = 'S':  compute selected right and/or left eigenvectors,
                  as indicated by the logical array SELECT. \n
 * @param[in,out] SELECT
          SELECT is LOGICAL array, dimension (N) \n
          If HOWMNY = 'S', SELECT specifies the eigenvectors to be
          computed. \n
          If w(j) is a real eigenvalue, the corresponding real
          eigenvector is computed if SELECT(j) is .TRUE.. \n
          If w(j) and w(j+1) are the real and imaginary parts of a
          complex eigenvalue, the corresponding complex eigenvector is
          computed if either SELECT(j) or SELECT(j+1) is .TRUE., and
          on exit SELECT(j) is set to .TRUE. and SELECT(j+1) is set to
          .FALSE.. \n
          Not referenced if HOWMNY = 'A' or 'B'. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix T. N >= 0. \n
 * @param[in] T
          T is REAL array, dimension (LDT,N) \n
          The upper quasi-triangular matrix T in Schur canonical form. \n
 * @param[in] LDT
          LDT is INTEGER \n
          The leading dimension of the array T. LDT >= max(1,N). \n
 * @param[in,out] VL
          VL is REAL array, dimension (LDVL,MM) \n
          On entry, if SIDE = 'L' or 'B' and HOWMNY = 'B', VL must
          contain an N-by-N matrix Q (usually the orthogonal matrix Q
          of Schur vectors returned by SHSEQR). \n
          On exit, if SIDE = 'L' or 'B', VL contains: \n
          if HOWMNY = 'A', the matrix Y of left eigenvectors of T; \n
          if HOWMNY = 'B', the matrix Q*Y; \n
          if HOWMNY = 'S', the left eigenvectors of T specified by
                           SELECT, stored consecutively in the columns
                           of VL, in the same order as their
                           eigenvalues. \n
          A complex eigenvector corresponding to a complex eigenvalue
          is stored in two consecutive columns, the first holding the
          real part, and the second the imaginary part.
          Not referenced if SIDE = 'R'. \n
 * @param[in] LDVL
          LDVL is INTEGER \n
          The leading dimension of the array VL.  LDVL >= 1, and if
          SIDE = 'L' or 'B', LDVL >= N. \n
 * @param[in,out] VR
          VR is REAL array, dimension (LDVR,MM) \n
          On entry, if SIDE = 'R' or 'B' and HOWMNY = 'B', VR must
          contain an N-by-N matrix Q (usually the orthogonal matrix Q
          of Schur vectors returned by SHSEQR). \n
          On exit, if SIDE = 'R' or 'B', VR contains: \n
          if HOWMNY = 'A', the matrix X of right eigenvectors of T; \n
          if HOWMNY = 'B', the matrix Q*X; \n
          if HOWMNY = 'S', the right eigenvectors of T specified by
                           SELECT, stored consecutively in the columns
                           of VR, in the same order as their
                           eigenvalues. \n
          A complex eigenvector corresponding to a complex eigenvalue
          is stored in two consecutive columns, the first holding the
          real part and the second the imaginary part. \n
          Not referenced if SIDE = 'L'. \n
 * @param[in] LDVR
          LDVR is INTEGER \n
          The leading dimension of the array VR.  LDVR >= 1, and if
          SIDE = 'R' or 'B', LDVR >= N. \n
 * @param[in] MM
          MM is INTEGER \n
          The number of columns in the arrays VL and/or VR. MM >= M. \n
 * @param[out] M
          M is INTEGER \n
          The number of columns in the arrays VL and/or VR actually
          used to store the eigenvectors. \n
          If HOWMNY = 'A' or 'B', M is set to N.
          Each selected real eigenvector occupies one column and each
          selected complex eigenvector occupies two columns. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (3*N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer trevc(char* side, char* howmny, logical* select, integer* n,  T* t, integer* ldt, T* vl, integer* ldvl, T* vr, integer* ldvr, integer* mm, integer* m, T* work, integer* info)
{
  return trevc(side, howmny, select, n,  t, ldt, vl, ldvl, vr, ldvr, mm, m, work, info);
}

/*! @brief TREXC reorders the real Schur factorization of a real matrix A = Q*T*Q**T

 * @details
 * \b Purpose:
    \verbatim 
     TREXC reorders the real Schur factorization of a real matrix
     A = Q*T*Q**T, so that the diagonal block of T with row index IFST is
     moved to row ILST.

     The real Schur form T is reordered by an orthogonal similarity
     transformation Z**T*T*Z, and optionally the matrix Q of Schur vectors
     is updated by postmultiplying it with Z.

     T must be in Schur canonical form (as returned by SHSEQR), that is,
     block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
     2-by-2 diagonal block has its diagonal elements equal and its
     off-diagonal elements of opposite sign.
    \endverbatim 

 * @param[in] COMPQ
          COMPQ is CHARACTER*1 \n
          = 'V':  update the matrix Q of Schur vectors; \n
          = 'N':  do not update Q. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix T. N >= 0.
          If N == 0 arguments ILST and IFST may be any value. \n
 * @param[in,out] T
          T is REAL array, dimension (LDT,N) \n
          On entry, the upper quasi-triangular matrix T, in Schur
          Schur canonical form. \n
          On exit, the reordered upper quasi-triangular matrix, again
          in Schur canonical form. \n
 * @param[in] LDT
          LDT is INTEGER \n
          The leading dimension of the array T. LDT >= max(1,N). \n
 * @param[in,out] Q
          Q is REAL array, dimension (LDQ,N) \n
          On entry, if COMPQ = 'V', the matrix Q of Schur vectors.
          On exit, if COMPQ = 'V', Q has been postmultiplied by the
          orthogonal transformation matrix Z which reorders T.
          If COMPQ = 'N', Q is not referenced. \n
 * @param[in] LDQ
          LDQ is INTEGER \n
          The leading dimension of the array Q.  LDQ >= 1, and if
          COMPQ = 'V', LDQ >= max(1,N). \n
 * @param[in,out] IFST
          IFST is INTEGER \n
 * @param[in,out] ILST
          ILST is INTEGER \n
          Specify the reordering of the diagonal blocks of T.
          The block with row index IFST is moved to row ILST, by a
          sequence of transpositions between adjacent blocks.
          On exit, if IFST pointed on entry to the second row of a
          2-by-2 block, it is changed to point to the first row; ILST
          always points to the first row of the block in its final
          position (which may differ from its input value by +1 or -1).
          1 <= IFST <= N; 1 <= ILST <= N. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          = 1:  two adjacent blocks were too close to swap (the problem
                is very ill-conditioned); T may have been partially
                reordered, and ILST points to the first row of the
                current position of the block being moved. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer trexc(char* compq, integer* n, T* t, integer* ldt, T* q, integer* ldq, integer* ifst, integer* ilst, T* work, integer* info)
{
  return trexc(compq, n, t, ldt, q, ldq, ifst, ilst, work, info);
}
template< typename T >
integer trexc(char* compq, integer* n, T* t, integer* ldt, T* q, integer* ldq, integer* ifst, integer* ilst, integer* info)
{
  return trexc(compq, n, t, ldt, q, ldq, ifst, ilst, info);
}
/*! @brief TRRFS provides error bounds and backward error estimates for the \n
     solution to a system of linear equations

 * @details
 * \b Purpose:
    \verbatim 
     TRRFS provides error bounds and backward error estimates for the
     solution to a system of linear equations with a triangular
     coefficient matrix.

     The solution matrix X must be computed by STRTRS or some other
     means before entering this routine.  STRRFS does not do iterative
     refinement because doing so cannot improve the backward error.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  A is upper triangular; \n
          = 'L':  A is lower triangular. \n
 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          Specifies the form of the system of equations: \n
          = 'N':  A * X = B  (No transpose) \n
          = 'T':  A**T * X = B  (Transpose) \n
          = 'C':  A**H * X = B  (Conjugate transpose = Transpose) \n
 * @param[in] DIAG
          DIAG is CHARACTER*1 \n
          = 'N':  A is non-unit triangular; \n
          = 'U':  A is unit triangular. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrices B and X.  NRHS >= 0. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          The triangular matrix A.  If UPLO = 'U', the leading N-by-N
          upper triangular part of the array A contains the upper
          triangular matrix, and the strictly lower triangular part of
          A is not referenced.  If UPLO = 'L', the leading N-by-N lower
          triangular part of the array A contains the lower triangular
          matrix, and the strictly upper triangular part of A is not
          referenced.  If DIAG = 'U', the diagonal elements of A are
          also not referenced and are assumed to be 1. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] B
          B is REAL array, dimension (LDB,NRHS) \n
          The right hand side matrix B. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[in] X
          X is REAL array, dimension (LDX,NRHS) \n
          The solution matrix X. \n
 * @param[in] LDX
          LDX is INTEGER \n
          The leading dimension of the array X.  LDX >= max(1,N). \n
 * @param[out] FERR
          FERR is REAL array, dimension (NRHS) \n
          The estimated forward error bound for each solution vector
          X(j) (the j-th column of the solution matrix X).
          If XTRUE is the true solution corresponding to X(j), FERR(j)
          is an estimated upper bound for the magnitude of the largest
          element in (X(j) - XTRUE) divided by the magnitude of the
          largest element in X(j).  The estimate is as reliable as
          the estimate for RCOND, and is almost always a slight
          overestimate of the true error. \n
 * @param[out] BERR
          BERR is REAL array, dimension (NRHS) \n
          The componentwise relative backward error of each solution
          vector X(j) (i.e., the smallest relative change in
          any element of A or B that makes X(j) an exact solution). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (3*N) \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer trrfs(char* uplo, char* trans, char* diag, integer* n, integer* nrhs,  T* a, integer* lda,  T* b, integer* ldb,  T* x, integer* ldx, T* ferr, T* berr, T* work, integer* iwork, integer* info)
{
  return trrfs(uplo, trans, diag, n, nrhs,  a, lda,  b, ldb,  x, ldx, ferr, berr, work, iwork, info);
}
template< typename T, typename Ta >
integer trrfs(char* uplo, char* trans, char* diag, integer* n, integer* nrhs, T* a, integer* lda,  T* b, integer* ldb,  T* x, integer* ldx, Ta* ferr, Ta* berr, T* work, Ta* rwork, integer* info)
{
  return trrfs(uplo, trans, diag, n, nrhs,  a, lda,  b, ldb,  x, ldx, ferr, berr, work, rwork, info);
}

/*! @brief TRSEN reorders the real Schur factorization of a real matrix A = Q*T*Q**T

 * @details
 * \b Purpose:
    \verbatim 
     TRSEN reorders the real Schur factorization of a real matrix
     A = Q*T*Q**T, so that a selected cluster of eigenvalues appears in
     the leading diagonal blocks of the upper quasi-triangular matrix T,
     and the leading columns of Q form an orthonormal basis of the
     corresponding right invariant subspace.

     Optionally the routine computes the reciprocal condition numbers of
     the cluster of eigenvalues and/or the invariant subspace.

     T must be in Schur canonical form (as returned by SHSEQR), that is,
     block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
     2-by-2 diagonal block has its diagonal elements equal and its
     off-diagonal elements of opposite sign.
    \endverbatim  

 * @param[in] JOB
          JOB is CHARACTER*1 \n
          Specifies whether condition numbers are required for the
          cluster of eigenvalues (S) or the invariant subspace (SEP): \n
          = 'N': none; \n
          = 'E': for eigenvalues only (S); \n
          = 'V': for invariant subspace only (SEP); \n
          = 'B': for both eigenvalues and invariant subspace (S and
                 SEP). \n
 * @param[in] COMPQ
          COMPQ is CHARACTER*1 \n
          = 'V': update the matrix Q of Schur vectors; \n
          = 'N': do not update Q. \n
 * @param[in] SELECT
          SELECT is LOGICAL array, dimension (N) \n
          SELECT specifies the eigenvalues in the selected cluster. To
          select a real eigenvalue w(j), SELECT(j) must be set to
          .TRUE.. To select a complex conjugate pair of eigenvalues
          w(j) and w(j+1), corresponding to a 2-by-2 diagonal block,
          either SELECT(j) or SELECT(j+1) or both must be set to
          .TRUE.; a complex conjugate pair of eigenvalues must be
          either both included in the cluster or both excluded. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix T. N >= 0. \n
 * @param[in,out] T
          T is REAL array, dimension (LDT,N) \n
          On entry, the upper quasi-triangular matrix T, in Schur
          canonical form. \n
          On exit, T is overwritten by the reordered matrix T, again in
          Schur canonical form, with the selected eigenvalues in the
          leading diagonal blocks. \n
 * @param[in] LDT
          LDT is INTEGER \n
          The leading dimension of the array T. LDT >= max(1,N). \n
 * @param[in,out] Q
          Q is REAL array, dimension (LDQ,N) \n
          On entry, if COMPQ = 'V', the matrix Q of Schur vectors. \n
          On exit, if COMPQ = 'V', Q has been postmultiplied by the
          orthogonal transformation matrix which reorders T; the
          leading M columns of Q form an orthonormal basis for the
          specified invariant subspace. \n
          If COMPQ = 'N', Q is not referenced. \n
 * @param[in] LDQ
          LDQ is INTEGER \n
          The leading dimension of the array Q.
          LDQ >= 1; and if COMPQ = 'V', LDQ >= N. \n
 * @param[out] WR
          WR is REAL array, dimension (N) \n
 * @param[out] WI
          WI is REAL array, dimension (N) \n
          The real and imaginary parts, respectively, of the reordered
          eigenvalues of T. The eigenvalues are stored in the same
          order as on the diagonal of T, with WR(i) = T(i,i) and, if
          T(i:i+1,i:i+1) is a 2-by-2 diagonal block, WI(i) > 0 and
          WI(i+1) = -WI(i). Note that if a complex eigenvalue is
          sufficiently ill-conditioned, then its value may differ
          significantly from its value before reordering. \n
 * @param[out] M
          M is INTEGER \n
          The dimension of the specified invariant subspace. \n
          0 < = M <= N. \n
 * @param[out] S
          S is REAL \n
          If JOB = 'E' or 'B', S is a lower bound on the reciprocal
          condition number for the selected cluster of eigenvalues.
          S cannot underestimate the true reciprocal condition number
          by more than a factor of sqrt(N). If M = 0 or N, S = 1. \n
          If JOB = 'N' or 'V', S is not referenced. \n
 * @param[out] SEP
          SEP is REAL \n
          If JOB = 'V' or 'B', SEP is the estimated reciprocal
          condition number of the specified invariant subspace. If
          M = 0 or N, SEP = norm(T). \n
          If JOB = 'N' or 'E', SEP is not referenced. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK. \n
          If JOB = 'N', LWORK >= max(1,N); \n
          if JOB = 'E', LWORK >= max(1,M*(N-M)); \n
          if JOB = 'V' or 'B', LWORK >= max(1,2*M*(N-M)). \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (MAX(1,LIWORK)) \n
          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK. \n
 * @param[in]	LIWORK	
          LIWORK is INTEGER \n
          The dimension of the array IWORK. \n
          If JOB = 'N' or 'E', LIWORK >= 1; \n
          if JOB = 'V' or 'B', LIWORK >= max(1,M*(N-M)). \n
 \n
          If LIWORK = -1, then a workspace query is assumed; the
          routine only calculates the optimal size of the IWORK array,
          returns this value as the first entry of the IWORK array, and
          no error message related to LIWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n
          = 1: reordering of T failed because some eigenvalues are too
               close to separate (the problem is very ill-conditioned);
               T may have been partially reordered, and WR and WI
               contain the eigenvalues in the same order as in T; S and
               SEP (if requested) are set to zero. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer trsen(char* job, char* compq,  logical* select, integer* n, T* t, integer* ldt, T* q, integer* ldq, T* wr, T* wi, integer* m, T* s, T* sep, T* work, integer* lwork, integer* iwork, integer* liwork, integer* info)
{
  return trsen(job, compq,  select, n, t, ldt, q, ldq, wr, wi, m, s, sep, work, lwork, iwork, liwork, info);
}
template< typename T, typename Ta >
integer trsen(char* job, char* compq,  logical* select, integer* n, T* t, integer* ldt, T* q, integer* ldq, T* w, integer* m, Ta* s, Ta* sep, T* work, integer* lwork, integer* info)
{
  return trsen(job, compq,  select, n, t, ldt, q, ldq, w, m, s, sep, work, lwork, info);
}

/*! @brief TRSNA estimates reciprocal condition numbers for specified eigenvalues

 * @details
 * \b Purpose:
    \verbatim 
     TRSNA estimates reciprocal condition numbers for specified
     eigenvalues and/or right eigenvectors of a real upper
     quasi-triangular matrix T (or of any matrix Q*T*Q**T with Q
     orthogonal).

     T must be in Schur canonical form (as returned by SHSEQR), that is,
     block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
     2-by-2 diagonal block has its diagonal elements equal and its
     off-diagonal elements of opposite sign.
    \endverbatim  

 * @param[in] JOB
          JOB is CHARACTER*1 \n
          Specifies whether condition numbers are required for
          eigenvalues (S) or eigenvectors (SEP): \n
          = 'E': for eigenvalues only (S); \n
          = 'V': for eigenvectors only (SEP); \n
          = 'B': for both eigenvalues and eigenvectors (S and SEP). \n
 * @param[in] HOWMNY
          HOWMNY is CHARACTER*1 \n
          = 'A': compute condition numbers for all eigenpairs; \n
          = 'S': compute condition numbers for selected eigenpairs
                 specified by the array SELECT. \n
 * @param[in] SELECT
          SELECT is LOGICAL array, dimension (N) \n
          If HOWMNY = 'S', SELECT specifies the eigenpairs for which
          condition numbers are required. To select condition numbers
          for the eigenpair corresponding to a real eigenvalue w(j),
          SELECT(j) must be set to .TRUE.. To select condition numbers
          corresponding to a complex conjugate pair of eigenvalues w(j)
          and w(j+1), either SELECT(j) or SELECT(j+1) or both, must be
          set to .TRUE.. \n
          If HOWMNY = 'A', SELECT is not referenced. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix T. N >= 0. \n
 * @param[in] T
          T is REAL array, dimension (LDT,N) \n
          The upper quasi-triangular matrix T, in Schur canonical form. \n
 * @param[in] LDT
          LDT is INTEGER \n
          The leading dimension of the array T. LDT >= max(1,N). \n
 * @param[in] VL
          VL is REAL array, dimension (LDVL,M) \n
          If JOB = 'E' or 'B', VL must contain left eigenvectors of T
          (or of any Q*T*Q**T with Q orthogonal), corresponding to the
          eigenpairs specified by HOWMNY and SELECT. The eigenvectors
          must be stored in consecutive columns of VL, as returned by
          SHSEIN or STREVC. \n
          If JOB = 'V', VL is not referenced. \n
 * @param[in] LDVL
          LDVL is INTEGER \n
          The leading dimension of the array VL.
          LDVL >= 1; and if JOB = 'E' or 'B', LDVL >= N. \n
 * @param[in] VR
          VR is REAL array, dimension (LDVR,M) \n
          If JOB = 'E' or 'B', VR must contain right eigenvectors of T
          (or of any Q*T*Q**T with Q orthogonal), corresponding to the
          eigenpairs specified by HOWMNY and SELECT. The eigenvectors
          must be stored in consecutive columns of VR, as returned by
          SHSEIN or STREVC. \n
          If JOB = 'V', VR is not referenced. \n
 * @param[in] LDVR
          LDVR is INTEGER \n
          The leading dimension of the array VR. \n
          LDVR >= 1; and if JOB = 'E' or 'B', LDVR >= N. \n
 * @param[out] S
          S is REAL array, dimension (MM) \n
          If JOB = 'E' or 'B', the reciprocal condition numbers of the
          selected eigenvalues, stored in consecutive elements of the
          array. For a complex conjugate pair of eigenvalues two
          consecutive elements of S are set to the same value. Thus
          S(j), SEP(j), and the j-th columns of VL and VR all
          correspond to the same eigenpair (but not in general the
          j-th eigenpair, unless all eigenpairs are selected). \n
          If JOB = 'V', S is not referenced. \n
 * @param[out] SEP
          SEP is REAL array, dimension (MM) \n
          If JOB = 'V' or 'B', the estimated reciprocal condition
          numbers of the selected eigenvectors, stored in consecutive
          elements of the array. For a complex eigenvector two
          consecutive elements of SEP are set to the same value. If
          the eigenvalues cannot be reordered to compute SEP(j), SEP(j)
          is set to 0; this can only occur when the true value would be
          very small anyway. \n
          If JOB = 'E', SEP is not referenced. \n
 * @param[in] MM
          MM is INTEGER \n
          The number of elements in the arrays S (if JOB = 'E' or 'B')
          and/or SEP (if JOB = 'V' or 'B'). MM >= M. \n
 * @param[out] M
          M is INTEGER \n
          The number of elements of the arrays S and/or SEP actually
          used to store the estimated condition numbers.
          If HOWMNY = 'A', M is set to N. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (LDWORK,N+6) \n
          If JOB = 'E', WORK is not referenced. \n
 * @param[in]	LDWORK	
          LDWORK is INTEGER \n
          The leading dimension of the array WORK.
          LDWORK >= 1; and if JOB = 'V' or 'B', LDWORK >= N. \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (2*(N-1)) \n
          If JOB = 'E', IWORK is not referenced. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer trsna(char* job, char* howmny,  logical* select, integer* n,  T* t, integer* ldt,  T* vl, integer* ldvl,  T* vr, integer* ldvr, T* s, T* sep, integer* mm, integer* m, T* work, integer* ldwork, integer* iwork, integer* info)
{
  return trsna(job, howmny,  select, n,  t, ldt,  vl, ldvl,  vr, ldvr, s, sep, mm, m, work, ldwork, iwork, info);
}
template< typename T, typename Ta >
integer trsna(char* job, char* howmny,  logical* select, integer* n,  T* t, integer* ldt,  T* vl, integer* ldvl,  T* vr, integer* ldvr, Ta* s, Ta* sep, integer* mm, integer* m, T* work, integer* ldwork, Ta* rwork, integer* info)
{
  return trsna(job, howmny,  select, n,  t, ldt,  vl, ldvl,  vr, ldvr, s, sep, mm, m, work, ldwork, rwork, info);
}

/*! @brief TRTRS solves a triangular system of the form A * X = B  or  A**T * X = B

 * @details
 * \b Purpose:
    \verbatim 
    TRTRS solves a triangular system of the form

       A * X = B  or  A**T * X = B,

    where A is a triangular matrix of order N, and B is an N-by-NRHS
    matrix.  A check is made to verify that A is nonsingular.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  A is upper triangular; \n
          = 'L':  A is lower triangular. \n
 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          Specifies the form of the system of equations: \n
          = 'N':  A * X = B  (No transpose) \n
          = 'T':  A**T * X = B  (Transpose) \n
          = 'C':  A**H * X = B  (Conjugate transpose = Transpose) \n
 * @param[in] DIAG
          DIAG is CHARACTER*1 \n
          = 'N':  A is non-unit triangular; \n
          = 'U':  A is unit triangular. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          The triangular matrix A.  If UPLO = 'U', the leading N-by-N
          upper triangular part of the array A contains the upper
          triangular matrix, and the strictly lower triangular part of
          A is not referenced.  If UPLO = 'L', the leading N-by-N lower
          triangular part of the array A contains the lower triangular
          matrix, and the strictly upper triangular part of A is not
          referenced.  If DIAG = 'U', the diagonal elements of A are
          also not referenced and are assumed to be 1. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,NRHS) \n
          On entry, the right hand side matrix B.
          On exit, if INFO = 0, the solution matrix X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n
          > 0: if INFO = i, the i-th diagonal element of A is zero,
               indicating that the matrix is singular and the solutions
               X have not been computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer trtrs(char* uplo, char* trans, char* diag, integer* n, integer* nrhs,  T* a, integer* lda, T* b, integer* ldb, integer* info)
{
  return trtrs(uplo, trans, diag, n, nrhs,  a, lda, b, ldb, info);
}

/*! @brief TRTTF copies a triangular matrix from the standard full \n
     format (TR) to the rectangular full packed format (TF).
 * @details
 * \b Purpose:
    \verbatim 
     TRTTF copies a triangular matrix A from standard full format (TR)
     to rectangular full packed format (TF) .
    \endverbatim  

 * @param[in] TRANSR
          TRANSR is CHARACTER*1 \n
          = 'N':  ARF in Normal form is wanted; \n
          = 'T':  ARF in Transpose form is wanted. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A. N >= 0. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N). \n
          On entry, the triangular matrix A.  If UPLO = 'U', the
          leading N-by-N upper triangular part of the array A contains
          the upper triangular matrix, and the strictly lower
          triangular part of A is not referenced.  If UPLO = 'L', the
          leading N-by-N lower triangular part of the array A contains
          the lower triangular matrix, and the strictly upper
          triangular part of A is not referenced. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the matrix A. LDA >= max(1,N). \n
 * @param[out] ARF
          ARF is REAL array, dimension (NT). \n
          NT=N*(N+1)/2. On exit, the triangular matrix A in RFP format. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer trttf(char* transr, char* uplo, integer* n,  T* a, integer* lda, T* arf, integer* info)
{
  return trttf(transr, uplo, n,  a, lda, arf, info);
}

/*! @brief TRTTP copies a triangular matrix from the standard full \n
     format (TR) to the standard packed format (TP).
 * @details
 * \b Purpose:
    \verbatim 
    TRTTP copies a triangular matrix A from full format (TR) to standard
    packed format (TP).
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  A is upper triangular. \n
          = 'L':  A is lower triangular. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrices AP and A.  N >= 0. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          On exit, the triangular matrix A.  If UPLO = 'U', the leading
          N-by-N upper triangular part of A contains the upper
          triangular part of the matrix A, and the strictly lower
          triangular part of A is not referenced.  If UPLO = 'L', the
          leading N-by-N lower triangular part of A contains the lower
          triangular part of the matrix A, and the strictly upper
          triangular part of A is not referenced. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] AP
          AP is REAL array, dimension (N*(N+1)/2) \n
          On exit, the upper or lower triangular matrix A, packed
          columnwise in a linear array. The j-th column of A is stored
          in the array AP as follows: \n
          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j; \n
          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer trttp(char* uplo, integer* n,  T* a, integer* lda, T* ap, integer* info)
{
  return trttp(uplo, n, a, lda, ap, info);
}

/*! @brief TZRZF reduces the M-by-N ( M<=N) real upper trapezoidal matrix A \n
     to upper triangular form by means of orthogonal transformations.
 * @details
 * \b Purpose:
    \verbatim 
    TZRZF reduces the M-by-N ( M<=N) real upper trapezoidal matrix A
    to upper triangular form by means of orthogonal transformations.

    The upper trapezoidal matrix A is factored as

       A = ( R  0) * Z,

    where Z is an N-by-N orthogonal matrix and R is an M-by-M upper
    triangular matrix.
    \endverbatim  

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A.  N >= M. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the leading M-by-N upper trapezoidal part of the
          array A must contain the matrix to be factorized.
          On exit, the leading M-by-M upper triangular part of A
          contains the upper triangular matrix R, and elements M+1 to
          N of the first M rows of A, with the array TAU, represent the
          orthogonal matrix Z as a product of M elementary reflectors. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,M). \n
 * @param[out] TAU
          TAU is REAL array, dimension (M) \n
          The scalar factors of the elementary reflectors. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK.  LWORK >= max(1,M).
          For optimum performance LWORK >= M*NB, where NB is
          the optimal blocksize. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer tzrzf(integer* m, integer* n, T* a, integer* lda, T* tau, T* work, integer* lwork, integer* info)
{
  return tzrzf(m, n, a, lda, tau, work, lwork, info);
}

/*! @brief SPRFS improves the computed solution to a system of linear equations \n
     when the coefficient matrix is symmetric indefinite and packed
 * @details
 * \b Purpose:
    \verbatim 
     SPRFS improves the computed solution to a system of linear
     equations when the coefficient matrix is symmetric indefinite
     and packed, and provides error bounds and backward error estimates
     for the solution.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrices B and X.  NRHS >= 0. \n
 * @param[in] AP
          AP is REAL array, dimension (N*(N+1)/2) \n
          The upper or lower triangle of the symmetric matrix A, packed
          columnwise in a linear array.  The j-th column of A is stored
          in the array AP as follows: \n
          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j; \n
          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n. \n
 * @param[in] AFP
          AFP is REAL array, dimension (N*(N+1)/2) \n
          The factored form of the matrix A. AFP contains the block
          diagonal matrix D and the multipliers used to obtain the
          factor U or L from the factorization A = U*D*U**T or
          A = L*D*L**T as computed by SSPTRF, stored as a packed
          triangular matrix. \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D
          as determined by SSPTRF. \n
 * @param[in] B
          B is REAL array, dimension (LDB,NRHS) \n
          The right hand side matrix B. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[in,out] X
          X is REAL array, dimension (LDX,NRHS) \n
          On entry, the solution matrix X, as computed by SSPTRS.
          On exit, the improved solution matrix X. \n
 * @param[in] LDX
          LDX is INTEGER \n
          The leading dimension of the array X.  LDX >= max(1,N). \n
 * @param[out] FERR
          FERR is REAL array, dimension (NRHS) \n
          The estimated forward error bound for each solution vector
          X(j) (the j-th column of the solution matrix X).
          If XTRUE is the true solution corresponding to X(j), FERR(j)
          is an estimated upper bound for the magnitude of the largest
          element in (X(j) - XTRUE) divided by the magnitude of the
          largest element in X(j).  The estimate is as reliable as
          the estimate for RCOND, and is almost always a slight
          overestimate of the true error. \n
 * @param[out] BERR
          BERR is REAL array, dimension (NRHS) \n
          The componentwise relative backward error of each solution
          vector X(j) (i.e., the smallest relative change in
          any element of A or B that makes X(j) an exact solution). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (3*N) \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sprfs(char* uplo, integer* n, integer* nrhs,  T* ap,  T* afp,  integer* ipiv,  T* b, integer* ldb, T* x, integer* ldx, T* ferr, T* berr, T* work, integer* iwork, integer* info)
{
  return sprfs(uplo, n, nrhs,  ap,  afp,  ipiv,  b, ldb, x, ldx, ferr, berr, work, iwork, info);
} 
template< typename T, typename Ta >
integer sprfs(char* uplo, integer* n, integer* nrhs,  T* ap,  T* afp,  integer* ipiv,  T* b, integer* ldb, T* x, integer* ldx, Ta* ferr, Ta* berr, T* work, Ta* rwork, integer* info)
{
  return sprfs(uplo, n, nrhs,  ap,  afp,  ipiv,  b, ldb, x, ldx, ferr, berr, work, rwork, info);
} 
template< typename T, typename Ta >
integer hprfs(char* uplo, integer* n, integer* nrhs,  T* ap,  T* afp,  integer* ipiv,  T* b, integer* ldb, T* x, integer* ldx, Ta* ferr, Ta* berr, T* work, Ta* rwork, integer* info)
{
  return hprfs(uplo, n, nrhs,  ap,  afp,  ipiv,  b, ldb, x, ldx, ferr, berr, work, rwork, info);
}

/*! @brief LATMS generates random matrices with specified singular values \n
     for testing LAPACK programs
 * @details
 * \b Purpose:
    \verbatim 
    LATMS generates random matrices with specified singular values
     (or symmetric/hermitian with specified eigenvalues)
     for testing LAPACK programs.
 
     SLATMS operates by applying the following sequence of
     operations:
 
       Set the diagonal to D, where D may be input or
          computed according to MODE, COND, DMAX, and SYM
          as described below.
 
       Generate a matrix with the appropriate band structure, by one
          of two methods:
 
       Method A:
           Generate a dense M x N matrix by multiplying D on the left
               and the right by random unitary matrices, then:
 
           Reduce the bandwidth according to KL and KU, using
           Householder transformations.
 
       Method B:
           Convert the bandwidth-0 (i.e., diagonal) matrix to a
               bandwidth-1 matrix using Givens rotations, "chasing"
               out-of-band elements back, much as in QR; then
               convert the bandwidth-1 to a bandwidth-2 matrix, etc.
               Note that for reasonably small bandwidths (relative to
               M and N) this requires less storage, as a dense matrix
               is not generated.  Also, for symmetric matrices, only
               one triangle is generated.
 
       Method A is chosen if the bandwidth is a large fraction of the
           order of the matrix, and LDA is at least M (so a dense
           matrix can be stored.)  Method B is chosen if the bandwidth
           is small (< 1/2 N for symmetric, < .3 N+M for
           non-symmetric), or LDA is less than M and not less than the
           bandwidth.
 
       Pack the matrix if desired. Options specified by PACK are:
          no packing
          zero out upper half (if symmetric)
          zero out lower half (if symmetric)
          store the upper half columnwise (if symmetric or upper
                triangular)
          store the lower half columnwise (if symmetric or lower
                triangular)
          store the lower triangle in banded format (if symmetric
                or lower triangular)
          store the upper triangle in banded format (if symmetric
                or upper triangular)
          store the entire matrix in banded format
       If Method B is chosen, and band format is specified, then the
          matrix will be generated in the band format, so no repacking
          will be necessary.
    \endverbatim   

  * @param[in] M
           M is INTEGER \n
           The number of rows of A. Not modified. \n
  * @param[in] N
           N is INTEGER \n
           The number of columns of A. Not modified. \n
  * @param[in] DIST
           DIST is CHARACTER*1 \n
           On entry, DIST specifies the type of distribution to be used
           to generate the random eigen-/singular values. \n
           'U' => UNIFORM( 0, 1)  ( 'U' for uniform) \n
           'S' => UNIFORM( -1, 1) ( 'S' for symmetric) \n
           'N' => NORMAL( 0, 1)   ( 'N' for normal) \n
           Not modified. \n
  * @param[in,out] ISEED
           ISEED is INTEGER array, dimension ( 4) \n
           On entry ISEED specifies the seed of the random number
           generator. They should lie between 0 and 4095 inclusive,
           and ISEED(4) should be odd. The random number generator
           uses a linear congruential sequence limited to small
           integers, and so should produce machine independent
           random numbers. The values of ISEED are changed on
           exit, and can be used in the next call to SLATMS
           to continue the same random number sequence. \n
           Changed on exit. \n
  * @param[in] SYM
           SYM is CHARACTER*1 \n
           If SYM='S' or 'H', the generated matrix is symmetric, with
             eigenvalues specified by D, COND, MODE, and DMAX; they
             may be positive, negative, or zero. \n
           If SYM='P', the generated matrix is symmetric, with
             eigenvalues (= singular values) specified by D, COND,
             MODE, and DMAX; they will not be negative. \n
           If SYM='N', the generated matrix is nonsymmetric, with
             singular values specified by D, COND, MODE, and DMAX;
             they will not be negative. \n
           Not modified. \n
  * @param[in,out] D
           D is REAL array, dimension ( MIN( M , N)) \n
           This array is used to specify the singular values or
           eigenvalues of A (see SYM, above.)  If MODE=0, then D is
           assumed to contain the singular/eigenvalues, otherwise
           they will be computed according to MODE, COND, and DMAX,
           and placed in D. \n
           Modified if MODE is nonzero. \n
  * @param[in] MODE
           MODE is INTEGER \n
           On entry this describes how the singular/eigenvalues are to
           be specified: \n
           MODE = 0 means use D as input \n
           MODE = 1 sets D(1)=1 and D(2:N)=1.0/COND \n
           MODE = 2 sets D(1:N-1)=1 and D(N)=1.0/COND \n
           MODE = 3 sets D(I)=COND**(-(I-1)/(N-1)) \n
           MODE = 4 sets D(i)=1 - (i-1)/(N-1)*(1 - 1/COND) \n
           MODE = 5 sets D to random numbers in the range
                    ( 1/COND , 1) such that their logarithms
                    are uniformly distributed. \n
           MODE = 6 set D to random numbers from same distribution
                    as the rest of the matrix. \n
           MODE < 0 has the same meaning as ABS(MODE), except that
              the order of the elements of D is reversed. \n
           Thus if MODE is positive, D has entries ranging from
              1 to 1/COND, if negative, from 1/COND to 1, \n
           If SYM='S' or 'H', and MODE is neither 0, 6, nor -6, then
              the elements of D will also be multiplied by a random
              sign (i.e., +1 or -1.) \n
           Not modified. \n
  * @param[in] COND
           COND is REAL \n
           On entry, this is used as described under MODE above.
           If used, it must be >= 1. Not modified. \n
  * @param[in] DMAX
           DMAX is REAL \n
           If MODE is neither -6, 0 nor 6, the contents of D, as
           computed according to MODE and COND, will be scaled by
           DMAX / max(abs(D(i))); thus, the maximum absolute eigen- or
           singular value (which is to say the norm) will be abs(DMAX).
           Note that DMAX need not be positive: if DMAX is negative
           (or zero), D will be scaled by a negative number (or zero).
           Not modified. \n
  * @param[in] KL
           KL is INTEGER \n
           This specifies the lower bandwidth of the  matrix. For
           example, KL=0 implies upper triangular, KL=1 implies upper
           Hessenberg, and KL being at least M-1 means that the matrix
           has full lower bandwidth.  KL must equal KU if the matrix
           is symmetric. \n
           Not modified. \n
  * @param[in] KU
           KU is INTEGER \n
           This specifies the upper bandwidth of the  matrix. For
           example, KU=0 implies lower triangular, KU=1 implies lower
           Hessenberg, and KU being at least N-1 means that the matrix
           has full upper bandwidth.  KL must equal KU if the matrix
           is symmetric. \n
           Not modified. \n
  * @param[in] PACK
           PACK is CHARACTER*1 \n
           This specifies packing of matrix as follows:
           'N' => no packing \n
           'U' => zero out all subdiagonal entries (if symmetric) \n
           'L' => zero out all superdiagonal entries (if symmetric) \n
           'C' => store the upper triangle columnwise
                  (only if the matrix is symmetric or upper triangular) \n
           'R' => store the lower triangle columnwise
                  (only if the matrix is symmetric or lower triangular) \n
           'B' => store the lower triangle in band storage scheme
                  (only if matrix symmetric or lower triangular) \n
           'Q' => store the upper triangle in band storage scheme
                  (only if matrix symmetric or upper triangular) \n
           'Z' => store the entire matrix in band storage scheme
                      (pivoting can be provided for by using this
                      option to store A in the trailing rows of
                      the allocated storage) \n
 \n
           Using these options, the various LAPACK packed and banded
           storage schemes can be obtained: \n
           GB               - use 'Z' \n
           PB, SB or TB     - use 'B' or 'Q' \n
           PP, SP or TP     - use 'C' or 'R' \n
 \n
           If two calls to SLATMS differ only in the PACK parameter,
           they will generate mathematically equivalent matrices.
           Not modified. \n
  * @param[in,out] A
           A is REAL array, dimension ( LDA, N) \n
           On exit A is the desired test matrix.  A is first generated
           in full (unpacked) form, and then packed, if so specified
           by PACK.  Thus, the first M elements of the first N
           columns will always be modified.  If PACK specifies a
           packed or banded storage scheme, all LDA elements of the
           first N columns will be modified; the elements of the
           array which do not correspond to elements of the generated
           matrix are set to zero.
           Modified. \n
  * @param[in] LDA
           LDA is INTEGER \n
           LDA specifies the first dimension of A as declared in the
           calling program.  If PACK='N', 'U', 'L', 'C', or 'R', then
           LDA must be at least M.  If PACK='B' or 'Q', then LDA must
           be at least MIN( KL, M-1) (which is equal to MIN(KU,N-1)).
           If PACK='Z', LDA must be large enough to hold the packed
           array: MIN( KU, N-1) + MIN( KL, M-1) + 1. \n
           Not modified.  \n
  * @param[out]	WORK	
          WORK is REAL array, dimension ( 3*MAX( N , M ) ) \n
          Workspace. \n
          Modified. \n
  * @param[out]	INFO	
          INFO is INTEGER \n
          Error code.  On exit, INFO will be set to one of the
          following values: \n
            0 => normal return \n
           -1 => M negative or unequal to N and SYM='S', 'H', or 'P' \n
           -2 => N negative \n
           -3 => DIST illegal string \n
           -5 => SYM illegal string \n
           -7 => MODE not in range -6 to 6 \n
           -8 => COND less than 1.0, and MODE neither -6, 0 nor 6 \n
           -10 => KL negative \n
           -11 => KU negative, or SYM='S' or 'H' and KU not equal to KL \n
           -12 => PACK illegal string, or PACK='U' or 'L', and SYM='N';
                  or PACK='C' or 'Q' and SYM='N' and KL is not zero;
                  or PACK='R' or 'B' and SYM='N' and KU is not zero;
                  or PACK='U', 'L', 'C', 'R', 'B', or 'Q', and M is not
                  N. \n
           -14 => LDA is less than M, or PACK='Z' and LDA is less than
                  MIN(KU,N-1) + MIN(KL,M-1) + 1. \n
            1  => Error return from SLATM1 \n
            2  => Cannot scale to DMAX (max. sing. value is 0) \n
            3  => Error return from SLAGGE or SLAGSY \n

 * @return INTEGER Return value of the function.
 * */
/*template< typename T >
integer latms(integer* m, integer* n, char* dist, integer* iseed, char* sym, T* d, integer* mode, T cond, T dmax, integer* kl, integer* ku, char* pack, T* a, integer* lda)
{
  return latms(m, n, dist, iseed, sym, d, mode, cond, dmax, kl, ku, pack, a, lda);
} 
template< typename T, typename Ta >
integer latms(integer* m, integer* n, char* dist, integer* iseed, char* sym, Ta* d, integer* mode, Ta cond, Ta dmax, integer* kl, integer* ku, char* pack, T* a, integer* lda)
{
  return latms(m, n, dist, iseed, sym, d, mode, cond, dmax, kl, ku, pack, a, lda);
}*/

/*! @brief LAGGE generates a real general m by n matrix A

 * @details
 * \b Purpose:
    \verbatim 
     LAGGE generates a real general m by n matrix A, by pre- and post-
    multiplying a real diagonal matrix D with random orthogonal matrices:
    A = U*D*V. The lower and upper bandwidths may then be reduced to
    kl and ku by additional orthogonal transformations.
    \endverbatim   

  * @param[in] M
           M is INTEGER \n
           The number of rows of the matrix A.  M >= 0. \n
  * @param[in] N
           N is INTEGER \n
           The number of columns of the matrix A.  N >= 0. \n
  * @param[in] KL
           KL is INTEGER \n
           The number of nonzero subdiagonals within the band of A.
           0 <= KL <= M-1. \n
  * @param[in] KU
           KU is INTEGER \n
           The number of nonzero superdiagonals within the band of A.
           0 <= KU <= N-1. \n
  * @param[in] D
           D is REAL array, dimension (min(M,N)) \n
           The diagonal elements of the diagonal matrix D. \n
  * @param[out] A
           A is REAL array, dimension (LDA,N) \n
           The generated m by n matrix A. \n
  * @param[in] LDA
           LDA is INTEGER \n
           The leading dimension of the array A.  LDA >= M. \n
  * @param[in,out] ISEED
           ISEED is INTEGER array, dimension (4) \n
           On entry, the seed of the random number generator; the array
           elements must be between 0 and 4095, and ISEED(4) must be
           odd. \n
           On exit, the seed is updated. \n
  * @param[out]	WORK	
          WORK is REAL array, dimension (M+N) \n
  * @param[out]	INFO	
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
/*template< typename T >
integer lagge(integer* m, integer* n, integer* kl, integer* ku,  T* d, T* a, integer* lda, integer* iseed)
{
  return lagge(m, n, kl, ku, d, a, lda, iseed);
}
template< typename T, typename Ta >
integer lagge(integer* m, integer* n, integer* kl, integer* ku,  Ta* d, T* a, integer* lda, integer* iseed)
{
  return lagge(m, n, kl, ku, d, a, lda, iseed);
}*/

/*! @brief LACGV conjugates a complex vector

 * @details
 * \b Purpose:
    \verbatim 
    CLACGV conjugates a complex vector of length N.
    \endverbatim  
    
 * @param[in] N
          N is INTEGER \n
          The length of the vector X.  N >= 0. \n
 * @param[in,out] X
          X is COMPLEX array, dimension
                         (1+(N-1)*abs(INCX)) \n
          On entry, the vector of length N to be conjugated.
          On exit, X is overwritten with conjg(X). \n
 * @param[in] INCX
          INCX is INTEGER \n
          The spacing between successive elements of X. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lacgv(integer *n, T* x, integer *incx)
{
  return lacgv(n, x, incx); 
}

/*! @brief LACP2 copies all or part of a real two-dimensional array to a complex array

 * @details
 * \b Purpose:
    \verbatim 
     LACP2 copies all or part of a real two-dimensional matrix A to a
     complex matrix B.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies the part of the matrix A to be copied to B. \n
          = 'U':      Upper triangular part \n
          = 'L':      Lower triangular part \n
          Otherwise:  All of the matrix A \n
 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A.  N >= 0. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          The m by n matrix A.  If UPLO = 'U', only the upper trapezium
          is accessed; if UPLO = 'L', only the lower trapezium is
          accessed. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,M). \n
 * @param[out] B
          B is COMPLEX array, dimension (LDB,N) \n
          On exit, B = A in the locations specified by UPLO. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,M). \n

 * @return INTEGER Return value of the function.
 * */
template< typename T, typename Ta >
integer lacp2(char *uplo, integer *m, integer *n, T* a, integer *lda, Ta* b, integer *ldb)
{
  return lacp2(uplo, m, n, a, lda, b, ldb);
} 

/*! @brief LACRM multiplies a complex matrix by a square real matrix

 * @details
 * \b Purpose:
    \verbatim 
    LACRM performs a very simple matrix-matrix multiplication:
             C := A * B,
    where A is M by N and complex; B is N by N and real;
    C is M by N and complex.
    \endverbatim  

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A and of the matrix C.
          M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns and rows of the matrix B and
          the number of columns of the matrix C.
          N >= 0. \n
 * @param[in] A
          A is COMPLEX array, dimension (LDA, N) \n
          On entry, A contains the M by N matrix A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A. LDA >=max(1,M). \n
 * @param[in] B
          B is REAL array, dimension (LDB, N) \n
          On entry, B contains the N by N matrix B. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B. LDB >=max(1,N). \n
 * @param[out] C
          C is COMPLEX array, dimension (LDC, N) \n
          On exit, C contains the M by N matrix C. \n
 * @param[in] LDC
          LDC is INTEGER \n
          The leading dimension of the array C. LDC >=max(1,N). \n
 * @param[out]	RWORK	
          RWORK is REAL array, dimension (2*M*N) \n

 * @return INTEGER Return value of the function.
 * */
template< typename T, typename Ta >
integer lacrm(integer *m, integer *n, T* a, integer *lda, Ta* b, integer *ldb, T* c, integer *ldc, T* rwork)
{
  return lacrm(m, n, a, lda, b, ldb, c, ldc, rwork); 
}

/*! @brief LAGHE generates a complex hermitian matrix A, by pre- and post- \n
     multiplying a real diagonal matrix D
 * @details
 * \b Purpose:
    \verbatim 
    LAGHE generates a complex hermitian matrix A, by pre- and post-
    multiplying a real diagonal matrix D with a random unitary matrix:
    A = U*D*U'. The semi-bandwidth may then be reduced to k by additional
    unitary transformations.
    \endverbatim   

  * @param[in] N
           N is INTEGER \n
           The order of the matrix A.  N >= 0. \n
  * @param[in] K
           K is INTEGER \n
           The number of nonzero subdiagonals within the band of A.
           0 <= K <= N-1. \n
  * @param[in] D
           D is REAL array, dimension (N) \n
           The diagonal elements of the diagonal matrix D. \n
  * @param[out] A
           A is COMPLEX array, dimension (LDA,N) \n
           The generated n by n hermitian matrix A (the full matrix is
           stored). \n
  * @param[in] LDA
           LDA is INTEGER \n
           The leading dimension of the array A.  LDA >= N. \n
  * @param[in,out] ISEED
           ISEED is INTEGER array, dimension (4) \n
           On entry, the seed of the random number generator; the array
           elements must be between 0 and 4095, and ISEED(4) must be
           odd. \n
           On exit, the seed is updated. \n
  * @param[out]	WORK	
          WORK is COMPLEX array, dimension (2*N) \n
  * @param[out]	INFO	
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
/*template< typename T, typename Ta >
integer laghe(integer *n, integer *k, Ta* d, T* a, integer *lda, integer* iseed)
{
  return laghe(n, k, d, a, lda, iseed); 
}*/

/*! @brief LANHE returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, \n
     or the element of largest absolute value of a complex Hermitian matrix.
 * @details
 * \b Purpose:
    \verbatim 
    LANHE  returns the value of the one norm,  or the Frobenius norm, or
    the  infinity norm,  or the  element of  largest absolute value  of a
    complex hermitian matrix A.
 * \b Returns LANHE

       CLANHE = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                (
                ( norm1(A),         NORM = '1', 'O' or 'o'
                (
                ( normI(A),         NORM = 'I' or 'i'
                (
                ( normF(A),         NORM = 'F', 'f', 'E' or 'e'

    where  norm1  denotes the  one norm of a matrix (maximum column sum),
    normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
    normF  denotes the  Frobenius norm of a matrix (square root of sum of
    squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
    \endverbatim 

 * @param[in] NORM
          NORM is CHARACTER*1 \n
          Specifies the value to be returned in CLANHE as described
          above. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the upper or lower triangular part of the
          hermitian matrix A is to be referenced. \n
          = 'U':  Upper triangular part of A is referenced \n
          = 'L':  Lower triangular part of A is referenced \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0.  When N = 0, CLANHE is
          set to zero. \n
 * @param[in] A
          A is COMPLEX array, dimension (LDA,N) \n
          The hermitian matrix A.  If UPLO = 'U', the leading n by n
          upper triangular part of A contains the upper triangular part
          of the matrix A, and the strictly lower triangular part of A
          is not referenced.  If UPLO = 'L', the leading n by n lower
          triangular part of A contains the lower triangular part of
          the matrix A, and the strictly upper triangular part of A is
          not referenced. Note that the imaginary parts of the diagonal
          elements need not be set and are assumed to be zero. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(N,1). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)), \n
          where LWORK >= N when NORM = 'I' or '1' or 'O'; otherwise,
          WORK is not referenced. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T, typename Ta >
Ta lanhe(char *norm, char *uplo, integer *n, T* a, integer *lda, Ta* work)
{
  return lanhe(norm, uplo, n, a, lda, work); 
}

/*! @brief LARCM copies all or part of a real two-dimensional array to a complex array.

 * @details
 * \b Purpose:
    \verbatim 
    LARCM performs a very simple matrix-matrix multiplication:
             C := A * B,
    where A is M by M and real; B is M by N and complex;
    C is M by N and complex.
    \endverbatim  

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A and of the matrix C.
          M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns and rows of the matrix B and
          the number of columns of the matrix C.
          N >= 0. \n
 * @param[in] A
          A is REAL array, dimension (LDA, M) \n
          On entry, A contains the M by M matrix A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A. LDA >=max(1,M). \n
 * @param[in] B
          B is COMPLEX array, dimension (LDB, N) \n
          On entry, B contains the M by N matrix B. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B. LDB >=max(1,M). \n
 * @param[out] C
          C is COMPLEX array, dimension (LDC, N) \n
          On exit, C contains the M by N matrix C. \n
 * @param[in] LDC
          LDC is INTEGER \n
          The leading dimension of the array C. LDC >=max(1,M). \n
 * @param[out]	RWORK	
          RWORK is REAL array, dimension (2*M*N) \n

 * @return INTEGER Return value of the function.
 * */
template< typename T, typename Ta >
integer larcm(integer *m, integer *n, Ta* a, integer *lda, T* b, integer *ldb, T* c, integer *ldc, Ta* rwork)
{
  return larcm(m, n, a, lda, b, ldb, c, ldc, rwork); 
}

/*! @brief GECON estimates the reciprocal of the condition number of a general real matrix A

 * @details
 * \b Purpose:
    \verbatim 
    GECON estimates the reciprocal of the condition number of a general
    real matrix A, in either the 1-norm or the infinity-norm, using
    the LU factorization computed by SGETRF.

    An estimate is obtained for norm(inv(A)), and the reciprocal of the
    condition number is computed as
       RCOND = 1 / ( norm(A) * norm(inv(A))).
    \endverbatim  

 * @param[in] NORM
          NORM is CHARACTER*1 \n
          Specifies whether the 1-norm condition number or the
          infinity-norm condition number is required: \n
          = '1' or 'O':  1-norm; \n
          = 'I':         Infinity-norm. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          The factors L and U from the factorization A = P*L*U
          as computed by SGETRF. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] ANORM
          ANORM is REAL \n
          If NORM = '1' or 'O', the 1-norm of the original matrix A. \n
          If NORM = 'I', the infinity-norm of the original matrix A. \n
 * @param[out] RCOND
          RCOND is REAL \n
          The reciprocal of the condition number of the matrix A,
          computed as RCOND = 1/(norm(A) * norm(inv(A))). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (4*N) \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer gecon(char* norm, integer* n,  T* a, integer* lda, T* anorm, T* rcond, T* work, integer* iwork, integer* info)
{
return gecon(norm, n,  a, lda, anorm, rcond, work, iwork, info);
}
template< typename T, typename Ta >
integer gecon(char* norm, integer* n,  T* a, integer* lda, Ta* anorm, Ta* rcond, T* work, Ta* rwork, integer* info)
{
  return gecon(norm, n,  a, lda, anorm, rcond, work, rwork, info);
}

/*! @brief GEEQU computes row and column scalings intended to equilibrate an \n
     M-by-N matrix A and reduce its condition number

 * @details
 * \b Purpose:
    \verbatim 
     GEEQU computes row and column scalings intended to equilibrate an
     M-by-N matrix A and reduce its condition number.  R returns the row
     scale factors and C the column scale factors, chosen to try to make
     the largest element in each row and column of the matrix B with
     elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.

     R(i) and C(j) are restricted to be between SMLNUM = smallest safe
     number and BIGNUM = largest safe number.  Use of these scaling
     factors is not guaranteed to reduce the condition number of A but
     works well in practice.
    \endverbatim  

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A.  N >= 0. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          The M-by-N matrix whose equilibration factors are
          to be computed. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,M). \n
 * @param[out] R
          R is REAL array, dimension (M) \n
          If INFO = 0 or INFO > M, R contains the row scale factors
          for A. \n
 * @param[out] C
          C is REAL array, dimension (N) \n
          If INFO = 0,  C contains the column scale factors for A. \n
 * @param[out] ROWCND
          ROWCND is REAL \n
          If INFO = 0 or INFO > M, ROWCND contains the ratio of the
          smallest R(i) to the largest R(i).  If ROWCND >= 0.1 and
          AMAX is neither too large nor too small, it is not worth
          scaling by R. \n
 * @param[out] COLCND
          COLCND is REAL \n
          If INFO = 0, COLCND contains the ratio of the smallest
          C(i) to the largest C(i).  If COLCND >= 0.1, it is not
          worth scaling by C. \n
 * @param[out] AMAX
          AMAX is REAL \n
          Absolute value of largest matrix element.  If AMAX is very
          close to overflow or very close to underflow, the matrix
          should be scaled. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i,  and i is \n
                <= M:  the i-th row of A is exactly zero \n
                >  M:  the (i-M)-th column of A is exactly zero \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer geequ(integer* m, integer* n,  T* a, integer* lda, T* r, T* c, T* rowcnd, T* colcnd, T* amax, integer* info)
{
  return geequ(m, n, a, lda, r, c, rowcnd, colcnd, amax, info);
}
template< typename T, typename Ta >
integer geequ(integer* m, integer* n,  T* a, integer* lda, Ta* r, Ta* c, Ta* rowcnd, Ta* colcnd, Ta* amax, integer* info)
{
  return geequ(m, n, a, lda, r, c, rowcnd, colcnd, amax, info);
}

/*! @brief HECON estimates the reciprocal of the condition number of a complex Hermitian matrix A

 * @details
 * \b Purpose:
    \verbatim 
    HECON estimates the reciprocal of the condition number of a complex
    Hermitian matrix A using the factorization A = U*D*U**H or
    A = L*D*L**H computed by CHETRF.

    An estimate is obtained for norm(inv(A)), and the reciprocal of the
    condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the details of the factorization are stored
          as an upper or lower triangular matrix. \n
          = 'U':  Upper triangular, form is A = U*D*U**H; \n
          = 'L':  Lower triangular, form is A = L*D*L**H. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] A
          A is COMPLEX array, dimension (LDA,N) \n
          The block diagonal matrix D and the multipliers used to
          obtain the factor U or L as computed by CHETRF. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D
          as determined by CHETRF. \n
 * @param[in] ANORM
          ANORM is REAL \n
          The 1-norm of the original matrix A. \n
 * @param[out] RCOND
          RCOND is REAL \n
          The reciprocal of the condition number of the matrix A,
          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
          estimate of the 1-norm of inv(A) computed in this routine. \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (2*N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T, typename Ta >
integer hecon(char* uplo, integer* n,  T* a, integer* lda,  integer* ipiv, Ta* anorm, Ta* rcond, T* work, integer* info)
{
  return hecon(uplo, n, a, lda, ipiv, anorm, rcond, work, info);
}

/*! @brief HECON_3 estimates the reciprocal of the condition number

 * @details
 * \b Purpose:
    \verbatim 
     HECON_3 estimates the reciprocal of the condition number (in the
     1-norm) of a complex Hermitian matrix A using the factorization
     computed by CHETRF_RK or CHETRF_BK:

        A = P*U*D*(U**H)*(P**T) or A = P*L*D*(L**H)*(P**T),

     where U (or L) is unit upper (or lower) triangular matrix,
     U**H (or L**H) is the conjugate of U (or L), P is a permutation
     matrix, P**T is the transpose of P, and D is Hermitian and block
     diagonal with 1-by-1 and 2-by-2 diagonal blocks.

     An estimate is obtained for norm(inv(A)), and the reciprocal of the
     condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
     This routine uses BLAS3 solver CHETRS_3.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the details of the factorization are
          stored as an upper or lower triangular matrix: \n
          = 'U':  Upper triangular, form is A = P*U*D*(U**H)*(P**T); \n
          = 'L':  Lower triangular, form is A = P*L*D*(L**H)*(P**T). \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] A
          A is COMPLEX array, dimension (LDA,N) \n
          Diagonal of the block diagonal matrix D and factors U or L
          as computed by CHETRF_RK and CHETRF_BK: \n
            a) ONLY diagonal elements of the Hermitian block diagonal
               matrix D on the diagonal of A, i.e. D(k,k) = A(k,k);
               (superdiagonal (or subdiagonal) elements of D
                should be provided on entry in array E), and \n
            b) If UPLO = 'U': factor U in the superdiagonal part of A.
               If UPLO = 'L': factor L in the subdiagonal part of A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] E
          E is COMPLEX array, dimension (N) \n
          On entry, contains the superdiagonal (or subdiagonal)
          elements of the Hermitian block diagonal matrix D
          with 1-by-1 or 2-by-2 diagonal blocks, where \n
          If UPLO = 'U': E(i) = D(i-1,i),i=2:N, E(1) not referenced; \n
          If UPLO = 'L': E(i) = D(i+1,i),i=1:N-1, E(N) not referenced. \n
 \n
          NOTE: For 1-by-1 diagonal block D(k), where
          1 <= k <= N, the element E(k) is not referenced in both
          UPLO = 'U' or UPLO = 'L' cases. \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D
          as determined by CHETRF_RK or CHETRF_BK. \n
 * @param[in] ANORM
          ANORM is REAL \n
          The 1-norm of the original matrix A. \n
 * @param[out] RCOND
          RCOND is REAL \n
          The reciprocal of the condition number of the matrix A,
          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
          estimate of the 1-norm of inv(A) computed in this routine. \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (2*N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T, typename Ta >
integer hecon_3(char* uplo, integer* n, T* a, integer* lda, T* e, integer* ipiv, Ta* anorm, Ta* rcond, T* work, integer* info)
{
  return hecon_3(uplo, n, a, lda, e, ipiv, anorm, rcond, work, info);
}

/*! @brief HEEQUB computes row and column scalings intended to equilibrate a Hermitian matrix A

 * @details
 * \b Purpose:
    \verbatim 
     HEEQUB computes row and column scalings intended to equilibrate a
     Hermitian matrix A (with respect to the Euclidean norm) and reduce
     its condition number. The scale factors S are computed by the BIN
     algorithm (see references) so that the scaled matrix B with elements
     B(i,j) = S(i)*A(i,j)*S(j) has a condition number within a factor N of
     the smallest possible condition number over all possible diagonal
     scalings.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A. N >= 0. \n
 * @param[in] A
          A is COMPLEX array, dimension (LDA,N) \n
          The N-by-N Hermitian matrix whose scaling factors are to be
          computed. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A. LDA >= max(1,N). \n
 * @param[out] S
          S is REAL array, dimension (N) \n
          If INFO = 0, S contains the scale factors for A. \n
 * @param[out] SCOND
          SCOND is REAL \n
          If INFO = 0, S contains the ratio of the smallest S(i) to
          the largest S(i). If SCOND >= 0.1 and AMAX is neither too
          large nor too small, it is not worth scaling by S. \n
 * @param[out] AMAX
          AMAX is REAL \n
          Largest absolute value of any matrix element. If AMAX is
          very close to overflow or very close to underflow, the
          matrix should be scaled. \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (2*N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, the i-th diagonal element is nonpositive. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T, typename Ta >
integer heequb(char* uplo, integer* n, T* a, integer* lda, Ta* s, Ta* scond, Ta* amax, T* work, integer* info)
{
  return heequb(uplo, n, a, lda, s, scond, amax, work, info);
}

/*! @brief HEEV_2STAGE computes the eigenvalues and, optionally, the left and/or right eigenvectors for HE matrices

 * @details
 * \b Purpose:
    \verbatim 
     HEEV_2STAGE computes all eigenvalues and, optionally, eigenvectors of a
     complex Hermitian matrix A using the 2stage technique for
     the reduction to tridiagonal.
    \endverbatim 

 * @param[in] JOBZ
          JOBZ is CHARACTER*1 \n
          = 'N':  Compute eigenvalues only; \n
          = 'V':  Compute eigenvalues and eigenvectors. \n
                  Not available in this release. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is COMPLEX array, dimension (LDA, N) \n
          On entry, the Hermitian matrix A.  If UPLO = 'U', the
          leading N-by-N upper triangular part of A contains the
          upper triangular part of the matrix A.  If UPLO = 'L',
          the leading N-by-N lower triangular part of A contains
          the lower triangular part of the matrix A. \n
          On exit, if JOBZ = 'V', then if INFO = 0, A contains the
          orthonormal eigenvectors of the matrix A. \n
          If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
          or the upper triangle (if UPLO='U') of A, including the
          diagonal, is destroyed. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] W
          W is REAL array, dimension (N) \n
          If INFO = 0, the eigenvalues in ascending order. \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The length of the array WORK. LWORK >= 1, when N <= 1;
          otherwise   \n
          If JOBZ = 'N' and N > 1, LWORK must be queried.
                                   LWORK = MAX(1, dimension) where
                                   dimension = max(stage1,stage2) + (KD+1)*N + N
                                             = N*KD + N*max(KD+1,FACTOPTNB) 
                                               + max(2*KD*KD, KD*NTHREADS) 
                                               + (KD+1)*N + N
                                   where KD is the blocking size of the reduction,
                                   FACTOPTNB is the blocking used by the QR or LQ
                                   algorithm, usually FACTOPTNB=128 is a good choice
                                   NTHREADS is the number of threads used when
                                   openMP compilation is enabled, otherwise =1. \n
          If JOBZ = 'V' and N > 1, LWORK must be queried. Not yet available \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	RWORK	
          RWORK is REAL array, dimension (max(1, 3*N-2)) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, the algorithm failed to converge; i
                off-diagonal elements of an intermediate tridiagonal
                form did not converge to zero. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T, typename Ta >
integer heev_2stage(char* jobz, char* uplo, integer* n, T* a, integer* lda, Ta* w, T* work, integer* lwork, Ta* rwork, integer* info)
{
  return heev_2stage(jobz, uplo, n, a, lda, w, work, lwork, rwork, info);
}

/*! @brief HEEVD_2STAGE computes the eigenvalues and, optionally, the left and/or right eigenvectors for HE matrices

 * @details
 * \b Purpose:
    \verbatim 
     HEEVD_2STAGE computes all eigenvalues and, optionally, eigenvectors of a
     complex Hermitian matrix A using the 2stage technique for
     the reduction to tridiagonal.  If eigenvectors are desired, it uses a
     divide and conquer algorithm.

     The divide and conquer algorithm makes very mild assumptions about
     floating point arithmetic. It will work on machines with a guard
     digit in add/subtract, or on those binary machines without guard
     digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
     Cray-2. It could conceivably fail on hexadecimal or decimal machines
     without guard digits, but we know of none.
    \endverbatim  

 * @param[in] JOBZ
          JOBZ is CHARACTER*1
          = 'N':  Compute eigenvalues only;
          = 'V':  Compute eigenvalues and eigenvectors.
                  Not available in this release.
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is COMPLEX array, dimension (LDA, N) \n
          On entry, the Hermitian matrix A.  If UPLO = 'U', the
          leading N-by-N upper triangular part of A contains the
          upper triangular part of the matrix A.  If UPLO = 'L',
          the leading N-by-N lower triangular part of A contains
          the lower triangular part of the matrix A. \n
          On exit, if JOBZ = 'V', then if INFO = 0, A contains the
          orthonormal eigenvectors of the matrix A. \n
          If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
          or the upper triangle (if UPLO='U') of A, including the
          diagonal, is destroyed. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] W
          W is REAL array, dimension (N) \n
          If INFO = 0, the eigenvalues in ascending order. \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK. \n
          If N <= 1,               LWORK must be at least 1. \n
          If JOBZ = 'N' and N > 1, LWORK must be queried.
                                   LWORK = MAX(1, dimension) where
                                   dimension = max(stage1,stage2) + (KD+1)*N + N+1
                                             = N*KD + N*max(KD+1,FACTOPTNB) 
                                               + max(2*KD*KD, KD*NTHREADS) 
                                               + (KD+1)*N + N+1
                                   where KD is the blocking size of the reduction,
                                   FACTOPTNB is the blocking used by the QR or LQ
                                   algorithm, usually FACTOPTNB=128 is a good choice
                                   NTHREADS is the number of threads used when
                                   openMP compilation is enabled, otherwise =1. \n
          If JOBZ = 'V' and N > 1, LWORK must be at least 2*N + N**2 \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal sizes of the WORK, RWORK and
          IWORK arrays, returns these values as the first entries of
          the WORK, RWORK and IWORK arrays, and no error message
          related to LWORK or LRWORK or LIWORK is issued by XERBLA. \n
 * @param[out]	RWORK	
          RWORK is REAL array,
                                         dimension (LRWORK) \n
          On exit, if INFO = 0, RWORK(1) returns the optimal LRWORK. \n
 * @param[in]	LRWORK	
          LRWORK is INTEGER \n
          The dimension of the array RWORK. \n
          If N <= 1,                LRWORK must be at least 1. \n
          If JOBZ  = 'N' and N > 1, LRWORK must be at least N. \n
          If JOBZ  = 'V' and N > 1, LRWORK must be at least
                         1 + 5*N + 2*N**2. \n
 \n
          If LRWORK = -1, then a workspace query is assumed; the
          routine only calculates the optimal sizes of the WORK, RWORK
          and IWORK arrays, returns these values as the first entries
          of the WORK, RWORK and IWORK arrays, and no error message
          related to LWORK or LRWORK or LIWORK is issued by XERBLA. \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (MAX(1,LIWORK)) \n
          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK. \n
 * @param[in]	LIWORK	
          LIWORK is INTEGER \n
          The dimension of the array IWORK. \n
          If N <= 1,                LIWORK must be at least 1. \n
          If JOBZ  = 'N' and N > 1, LIWORK must be at least 1. \n
          If JOBZ  = 'V' and N > 1, LIWORK must be at least 3 + 5*N. \n
 \n
          If LIWORK = -1, then a workspace query is assumed; the
          routine only calculates the optimal sizes of the WORK, RWORK
          and IWORK arrays, returns these values as the first entries
          of the WORK, RWORK and IWORK arrays, and no error message
          related to LWORK or LRWORK or LIWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i and JOBZ = 'N', then the algorithm failed
                to converge; i off-diagonal elements of an intermediate
                tridiagonal form did not converge to zero;
                if INFO = i and JOBZ = 'V', then the algorithm failed
                to compute an eigenvalue while working on the submatrix
                lying in rows and columns INFO/(N+1) through
                mod(INFO,N+1). \n

 * @return INTEGER Return value of the function.
 * */
template< typename T, typename Ta >
integer heevd_2stage(char* jobz, char* uplo, integer* n, T* a, integer* lda, Ta* w, T* work, integer* lwork, Ta* rwork, integer* lrwork, integer* iwork, integer* liwork, integer* info)
{
  return heevd_2stage(jobz, uplo, n, a, lda, w, work, lwork, rwork, lrwork, iwork, liwork, info);
}

/*! @brief HEEVR_2STAGE computes the eigenvalues and, optionally, the left and/or right eigenvectors for HE matrices

 * @details
 * \b Purpose:
    \verbatim 
     HEEVR_2STAGE computes selected eigenvalues and, optionally, eigenvectors
     of a complex Hermitian matrix A using the 2stage technique for
     the reduction to tridiagonal.  Eigenvalues and eigenvectors can
     be selected by specifying either a range of values or a range of
     indices for the desired eigenvalues.

     CHEEVR_2STAGE first reduces the matrix A to tridiagonal form T with a call
     to CHETRD.  Then, whenever possible, CHEEVR_2STAGE calls CSTEMR to compute
     eigenspectrum using Relatively Robust Representations.  CSTEMR
     computes eigenvalues by the dqds algorithm, while orthogonal
     eigenvectors are computed from various "good" L D L^T representations
     (also known as Relatively Robust Representations). Gram-Schmidt
     orthogonalization is avoided as far as possible. More specifically,
     the various steps of the algorithm are as follows.

     For each unreduced block (submatrix) of T,
        (a) Compute T - sigma I  = L D L^T, so that L and D
            define all the wanted eigenvalues to high relative accuracy.
            This means that small relative changes in the entries of D and L
            cause only small relative changes in the eigenvalues and
            eigenvectors. The standard (unfactored) representation of the
            tridiagonal matrix T does not have this property in general.
        (b) Compute the eigenvalues to suitable accuracy.
            If the eigenvectors are desired, the algorithm attains full
            accuracy of the computed eigenvalues only right before
            the corresponding vectors have to be computed, see steps c) and d).
        (c) For each cluster of close eigenvalues, select a new
            shift close to the cluster, find a new factorization, and refine
            the shifted eigenvalues to suitable accuracy.
        (d) For each eigenvalue with a large enough relative separation compute
            the corresponding eigenvector by forming a rank revealing twisted
            factorization. Go back to (c) for any clusters that remain.

     The desired accuracy of the output can be specified by the input
     parameter ABSTOL.

     For more details, see DSTEMR's documentation and:
     - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations
       to compute orthogonal eigenvectors of symmetric tridiagonal matrices,"
       Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
     - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and
       Relative Gaps," SIAM Journal on Matrix Analysis and Applications, Vol. 25,
       2004.  Also LAPACK Working Note 154.
     - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric
       tridiagonal eigenvalue/eigenvector problem",
       Computer Science Division Technical Report No. UCB/CSD-97-971,
       UC Berkeley, May 1997.


     Note 1 : CHEEVR_2STAGE calls CSTEMR when the full spectrum is requested
     on machines which conform to the ieee-754 floating point standard.
     CHEEVR_2STAGE calls SSTEBZ and CSTEIN on non-ieee machines and
     when partial spectrum requests are made.

     Normal execution of CSTEMR may create NaNs and infinities and
     hence may abort due to a floating point exception in environments
     which do not handle NaNs and infinities in the ieee standard default
     manner.
    \endverbatim  

 * @param[in] JOBZ
          JOBZ is CHARACTER*1 \n
          = 'N':  Compute eigenvalues only; \n
          = 'V':  Compute eigenvalues and eigenvectors.
                  Not available in this release. \n
 * @param[in] RANGE
          RANGE is CHARACTER*1 \n
          = 'A': all eigenvalues will be found. \n
          = 'V': all eigenvalues in the half-open interval (VL,VU]
                 will be found. \n
          = 'I': the IL-th through IU-th eigenvalues will be found.
          For RANGE = 'V' or 'I' and IU - IL < N - 1, SSTEBZ and
          CSTEIN are called \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is COMPLEX array, dimension (LDA, N) \n
          On entry, the Hermitian matrix A.  If UPLO = 'U', the
          leading N-by-N upper triangular part of A contains the
          upper triangular part of the matrix A.  If UPLO = 'L',
          the leading N-by-N lower triangular part of A contains
          the lower triangular part of the matrix A. \n
          On exit, the lower triangle (if UPLO='L') or the upper
          triangle (if UPLO='U') of A, including the diagonal, is
          destroyed. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] VL
          VL is REAL \n
          If RANGE='V', the lower bound of the interval to
          be searched for eigenvalues. VL < VU.
          Not referenced if RANGE = 'A' or 'I'. \n
 * @param[in] VU
          VU is REAL \n
          If RANGE='V', the upper bound of the interval to
          be searched for eigenvalues. VL < VU.
          Not referenced if RANGE = 'A' or 'I'. \n
 * @param[in] IL
          IL is INTEGER \n
          If RANGE='I', the index of the
          smallest eigenvalue to be returned. \n
          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0. \n
          Not referenced if RANGE = 'A' or 'V'. \n
 * @param[in] IU
          IU is INTEGER \n
          If RANGE='I', the index of the
          largest eigenvalue to be returned. \n
          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0. \n
          Not referenced if RANGE = 'A' or 'V'. \n
 * @param[in] ABSTOL
          ABSTOL is REAL \n
          The absolute error tolerance for the eigenvalues.
          An approximate eigenvalue is accepted as converged
          when it is determined to lie in an interval [a,b]
          of width less than or equal to \n
 \n
                  ABSTOL + EPS *   max( |a|,|b|) , \n
 \n
          where EPS is the machine precision.  If ABSTOL is less than
          or equal to zero, then  EPS*|T|  will be used in its place,
          where |T| is the 1-norm of the tridiagonal matrix obtained
          by reducing A to tridiagonal form. \n
 \n
          See "Computing Small Singular Values of Bidiagonal Matrices
          with Guaranteed High Relative Accuracy," by Demmel and
          Kahan, LAPACK Working Note #3. \n
 \n
          If high relative accuracy is important, set ABSTOL to
          SLAMCH( 'Safe minimum').  Doing so will guarantee that
          eigenvalues are computed to high relative accuracy when
          possible in future releases.  The current code does not
          make any guarantees about high relative accuracy, but
          future releases will. See J. Barlow and J. Demmel,
          "Computing Accurate Eigensystems of Scaled Diagonally
          Dominant Matrices", LAPACK Working Note #7, for a discussion
          of which matrices define their eigenvalues to high relative
          accuracy. \n
 * @param[out] M
          M is INTEGER \n
          The total number of eigenvalues found.  0 <= M <= N.
          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1. \n
 * @param[out] W
          W is REAL array, dimension (N) \n
          The first M elements contain the selected eigenvalues in
          ascending order. \n
 * @param[out] Z
          Z is COMPLEX array, dimension (LDZ, max(1,M)) \n
          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
          contain the orthonormal eigenvectors of the matrix A
          corresponding to the selected eigenvalues, with the i-th
          column of Z holding the eigenvector associated with W(i).
          If JOBZ = 'N', then Z is not referenced. \n
          Note: the user must ensure that at least max(1,M) columns are
          supplied in the array Z; if RANGE = 'V', the exact value of M
          is not known in advance and an upper bound must be used. \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of the array Z.  LDZ >= 1, and if
          JOBZ = 'V', LDZ >= max(1,N). \n
 * @param[out] ISUPPZ
          ISUPPZ is INTEGER array, dimension ( 2*max(1,M)) \n
          The support of the eigenvectors in Z, i.e., the indices
          indicating the nonzero elements in Z. The i-th eigenvector
          is nonzero only in elements ISUPPZ( 2*i-1) through
          ISUPPZ( 2*i). This is an output of CSTEMR (tridiagonal
          matrix). The support of the eigenvectors of A is typically 
          1:N because of the unitary transformations applied by CUNMTR.
          Implemented only for RANGE = 'A' or 'I' and IU - IL = N - 1 \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK.   \n
          If JOBZ = 'N' and N > 1, LWORK must be queried.
                                   LWORK = MAX(1, 26*N, dimension) where
                                   dimension = max(stage1,stage2) + (KD+1)*N + N
                                             = N*KD + N*max(KD+1,FACTOPTNB) 
                                               + max(2*KD*KD, KD*NTHREADS) 
                                               + (KD+1)*N + N
                                   where KD is the blocking size of the reduction,
                                   FACTOPTNB is the blocking used by the QR or LQ
                                   algorithm, usually FACTOPTNB=128 is a good choice
                                   NTHREADS is the number of threads used when
                                   openMP compilation is enabled, otherwise =1. \n
          If JOBZ = 'V' and N > 1, LWORK must be queried. Not yet available \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal sizes of the WORK, RWORK and
          IWORK arrays, returns these values as the first entries of
          the WORK, RWORK and IWORK arrays, and no error message
          related to LWORK or LRWORK or LIWORK is issued by XERBLA. \n
 * @param[out]	RWORK	
          RWORK is REAL array, dimension (MAX(1,LRWORK)) \n
          On exit, if INFO = 0, RWORK(1) returns the optimal
          (and minimal) LRWORK. \n
 * @param[in]	LRWORK	
          LRWORK is INTEGER \n
          The length of the array RWORK.  LRWORK >= max(1,24*N). \n
 \n
          If LRWORK = -1, then a workspace query is assumed; the
          routine only calculates the optimal sizes of the WORK, RWORK
          and IWORK arrays, returns these values as the first entries
          of the WORK, RWORK and IWORK arrays, and no error message
          related to LWORK or LRWORK or LIWORK is issued by XERBLA. \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (MAX(1,LIWORK)) \n
          On exit, if INFO = 0, IWORK(1) returns the optimal
          (and minimal) LIWORK. \n
 * @param[in]	LIWORK	
          LIWORK is INTEGER \n
          The dimension of the array IWORK.  LIWORK >= max(1,10*N). \n
 \n
          If LIWORK = -1, then a workspace query is assumed; the
          routine only calculates the optimal sizes of the WORK, RWORK
          and IWORK arrays, returns these values as the first entries
          of the WORK, RWORK and IWORK arrays, and no error message
          related to LWORK or LRWORK or LIWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  Internal error \n

 * @return INTEGER Return value of the function.
 * */
template< typename T, typename Ta >
integer heevr_2stage(char* jobz, char* range, char* uplo, integer* n, T* a, integer* lda, Ta* vl, Ta* vu, integer* il, integer* iu, Ta* abstol, integer* m, Ta* w, T* z, integer* ldz, integer* isuppz, T* work, integer* lwork, Ta* rwork, integer* lrwork, integer* iwork, integer* liwork, integer* info)
{
  return heevr_2stage(jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, rwork, lrwork, iwork, liwork, info);
}

/*! @brief HEEVX computes the eigenvalues and, optionally, the left and/or right eigenvectors for HE matrices

 * @details
 * \b Purpose:
    \verbatim 
     HEEVX computes selected eigenvalues and, optionally, eigenvectors
     of a complex Hermitian matrix A.  Eigenvalues and eigenvectors can
     be selected by specifying either a range of values or a range of
     indices for the desired eigenvalues.
    \endverbatim  

 * @param[in] JOBZ
          JOBZ is CHARACTER*1 \n
          = 'N':  Compute eigenvalues only; \n
          = 'V':  Compute eigenvalues and eigenvectors. \n
 * @param[in] RANGE
          RANGE is CHARACTER*1 \n
          = 'A': all eigenvalues will be found. \n
          = 'V': all eigenvalues in the half-open interval (VL,VU]
                 will be found. \n
          = 'I': the IL-th through IU-th eigenvalues will be found. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is COMPLEX array, dimension (LDA, N) \n
          On entry, the Hermitian matrix A.  If UPLO = 'U', the
          leading N-by-N upper triangular part of A contains the
          upper triangular part of the matrix A.  If UPLO = 'L',
          the leading N-by-N lower triangular part of A contains
          the lower triangular part of the matrix A. \n
          On exit, the lower triangle (if UPLO='L') or the upper
          triangle (if UPLO='U') of A, including the diagonal, is
          destroyed. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] VL
          VL is REAL \n
          If RANGE='V', the lower bound of the interval to
          be searched for eigenvalues. VL < VU.
          Not referenced if RANGE = 'A' or 'I'. \n
 * @param[in] VU
          VU is REAL \n
          If RANGE='V', the upper bound of the interval to
          be searched for eigenvalues. VL < VU.
          Not referenced if RANGE = 'A' or 'I'. \n
 * @param[in] IL
          IL is INTEGER \n
          If RANGE='I', the index of the
          smallest eigenvalue to be returned. \n
          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0. \n
          Not referenced if RANGE = 'A' or 'V'. \n
 * @param[in] IU
          IU is INTEGER \n
          If RANGE='I', the index of the
          largest eigenvalue to be returned. \n
          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0. \n
          Not referenced if RANGE = 'A' or 'V'. \n
 * @param[in] ABSTOL
          ABSTOL is REAL \n
          The absolute error tolerance for the eigenvalues.
          An approximate eigenvalue is accepted as converged
          when it is determined to lie in an interval [a,b]
          of width less than or equal to \n
 \n
                  ABSTOL + EPS *   max( |a|,|b|) , \n
 \n
          where EPS is the machine precision.  If ABSTOL is less than
          or equal to zero, then  EPS*|T|  will be used in its place,
          where |T| is the 1-norm of the tridiagonal matrix obtained
          by reducing A to tridiagonal form.
 \n
          Eigenvalues will be computed most accurately when ABSTOL is
          set to twice the underflow threshold 2*SLAMCH('S'), not zero.
          If this routine returns with INFO>0, indicating that some
          eigenvectors did not converge, try setting ABSTOL to
          2*SLAMCH('S').
 \n
          See "Computing Small Singular Values of Bidiagonal Matrices
          with Guaranteed High Relative Accuracy," by Demmel and
          Kahan, LAPACK Working Note #3. \n
 * @param[out] M
          M is INTEGER \n
          The total number of eigenvalues found.  0 <= M <= N.
          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1. \n
 * @param[out] W
          W is REAL array, dimension (N) \n
          On normal exit, the first M elements contain the selected
          eigenvalues in ascending order. \n
 * @param[out] Z
          Z is COMPLEX array, dimension (LDZ, max(1,M)) \n
          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
          contain the orthonormal eigenvectors of the matrix A
          corresponding to the selected eigenvalues, with the i-th
          column of Z holding the eigenvector associated with W(i).
          If an eigenvector fails to converge, then that column of Z
          contains the latest approximation to the eigenvector, and the
          index of the eigenvector is returned in IFAIL.
          If JOBZ = 'N', then Z is not referenced. \n
          Note: the user must ensure that at least max(1,M) columns are
          supplied in the array Z; if RANGE = 'V', the exact value of M
          is not known in advance and an upper bound must be used. \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of the array Z.  LDZ >= 1, and if
          JOBZ = 'V', LDZ >= max(1,N). \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The length of the array WORK.  LWORK >= 1, when N <= 1;
          otherwise 2*N. \n
          For optimal efficiency, LWORK >= (NB+1)*N,
          where NB is the max of the blocksize for CHETRD and for
          CUNMTR as returned by ILAENV. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	RWORK	
          RWORK is REAL array, dimension (7*N) \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (5*N) \n
 * @param[out]	IFAIL	
          IFAIL is INTEGER array, dimension (N) \n
          If JOBZ = 'V', then if INFO = 0, the first M elements of
          IFAIL are zero.  If INFO > 0, then IFAIL contains the
          indices of the eigenvectors that failed to converge. \n
          If JOBZ = 'N', then IFAIL is not referenced. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, then i eigenvectors failed to converge.
                Their indices are stored in array IFAIL. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T, typename Ta >
integer heevx(char* jobz, char* range, char* uplo, integer* n, T* a, integer* lda, Ta* vl, Ta* vu, integer* il, integer* iu, Ta* abstol, integer* m, Ta* w, T* z, integer* ldz, T* work, integer* lwork, Ta* rwork, integer* iwork, integer* ifail, integer* info)
{
  return heevx(jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, rwork, iwork, ifail, info);
}

/*! @brief HEEVX_2STAGE computes the eigenvalues and, optionally, the left and/or right eigenvectors for HE matrices

 * @details
 * \b Purpose:
    \verbatim 
    HEEVX_2STAGE computes selected eigenvalues and, optionally, eigenvectors
    of a complex Hermitian matrix A using the 2stage technique for
    the reduction to tridiagonal.  Eigenvalues and eigenvectors can
    be selected by specifying either a range of values or a range of
    indices for the desired eigenvalues
    \endverbatim  

 * @param[in] JOBZ
          JOBZ is CHARACTER*1 \n
          = 'N':  Compute eigenvalues only; \n
          = 'V':  Compute eigenvalues and eigenvectors. \n
 * @param[in] RANGE
          RANGE is CHARACTER*1 \n
          = 'A': all eigenvalues will be found. \n
          = 'V': all eigenvalues in the half-open interval (VL,VU]
                 will be found. \n
          = 'I': the IL-th through IU-th eigenvalues will be found. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is COMPLEX array, dimension (LDA, N) \n
          On entry, the Hermitian matrix A.  If UPLO = 'U', the
          leading N-by-N upper triangular part of A contains the
          upper triangular part of the matrix A.  If UPLO = 'L',
          the leading N-by-N lower triangular part of A contains
          the lower triangular part of the matrix A. \n
          On exit, the lower triangle (if UPLO='L') or the upper
          triangle (if UPLO='U') of A, including the diagonal, is
          destroyed. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] VL
          VL is REAL \n
          If RANGE='V', the lower bound of the interval to
          be searched for eigenvalues. VL < VU. \n
          Not referenced if RANGE = 'A' or 'I'. \n
 * @param[in] VU
          VU is REAL \n
          If RANGE='V', the upper bound of the interval to
          be searched for eigenvalues. VL < VU.
          Not referenced if RANGE = 'A' or 'I'. \n
 * @param[in] IL
          IL is INTEGER \n
          If RANGE='I', the index of the
          smallest eigenvalue to be returned. \n
          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0. \n
          Not referenced if RANGE = 'A' or 'V'. \n
 * @param[in] IU
          IU is INTEGER \n
          If RANGE='I', the index of the
          largest eigenvalue to be returned. \n
          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0. \n
          Not referenced if RANGE = 'A' or 'V'. \n
 * @param[in] ABSTOL
          ABSTOL is REAL \n
          The absolute error tolerance for the eigenvalues.
          An approximate eigenvalue is accepted as converged
          when it is determined to lie in an interval [a,b]
          of width less than or equal to \n
 \n
                  ABSTOL + EPS *   max( |a|,|b|) , \n
 \n
          where EPS is the machine precision.  If ABSTOL is less than
          or equal to zero, then  EPS*|T|  will be used in its place,
          where |T| is the 1-norm of the tridiagonal matrix obtained
          by reducing A to tridiagonal form. \n
 \n
          Eigenvalues will be computed most accurately when ABSTOL is
          set to twice the underflow threshold 2*SLAMCH('S'), not zero.
          If this routine returns with INFO>0, indicating that some
          eigenvectors did not converge, try setting ABSTOL to
          2*SLAMCH('S'). \n
 \n
          See "Computing Small Singular Values of Bidiagonal Matrices
          with Guaranteed High Relative Accuracy," by Demmel and
          Kahan, LAPACK Working Note #3. \n
 * @param[out] M
          M is INTEGER \n
          The total number of eigenvalues found.  0 <= M <= N.
          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1. \n
 * @param[out] W
          W is REAL array, dimension (N) \n
          On normal exit, the first M elements contain the selected
          eigenvalues in ascending order. \n
 * @param[out] Z
          Z is COMPLEX array, dimension (LDZ, max(1,M)) \n
          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
          contain the orthonormal eigenvectors of the matrix A
          corresponding to the selected eigenvalues, with the i-th
          column of Z holding the eigenvector associated with W(i).
          If an eigenvector fails to converge, then that column of Z
          contains the latest approximation to the eigenvector, and the
          index of the eigenvector is returned in IFAIL. \n
          If JOBZ = 'N', then Z is not referenced. \n
          Note: the user must ensure that at least max(1,M) columns are
          supplied in the array Z; if RANGE = 'V', the exact value of M
          is not known in advance and an upper bound must be used. \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of the array Z.  LDZ >= 1, and if
          JOBZ = 'V', LDZ >= max(1,N). \n
 * @param[out] IFAIL
          IFAIL is INTEGER array, dimension (N) \n
          If JOBZ = 'V', then if INFO = 0, the first M elements of
          IFAIL are zero.  If INFO > 0, then IFAIL contains the
          indices of the eigenvectors that failed to converge.
          If JOBZ = 'N', then IFAIL is not referenced. \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The length of the array WORK. LWORK >= 1, when N <= 1;
          otherwise   \n
          If JOBZ = 'N' and N > 1, LWORK must be queried.
                                   LWORK = MAX(1, 8*N, dimension) where
                                   dimension = max(stage1,stage2) + (KD+1)*N + N
                                             = N*KD + N*max(KD+1,FACTOPTNB) 
                                               + max(2*KD*KD, KD*NTHREADS) 
                                               + (KD+1)*N + N
                                   where KD is the blocking size of the reduction,
                                   FACTOPTNB is the blocking used by the QR or LQ
                                   algorithm, usually FACTOPTNB=128 is a good choice
                                   NTHREADS is the number of threads used when
                                   openMP compilation is enabled, otherwise =1. \n
          If JOBZ = 'V' and N > 1, LWORK must be queried. Not yet available
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	RWORK	
          RWORK is REAL array, dimension (7*N) \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (5*N) \n
 * @param[out]	IFAIL	
          IFAIL is INTEGER array, dimension (N) \n
          If JOBZ = 'V', then if INFO = 0, the first M elements of
          IFAIL are zero.  If INFO > 0, then IFAIL contains the
          indices of the eigenvectors that failed to converge. \n
          If JOBZ = 'N', then IFAIL is not referenced. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, then i eigenvectors failed to converge.
                Their indices are stored in array IFAIL. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T, typename Ta >
integer heevx_2stage(char* jobz, char* range, char* uplo, integer* n, T* a, integer* lda, Ta* vl, Ta* vu, integer* il, integer* iu, Ta* abstol, integer* m, Ta* w, T* z, integer* ldz, T* work, integer* lwork, Ta* rwork, integer* iwork, integer* ifail, integer* info)
{
  return heevx_2stage(jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, rwork, iwork, ifail, info);
}

/*! @brief HEGV computes all the eigenvalues, and optionally, the eigenvectors  \n
     of a complex generalized Hermitian-definite eigenproblem

 * @details
 * \b Purpose:
    \verbatim 
     HEGV computes all the eigenvalues, and optionally, the eigenvectors
     of a complex generalized Hermitian-definite eigenproblem, of the form
     A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.
     Here A and B are assumed to be Hermitian and B is also
     positive definite.
    \endverbatim  

 * @param[in] ITYPE
          ITYPE is INTEGER \n
          Specifies the problem type to be solved: \n
          = 1:  A*x = (lambda)*B*x \n
          = 2:  A*B*x = (lambda)*x \n
          = 3:  B*A*x = (lambda)*x \n
 * @param[in] JOBZ
          JOBZ is CHARACTER*1 \n
          = 'N':  Compute eigenvalues only; \n
          = 'V':  Compute eigenvalues and eigenvectors. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangles of A and B are stored; \n
          = 'L':  Lower triangles of A and B are stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrices A and B.  N >= 0. \n
 * @param[in,out] A
          A is COMPLEX array, dimension (LDA, N) \n
          On entry, the Hermitian matrix A.  If UPLO = 'U', the
          leading N-by-N upper triangular part of A contains the
          upper triangular part of the matrix A.  If UPLO = 'L',
          the leading N-by-N lower triangular part of A contains
          the lower triangular part of the matrix A. \n
 \n
          On exit, if JOBZ = 'V', then if INFO = 0, A contains the
          matrix Z of eigenvectors.  The eigenvectors are normalized
          as follows: \n
          if ITYPE = 1 or 2, Z**H*B*Z = I; \n
          if ITYPE = 3, Z**H*inv(B)*Z = I. \n
          If JOBZ = 'N', then on exit the upper triangle (if UPLO='U')
          or the lower triangle (if UPLO='L') of A, including the
          diagonal, is destroyed. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in,out] B
          B is COMPLEX array, dimension (LDB, N) \n
          On entry, the Hermitian positive definite matrix B.
          If UPLO = 'U', the leading N-by-N upper triangular part of B
          contains the upper triangular part of the matrix B. \n
          If UPLO = 'L', the leading N-by-N lower triangular part of B
          contains the lower triangular part of the matrix B. \n
 \n
          On exit, if INFO <= N, the part of B containing the matrix is
          overwritten by the triangular factor U or L from the Cholesky
          factorization B = U**H*U or B = L*L**H. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out] W
          W is REAL array, dimension (N) \n
          If INFO = 0, the eigenvalues in ascending order. \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The length of the array WORK.  LWORK >= max(1,2*N-1).
          For optimal efficiency, LWORK >= (NB+1)*N,
          where NB is the blocksize for CHETRD returned by ILAENV. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	RWORK	
          RWORK is REAL array, dimension (max(1, 3*N-2)) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  CPOTRF or CHEEV returned an error code: \n
             <= N:  if INFO = i, CHEEV failed to converge;
                    i off-diagonal elements of an intermediate
                    tridiagonal form did not converge to zero; \n
             > N:   if INFO = N + i, for 1 <= i <= N, then the leading
                    minor of order i of B is not positive definite.
                    The factorization of B could not be completed and
                    no eigenvalues or eigenvectors were computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T, typename Ta >
integer hegv(integer* itype, char* jobz, char* uplo, integer* n, T* a, integer* lda, T* b, integer* ldb, Ta* w, T* work, integer* lwork, Ta* rwork, integer* info)
{
  return hegv(itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, rwork, info);
}

/*! @brief HEGV_2STAGE computes all the eigenvalues, and optionally, the eigenvectors  \n
     of a complex generalized Hermitian-definite eigenproblem

 * @details
 * \b Purpose:
    \verbatim 
     HEGV_2STAGE computes all the eigenvalues, and optionally, the eigenvectors
     of a complex generalized Hermitian-definite eigenproblem, of the form
     A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.
     Here A and B are assumed to be Hermitian and B is also
     positive definite.
     This routine use the 2stage technique for the reduction to tridiagonal
     which showed higher performance on recent architecture and for large
     sizes N>2000.
    \endverbatim  

 * @param[in] ITYPE
          ITYPE is INTEGER \n
          Specifies the problem type to be solved: \n
          = 1:  A*x = (lambda)*B*x \n
          = 2:  A*B*x = (lambda)*x \n
          = 3:  B*A*x = (lambda)*x \n
 * @param[in] JOBZ
          JOBZ is CHARACTER*1 \n
          = 'N':  Compute eigenvalues only; \n
          = 'V':  Compute eigenvalues and eigenvectors. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangles of A and B are stored; \n
          = 'L':  Lower triangles of A and B are stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrices A and B.  N >= 0. \n
 * @param[in,out] A
          A is COMPLEX array, dimension (LDA, N) \n
          On entry, the Hermitian matrix A.  If UPLO = 'U', the
          leading N-by-N upper triangular part of A contains the
          upper triangular part of the matrix A.  If UPLO = 'L',
          the leading N-by-N lower triangular part of A contains
          the lower triangular part of the matrix A. \n
 \n
          On exit, if JOBZ = 'V', then if INFO = 0, A contains the
          matrix Z of eigenvectors.  The eigenvectors are normalized
          as follows: \n
          if ITYPE = 1 or 2, Z**H*B*Z = I; \n
          if ITYPE = 3, Z**H*inv(B)*Z = I. \n
          If JOBZ = 'N', then on exit the upper triangle (if UPLO='U')
          or the lower triangle (if UPLO='L') of A, including the
          diagonal, is destroyed. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in,out] B
          B is COMPLEX array, dimension (LDB, N) \n
          On entry, the Hermitian positive definite matrix B.
          If UPLO = 'U', the leading N-by-N upper triangular part of B
          contains the upper triangular part of the matrix B. \n
          If UPLO = 'L', the leading N-by-N lower triangular part of B
          contains the lower triangular part of the matrix B. \n
 \n
          On exit, if INFO <= N, the part of B containing the matrix is
          overwritten by the triangular factor U or L from the Cholesky
          factorization B = U**H*U or B = L*L**H. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out] W
          W is REAL array, dimension (N) \n
          If INFO = 0, the eigenvalues in ascending order. \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The length of the array WORK. LWORK >= 1, when N <= 1;
          otherwise   \n
          If JOBZ = 'N' and N > 1, LWORK must be queried.
                                   LWORK = MAX(1, dimension) where
                                   dimension = max(stage1,stage2) + (KD+1)*N + N
                                             = N*KD + N*max(KD+1,FACTOPTNB) 
                                               + max(2*KD*KD, KD*NTHREADS) 
                                               + (KD+1)*N + N
                                   where KD is the blocking size of the reduction,
                                   FACTOPTNB is the blocking used by the QR or LQ
                                   algorithm, usually FACTOPTNB=128 is a good choice
                                   NTHREADS is the number of threads used when
                                   openMP compilation is enabled, otherwise =1. \n
          If JOBZ = 'V' and N > 1, LWORK must be queried. Not yet available \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	RWORK	
          RWORK is REAL array, dimension (max(1, 3*N-2)) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  CPOTRF or CHEEV returned an error code: \n
             <= N:  if INFO = i, CHEEV failed to converge;
                    i off-diagonal elements of an intermediate
                    tridiagonal form did not converge to zero; \n
             > N:   if INFO = N + i, for 1 <= i <= N, then the leading
                    minor of order i of B is not positive definite.
                    The factorization of B could not be completed and
                    no eigenvalues or eigenvectors were computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T, typename Ta >
integer hegv_2stage(integer* itype, char* jobz, char* uplo, integer* n, T* a, integer* lda, T* b, integer* ldb, Ta* w, T* work, integer* lwork, Ta* rwork, integer* info)
{
  return hegv_2stage(itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, rwork, info);
}

/*! @brief HEGVD computes all the eigenvalues, and optionally, the eigenvectors  \n
     of a complex generalized Hermitian-definite eigenproblem

 * @details
 * \b Purpose:
    \verbatim 
    HEGVD computes all the eigenvalues, and optionally, the eigenvectors
    of a complex generalized Hermitian-definite eigenproblem, of the form
    A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and
    B are assumed to be Hermitian and B is also positive definite.
    If eigenvectors are desired, it uses a divide and conquer algorithm.

    The divide and conquer algorithm makes very mild assumptions about
    floating point arithmetic. It will work on machines with a guard
    digit in add/subtract, or on those binary machines without guard
    digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
    Cray-2. It could conceivably fail on hexadecimal or decimal machines
    without guard digits, but we know of none.
    \endverbatim  

 * @param[in] ITYPE
          ITYPE is INTEGER \n
          Specifies the problem type to be solved: \n
          = 1:  A*x = (lambda)*B*x \n
          = 2:  A*B*x = (lambda)*x \n
          = 3:  B*A*x = (lambda)*x \n
 * @param[in] JOBZ
          JOBZ is CHARACTER*1 \n
          = 'N':  Compute eigenvalues only; \n
          = 'V':  Compute eigenvalues and eigenvectors. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangles of A and B are stored; \n
          = 'L':  Lower triangles of A and B are stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrices A and B.  N >= 0. \n
 * @param[in,out] A
          A is COMPLEX array, dimension (LDA, N) \n
          On entry, the Hermitian matrix A.  If UPLO = 'U', the
          leading N-by-N upper triangular part of A contains the
          upper triangular part of the matrix A.  If UPLO = 'L',
          the leading N-by-N lower triangular part of A contains
          the lower triangular part of the matrix A. \n
 \n
          On exit, if JOBZ = 'V', then if INFO = 0, A contains the
          matrix Z of eigenvectors.  The eigenvectors are normalized
          as follows: \n
          if ITYPE = 1 or 2, Z**H*B*Z = I; \n
          if ITYPE = 3, Z**H*inv(B)*Z = I. \n
          If JOBZ = 'N', then on exit the upper triangle (if UPLO='U')
          or the lower triangle (if UPLO='L') of A, including the
          diagonal, is destroyed. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in,out] B
          B is COMPLEX array, dimension (LDB, N) \n
          On entry, the Hermitian positive definite matrix B.
          If UPLO = 'U', the leading N-by-N upper triangular part of B
          contains the upper triangular part of the matrix B. \n
          If UPLO = 'L', the leading N-by-N lower triangular part of B
          contains the lower triangular part of the matrix B.
 \n
          On exit, if INFO <= N, the part of B containing the matrix is
          overwritten by the triangular factor U or L from the Cholesky
          factorization B = U**H*U or B = L*L**H. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out] W
          W is REAL array, dimension (N) \n
          If INFO = 0, the eigenvalues in ascending order. \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The length of the array WORK. \n
          If N <= 1,                LWORK >= 1. \n
          If JOBZ  = 'N' and N > 1, LWORK >= N + 1. \n
          If JOBZ  = 'V' and N > 1, LWORK >= 2*N + N**2.
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal sizes of the WORK, RWORK and
          IWORK arrays, returns these values as the first entries of
          the WORK, RWORK and IWORK arrays, and no error message
          related to LWORK or LRWORK or LIWORK is issued by XERBLA. \n
 * @param[out]	RWORK	
          RWORK is REAL array, dimension (MAX(1,LRWORK)) \n
          On exit, if INFO = 0, RWORK(1) returns the optimal LRWORK. \n
 * @param[in]	LRWORK	
          LRWORK is INTEGER \n
          The dimension of the array RWORK. \n
          If N <= 1,                LRWORK >= 1. \n
          If JOBZ  = 'N' and N > 1, LRWORK >= N. \n
          If JOBZ  = 'V' and N > 1, LRWORK >= 1 + 5*N + 2*N**2.
 \n
          If LRWORK = -1, then a workspace query is assumed; the
          routine only calculates the optimal sizes of the WORK, RWORK
          and IWORK arrays, returns these values as the first entries
          of the WORK, RWORK and IWORK arrays, and no error message
          related to LWORK or LRWORK or LIWORK is issued by XERBLA. \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (MAX(1,LIWORK)) \n
          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK. \n
 * @param[in]	LIWORK	
          LIWORK is INTEGER \n
          The dimension of the array IWORK. \n
          If N <= 1,                LIWORK >= 1. \n
          If JOBZ  = 'N' and N > 1, LIWORK >= 1. \n
          If JOBZ  = 'V' and N > 1, LIWORK >= 3 + 5*N.
 \n
          If LIWORK = -1, then a workspace query is assumed; the
          routine only calculates the optimal sizes of the WORK, RWORK
          and IWORK arrays, returns these values as the first entries
          of the WORK, RWORK and IWORK arrays, and no error message
          related to LWORK or LRWORK or LIWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  CPOTRF or CHEEVD returned an error code: \n
             <= N:  if INFO = i and JOBZ = 'N', then the algorithm
                    failed to converge; i off-diagonal elements of an
                    intermediate tridiagonal form did not converge to
                    zero;
                    if INFO = i and JOBZ = 'V', then the algorithm
                    failed to compute an eigenvalue while working on
                    the submatrix lying in rows and columns INFO/(N+1)
                    through mod(INFO,N+1); \n
             > N:   if INFO = N + i, for 1 <= i <= N, then the leading
                    minor of order i of B is not positive definite.
                    The factorization of B could not be completed and
                    no eigenvalues or eigenvectors were computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T, typename Ta >
integer hegvd(integer* itype, char* jobz, char* uplo, integer* n, T* a, integer* lda, T* b, integer* ldb, Ta* w, T* work, integer* lwork, Ta* rwork, integer* lrwork, integer* iwork, integer* liwork, integer* info)
{
  return hegvd(itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, rwork, lrwork, iwork, liwork, info);
}

/*! @brief HEGVX computes selected eigenvalues, and optionally, eigenvectors   \n
     of a complex generalized Hermitian-definite eigenproblem
 * @details
 * \b Purpose:
    \verbatim 
    HEGVX computes selected eigenvalues, and optionally, eigenvectors
    of a complex generalized Hermitian-definite eigenproblem, of the form
    A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and
    B are assumed to be Hermitian and B is also positive definite.
    Eigenvalues and eigenvectors can be selected by specifying either a
    range of values or a range of indices for the desired eigenvalues.
    \endverbatim 

 * @param[in] ITYPE
          ITYPE is INTEGER \n
          Specifies the problem type to be solved: \n
          = 1:  A*x = (lambda)*B*x \n
          = 2:  A*B*x = (lambda)*x \n
          = 3:  B*A*x = (lambda)*x \n
 * @param[in] JOBZ
          JOBZ is CHARACTER*1 \n
          = 'N':  Compute eigenvalues only; \n
          = 'V':  Compute eigenvalues and eigenvectors. \n
 * @param[in] RANGE
          RANGE is CHARACTER*1 \n
          = 'A': all eigenvalues will be found. \n
          = 'V': all eigenvalues in the half-open interval (VL,VU]
                 will be found. \n
          = 'I': the IL-th through IU-th eigenvalues will be found. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangles of A and B are stored; \n
          = 'L':  Lower triangles of A and B are stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrices A and B.  N >= 0. \n
 * @param[in,out] A
          A is COMPLEX array, dimension (LDA, N) \n
          On entry, the Hermitian matrix A.  If UPLO = 'U', the
          leading N-by-N upper triangular part of A contains the
          upper triangular part of the matrix A.  If UPLO = 'L',
          the leading N-by-N lower triangular part of A contains
          the lower triangular part of the matrix A. \n
 \n
          On exit,  the lower triangle (if UPLO='L') or the upper
          triangle (if UPLO='U') of A, including the diagonal, is
          destroyed. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in,out] B
          B is COMPLEX array, dimension (LDB, N) \n
          On entry, the Hermitian matrix B.  If UPLO = 'U', the
          leading N-by-N upper triangular part of B contains the
          upper triangular part of the matrix B.  If UPLO = 'L',
          the leading N-by-N lower triangular part of B contains
          the lower triangular part of the matrix B. \n
 \n
          On exit, if INFO <= N, the part of B containing the matrix is
          overwritten by the triangular factor U or L from the Cholesky
          factorization B = U**H*U or B = L*L**H. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[in] VL
          VL is REAL \n
          If RANGE='V', the lower bound of the interval to
          be searched for eigenvalues. VL < VU.
          Not referenced if RANGE = 'A' or 'I'. \n
 * @param[in] VU
          VU is REAL \n
          If RANGE='V', the upper bound of the interval to
          be searched for eigenvalues. VL < VU.
          Not referenced if RANGE = 'A' or 'I'. \n
 * @param[in] IL
          IL is INTEGER \n
          If RANGE='I', the index of the
          smallest eigenvalue to be returned. \n
          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0. \n
          Not referenced if RANGE = 'A' or 'V'. \n
 * @param[in] IU
          IU is INTEGER \n
          If RANGE='I', the index of the
          largest eigenvalue to be returned. \n
          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0. \n
          Not referenced if RANGE = 'A' or 'V'. \n
 * @param[in] ABSTOL
          ABSTOL is REAL \n
          The absolute error tolerance for the eigenvalues.
          An approximate eigenvalue is accepted as converged
          when it is determined to lie in an interval [a,b]
          of width less than or equal to \n
 \n
                  ABSTOL + EPS *   max( |a|,|b|) , \n
 \n
          where EPS is the machine precision.  If ABSTOL is less than
          or equal to zero, then  EPS*|T|  will be used in its place,
          where |T| is the 1-norm of the tridiagonal matrix obtained
          by reducing C to tridiagonal form, where C is the symmetric
          matrix of the standard symmetric problem to which the
          generalized problem is transformed.
 \n
          Eigenvalues will be computed most accurately when ABSTOL is
          set to twice the underflow threshold 2*SLAMCH('S'), not zero.
          If this routine returns with INFO>0, indicating that some
          eigenvectors did not converge, try setting ABSTOL to
          2*SLAMCH('S'). \n
 * @param[out] M
          M is INTEGER \n
          The total number of eigenvalues found.  0 <= M <= N.
          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1. \n
 * @param[out] W
          W is REAL array, dimension (N) \n
          The first M elements contain the selected
          eigenvalues in ascending order. \n
 * @param[out] Z
          Z is COMPLEX array, dimension (LDZ, max(1,M)) \n
          If JOBZ = 'N', then Z is not referenced. \n
          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
          contain the orthonormal eigenvectors of the matrix A
          corresponding to the selected eigenvalues, with the i-th
          column of Z holding the eigenvector associated with W(i).
          The eigenvectors are normalized as follows: \n
          if ITYPE = 1 or 2, Z**T*B*Z = I; \n
          if ITYPE = 3, Z**T*inv(B)*Z = I. \n
 \n
          If an eigenvector fails to converge, then that column of Z
          contains the latest approximation to the eigenvector, and the
          index of the eigenvector is returned in IFAIL.
          Note: the user must ensure that at least max(1,M) columns are
          supplied in the array Z; if RANGE = 'V', the exact value of M
          is not known in advance and an upper bound must be used. \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of the array Z.  LDZ >= 1, and if
          JOBZ = 'V', LDZ >= max(1,N). \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The length of the array WORK.  LWORK >= max(1,2*N).
          For optimal efficiency, LWORK >= (NB+1)*N,
          where NB is the blocksize for CHETRD returned by ILAENV.
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	RWORK	
          RWORK is REAL array, dimension (7*N) \n
 * @param[out]	IWORK	
          IWORK is INTEGER array, dimension (5*N) \n
 * @param[out]	IFAIL	
          IFAIL is INTEGER array, dimension (N) \n
          If JOBZ = 'V', then if INFO = 0, the first M elements of
          IFAIL are zero.  If INFO > 0, then IFAIL contains the
          indices of the eigenvectors that failed to converge. \n
          If JOBZ = 'N', then IFAIL is not referenced. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  CPOTRF or CHEEVX returned an error code: \n
             <= N:  if INFO = i, CHEEVX failed to converge;
                    i eigenvectors failed to converge.  Their indices
                    are stored in array IFAIL. \n
             > N:   if INFO = N + i, for 1 <= i <= N, then the leading
                    minor of order i of B is not positive definite.
                    The factorization of B could not be completed and
                    no eigenvalues or eigenvectors were computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T, typename Ta >
integer hegvx(integer* itype, char* jobz, char* range, char* uplo, integer* n, T* a, integer* lda, T* b, integer* ldb, Ta* vl, Ta* vu, integer* il, integer* iu, Ta* abstol, integer* m, Ta* w, T* z, integer* ldz, T* work, integer* lwork, Ta* rwork, integer* iwork, integer* ifail, integer* info)
{
  return hegvx(itype, jobz, range, uplo, n, a, lda, b, ldb, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, rwork, iwork, ifail, info);
}

/*! @brief HERFS improves the computed solution to a system of linear equations

 * @details
 * \b Purpose:
    \verbatim 
     HERFS improves the computed solution to a system of linear
     equations when the coefficient matrix is Hermitian indefinite, and
     provides error bounds and backward error estimates for the solution.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrices B and X.  NRHS >= 0. \n
 * @param[in] A
          A is COMPLEX array, dimension (LDA,N) \n
          The Hermitian matrix A.  If UPLO = 'U', the leading N-by-N
          upper triangular part of A contains the upper triangular part
          of the matrix A, and the strictly lower triangular part of A
          is not referenced.  If UPLO = 'L', the leading N-by-N lower
          triangular part of A contains the lower triangular part of
          the matrix A, and the strictly upper triangular part of A is
          not referenced. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] AF
          AF is COMPLEX array, dimension (LDAF,N) \n
          The factored form of the matrix A.  AF contains the block
          diagonal matrix D and the multipliers used to obtain the
          factor U or L from the factorization A = U*D*U**H or
          A = L*D*L**H as computed by CHETRF. \n
 * @param[in] LDAF
          LDAF is INTEGER \n
          The leading dimension of the array AF.  LDAF >= max(1,N). \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D
          as determined by CHETRF. \n
 * @param[in] B
          B is COMPLEX array, dimension (LDB,NRHS) \n
          The right hand side matrix B. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[in,out] X
          X is COMPLEX array, dimension (LDX,NRHS) \n
          On entry, the solution matrix X, as computed by CHETRS.
          On exit, the improved solution matrix X. \n
 * @param[in] LDX
          LDX is INTEGER \n
          The leading dimension of the array X.  LDX >= max(1,N). \n
 * @param[out] FERR
          FERR is REAL array, dimension (NRHS) \n
          The estimated forward error bound for each solution vector
          X(j) (the j-th column of the solution matrix X).
          If XTRUE is the true solution corresponding to X(j), FERR(j)
          is an estimated upper bound for the magnitude of the largest
          element in (X(j) - XTRUE) divided by the magnitude of the
          largest element in X(j).  The estimate is as reliable as
          the estimate for RCOND, and is almost always a slight
          overestimate of the true error. \n
 * @param[out] BERR
          BERR is REAL array, dimension (NRHS) \n
          The componentwise relative backward error of each solution
          vector X(j) (i.e., the smallest relative change in
          any element of A or B that makes X(j) an exact solution). \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (2*N) \n
 * @param[out]	RWORK	
          RWORK is REAL array, dimension (N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T, typename Ta >
integer herfs(char* uplo, integer* n, integer* nrhs,  T* a, integer* lda,  T* af, integer* ldaf, integer* ipiv,  T* b, integer* ldb, T* x, integer* ldx, Ta* ferr, Ta* berr, T* work, Ta* rwork, integer* info)
{
  return herfs(uplo, n, nrhs,  a, lda,  af, ldaf,  ipiv,  b, ldb, x, ldx, ferr, berr, work, rwork, info);
}

/*! @brief HERFSX improves the computed solution to a system of linear equations

 * @details
 * \b Purpose:
    \verbatim 
    HERFSX improves the computed solution to a system of linear
    equations when the coefficient matrix is Hermitian indefinite, and
    provides error bounds and backward error estimates for the
    solution.  In addition to normwise error bound, the code provides
    maximum componentwise error bound if possible.  See comments for
    ERR_BNDS_NORM and ERR_BNDS_COMP for details of the error bounds.

    The original system of linear equations may have been equilibrated
    before calling this routine, as described by arguments EQUED and S
    below. In this case, the solution and error bounds returned are
    for the original unequilibrated system.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] EQUED
          EQUED is CHARACTER*1 \n
          Specifies the form of equilibration that was done to A
          before calling this routine. This is needed to compute
          the solution and error bounds correctly. \n
           = 'N':  No equilibration \n
           = 'Y':  Both row and column equilibration, i.e., A has been
                   replaced by diag(S) * A * diag(S).
                   The right hand side B has been changed accordingly. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrices B and X.  NRHS >= 0. \n
 * @param[in] A
          A is COMPLEX array, dimension (LDA,N) \n
          The Hermitian matrix A.  If UPLO = 'U', the leading N-by-N
          upper triangular part of A contains the upper triangular
          part of the matrix A, and the strictly lower triangular
          part of A is not referenced.  If UPLO = 'L', the leading
          N-by-N lower triangular part of A contains the lower
          triangular part of the matrix A, and the strictly upper
          triangular part of A is not referenced. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] AF
          AF is COMPLEX array, dimension (LDAF,N) \n
          The factored form of the matrix A.  AF contains the block
          diagonal matrix D and the multipliers used to obtain the
          factor U or L from the factorization A = U*D*U**T or A =
          L*D*L**T as computed by SSYTRF. \n
 * @param[in] LDAF
          LDAF is INTEGER \n
          The leading dimension of the array AF.  LDAF >= max(1,N). \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D
          as determined by SSYTRF. \n
 * @param[in,out] S
          S is REAL array, dimension (N) \n
          The scale factors for A.  If EQUED = 'Y', A is multiplied on
          the left and right by diag(S).  S is an input argument if FACT =
          'F'; otherwise, S is an output argument.  If FACT = 'F' and EQUED
          = 'Y', each element of S must be positive.  If S is output, each
          element of S is a power of the radix. If S is input, each element
          of S should be a power of the radix to ensure a reliable solution
          and error estimates. Scaling by powers of the radix does not cause
          rounding errors unless the result underflows or overflows.
          Rounding errors during scaling lead to refining with a matrix that
          is not equivalent to the input matrix, producing error estimates
          that may not be reliable. \n
 * @param[in] B
          B is COMPLEX array, dimension (LDB,NRHS) \n
          The right hand side matrix B. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[in,out] X
          X is COMPLEX array, dimension (LDX,NRHS) \n
          On entry, the solution matrix X, as computed by SGETRS.
          On exit, the improved solution matrix X. \n
 * @param[in] LDX
          LDX is INTEGER \n
          The leading dimension of the array X.  LDX >= max(1,N). \n
 * @param[out] RCOND
          RCOND is REAL \n
          Reciprocal scaled condition number.  This is an estimate of the
          reciprocal Skeel condition number of the matrix A after
          equilibration (if done).  If this is less than the machine
          precision (in particular, if it is zero), the matrix is singular
          to working precision.  Note that the error may still be small even
          if this number is very small and the matrix appears ill-
          conditioned. \n
 * @param[out] BERR
          BERR is REAL array, dimension (NRHS) \n
          Componentwise relative backward error.  This is the
          componentwise relative backward error of each solution vector X(j)
          (i.e., the smallest relative change in any element of A or B that
          makes X(j) an exact solution). \n
 * @param[in] N_ERR_BNDS
          N_ERR_BNDS is INTEGER \n
          Number of error bounds to return for each right hand side
          and each type (normwise or componentwise).  See ERR_BNDS_NORM and
          ERR_BNDS_COMP below. \n
 * @param[out] ERR_BNDS_NORM
          ERR_BNDS_NORM is REAL array, dimension (NRHS, N_ERR_BNDS)
          For each right-hand side, this array contains information about
          various error bounds and condition numbers corresponding to the
          normwise relative error, which is defined as follows:
 \n
          Normwise relative error in the ith solution vector: \n
                 max_j (abs(XTRUE(j,i) - X(j,i))) \n
                ------------------------------ \n
                      max_j abs(X(j,i)) \n
 \n
          The array is indexed by the type of error information as described
          below. There currently are up to three pieces of information
          returned. \n
 \n
          The first index in ERR_BNDS_NORM(i,:) corresponds to the ith
          right-hand side. \n
 \n
          The second index in ERR_BNDS_NORM(:,err) contains the following
          three fields: \n
          err = 1 "Trust/don't trust" boolean. Trust the answer if the
                  reciprocal condition number is less than the threshold
                  sqrt(n) * slamch('Epsilon').
 \n
          err = 2 "Guaranteed" error bound: The estimated forward error,
                  almost certainly within a factor of 10 of the true error
                  so long as the next entry is greater than the threshold
                  sqrt(n) * slamch('Epsilon'). This error bound should only
                  be trusted if the previous boolean is true.
 \n
          err = 3  Reciprocal condition number: Estimated normwise
                  reciprocal condition number.  Compared with the threshold
                  sqrt(n) * slamch('Epsilon') to determine if the error
                  estimate is "guaranteed". These reciprocal condition
                  numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
                  appropriately scaled matrix Z.
                  Let Z = S*A, where S scales each row by a power of the
                  radix so all absolute row sums of Z are approximately 1.
 \n
          See Lapack Working Note 165 for further details and extra
          cautions. \n
 * @param[out] ERR_BNDS_COMP
          ERR_BNDS_COMP is REAL array, dimension (NRHS, N_ERR_BNDS) \n
          For each right-hand side, this array contains information about
          various error bounds and condition numbers corresponding to the
          componentwise relative error, which is defined as follows:
 \n
          Componentwise relative error in the ith solution vector: \n
                        abs(XTRUE(j,i) - X(j,i)) \n
                 max_j ---------------------- \n
                             abs(X(j,i)) \n
 \n
          The array is indexed by the right-hand side i (on which the
          componentwise relative error depends), and the type of error
          information as described below. There currently are up to three
          pieces of information returned for each right-hand side. If
          componentwise accuracy is not requested (PARAMS(3) = 0.0), then
          ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS < 3, then at most
          the first (:,N_ERR_BNDS) entries are returned.
 \n
          The first index in ERR_BNDS_COMP(i,:) corresponds to the ith
          right-hand side.
 \n
          The second index in ERR_BNDS_COMP(:,err) contains the following
          three fields: \n
          err = 1 "Trust/don't trust" boolean. Trust the answer if the
                  reciprocal condition number is less than the threshold
                  sqrt(n) * slamch('Epsilon').
 \n
          err = 2 "Guaranteed" error bound: The estimated forward error,
                  almost certainly within a factor of 10 of the true error
                  so long as the next entry is greater than the threshold
                  sqrt(n) * slamch('Epsilon'). This error bound should only
                  be trusted if the previous boolean is true.
 \n
          err = 3  Reciprocal condition number: Estimated componentwise
                  reciprocal condition number.  Compared with the threshold
                  sqrt(n) * slamch('Epsilon') to determine if the error
                  estimate is "guaranteed". These reciprocal condition
                  numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
                  appropriately scaled matrix Z.
                  Let Z = S*(A*diag(x)), where x is the solution for the
                  current right-hand side and S scales each row of
                  A*diag(x) by a power of the radix so all absolute row
                  sums of Z are approximately 1.
 \n
          See Lapack Working Note 165 for further details and extra
          cautions. \n
 * @param[in] NPARAMS
          NPARAMS is INTEGER \n
          Specifies the number of parameters set in PARAMS.  If <= 0, the
          PARAMS array is never referenced and default values are used. \n
 * @param[in,out] PARAMS
          PARAMS is REAL array, dimension NPARAMS \n
          Specifies algorithm parameters.  If an entry is < 0.0, then
          that entry will be filled with default value used for that
          parameter.  Only positions up to NPARAMS are accessed; defaults
          are used for higher-numbered parameters. \n
 \n
          PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative
              refinement or not. \n
           Default: 1.0 \n
              = 0.0:  No refinement is performed, and no error bounds are
                      computed. \n
              = 1.0:  Use the double-precision refinement algorithm,
                      possibly with doubled-single computations if the
                      compilation environment does not support DOUBLE
                      PRECISION. \n
                (other values are reserved for future use) \n
 \n
          PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual
              computations allowed for refinement. \n
           Default: 10 \n
           Aggressive: Set to 100 to permit convergence using approximate
                       factorizations or factorizations other than LU. If
                       the factorization uses a technique other than
                       Gaussian elimination, the guarantees in
                       err_bnds_norm and err_bnds_comp may no longer be
                       trustworthy. \n
 \n
          PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code
              will attempt to find a solution with small componentwise
              relative error in the double-precision algorithm.  Positive
              is true, 0.0 is false. \n
           Default: 1.0 (attempt componentwise convergence) \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (2*N) \n
 * @param[out]	RWORK	
          RWORK is REAL array, dimension (2*N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  Successful exit. The solution to every right-hand side is
           guaranteed. \n
          < 0:  If INFO = -i, the i-th argument had an illegal value \n
          > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization
           has been completed, but the factor U is exactly singular, so
           the solution and error bounds could not be computed. RCOND = 0
           is returned. \n
          = N+J: The solution corresponding to the Jth right-hand side is
           not guaranteed. The solutions corresponding to other right-
           hand sides K with K > J may not be guaranteed as well, but
           only the first such right-hand side is reported. If a small
           componentwise error is not requested (PARAMS(3) = 0.0) then
           the Jth right-hand side is the first with a normwise error
           bound that is not guaranteed (the smallest J such
           that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)
           the Jth right-hand side is the first with either a normwise or
           componentwise error bound that is not guaranteed (the smallest
           J such that either ERR_BNDS_NORM(J,1) = 0.0 or
           ERR_BNDS_COMP(J,1) = 0.0). See the definition of
           ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information
           about all of the right-hand sides check ERR_BNDS_NORM or
           ERR_BNDS_COMP. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T, typename Ta >
integer herfsx(char* uplo, char* equed, integer* n, integer* nrhs, T* a, integer* lda, T* af, integer* ldaf, integer* ipiv, Ta* s, T* b, integer* ldb, T* x, integer* ldx, Ta* rcond, Ta* berr, integer* n_err_bnds, Ta* err_bnds_norm, Ta* err_bnds_comp, integer* nparams, Ta* params, T* work, Ta* rwork, integer* info)
{
  return herfsx(uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info);
}

/*! @brief HESV computes the solution to system of linear equations A * X = B for HE matrices

 * @details
 * \b Purpose:
    \verbatim 
     HESV computes the solution to a complex system of linear equations
        A * X = B,
     where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
     matrices.

     The diagonal pivoting method is used to factor A as
        A = U * D * U**H,  if UPLO = 'U', or
        A = L * D * L**H,  if UPLO = 'L',
     where U (or L) is a product of permutation and unit upper (lower)
     triangular matrices, and D is Hermitian and block diagonal with
     1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then
     used to solve the system of equations A * X = B.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in,out] A
          A is COMPLEX array, dimension (LDA,N) \n
          On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
          N-by-N upper triangular part of A contains the upper
          triangular part of the matrix A, and the strictly lower
          triangular part of A is not referenced.  If UPLO = 'L', the
          leading N-by-N lower triangular part of A contains the lower
          triangular part of the matrix A, and the strictly upper
          triangular part of A is not referenced. \n
 \n
          On exit, if INFO = 0, the block diagonal matrix D and the
          multipliers used to obtain the factor U or L from the
          factorization A = U*D*U**H or A = L*D*L**H as computed by
          CHETRF. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D, as
          determined by CHETRF.  If IPIV(k) > 0, then rows and columns
          k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1
          diagonal block.  If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0,
          then rows and columns k-1 and -IPIV(k) were interchanged and
          D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = 'L' and
          IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and
          -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2
          diagonal block. \n
 * @param[in,out] B
          B is COMPLEX array, dimension (LDB,NRHS) \n
          On entry, the N-by-NRHS right hand side matrix B.
          On exit, if INFO = 0, the N-by-NRHS solution matrix X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The length of WORK.  LWORK >= 1, and for best performance
          LWORK >= max(1,N*NB), where NB is the optimal blocksize for
          CHETRF. \n
          for LWORK < N, TRS will be done with Level BLAS 2 \n
          for LWORK >= N, TRS will be done with Level BLAS 3 \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n
          > 0: if INFO = i, D(i,i) is exactly zero.  The factorization
               has been completed, but the block diagonal matrix D is
               exactly singular, so the solution could not be computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer hesv(char* uplo, integer* n, integer* nrhs, T* a, integer* lda, integer* ipiv, T* b, integer* ldb, T* work, integer* lwork, integer* info)
{
  return hesv(uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork, info);
}

/*! @brief HESV_AA computes the solution to system of linear equations A * X = B for HE matrices

 * @details
 * \b Purpose:
    \verbatim 
     HESV computes the solution to a complex system of linear equations
        A * X = B,
     where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
     matrices.

     The diagonal pivoting method is used to factor A as
        A = U ** H * T*U,  if UPLO = 'U', or
        A = L * T * L**H,  if UPLO = 'L',
     where U (or L) is a product of permutation and unit upper (lower)
     triangular matrices, and T is Hermitian and tridiagonal.  The factored 
     form of A is then used to solve the system of equations A * X = B.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in,out] A
          A is COMPLEX array, dimension (LDA,N) \n
          On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
          N-by-N upper triangular part of A contains the upper
          triangular part of the matrix A, and the strictly lower
          triangular part of A is not referenced.  If UPLO = 'L', the
          leading N-by-N lower triangular part of A contains the lower
          triangular part of the matrix A, and the strictly upper
          triangular part of A is not referenced. \n
 \n
          On exit, if INFO = 0, the block diagonal matrix D and the
          multipliers used to obtain the factor U or L from the
          factorization A = U*D*U**H or A = L*D*L**H as computed by
          CHETRF. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D, as
          determined by CHETRF.  If IPIV(k) > 0, then rows and columns
          k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1
          diagonal block.  If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0,
          then rows and columns k-1 and -IPIV(k) were interchanged and
          D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = 'L' and
          IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and
          -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2
          diagonal block. \n
 * @param[in,out] B
          B is COMPLEX array, dimension (LDB,NRHS) \n
          On entry, the N-by-NRHS right hand side matrix B.
          On exit, if INFO = 0, the N-by-NRHS solution matrix X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The length of WORK.  LWORK >= MAX(1,2*N,3*N-2), and for best 
          performance LWORK >= MAX(1,N*NB), where NB is the optimal
          blocksize for CHETRF. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n
          > 0: if INFO = i, D(i,i) is exactly zero.  The factorization
               has been completed, but the block diagonal matrix D is
               exactly singular, so the solution could not be computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer hesv_aa(char* uplo, integer* n, integer* nrhs, T* a, integer* lda, integer* ipiv, T* b, integer* ldb, T* work, integer* lwork, integer* info)
{
  return hesv_aa(uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork, info);
}
 
/*! @brief HESV_AA_2STAGE computes the solution to system of linear equations A * X = B for HE matrices

 * @details
 * \b Purpose:
    \verbatim 
     HESV_AA_2STAGE computes the solution to a complex system of 
     linear equations
        A * X = B,
     where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
     matrices.

     Aasen's 2-stage algorithm is used to factor A as
        A = U**H * T * U,  if UPLO = 'U', or
        A = L * T * L**H,  if UPLO = 'L',
     where U (or L) is a product of permutation and unit upper (lower)
     triangular matrices, and T is Hermitian and band. The matrix T is
     then LU-factored with partial pivoting. The factored form of A
     is then used to solve the system of equations A * X = B.

     This is the blocked version of the algorithm, calling Level 3 BLAS.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in,out] A
          A is COMPLEX array, dimension (LDA,N) \n
          On entry, the hermitian matrix A.  If UPLO = 'U', the leading
          N-by-N upper triangular part of A contains the upper
          triangular part of the matrix A, and the strictly lower
          triangular part of A is not referenced.  If UPLO = 'L', the
          leading N-by-N lower triangular part of A contains the lower
          triangular part of the matrix A, and the strictly upper
          triangular part of A is not referenced. \n
 \n
          On exit, L is stored below (or above) the subdiaonal blocks,
          when UPLO  is 'L' (or 'U'). \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] TB
          TB is COMPLEX array, dimension (LTB) \n
          On exit, details of the LU factorization of the band matrix. \n
 * @param[in] LTB
          LTB is INTEGER \n
          The size of the array TB. LTB >= 4*N, internally
          used to select NB such that LTB >= (3*NB+1)*N. \n
 \n
          If LTB = -1, then a workspace query is assumed; the
          routine only calculates the optimal size of LTB, 
          returns this value as the first entry of TB, and
          no error message related to LTB is issued by XERBLA. \n
 * @param[out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          On exit, it contains the details of the interchanges, i.e.,
          the row and column k of A were interchanged with the
          row and column IPIV(k). \n
 * @param[out] IPIV2
          IPIV2 is INTEGER array, dimension (N) \n
          On exit, it contains the details of the interchanges, i.e.,
          the row and column k of T were interchanged with the
          row and column IPIV(k). \n
 * @param[in,out] B
          B is COMPLEX array, dimension (LDB,NRHS) \n
          On entry, the right hand side matrix B.
          On exit, the solution matrix X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out]	WORK	
          WORK is COMPLEX workspace of size LWORK \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The size of WORK. LWORK >= N, internally used to select NB
          such that LWORK >= N*NB. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the
          routine only calculates the optimal size of the WORK array,
          returns this value as the first entry of the WORK array, and
          no error message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n
          > 0:  if INFO = i, band LU factorization failed on i-th column \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer hesv_aa_2stage(char* uplo, integer* n, integer* nrhs, T* a, integer* lda, T* tb, integer* ltb, integer* ipiv, integer* ipiv2, T* b, integer* ldb, T* work, integer* lwork, integer* info)
{
  return hesv_aa_2stage(uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb, work, lwork, info);
}

/*! @brief HESV_RK computes the solution to system of linear equations A * X = B for SY matrices

 * @details
 * \b Purpose:
    \verbatim 
     HESV_RK computes the solution to a complex system of linear
     equations A * X = B, where A is an N-by-N Hermitian matrix
     and X and B are N-by-NRHS matrices.

     The bounded Bunch-Kaufman (rook) diagonal pivoting method is used
     to factor A as
        A = P*U*D*(U**H)*(P**T),  if UPLO = 'U', or
        A = P*L*D*(L**H)*(P**T),  if UPLO = 'L',
     where U (or L) is unit upper (or lower) triangular matrix,
     U**H (or L**H) is the conjugate of U (or L), P is a permutation
     matrix, P**T is the transpose of P, and D is Hermitian and block
     diagonal with 1-by-1 and 2-by-2 diagonal blocks.

     CHETRF_RK is called to compute the factorization of a complex
     Hermitian matrix.  The factored form of A is then used to solve
     the system of equations A * X = B by calling BLAS3 routine CHETRS_3.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the upper or lower triangular part of the
          Hermitian matrix A is stored: \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in,out] A
          A is COMPLEX array, dimension (LDA,N) \n
          On entry, the Hermitian matrix A. \n
            If UPLO = 'U': the leading N-by-N upper triangular part
            of A contains the upper triangular part of the matrix A,
            and the strictly lower triangular part of A is not
            referenced. \n
 \n
            If UPLO = 'L': the leading N-by-N lower triangular part
            of A contains the lower triangular part of the matrix A,
            and the strictly upper triangular part of A is not
            referenced. \n
 \n
          On exit, if INFO = 0, diagonal of the block diagonal
          matrix D and factors U or L  as computed by CHETRF_RK: \n
            a) ONLY diagonal elements of the Hermitian block diagonal
               matrix D on the diagonal of A, i.e. D(k,k) = A(k,k);
               (superdiagonal (or subdiagonal) elements of D
                are stored on exit in array E), and \n
            b) If UPLO = 'U': factor U in the superdiagonal part of A.
               If UPLO = 'L': factor L in the subdiagonal part of A. \n
 \n
          For more info see the description of CHETRF_RK routine. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] E
          E is COMPLEX array, dimension (N) \n
          On exit, contains the output computed by the factorization
          routine CHETRF_RK, i.e. the superdiagonal (or subdiagonal)
          elements of the Hermitian block diagonal matrix D
          with 1-by-1 or 2-by-2 diagonal blocks, where \n
          If UPLO = 'U': E(i) = D(i-1,i), i=2:N, E(1) is set to 0; \n
          If UPLO = 'L': E(i) = D(i+1,i), i=1:N-1, E(N) is set to 0. \n
 \n
          NOTE: For 1-by-1 diagonal block D(k), where
          1 <= k <= N, the element E(k) is set to 0 in both
          UPLO = 'U' or UPLO = 'L' cases. \n
 \n
          For more info see the description of CHETRF_RK routine. \n
 * @param[out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D,
          as determined by CHETRF_RK. \n
 \n
          For more info see the description of CHETRF_RK routine. \n
 * @param[in,out] B
          B is COMPLEX array, dimension (LDB,NRHS) \n
          On entry, the N-by-NRHS right hand side matrix B.
          On exit, if INFO = 0, the N-by-NRHS solution matrix X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension ( MAX(1,LWORK) ). \n
          Work array used in the factorization stage.
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The length of WORK.  LWORK >= 1. For best performance
          of factorization stage LWORK >= max(1,N*NB), where NB is
          the optimal blocksize for CHETRF_RK. \n
 \n
          If LWORK = -1, then a workspace query is assumed;
          the routine only calculates the optimal size of the WORK
          array for factorization stage, returns this value as
          the first entry of the WORK array, and no error message
          related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: If INFO = -k, the k-th argument had an illegal value \n
          > 0: If INFO = k, the matrix A is singular, because: \n
                 If UPLO = 'U': column k in the upper
                 triangular part of A contains all zeros. \n
                 If UPLO = 'L': column k in the lower
                 triangular part of A contains all zeros. \n
 \n
               Therefore D(k,k) is exactly zero, and superdiagonal
               elements of column k of U (or subdiagonal elements of
               column k of L ) are all zeros. The factorization has
               been completed, but the block diagonal matrix D is
               exactly singular, and division by zero will occur if
               it is used to solve a system of equations. \n

               NOTE: INFO only stores the first occurrence of
               a singularity, any subsequent occurrence of singularity
               is not stored in INFO even though the factorization
               always completes. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer hesv_rk(char* uplo, integer* n, integer* nrhs, T* a, integer* lda, T* e, integer* ipiv, T* b, integer* ldb, T* work, integer* lwork, integer* info)
{
  return hesv_rk(uplo, n, nrhs, a, lda, e, ipiv, b, ldb, work, lwork, info);
}

/*! @brief HESVX computes the solution to system of linear equations A * X = B for HE matrices

 * @details
 * \b Purpose:
    \verbatim 
     HESVX uses the diagonal pivoting factorization to compute the
     solution to a complex system of linear equations A * X = B,
     where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
     matrices.

     Error bounds on the solution and a condition estimate are also
     provided.
     
     * \b Description:
       =================

     The following steps are performed:

     1. If FACT = 'N', the diagonal pivoting method is used to factor A.
        The form of the factorization is
           A = U * D * U**H,  if UPLO = 'U', or
           A = L * D * L**H,  if UPLO = 'L',
        where U (or L) is a product of permutation and unit upper (lower)
        triangular matrices, and D is Hermitian and block diagonal with
        1-by-1 and 2-by-2 diagonal blocks.

     2. If some D(i,i)=0, so that D is exactly singular, then the routine
        returns with INFO = i. Otherwise, the factored form of A is used
        to estimate the condition number of the matrix A.  If the
        reciprocal of the condition number is less than machine precision,
        INFO = N+1 is returned as a warning, but the routine still goes on
        to solve for X and compute error bounds as described below.

     3. The system of equations is solved for X using the factored form
        of A.

     4. Iterative refinement is applied to improve the computed solution
        matrix and calculate error bounds and backward error estimates
        for it.
    \endverbatim  

 * @param[in] FACT
          FACT is CHARACTER*1 \n
          Specifies whether or not the factored form of A has been
          supplied on entry. \n
          = 'F':  On entry, AF and IPIV contain the factored form
                  of A.  A, AF and IPIV will not be modified. \n
          = 'N':  The matrix A will be copied to AF and factored. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrices B and X.  NRHS >= 0. \n
 * @param[in] A
          A is COMPLEX array, dimension (LDA,N) \n
          The Hermitian matrix A.  If UPLO = 'U', the leading N-by-N
          upper triangular part of A contains the upper triangular part
          of the matrix A, and the strictly lower triangular part of A
          is not referenced.  If UPLO = 'L', the leading N-by-N lower
          triangular part of A contains the lower triangular part of
          the matrix A, and the strictly upper triangular part of A is
          not referenced. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in,out] AF
          AF is COMPLEX array, dimension (LDAF,N) \n
          If FACT = 'F', then AF is an input argument and on entry
          contains the block diagonal matrix D and the multipliers used
          to obtain the factor U or L from the factorization
          A = U*D*U**H or A = L*D*L**H as computed by CHETRF. \n
 \n
          If FACT = 'N', then AF is an output argument and on exit
          returns the block diagonal matrix D and the multipliers used
          to obtain the factor U or L from the factorization
          A = U*D*U**H or A = L*D*L**H. \n
 * @param[in] LDAF
          LDAF is INTEGER \n
          The leading dimension of the array AF.  LDAF >= max(1,N). \n
 * @param[in,out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          If FACT = 'F', then IPIV is an input argument and on entry
          contains details of the interchanges and the block structure
          of D, as determined by CHETRF. \n
          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
          interchanged and D(k,k) is a 1-by-1 diagonal block.
          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block. \n
 \n
          If FACT = 'N', then IPIV is an output argument and on exit
          contains details of the interchanges and the block structure
          of D, as determined by CHETRF. \n
 * @param[in] B
          B is COMPLEX array, dimension (LDB,NRHS) \n
          The N-by-NRHS right hand side matrix B. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out] X
          X is COMPLEX array, dimension (LDX,NRHS) \n
          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X. \n
 * @param[in] LDX
          LDX is INTEGER \n
          The leading dimension of the array X.  LDX >= max(1,N). \n
 * @param[out] RCOND
          RCOND is REAL \n
          The estimate of the reciprocal condition number of the matrix
          A. If RCOND is less than the machine precision (in
          particular, if RCOND = 0), the matrix is singular to working
          precision.  This condition is indicated by a return code of
          INFO > 0. \n
 * @param[out] FERR
          FERR is REAL array, dimension (NRHS) \n
          The estimated forward error bound for each solution vector
          X(j) (the j-th column of the solution matrix X).
          If XTRUE is the true solution corresponding to X(j), FERR(j)
          is an estimated upper bound for the magnitude of the largest
          element in (X(j) - XTRUE) divided by the magnitude of the
          largest element in X(j).  The estimate is as reliable as
          the estimate for RCOND, and is almost always a slight
          overestimate of the true error. \n
 * @param[out] BERR
          BERR is REAL array, dimension (NRHS) \n
          The componentwise relative backward error of each solution
          vector X(j) (i.e., the smallest relative change in
          any element of A or B that makes X(j) an exact solution). \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The length of WORK.  LWORK >= max(1,2*N), and for best
          performance, when FACT = 'N', LWORK >= max(1,2*N,N*NB), where
          NB is the optimal blocksize for CHETRF. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	RWORK	
          RWORK is REAL array, dimension (N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n
          > 0: if INFO = i, and i is \n
                <= N:  D(i,i) is exactly zero.  The factorization
                       has been completed but the factor D is exactly
                       singular, so the solution and error bounds could
                       not be computed. RCOND = 0 is returned. \n
                = N+1: D is nonsingular, but RCOND is less than machine
                       precision, meaning that the matrix is singular
                       to working precision.  Nevertheless, the
                       solution and error bounds are computed because
                       there are a number of situations where the
                       computed solution can be more accurate than the
                       value of RCOND would suggest. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T, typename Ta >
integer hesvx(char* fact, char* uplo, integer* n, integer* nrhs, T* a, integer* lda, T* af, integer* ldaf, integer* ipiv, T* b, integer* ldb, T* x, integer* ldx, Ta* rcond, Ta* ferr, Ta* berr, T* work, integer* lwork, Ta* rwork, integer* info)
{
  return hesvx(fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, lwork, rwork, info);
}

/*! @brief HESVXX computes the solution to system of linear equations A * X = B for HE matrices

 * @details
 * \b Purpose:
    \verbatim 
    HESVXX uses the diagonal pivoting factorization to compute the
    solution to a complex system of linear equations A * X = B, where
    A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
    matrices.

    If requested, both normwise and maximum componentwise error bounds
    are returned. CHESVXX will return a solution with a tiny
    guaranteed error (O(eps) where eps is the working machine
    precision) unless the matrix is very ill-conditioned, in which
    case a warning is returned. Relevant condition numbers also are
    calculated and returned.

    CHESVXX accepts user-provided factorizations and equilibration
    factors; see the definitions of the FACT and EQUED options.
    Solving with refinement and using a factorization from a previous
    CHESVXX call will also produce a solution with either O(eps)
    errors or warnings, but we cannot make that claim for general
    user-provided factorizations and equilibration factors if they
    differ from what CHESVXX would itself produce.
 
 * \b Description:
    =================

    The following steps are performed:

    1. If FACT = 'E', real scaling factors are computed to equilibrate
    the system:

      diag(S)*A*diag(S)     *inv(diag(S))*X = diag(S)*B

    Whether or not the system will be equilibrated depends on the
    scaling of the matrix A, but if equilibration is used, A is
    overwritten by diag(S)*A*diag(S) and B by diag(S)*B.

    2. If FACT = 'N' or 'E', the LU decomposition is used to factor
    the matrix A (after equilibration if FACT = 'E') as

       A = U * D * U**T,  if UPLO = 'U', or
       A = L * D * L**T,  if UPLO = 'L',

    where U (or L) is a product of permutation and unit upper (lower)
    triangular matrices, and D is Hermitian and block diagonal with
    1-by-1 and 2-by-2 diagonal blocks.

    3. If some D(i,i)=0, so that D is exactly singular, then the
    routine returns with INFO = i. Otherwise, the factored form of A
    is used to estimate the condition number of the matrix A (see
    argument RCOND).  If the reciprocal of the condition number is
    less than machine precision, the routine still goes on to solve
    for X and compute error bounds as described below.

    4. The system of equations is solved for X using the factored form
    of A.

    5. By default (unless PARAMS(LA_LINRX_ITREF_I) is set to zero),
    the routine will use iterative refinement to try to get a small
    error and error bounds.  Refinement calculates the residual to at
    least twice the working precision.

    6. If equilibration was used, the matrix X is premultiplied by
    diag(R) so that it solves the original system before
    equilibration.
    \endverbatim  


 * @param[in] FACT
          FACT is CHARACTER*1 \n
          Specifies whether or not the factored form of the matrix A is
          supplied on entry, and if not, whether the matrix A should be
          equilibrated before it is factored. \n
           = 'F':  On entry, AF and IPIV contain the factored form of A.
                   If EQUED is not 'N', the matrix A has been
                   equilibrated with scaling factors given by S.
                   A, AF, and IPIV are not modified. \n
           = 'N':  The matrix A will be copied to AF and factored. \n
           = 'E':  The matrix A will be equilibrated if necessary, then
                   copied to AF and factored. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrices B and X.  NRHS >= 0. \n
 * @param[in,out] A
          A is COMPLEX array, dimension (LDA,N) \n
          The Hermitian matrix A.  If UPLO = 'U', the leading N-by-N
          upper triangular part of A contains the upper triangular
          part of the matrix A, and the strictly lower triangular
          part of A is not referenced.  If UPLO = 'L', the leading
          N-by-N lower triangular part of A contains the lower
          triangular part of the matrix A, and the strictly upper
          triangular part of A is not referenced. \n
 \n
          On exit, if FACT = 'E' and EQUED = 'Y', A is overwritten by
          diag(S)*A*diag(S). \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in,out] AF
          AF is COMPLEX array, dimension (LDAF,N) \n
          If FACT = 'F', then AF is an input argument and on entry
          contains the block diagonal matrix D and the multipliers
          used to obtain the factor U or L from the factorization A =
          U*D*U**T or A = L*D*L**T as computed by SSYTRF. \n
 \n
          If FACT = 'N', then AF is an output argument and on exit
          returns the block diagonal matrix D and the multipliers
          used to obtain the factor U or L from the factorization A =
          U*D*U**T or A = L*D*L**T. \n
 * @param[in] LDAF
          LDAF is INTEGER \n
          The leading dimension of the array AF.  LDAF >= max(1,N). \n
 * @param[in,out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          If FACT = 'F', then IPIV is an input argument and on entry
          contains details of the interchanges and the block
          structure of D, as determined by CHETRF.  If IPIV(k) > 0,
          then rows and columns k and IPIV(k) were interchanged and
          D(k,k) is a 1-by-1 diagonal block.  If UPLO = 'U' and
          IPIV(k) = IPIV(k-1) < 0, then rows and columns k-1 and
          -IPIV(k) were interchanged and D(k-1:k,k-1:k) is a 2-by-2
          diagonal block.  If UPLO = 'L' and IPIV(k) = IPIV(k+1) < 0,
          then rows and columns k+1 and -IPIV(k) were interchanged
          and D(k:k+1,k:k+1) is a 2-by-2 diagonal block. \n
 \n
          If FACT = 'N', then IPIV is an output argument and on exit
          contains details of the interchanges and the block
          structure of D, as determined by CHETRF. \n
 * @param[in,out] EQUED
          EQUED is CHARACTER*1 \n
          Specifies the form of equilibration that was done. \n
           = 'N':  No equilibration (always true if FACT = 'N'). \n
           = 'Y':  Both row and column equilibration, i.e., A has been
                   replaced by diag(S) * A * diag(S). \n
          EQUED is an input argument if FACT = 'F'; otherwise, it is an
          output argument. \n
 * @param[in,out] S
          S is REAL array, dimension (N) \n
          The scale factors for A.  If EQUED = 'Y', A is multiplied on
          the left and right by diag(S).  S is an input argument if FACT =
          'F'; otherwise, S is an output argument.  If FACT = 'F' and EQUED
          = 'Y', each element of S must be positive.  If S is output, each
          element of S is a power of the radix. If S is input, each element
          of S should be a power of the radix to ensure a reliable solution
          and error estimates. Scaling by powers of the radix does not cause
          rounding errors unless the result underflows or overflows.
          Rounding errors during scaling lead to refining with a matrix that
          is not equivalent to the input matrix, producing error estimates
          that may not be reliable. \n
 * @param[in,out] B
          B is COMPLEX array, dimension (LDB,NRHS) \n
          On entry, the N-by-NRHS right hand side matrix B. \n
          On exit, \n
          if EQUED = 'N', B is not modified; \n
          if EQUED = 'Y', B is overwritten by diag(S)*B; \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out] X
          X is COMPLEX array, dimension (LDX,NRHS) \n
          If INFO = 0, the N-by-NRHS solution matrix X to the original
          system of equations.  Note that A and B are modified on exit if
          EQUED .ne. 'N', and the solution to the equilibrated system is
          inv(diag(S))*X. \n
 * @param[in] LDX
          LDX is INTEGER \n
          The leading dimension of the array X.  LDX >= max(1,N). \n
 * @param[out] RCOND
          RCOND is REAL \n
          Reciprocal scaled condition number.  This is an estimate of the
          reciprocal Skeel condition number of the matrix A after
          equilibration (if done).  If this is less than the machine
          precision (in particular, if it is zero), the matrix is singular
          to working precision.  Note that the error may still be small even
          if this number is very small and the matrix appears ill-
          conditioned. \n
 * @param[out] RPVGRW
          RPVGRW is REAL \n
          Reciprocal pivot growth.  On exit, this contains the reciprocal
          pivot growth factor norm(A)/norm(U). The "max absolute element"
          norm is used.  If this is much less than 1, then the stability of
          the LU factorization of the (equilibrated) matrix A could be poor.
          This also means that the solution X, estimated condition numbers,
          and error bounds could be unreliable. If factorization fails with
          0<INFO<=N, then this contains the reciprocal pivot growth factor
          for the leading INFO columns of A. \n
 * @param[out] BERR
          BERR is REAL array, dimension (NRHS) \n
          Componentwise relative backward error.  This is the
          componentwise relative backward error of each solution vector X(j)
          (i.e., the smallest relative change in any element of A or B that
          makes X(j) an exact solution). \n
 * @param[in] N_ERR_BNDS
          N_ERR_BNDS is INTEGER \n
          Number of error bounds to return for each right hand side
          and each type (normwise or componentwise).  See ERR_BNDS_NORM and
          ERR_BNDS_COMP below. \n
 * @param[out] ERR_BNDS_NORM
          ERR_BNDS_NORM is REAL array, dimension (NRHS, N_ERR_BNDS) \n
          For each right-hand side, this array contains information about
          various error bounds and condition numbers corresponding to the
          normwise relative error, which is defined as follows: \n
 \n
          Normwise relative error in the ith solution vector: \n
                 max_j (abs(XTRUE(j,i) - X(j,i))) \n
                ------------------------------ \n
                      max_j abs(X(j,i)) \n
 \n
          The array is indexed by the type of error information as described
          below. There currently are up to three pieces of information
          returned. \n
 \n
          The first index in ERR_BNDS_NORM(i,:) corresponds to the ith
          right-hand side. \n
 \n
          The second index in ERR_BNDS_NORM(:,err) contains the following
          three fields: \n
          err = 1 "Trust/don't trust" boolean. Trust the answer if the
                  reciprocal condition number is less than the threshold
                  sqrt(n) * slamch('Epsilon'). \n
 \n
          err = 2 "Guaranteed" error bound: The estimated forward error,
                  almost certainly within a factor of 10 of the true error
                  so long as the next entry is greater than the threshold
                  sqrt(n) * slamch('Epsilon'). This error bound should only
                  be trusted if the previous boolean is true. \n
 \n
          err = 3  Reciprocal condition number: Estimated normwise
                  reciprocal condition number.  Compared with the threshold
                  sqrt(n) * slamch('Epsilon') to determine if the error
                  estimate is "guaranteed". These reciprocal condition
                  numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
                  appropriately scaled matrix Z.
                  Let Z = S*A, where S scales each row by a power of the
                  radix so all absolute row sums of Z are approximately 1. \n
 \n
          See Lapack Working Note 165 for further details and extra
          cautions. \n
 * @param[out] ERR_BNDS_COMP
          ERR_BNDS_COMP is REAL array, dimension (NRHS, N_ERR_BNDS) \n
          For each right-hand side, this array contains information about
          various error bounds and condition numbers corresponding to the
          componentwise relative error, which is defined as follows: \n
 \n
          Componentwise relative error in the ith solution vector: \n
                        abs(XTRUE(j,i) - X(j,i)) \n
                 max_j ---------------------- \n
                             abs(X(j,i)) \n
 \n
          The array is indexed by the right-hand side i (on which the
          componentwise relative error depends), and the type of error
          information as described below. There currently are up to three
          pieces of information returned for each right-hand side. If
          componentwise accuracy is not requested (PARAMS(3) = 0.0), then
          ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS < 3, then at most
          the first (:,N_ERR_BNDS) entries are returned. \n
 \n
          The first index in ERR_BNDS_COMP(i,:) corresponds to the ith
          right-hand side. \n
 \n
          The second index in ERR_BNDS_COMP(:,err) contains the following
          three fields: \n
          err = 1 "Trust/don't trust" boolean. Trust the answer if the
                  reciprocal condition number is less than the threshold
                  sqrt(n) * slamch('Epsilon'). \n
 \n
          err = 2 "Guaranteed" error bound: The estimated forward error,
                  almost certainly within a factor of 10 of the true error
                  so long as the next entry is greater than the threshold
                  sqrt(n) * slamch('Epsilon'). This error bound should only
                  be trusted if the previous boolean is true. \n
 \n
          err = 3  Reciprocal condition number: Estimated componentwise
                  reciprocal condition number.  Compared with the threshold
                  sqrt(n) * slamch('Epsilon') to determine if the error
                  estimate is "guaranteed". These reciprocal condition
                  numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
                  appropriately scaled matrix Z.
                  Let Z = S*(A*diag(x)), where x is the solution for the
                  current right-hand side and S scales each row of
                  A*diag(x) by a power of the radix so all absolute row
                  sums of Z are approximately 1. \n
 \n
          See Lapack Working Note 165 for further details and extra
          cautions. \n
 * @param[in] NPARAMS
          NPARAMS is INTEGER \n
          Specifies the number of parameters set in PARAMS.  If <= 0, the
          PARAMS array is never referenced and default values are used. \n
 * @param[in,out] PARAMS
          PARAMS is REAL array, dimension NPARAMS \n
          Specifies algorithm parameters.  If an entry is < 0.0, then
          that entry will be filled with default value used for that
          parameter.  Only positions up to NPARAMS are accessed; defaults
          are used for higher-numbered parameters. \n
 \n
          PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative
              refinement or not. \n
           Default: 1.0 \n
              = 0.0:  No refinement is performed, and no error bounds are
                      computed. \n
              = 1.0:  Use the double-precision refinement algorithm,
                      possibly with doubled-single computations if the
                      compilation environment does not support DOUBLE
                      PRECISION. \n
                (other values are reserved for future use) \n
 \n
          PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual
              computations allowed for refinement. \n
           Default: 10 \n
           Aggressive: Set to 100 to permit convergence using approximate
                       factorizations or factorizations other than LU. If
                       the factorization uses a technique other than
                       Gaussian elimination, the guarantees in
                       err_bnds_norm and err_bnds_comp may no longer be
                       trustworthy. \n
 \n
          PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code
              will attempt to find a solution with small componentwise
              relative error in the double-precision algorithm.  Positive
              is true, 0.0 is false. \n
           Default: 1.0 (attempt componentwise convergence) \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (5*N) \n
 * @param[out]	RWORK	
          RWORK is REAL array, dimension (2*N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  Successful exit. The solution to every right-hand side is
           guaranteed. \n
          < 0:  If INFO = -i, the i-th argument had an illegal value \n
          > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization
           has been completed, but the factor U is exactly singular, so
           the solution and error bounds could not be computed. RCOND = 0
           is returned. \n
          = N+J: The solution corresponding to the Jth right-hand side is
           not guaranteed. The solutions corresponding to other right-
           hand sides K with K > J may not be guaranteed as well, but
           only the first such right-hand side is reported. If a small
           componentwise error is not requested (PARAMS(3) = 0.0) then
           the Jth right-hand side is the first with a normwise error
           bound that is not guaranteed (the smallest J such
           that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)
           the Jth right-hand side is the first with either a normwise or
           componentwise error bound that is not guaranteed (the smallest
           J such that either ERR_BNDS_NORM(J,1) = 0.0 or
           ERR_BNDS_COMP(J,1) = 0.0). See the definition of
           ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information
           about all of the right-hand sides check ERR_BNDS_NORM or
           ERR_BNDS_COMP. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T, typename Ta >
integer hesvxx(char* fact, char* uplo, integer* n, integer* nrhs, T* a, integer* lda, T* af, integer* ldaf, integer* ipiv, char* equed, Ta* s, T* b, integer* ldb, T* x, integer* ldx, Ta* rcond, Ta* rpvgrw, Ta* berr, integer* n_err_bnds, Ta* err_bnds_norm, Ta* err_bnds_comp, integer* nparams, Ta* params, T* work, Ta* rwork, integer* info)
{
  return hesvxx(fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info);
}

/*! @brief HESWAPR applies an elementary permutation on the rows and columns of a Hermitian matrix.

 * @details
 * \b Purpose:
    \verbatim 
     HESWAPR applies an elementary permutation on the rows and the columns of
     a hermitian matrix.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the details of the factorization are stored
          as an upper or lower triangular matrix. \n
          = 'U':  Upper triangular, form is A = U*D*U**T; \n
          = 'L':  Lower triangular, form is A = L*D*L**T. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is COMPLEX array, dimension (LDA,N) \n
          On entry, the NB diagonal matrix D and the multipliers
          used to obtain the factor U or L as computed by CSYTRF. \n
 \n
          On exit, if INFO = 0, the (symmetric) inverse of the original
          matrix.  If UPLO = 'U', the upper triangular part of the
          inverse is formed and the part of A below the diagonal is not
          referenced; if UPLO = 'L' the lower triangular part of the
          inverse is formed and the part of A above the diagonal is
          not referenced. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] I1
          I1 is INTEGER
          Index of the first row to swap \n
 * @param[in] I2
          I2 is INTEGER
          Index of the second row to swap \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer heswapr(char* uplo, integer* n, T* a, integer* lda, integer* i1, integer* i2)
{
  return heswapr(uplo, n, a, lda, i1, i2);
}

/*! @brief HETRF computes the factorization of a complex Hermitian matrix A

 * @details
 * \b Purpose:
    \verbatim 
     HETRF computes the factorization of a complex Hermitian matrix A
     using the Bunch-Kaufman diagonal pivoting method.  The form of the
     factorization is

        A = U*D*U**H  or  A = L*D*L**H

     where U (or L) is a product of permutation and unit upper (lower)
     triangular matrices, and D is Hermitian and block diagonal with
     1-by-1 and 2-by-2 diagonal blocks.

     This is the blocked version of the algorithm, calling Level 3 BLAS.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is COMPLEX array, dimension (LDA,N) \n
          On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
          N-by-N upper triangular part of A contains the upper
          triangular part of the matrix A, and the strictly lower
          triangular part of A is not referenced.  If UPLO = 'L', the
          leading N-by-N lower triangular part of A contains the lower
          triangular part of the matrix A, and the strictly upper
          triangular part of A is not referenced. \n
 \n
          On exit, the block diagonal matrix D and the multipliers used
          to obtain the factor U or L (see below for further details). \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D.
          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
          interchanged and D(k,k) is a 1-by-1 diagonal block.
          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block. \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The length of WORK.  LWORK >=1.  For best performance
          LWORK >= N*NB, where NB is the block size returned by ILAENV. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization
                has been completed, but the block diagonal matrix D is
                exactly singular, and division by zero will occur if it
                is used to solve a system of equations. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer hetrf(char* uplo, integer* n, T* a, integer* lda, integer* ipiv, T* work, integer* lwork, integer* info)
{
  return hetrf(uplo, n, a, lda, ipiv, work, lwork, info);
}

/*! @brief HETRF_AA computes the factorization of a complex hermitian matrix A

 * @details
 * \b Purpose:
    \verbatim 
    HETRF_AA computes the factorization of a complex hermitian matrix A
    using the Aasen's algorithm.  The form of the factorization is

       A = U**H*T*U  or  A = L*T*L**H

    where U (or L) is a product of permutation and unit upper (lower)
    triangular matrices, and T is a hermitian tridiagonal matrix.

    This is the blocked version of the algorithm, calling Level 3 BLAS.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is COMPLEX array, dimension (LDA,N) \n
          On entry, the hermitian matrix A.  If UPLO = 'U', the leading
          N-by-N upper triangular part of A contains the upper
          triangular part of the matrix A, and the strictly lower
          triangular part of A is not referenced.  If UPLO = 'L', the
          leading N-by-N lower triangular part of A contains the lower
          triangular part of the matrix A, and the strictly upper
          triangular part of A is not referenced. \n
 \n
          On exit, the tridiagonal matrix is stored in the diagonals
          and the subdiagonals of A just below (or above) the diagonals,
          and L is stored below (or above) the subdiaonals, when UPLO
          is 'L' (or 'U'). \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          On exit, it contains the details of the interchanges, i.e.,
          the row and column k of A were interchanged with the
          row and column IPIV(k). \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The length of WORK.  LWORK >= 2*N. For optimum performance
          LWORK >= N*(1+NB), where NB is the optimal blocksize. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer hetrf_aa(char* uplo, integer* n, T* a, integer* lda, integer* ipiv, T* work, integer* lwork, integer* info)
{
  return hetrf_aa(uplo, n, a, lda, ipiv, work, lwork, info);
}

/*! @brief HETRF_AA_2STAGE computes the factorization of a real hermitian matrix A

 * @details
 * \b Purpose:
    \verbatim 
    HETRF_AA_2STAGE computes the factorization of a real hermitian matrix A
    using the Aasen's algorithm.  The form of the factorization is

       A = U**T*T*U  or  A = L*T*L**T

    where U (or L) is a product of permutation and unit upper (lower)
    triangular matrices, and T is a hermitian band matrix with the
    bandwidth of NB (NB is internally selected and stored in TB( 1), and T is 
    LU factorized with partial pivoting).

    This is the blocked version of the algorithm, calling Level 3 BLAS.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is COMPLEX array, dimension (LDA,N) \n
          On entry, the hermitian matrix A.  If UPLO = 'U', the leading
          N-by-N upper triangular part of A contains the upper
          triangular part of the matrix A, and the strictly lower
          triangular part of A is not referenced.  If UPLO = 'L', the
          leading N-by-N lower triangular part of A contains the lower
          triangular part of the matrix A, and the strictly upper
          triangular part of A is not referenced. \n
 \n
          On exit, L is stored below (or above) the subdiaonal blocks,
          when UPLO  is 'L' (or 'U'). \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] TB
          TB is COMPLEX array, dimension (LTB) \n
          On exit, details of the LU factorization of the band matrix. \n
 * @param[in] LTB
          LTB is INTEGER \n
          The size of the array TB. LTB >= 4*N, internally
          used to select NB such that LTB >= (3*NB+1)*N. \n
 \n
          If LTB = -1, then a workspace query is assumed; the
          routine only calculates the optimal size of LTB, 
          returns this value as the first entry of TB, and
          no error message related to LTB is issued by XERBLA. \n
 * @param[out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          On exit, it contains the details of the interchanges, i.e.,
          the row and column k of A were interchanged with the
          row and column IPIV(k). \n
 * @param[out] IPIV2
          IPIV2 is INTEGER array, dimension (N) \n
          On exit, it contains the details of the interchanges, i.e.,
          the row and column k of T were interchanged with the
          row and column IPIV(k). \n
 * @param[out]	WORK	
          WORK is COMPLEX workspace of size LWORK \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The size of WORK. LWORK >= N, internally used to select NB
          such that LWORK >= N*NB. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the
          routine only calculates the optimal size of the WORK array,
          returns this value as the first entry of the WORK array, and
          no error message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n
          > 0:  if INFO = i, band LU factorization failed on i-th column \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer hetrf_aa_2stage(char* uplo, integer* n, T* a, integer* lda, T* tb, integer* ltb, integer* ipiv, integer* ipiv2, T* work, integer* lwork, integer* info)
{
  return hetrf_aa_2stage(uplo, n, a, lda, tb, ltb, ipiv, ipiv2, work, lwork, info);
}

/*! @brief HETRF_RK computes the factorization of a complex Hermitian indefinite matrix   \n
     using the bounded Bunch-Kaufman (rook) diagonal pivoting method (BLAS3 blocked algorithm).
 * @details
 * \b Purpose:
    \verbatim 
     HETRF_RK computes the factorization of a complex Hermitian matrix A
     using the bounded Bunch-Kaufman (rook) diagonal pivoting method:

        A = P*U*D*(U**H)*(P**T) or A = P*L*D*(L**H)*(P**T),

     where U (or L) is unit upper (or lower) triangular matrix,
     U**H (or L**H) is the conjugate of U (or L), P is a permutation
     matrix, P**T is the transpose of P, and D is Hermitian and block
     diagonal with 1-by-1 and 2-by-2 diagonal blocks.

     This is the blocked version of the algorithm, calling Level 3 BLAS.
     For more information see Further Details section.
    \endverbatim

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the upper or lower triangular part of the
          Hermitian matrix A is stored: \n
          = 'U':  Upper triangular \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is COMPLEX array, dimension (LDA,N) \n
          On entry, the Hermitian matrix A. \n
            If UPLO = 'U': the leading N-by-N upper triangular part
            of A contains the upper triangular part of the matrix A,
            and the strictly lower triangular part of A is not
            referenced. \n
 \n
            If UPLO = 'L': the leading N-by-N lower triangular part
            of A contains the lower triangular part of the matrix A,
            and the strictly upper triangular part of A is not
            referenced. \n
 \n
          On exit, contains: \n
            a) ONLY diagonal elements of the Hermitian block diagonal
               matrix D on the diagonal of A, i.e. D(k,k) = A(k,k);
               (superdiagonal (or subdiagonal) elements of D
                are stored on exit in array E), and \n
            b) If UPLO = 'U': factor U in the superdiagonal part of A.
               If UPLO = 'L': factor L in the subdiagonal part of A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] E
          E is COMPLEX array, dimension (N) \n
          On exit, contains the superdiagonal (or subdiagonal)
          elements of the Hermitian block diagonal matrix D
          with 1-by-1 or 2-by-2 diagonal blocks, where \n
          If UPLO = 'U': E(i) = D(i-1,i), i=2:N, E(1) is set to 0; \n
          If UPLO = 'L': E(i) = D(i+1,i), i=1:N-1, E(N) is set to 0. \n
 \n
          NOTE: For 1-by-1 diagonal block D(k), where
          1 <= k <= N, the element E(k) is set to 0 in both
          UPLO = 'U' or UPLO = 'L' cases. \n
 * @param[out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          IPIV describes the permutation matrix P in the factorization
          of matrix A as follows. The absolute value of IPIV(k)
          represents the index of row and column that were
          interchanged with the k-th row and column. The value of UPLO
          describes the order in which the interchanges were applied.
          Also, the sign of IPIV represents the block structure of
          the Hermitian block diagonal matrix D with 1-by-1 or 2-by-2
          diagonal blocks which correspond to 1 or 2 interchanges
          at each factorization step. For more info see Further
          Details section. \n
 \n
          If UPLO = 'U', 
          ( in factorization order, k decreases from N to 1): \n
            a) A single positive entry IPIV(k) > 0 means:
               D(k,k) is a 1-by-1 diagonal block.
               If IPIV(k) != k, rows and columns k and IPIV(k) were
               interchanged in the matrix A(1:N,1:N);
               If IPIV(k) = k, no interchange occurred. \n
 \n
            b) A pair of consecutive negative entries
               IPIV(k) < 0 and IPIV(k-1) < 0 means:
               D(k-1:k,k-1:k) is a 2-by-2 diagonal block.
               (NOTE: negative entries in IPIV appear ONLY in pairs). \n
               1) If -IPIV(k) != k, rows and columns
                  k and -IPIV(k) were interchanged
                  in the matrix A(1:N,1:N).
                  If -IPIV(k) = k, no interchange occurred. \n
               2) If -IPIV(k-1) != k-1, rows and columns
                  k-1 and -IPIV(k-1) were interchanged
                  in the matrix A(1:N,1:N).
                  If -IPIV(k-1) = k-1, no interchange occurred. \n
 \n
            c) In both cases a) and b), always ABS( IPIV(k)) <= k. \n
 \n
            d) NOTE: Any entry IPIV(k) is always NONZERO on output. \n
 \n
          If UPLO = 'L',
          ( in factorization order, k increases from 1 to N): \n
            a) A single positive entry IPIV(k) > 0 means:
               D(k,k) is a 1-by-1 diagonal block.
               If IPIV(k) != k, rows and columns k and IPIV(k) were
               interchanged in the matrix A(1:N,1:N).
               If IPIV(k) = k, no interchange occurred. \n
 \n
            b) A pair of consecutive negative entries
               IPIV(k) < 0 and IPIV(k+1) < 0 means:
               D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
               (NOTE: negative entries in IPIV appear ONLY in pairs). \n
               1) If -IPIV(k) != k, rows and columns
                  k and -IPIV(k) were interchanged
                  in the matrix A(1:N,1:N).
                  If -IPIV(k) = k, no interchange occurred. \n
               2) If -IPIV(k+1) != k+1, rows and columns
                  k-1 and -IPIV(k-1) were interchanged
                  in the matrix A(1:N,1:N).
                  If -IPIV(k+1) = k+1, no interchange occurred. \n
 \n
            c) In both cases a) and b), always ABS( IPIV(k)) >= k. \n
 \n
            d) NOTE: Any entry IPIV(k) is always NONZERO on output. \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension ( MAX(1,LWORK) ). \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The length of WORK.  LWORK >=1.  For best performance
          LWORK >= N*NB, where NB is the block size returned
          by ILAENV. \n
 \n
          If LWORK = -1, then a workspace query is assumed;
          the routine only calculates the optimal size of the WORK
          array, returns this value as the first entry of the WORK
          array, and no error message related to LWORK is issued
          by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: If INFO = -k, the k-th argument had an illegal value \n
          > 0: If INFO = k, the matrix A is singular, because: \n
                 If UPLO = 'U': column k in the upper
                 triangular part of A contains all zeros. \n
                 If UPLO = 'L': column k in the lower
                 triangular part of A contains all zeros. \n
 \n
               Therefore D(k,k) is exactly zero, and superdiagonal
               elements of column k of U (or subdiagonal elements of
               column k of L ) are all zeros. The factorization has
               been completed, but the block diagonal matrix D is
               exactly singular, and division by zero will occur if
               it is used to solve a system of equations. \n
 \n
               NOTE: INFO only stores the first occurrence of
               a singularity, any subsequent occurrence of singularity
               is not stored in INFO even though the factorization
               always completes. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer hetrf_rk(char* uplo, integer* n, T* a, integer* lda, T* e, integer* ipiv, T* work, integer* lwork, integer* info)
{
  return hetrf_rk(uplo, n, a, lda, e, ipiv, work, lwork, info);
}

/*! @brief HETRF_ROOK computes the factorization of a complex Hermitian indefinite matrix   \n
     using the bounded Bunch-Kaufman ("rook") diagonal pivoting method (blocked algorithm, calling Level 3 BLAS).
 * @details
 * \b Purpose:
    \verbatim 
     HETRF_ROOK computes the factorization of a comlex Hermitian matrix A
     using the bounded Bunch-Kaufman ("rook") diagonal pivoting method.
     The form of the factorization is

        A = U*D*U**T  or  A = L*D*L**T

     where U (or L) is a product of permutation and unit upper (lower)
     triangular matrices, and D is Hermitian and block diagonal with
     1-by-1 and 2-by-2 diagonal blocks.

     This is the blocked version of the algorithm, calling Level 3 BLAS.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is COMPLEX array, dimension (LDA,N) \n
          On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
          N-by-N upper triangular part of A contains the upper
          triangular part of the matrix A, and the strictly lower
          triangular part of A is not referenced.  If UPLO = 'L', the
          leading N-by-N lower triangular part of A contains the lower
          triangular part of the matrix A, and the strictly upper
          triangular part of A is not referenced. \n
 \n
          On exit, the block diagonal matrix D and the multipliers used
          to obtain the factor U or L (see below for further details). \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D. \n
 \n
          If UPLO = 'U': \n
             Only the last KB elements of IPIV are set.
 \n
             If IPIV(k) > 0, then rows and columns k and IPIV(k) were
             interchanged and D(k,k) is a 1-by-1 diagonal block.
 \n
             If IPIV(k) < 0 and IPIV(k-1) < 0, then rows and
             columns k and -IPIV(k) were interchanged and rows and
             columns k-1 and -IPIV(k-1) were inerchaged,
             D(k-1:k,k-1:k) is a 2-by-2 diagonal block.
 \n
          If UPLO = 'L': \n
             Only the first KB elements of IPIV are set.
 \n
             If IPIV(k) > 0, then rows and columns k and IPIV(k)
             were interchanged and D(k,k) is a 1-by-1 diagonal block.
 \n
             If IPIV(k) < 0 and IPIV(k+1) < 0, then rows and
             columns k and -IPIV(k) were interchanged and rows and
             columns k+1 and -IPIV(k+1) were inerchaged,
             D(k:k+1,k:k+1) is a 2-by-2 diagonal block. \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (MAX(1,LWORK)). \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The length of WORK.  LWORK >=1.  For best performance
          LWORK >= N*NB, where NB is the block size returned by ILAENV. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization
                has been completed, but the block diagonal matrix D is
                exactly singular, and division by zero will occur if it
                is used to solve a system of equations. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer hetrf_rook(char* uplo, integer* n, T* a, integer* lda, integer* ipiv, T* work, integer* lwork, integer* info)
{
  return hetrf_rook(uplo, n, a, lda, ipiv, work, lwork, info);
}

/*! @brief HETRI computes the inverse of a complex Hermitian indefinite matrix A

 * @details
 * \b Purpose:
    \verbatim 
     HETRI computes the inverse of a complex Hermitian indefinite matrix
     A using the factorization A = U*D*U**H or A = L*D*L**H computed by
     HETRF.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the details of the factorization are stored
          as an upper or lower triangular matrix. \n
          = 'U':  Upper triangular, form is A = U*D*U**H; \n
          = 'L':  Lower triangular, form is A = L*D*L**H. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is COMPLEX array, dimension (LDA,N) \n
          On entry, the block diagonal matrix D and the multipliers
          used to obtain the factor U or L as computed by CHETRF. \n
 \n
          On exit, if INFO = 0, the (Hermitian) inverse of the original
          matrix.  If UPLO = 'U', the upper triangular part of the
          inverse is formed and the part of A below the diagonal is not
          referenced; if UPLO = 'L' the lower triangular part of the
          inverse is formed and the part of A above the diagonal is
          not referenced. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D
          as determined by CHETRF. \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n
          > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its
               inverse could not be computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer hetri(char* uplo, integer* n, T* a, integer* lda, integer* ipiv, T* work, integer* info)
{
  return hetri(uplo, n, a, lda, ipiv, work, info);
}

/*! @brief HETRI_3 computes the inverse of a complex Hermitian indefinite matrix A

 * @details
 * \b Purpose:
    \verbatim 
     HETRI_3 computes the inverse of a complex Hermitian indefinite
     matrix A using the factorization computed by CHETRF_RK or CHETRF_BK:

         A = P*U*D*(U**H)*(P**T) or A = P*L*D*(L**H)*(P**T),

     where U (or L) is unit upper (or lower) triangular matrix,
     U**H (or L**H) is the conjugate of U (or L), P is a permutation
     matrix, P**T is the transpose of P, and D is Hermitian and block
     diagonal with 1-by-1 and 2-by-2 diagonal blocks.

     CHETRI_3 sets the leading dimension of the workspace  before calling
     CHETRI_3X that actually computes the inverse.  This is the blocked
     version of the algorithm, calling Level 3 BLAS.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the details of the factorization are
          stored as an upper or lower triangular matrix. \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is COMPLEX array, dimension (LDA,N) \n
          On entry, diagonal of the block diagonal matrix D and
          factors U or L as computed by CHETRF_RK and CHETRF_BK: \n
            a) ONLY diagonal elements of the Hermitian block diagonal
               matrix D on the diagonal of A, i.e. D(k,k) = A(k,k);
               (superdiagonal (or subdiagonal) elements of D
                should be provided on entry in array E), and \n
            b) If UPLO = 'U': factor U in the superdiagonal part of A.
               If UPLO = 'L': factor L in the subdiagonal part of A. \n
 \n
          On exit, if INFO = 0, the Hermitian inverse of the original
          matrix. \n
             If UPLO = 'U': the upper triangular part of the inverse
             is formed and the part of A below the diagonal is not
             referenced; \n
             If UPLO = 'L': the lower triangular part of the inverse
             is formed and the part of A above the diagonal is not
             referenced. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] E
          E is COMPLEX array, dimension (N) \n
          On entry, contains the superdiagonal (or subdiagonal)
          elements of the Hermitian block diagonal matrix D
          with 1-by-1 or 2-by-2 diagonal blocks, where
          If UPLO = 'U': E(i) = D(i-1,i),i=2:N, E(1) not referenced;
          If UPLO = 'L': E(i) = D(i+1,i),i=1:N-1, E(N) not referenced. \n
 \n
          NOTE: For 1-by-1 diagonal block D(k), where
          1 <= k <= N, the element E(k) is not referenced in both
          UPLO = 'U' or UPLO = 'L' cases. \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D
          as determined by CHETRF_RK or CHETRF_BK. \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (N+NB+1)*(NB+3). \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The length of WORK. LWORK >= (N+NB+1)*(NB+3). \n
 \n
          If LDWORK = -1, then a workspace query is assumed;
          the routine only calculates the optimal size of the optimal
          size of the WORK array, returns this value as the first
          entry of the WORK array, and no error message related to
          LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n
          > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its
               inverse could not be computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer hetri_3(char* uplo, integer* n, T* a, integer* lda,  T* e,  integer* ipiv, T* work, integer* lwork, integer* info)
{
  return hetri_3(uplo, n, a, lda, e, ipiv, work, lwork, info);
}

/*! @brief HETRI2 computes the inverse of a COMPLEX hermitian indefinite matrix A 

 * @details
 * \b Purpose:
    \verbatim 
     HETRI2 computes the inverse of a COMPLEX hermitian indefinite matrix
     A using the factorization A = U*D*U**T or A = L*D*L**T computed by
     HETRF. HETRI2 set the LEADING DIMENSION of the workspace
     before calling HETRI2X that actually computes the inverse.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the details of the factorization are stored
          as an upper or lower triangular matrix. \n
          = 'U':  Upper triangular, form is A = U*D*U**T; \n
          = 'L':  Lower triangular, form is A = L*D*L**T. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is COMPLEX array, dimension (LDA,N) \n
          On entry, the block diagonal matrix D and the multipliers
          used to obtain the factor U or L as computed by CHETRF. \n
 \n
          On exit, if INFO = 0, the (symmetric) inverse of the original
          matrix.  If UPLO = 'U', the upper triangular part of the
          inverse is formed and the part of A below the diagonal is not
          referenced; if UPLO = 'L' the lower triangular part of the
          inverse is formed and the part of A above the diagonal is
          not referenced. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D
          as determined by HETRF. \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (N+NB+1)*(NB+3) \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK. \n
          WORK is size >= (N+NB+1)*(NB+3) \n
          If LWORK = -1, then a workspace query is assumed; the routine
           calculates: \n
              - the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, \n
              - and no error message related to LWORK is issued by XERBLA.
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n
          > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its
               inverse could not be computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer hetri2(char* uplo, integer* n, T* a, integer* lda, integer* ipiv, T* work, integer* lwork, integer* info)
{
  return hetri2(uplo, n, a, lda, ipiv, work, lwork, info);
}

/*! @brief HETRI2X computes the inverse of a complex Hermitian indefinite matrix A

 * @details
 * \b Purpose:
    \verbatim 
     HETRI2X computes the inverse of a complex Hermitian indefinite matrix
     A using the factorization A = U*D*U**H or A = L*D*L**H computed by
     HETRF.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the details of the factorization are stored
          as an upper or lower triangular matrix. \n
          = 'U':  Upper triangular, form is A = U*D*U**H; \n
          = 'L':  Lower triangular, form is A = L*D*L**H. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is COMPLEX array, dimension (LDA,N) \n
          On entry, the NNB diagonal matrix D and the multipliers
          used to obtain the factor U or L as computed by CHETRF. \n
 \n
          On exit, if INFO = 0, the (symmetric) inverse of the original
          matrix.  If UPLO = 'U', the upper triangular part of the
          inverse is formed and the part of A below the diagonal is not
          referenced; if UPLO = 'L' the lower triangular part of the
          inverse is formed and the part of A above the diagonal is
          not referenced. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the NNB structure of D
          as determined by CHETRF. \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (N+NB+1,NB+3) \n
 * @param[in]	NB	
          NB is INTEGER \n
          Block size \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n
          > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its
               inverse could not be computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer hetri2x(char* uplo, integer* n, T* a, integer* lda, integer* ipiv, T* work, integer *nb, integer* info)
{
  return hetri2x(uplo, n, a, lda, ipiv, work, nb, info);
}

/*! @brief HETRS solves a system of linear equations A*X = B with a complex Hermitian matrix A

 * @details
 * \b Purpose:
    \verbatim 
     HETRS solves a system of linear equations A*X = B with a complex
     Hermitian matrix A using the factorization A = U*D*U**H or
     A = L*D*L**H computed by HETRF.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the details of the factorization are stored
          as an upper or lower triangular matrix. \n
          = 'U':  Upper triangular, form is A = U*D*U**H; \n
          = 'L':  Lower triangular, form is A = L*D*L**H. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in] A
          A is COMPLEX array, dimension (LDA,N) \n
          The block diagonal matrix D and the multipliers used to
          obtain the factor U or L as computed by CHETRF. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D
          as determined by CHETRF. \n
 * @param[in,out] B
          B is COMPLEX array, dimension (LDB,NRHS) \n
          On entry, the right hand side matrix B.
          On exit, the solution matrix X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer hetrs(char* uplo, integer* n, integer* nrhs,  T* a, integer* lda,  integer* ipiv, T* b, integer* ldb, integer* info)
{
  return hetrs(uplo, n, nrhs,  a, lda,  ipiv, b, ldb, info);
}


/*! @brief HETRS_3 solves a system of linear equations A * X = B with a complex Hermitian matrix A

 * @details
 * \b Purpose:
    \verbatim 
     HETRS_3 solves a system of linear equations A * X = B with a complex
     Hermitian matrix A using the factorization computed
     by HETRF_RK or HETRF_BK:

        A = P*U*D*(U**H)*(P**T) or A = P*L*D*(L**H)*(P**T),

     where U (or L) is unit upper (or lower) triangular matrix,
     U**H (or L**H) is the conjugate of U (or L), P is a permutation
     matrix, P**T is the transpose of P, and D is Hermitian and block
     diagonal with 1-by-1 and 2-by-2 diagonal blocks.

     This algorithm is using Level 3 BLAS.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the details of the factorization are
          stored as an upper or lower triangular matrix: \n
          = 'U':  Upper triangular, form is A = P*U*D*(U**H)*(P**T); \n
          = 'L':  Lower triangular, form is A = P*L*D*(L**H)*(P**T). \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in] A
          A is COMPLEX array, dimension (LDA,N) \n
          Diagonal of the block diagonal matrix D and factors U or L
          as computed by CHETRF_RK and CHETRF_BK: \n
            a) ONLY diagonal elements of the Hermitian block diagonal
               matrix D on the diagonal of A, i.e. D(k,k) = A(k,k);
               (superdiagonal (or subdiagonal) elements of D
                should be provided on entry in array E), and \n
            b) If UPLO = 'U': factor U in the superdiagonal part of A.
               If UPLO = 'L': factor L in the subdiagonal part of A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] E
          E is COMPLEX array, dimension (N) \n
          On entry, contains the superdiagonal (or subdiagonal)
          elements of the Hermitian block diagonal matrix D
          with 1-by-1 or 2-by-2 diagonal blocks, where \n
          If UPLO = 'U': E(i) = D(i-1,i),i=2:N, E(1) not referenced; \n
          If UPLO = 'L': E(i) = D(i+1,i),i=1:N-1, E(N) not referenced. \n
 \n
          NOTE: For 1-by-1 diagonal block D(k), where
          1 <= k <= N, the element E(k) is not referenced in both
          UPLO = 'U' or UPLO = 'L' cases. \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D
          as determined by CHETRF_RK or CHETRF_BK. \n
 * @param[in,out] B
          B is COMPLEX array, dimension (LDB,NRHS) \n
          On entry, the right hand side matrix B.
          On exit, the solution matrix X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer hetrs_3(char* uplo, integer* n, integer* nrhs, T* a, integer* lda, T* e, integer* ipiv, T* b, integer* ldb, integer* info)
{
  return hetrs_3(uplo, n, nrhs, a, lda, e, ipiv, b, ldb, info);
}

/*! @brief HETRS_AA solves a system of linear equations A*X = B with a complex hermitian matrix A

 * @details
 * \b Purpose:
    \verbatim 
     HETRS_AA solves a system of linear equations A*X = B with a complex
     hermitian matrix A using the factorization A = U**H*T*U or
     A = L*T*L**H computed by HETRF_AA.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the details of the factorization are stored
          as an upper or lower triangular matrix. \n
          = 'U':  Upper triangular, form is A = U**H*T*U; \n
          = 'L':  Lower triangular, form is A = L*T*L**H. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in] A
          A is COMPLEX array, dimension (LDA,N) \n
          Details of factors computed by CHETRF_AA. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges as computed by CHETRF_AA. \n
 * @param[in,out] B
          B is COMPLEX array, dimension (LDB,NRHS) \n
          On entry, the right hand side matrix B.
          On exit, the solution matrix X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK. LWORK >= max(1,3*N-2). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer hetrs_aa(char* uplo, integer* n, integer* nrhs,  T* a, integer* lda,  integer* ipiv, T* b, integer* ldb, T* work, integer* lwork, integer* info)
{
  return hetrs_aa(uplo, n, nrhs,  a, lda,  ipiv, b, ldb, work, lwork, info);
}

/*! @brief HETRS_AA_2STAGE solves a system of linear equations A*X = B with a real hermitian matrix A

 * @details
 * \b Purpose:
    \verbatim 
     HETRS_AA_2STAGE solves a system of linear equations A*X = B with a real
     hermitian matrix A using the factorization A = U**T*T*U or
     A = L*T*L**T computed by HETRF_AA_2STAGE.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the details of the factorization are stored
          as an upper or lower triangular matrix. \n
          = 'U':  Upper triangular, form is A = U**T*T*U; \n
          = 'L':  Lower triangular, form is A = L*T*L**T. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in] A
          A is COMPLEX array, dimension (LDA,N) \n
          Details of factors computed by CHETRF_AA_2STAGE. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] TB
          TB is COMPLEX array, dimension (LTB) \n
          Details of factors computed by CHETRF_AA_2STAGE. \n
 * @param[in] LTB
          LTB is INTEGER \n
          The size of the array TB. LTB >= 4*N. \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges as computed by
          CHETRF_AA_2STAGE. \n
 * @param[in] IPIV2
          IPIV2 is INTEGER array, dimension (N) \n
          Details of the interchanges as computed by
          CHETRF_AA_2STAGE. \n
 * @param[in,out] B
          B is COMPLEX array, dimension (LDB,NRHS) \n
          On entry, the right hand side matrix B.
          On exit, the solution matrix X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer hetrs_aa_2stage(char* uplo, integer* n, integer* nrhs, T* a, integer* lda, T* tb, integer* ltb, integer* ipiv, integer* ipiv2, T* b, integer* ldb, integer* info)
{
  return hetrs_aa_2stage(uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb, info);
}

/*! @brief HETRS_ROOK computes the solution to a system of linear equations A * X = B for \n
     HE matrices using factorization obtained with one of the bounded diagonal pivoting   \n
     methods (max 2 interchanges)
 * @details
 * \b Purpose:
    \verbatim 
     HETRS_ROOK solves a system of linear equations A*X = B with a complex
     Hermitian matrix A using the factorization A = U*D*U**H or
     A = L*D*L**H computed by HETRF_ROOK.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the details of the factorization are stored
          as an upper or lower triangular matrix. \n
          = 'U':  Upper triangular, form is A = U*D*U**H; \n
          = 'L':  Lower triangular, form is A = L*D*L**H. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in] A
          A is COMPLEX array, dimension (LDA,N) \n
          The block diagonal matrix D and the multipliers used to
          obtain the factor U or L as computed by CHETRF_ROOK. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D
          as determined by CHETRF_ROOK. \n
 * @param[in,out] B
          B is COMPLEX array, dimension (LDB,NRHS) \n
          On entry, the right hand side matrix B.
          On exit, the solution matrix X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer hetrs_rook(char* uplo, integer* n, integer* nrhs,  T* a, integer* lda,  integer* ipiv, T* b, integer* ldb, integer* info)
{
  return hetrs_rook(uplo, n, nrhs,  a, lda,  ipiv, b, ldb, info);
}

/*! @brief HETRS2 solves a system of linear equations A*X = B with a complex Hermitian matrix A

 * @details
 * \b Purpose:
    \verbatim 
     HETRS2 solves a system of linear equations A*X = B with a complex
     Hermitian matrix A using the factorization A = U*D*U**H or
     A = L*D*L**H computed by HETRF and converted by CSYCONV.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the details of the factorization are stored
          as an upper or lower triangular matrix. \n
          = 'U':  Upper triangular, form is A = U*D*U**H; \n
          = 'L':  Lower triangular, form is A = L*D*L**H. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in] A
          A is COMPLEX array, dimension (LDA,N) \n
          The block diagonal matrix D and the multipliers used to
          obtain the factor U or L as computed by CHETRF. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D
          as determined by CHETRF. \n
 * @param[in,out] B
          B is COMPLEX array, dimension (LDB,NRHS) \n
          On entry, the right hand side matrix B.
          On exit, the solution matrix X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out]	WORK	
          WORK is COMPLEX array, dimension (N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer hetrs2(char* uplo, integer* n, integer* nrhs,  T* a, integer* lda,  integer* ipiv, T* b, integer* ldb, T* work, integer* info)
{
  return hetrs2(uplo, n, nrhs,  a, lda,  ipiv, b, ldb, work, info);
}

/*! @brief COMBSSQ adds two scaled sum of squares quantities

 * @details
 * \b Purpose:
    \verbatim 
     COMBSSQ adds two scaled sum of squares quantities, V1 := V1 + V2.
     That is,
    
        V1_scale**2 * V1_sumsq := V1_scale**2 * V1_sumsq
                                + V2_scale**2 * V2_sumsq
    \endverbatim
    
  * @param[in,out] V1 \n
           V1 is REAL array, dimension (2). \n
           The first scaled sum.
           V1(1) = V1_scale, V1(2) = V1_sumsq. \n
  * @param[in] V2
           V2 is REAL array, dimension (2). \n
           The second scaled sum.
           V2(1) = V2_scale, V2(2) = V2_sumsq.  \n
 * */
template< typename T >
integer combssq(T* v1, T* v2)
{
  return combssq(v1, v2);
}

/*! @brief SUM1 forms the 1-norm of the complex vector using the true absolute value

 * @details
 * \b Purpose:
    \verbatim 
    SUM1 takes the sum of the absolute values of a complex
    vector and returns a single precision result.

    Based on SCASUM from the Level 1 BLAS.
    The change is to use the 'genuine' absolute value.
    \endverbatim 

 * @param[in] N
          N is INTEGER
          The number of elements in the vector CX.
 * @param[in] CX
          CX is COMPLEX array, dimension (N)
          The vector whose elements will be summed.
 * @param[in] INCX
          INCX is INTEGER
          The spacing between successive values of CX.  INCX > 0.
 * */
template< typename T, typename Ta >
Ta sum1(integer* n, T* cx, integer* incx)
{
  return sum1(n, cx, incx);
}

/*! @brief GBTF2 computes the LU factorization of a general band matrix using the unblocked version of the algorithm

 * @details
 * \b Purpose:
    \verbatim 
    GBTF2 computes an LU factorization of a real m-by-n band matrix A
    using partial pivoting with row interchanges.

    This is the unblocked version of the algorithm, calling Level 2 BLAS.
    \endverbatim  

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A.  N >= 0. \n
 * @param[in] KL
          KL is INTEGER \n
          The number of subdiagonals within the band of A.  KL >= 0. \n
 * @param[in] KU
          KU is INTEGER \n
          The number of superdiagonals within the band of A.  KU >= 0. \n
 * @param[in,out] AB
          AB is REAL array, dimension (LDAB,N) \n
          On entry, the matrix A in band storage, in rows KL+1 to
          2*KL+KU+1; rows 1 to KL of the array need not be set.
          The j-th column of A is stored in the j-th column of the
          array AB as follows: \n
          AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl) \n
 \n
          On exit, details of the factorization: U is stored as an
          upper triangular band matrix with KL+KU superdiagonals in
          rows 1 to KL+KU+1, and the multipliers used during the
          factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
          See below for further details. \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1. \n
 * @param[out] IPIV
          IPIV is INTEGER array, dimension (min(M,N)) \n
          The pivot indices; for 1 <= i <= min(M,N), row i of the
          matrix was interchanged with row IPIV(i). \n
 * @param[out] INFO
            INFO is INTEGER \n
            = 0: successful exit \n
            < 0: if INFO = -i, the i-th argument had an illegal value \n
            > 0: if INFO = +i, U(i,i) is exactly zero. The factorization
                 has been completed, but the factor U is exactly
                 singular, and division by zero will occur if it is used
                 to solve a system of equations. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer gbtf2(integer* m, integer* n, integer* kl, integer* ku, T* ab, integer* ldab, integer* ipiv, integer* info)
{
  return gbtf2(m, n, kl, ku, ab, ldab, ipiv, info);
}

/*! @brief GELQT3 recursively computes a LQ factorization of a real M-by-N matrix A

 * @details
 * \b Purpose:
    \verbatim
    GELQT3 recursively computes a LQ factorization of a real M-by-N
    matrix A, using the compact WY representation of Q.

    Based on the algorithm of Elmroth and Gustavson,
    IBM J. Res. Develop. Vol 44 No. 4 July 2000.
    \endverbatim 

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M =< N. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the real M-by-N matrix A.  On exit, the elements on and
          below the diagonal contain the N-by-N lower triangular matrix L; the
          elements above the diagonal are the rows of V.  See below for
          further details. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,M). \n
 * @param[out] T
          T is REAL array, dimension (LDT,N) \n
          The N-by-N upper triangular factor of the block reflector.
          The elements on and above the diagonal contain the block
          reflector T; the elements below the diagonal are not used.
          See below for further details. \n
 * @param[in] LDT
          LDT is INTEGER \n
          The leading dimension of the array T.  LDT >= max(1,N). \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer gelqt3(integer *m, integer *n, T *a, integer *lda, T *t, integer *ldt, integer *info)
{
  return gelqt3(m, n, a, lda, t, ldt, info);
}

/*! @brief GEQL2 computes the QL factorization of a general rectangular matrix using an unblocked algorithm

 * @details
 * \b Purpose:
    \verbatim 
    GEQL2 computes a QL factorization of a real m by n matrix A:
    A = Q * L.
    \endverbatim  

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the m by n matrix A. \n
          On exit, if m >= n, the lower triangle of the subarray
          A(m-n+1:m,1:n) contains the n by n lower triangular matrix L;
          if m <= n, the elements on and below the (n-m)-th
          superdiagonal contain the m by n lower trapezoidal matrix L;
          the remaining elements, with the array TAU, represent the
          orthogonal matrix Q as a product of elementary reflectors
          (see Further Details). \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,M). \n
 * @param[out] TAU
          TAU is REAL array, dimension (min(M,N)) \n
          The scalar factors of the elementary reflectors (see Further
          Details). \n
 * @param[out] WORK
          WORK is REAL array, dimension (N) \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer geql2(integer *m, integer *n, T *a, integer *lda, T *tau, T *work, integer *info)
{
  return geql2(m, n, a, lda, tau, work, info);
}

/*! @brief GEQR2P computes the QR factorization of a general rectangular  \n
     matrix with non-negative diagonal elements using an unblocked algorithm

 * @details
 * \b Purpose:
    \verbatim 
    GEQR2P computes a QR factorization of a real m-by-n matrix A:

       A = Q * (R),
               (0)

    where:

       Q is a m-by-m orthogonal matrix;
       R is an upper-triangular n-by-n matrix with nonnegative diagonal
       entries;
       0 is a (m-n)-by-n zero matrix, if m > n.
    \endverbatim 
 
 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the m by n matrix A. \n
          On exit, the elements on and above the diagonal of the array
          contain the min(m,n) by n upper trapezoidal matrix R (R is
          upper triangular if m >= n). The diagonal entries of R
          are nonnegative; the elements below the diagonal,
          with the array TAU, represent the orthogonal matrix Q as a
          product of elementary reflectors (see Further Details). \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,M). \n
 * @param[out] TAU
          TAU is REAL array, dimension (min(M,N)) \n
          The scalar factors of the elementary reflectors (see Further
          Details). \n
 * @param[out] WORK
          WORK is REAL array, dimension (N) \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer geqr2p(integer *m, integer *n, T *a, integer *lda, T *tau, T *work, integer *info)
{
  return geqr2p(m, n, a, lda, tau, work, info);
}

/*! @brief GERQ2 computes the RQ factorization of a general rectangular matrix using an unblocked algorithm

 * @details
 * \b Purpose:
    \verbatim 
    GERQ2 computes an RQ factorization of a real m by n matrix A:
    A = R * Q.
    \endverbatim  

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the m by n matrix A. \n
          On exit, if m <= n, the upper triangle of the subarray
          A(1:m,n-m+1:n) contains the m by m upper triangular matrix R;
          if m >= n, the elements on and above the (m-n)-th subdiagonal
          contain the m by n upper trapezoidal matrix R; the remaining
          elements, with the array TAU, represent the orthogonal matrix
          Q as a product of elementary reflectors (see Further
          Details). \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,M). \n
 * @param[out] TAU
          TAU is REAL array, dimension (min(M,N)) \n
          The scalar factors of the elementary reflectors (see Further
          Details). \n
 * @param[out] WORK
          WORK is REAL array, dimension (M) \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer gerq2(integer *m, integer *n, T *a, integer *lda, T *tau, T *work, integer *info)
{
  return gerq2(m, n, a, lda, tau, work, info);
}

/*! @brief GESC2 solves a system of linear equations using the LU factorization with complete pivoting computed by getc2

 * @details
 * \b Purpose:
    \verbatim 
    GESC2 solves a system of linear equations

              A * X = scale* RHS

    with a general N-by-N matrix A using the LU factorization with
    complete pivoting computed by GETC2.
    \endverbatim  

 * @param[in] N
          N is INTEGER \n
          The order of the matrix A. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the  LU part of the factorization of the n-by-n
          matrix A computed by SGETC2:  A = P * L * U * Q \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1, N). \n
 * @param[in,out] RHS
          RHS is REAL array, dimension (N). \n
          On entry, the right hand side vector b.
          On exit, the solution vector X. \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N). \n
          The pivot indices; for 1 <= i <= N, row i of the
          matrix has been interchanged with row IPIV(i). \n
 * @param[in] JPIV
          JPIV is INTEGER array, dimension (N). \n
          The pivot indices; for 1 <= j <= N, column j of the
          matrix has been interchanged with column JPIV(j). \n
 * @param[out] SCALE
          SCALE is REAL \n
          On exit, SCALE contains the scale factor. SCALE is chosen
          0 <= SCALE <= 1 to prevent overflow in the solution. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer gesc2(integer *n, T *a, integer *lda, T *rhs, integer *ipiv, integer *jpiv, T *scale)
{
  return gesc2(n, a, lda, rhs, ipiv, jpiv, scale);
}
template< typename T, typename Ta >
integer gesc2(integer *n, T *a, integer *lda, T *rhs, integer *ipiv, integer *jpiv, Ta *scale)
{
  return gesc2(n, a, lda, rhs, ipiv, jpiv, scale);
}

/*! @brief GSVJ0 pre-processor for the routine gesvj

 * @details
 * \b Purpose:
    \verbatim 
    GSVJ0 is called from GESVJ as a pre-processor and that is its main
    purpose. It applies Jacobi rotations in the same way as GESVJ does, but
    it does not check convergence (stopping criterion). Few tuning
    parameters (marked by [TP]) are available for the implementer.
    \endverbatim 

 * @param[in] JOBV
          JOBV is CHARACTER*1 \n
          Specifies whether the output from this procedure is used
          to compute the matrix V: \n
          = 'V': the product of the Jacobi rotations is accumulated
                 by postmulyiplying the N-by-N array V.
                (See the description of V.) \n
          = 'A': the product of the Jacobi rotations is accumulated
                 by postmulyiplying the MV-by-N array V.
                (See the descriptions of MV and V.) \n
          = 'N': the Jacobi rotations are not accumulated. \n
 * @param[in] M
          M is INTEGER \n
          The number of rows of the input matrix A.  M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the input matrix A.
          M >= N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, M-by-N matrix A, such that A*diag(D) represents
          the input matrix. \n
          On exit,
          A_onexit * D_onexit represents the input matrix A*diag(D)
          post-multiplied by a sequence of Jacobi rotations, where the
          rotation threshold and the total number of sweeps are given in
          TOL and NSWEEP, respectively. \n
          (See the descriptions of D, TOL and NSWEEP.) \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,M). \n
 * @param[in,out] D
          D is REAL array, dimension (N) \n
          The array D accumulates the scaling factors from the fast scaled
          Jacobi rotations. \n
          On entry, A*diag(D) represents the input matrix. \n
          On exit, A_onexit*diag(D_onexit) represents the input matrix
          post-multiplied by a sequence of Jacobi rotations, where the
          rotation threshold and the total number of sweeps are given in
          TOL and NSWEEP, respectively. \n
          (See the descriptions of A, TOL and NSWEEP.) \n
 * @param[in,out] SVA
          SVA is REAL array, dimension (N) \n
          On entry, SVA contains the Euclidean norms of the columns of
          the matrix A*diag(D). \n
          On exit, SVA contains the Euclidean norms of the columns of
          the matrix onexit*diag(D_onexit). \n
 * @param[in] MV
          MV is INTEGER \n
          If JOBV = 'A', then MV rows of V are post-multipled by a
                           sequence of Jacobi rotations. \n
          If JOBV = 'N',  then MV is not referenced. \n
 * @param[in,out] V
          V is REAL array, dimension (LDV,N) \n
          If JOBV = 'V' then N rows of V are post-multipled by a
                           sequence of Jacobi rotations. \n
          If JOBV = 'A' then MV rows of V are post-multipled by a
                           sequence of Jacobi rotations. \n
          If JOBV = 'N',  then V is not referenced. \n
 * @param[in] LDV
          LDV is INTEGER \n
          The leading dimension of the array V, LDV >= 1. \n
          If JOBV = 'V', LDV >= N. \n
          If JOBV = 'A', LDV >= MV. \n
 * @param[in] EPS
          EPS is REAL \n
          EPS = SLAMCH('Epsilon') \n
 * @param[in] SFMIN
          SFMIN is REAL \n
          SFMIN = SLAMCH('Safe Minimum') \n
 * @param[in] TOL
          TOL is REAL \n
          TOL is the threshold for Jacobi rotations. For a pair
          A(:,p), A(:,q) of pivot columns, the Jacobi rotation is
          applied only if ABS(COS(angle(A(:,p),A(:,q)))) > TOL. \n
 * @param[in] NSWEEP
          NSWEEP is INTEGER \n
          NSWEEP is the number of sweeps of Jacobi rotations to be
          performed. \n
 * @param[out] WORK
          WORK is REAL array, dimension (LWORK) \n
 * @param[in] LWORK
          LWORK is INTEGER \n
          LWORK is the dimension of WORK. LWORK >= M. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, then the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer gsvj0(char *jobv, integer *m, integer *n, T *a, integer *lda, T *d, T *sva, integer *mv, T *v, integer *ldv, T *eps, T *sfmin, T *tol, integer *nsweep, T *work, integer *lwork, integer *info)
{
  return gsvj0(jobv, m, n, a, lda, d, sva, mv, v, ldv, eps, sfmin, tol, nsweep, work, lwork, info);
}
template< typename T, typename Ta >
integer gsvj0(char *jobv, integer *m, integer *n, T *a, integer *lda, T *d, Ta *sva, integer *mv, T *v, integer *ldv, Ta *eps, Ta *sfmin, Ta *tol, integer *nsweep, T *work, integer *lwork, integer *info)
{
  return gsvj0(jobv, m, n, a, lda, d, sva, mv, v, ldv, eps, sfmin, tol, nsweep, work, lwork, info);
}

/*! @brief GSVJ1 pre-processor for the routine gesvj, applies Jacobi rotations targeting only particular pivots

 * @details
 * \b Purpose:
    \verbatim 
    GSVJ1 is called from SGESVJ as a pre-processor and that is its main
    purpose. It applies Jacobi rotations in the same way as SGESVJ does, but
    it targets only particular pivots and it does not check convergence
    (stopping criterion). Few tunning parameters (marked by [TP]) are
    available for the implementer.

    Further Details
    ~~~~~~~~~~~~~~~
    SGSVJ1 applies few sweeps of Jacobi rotations in the column space of
    the input M-by-N matrix A. The pivot pairs are taken from the (1,2)
    off-diagonal block in the corresponding N-by-N Gram matrix A^T * A. The
    block-entries (tiles) of the (1,2) off-diagonal block are marked by the
    [x]'s in the following scheme:

       | *  *  * [x] [x] [x]|
       | *  *  * [x] [x] [x]|    Row-cycling in the nblr-by-nblc [x] blocks.
       | *  *  * [x] [x] [x]|    Row-cyclic pivoting inside each [x] block.
       |[x] [x] [x] *  *  * |
       |[x] [x] [x] *  *  * |
       |[x] [x] [x] *  *  * |

    In terms of the columns of A, the first N1 columns are rotated 'against'
    the remaining N-N1 columns, trying to increase the angle between the
    corresponding subspaces. The off-diagonal block is N1-by(N-N1) and it is
    tiled using quadratic tiles of side KBL. Here, KBL is a tunning parameter.
    The number of sweeps is given in NSWEEP and the orthogonality threshold
    is given in TOL.
    \endverbatim 

 * @param[in] JOBV
          JOBV is CHARACTER*1 \n
          Specifies whether the output from this procedure is used
          to compute the matrix V: \n
          = 'V': the product of the Jacobi rotations is accumulated
                 by postmulyiplying the N-by-N array V.
                (See the description of V.) \n
          = 'A': the product of the Jacobi rotations is accumulated
                 by postmulyiplying the MV-by-N array V.
                (See the descriptions of MV and V.) \n
          = 'N': the Jacobi rotations are not accumulated. \n
 * @param[in] M
          M is INTEGER \n
          The number of rows of the input matrix A.  M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the input matrix A.
          M >= N >= 0. \n
 * @param[in] N1
          N1 is INTEGER \n
          N1 specifies the 2 x 2 block partition, the first N1 columns are
          rotated 'against' the remaining N-N1 columns of A. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, M-by-N matrix A, such that A*diag(D) represents
          the input matrix. \n
          On exit,
          A_onexit * D_onexit represents the input matrix A*diag(D)
          post-multiplied by a sequence of Jacobi rotations, where the
          rotation threshold and the total number of sweeps are given in
          TOL and NSWEEP, respectively. \n
          (See the descriptions of N1, D, TOL and NSWEEP.) \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,M). \n
 * @param[in,out] D
          D is REAL array, dimension (N) \n
          The array D accumulates the scaling factors from the fast scaled
          Jacobi rotations. \n
          On entry, A*diag(D) represents the input matrix. \n
          On exit, A_onexit*diag(D_onexit) represents the input matrix
          post-multiplied by a sequence of Jacobi rotations, where the
          rotation threshold and the total number of sweeps are given in
          TOL and NSWEEP, respectively. \n
          (See the descriptions of N1, A, TOL and NSWEEP.) \n
 * @param[in,out] SVA
          SVA is REAL array, dimension (N) \n
          On entry, SVA contains the Euclidean norms of the columns of
          the matrix A*diag(D). \n
          On exit, SVA contains the Euclidean norms of the columns of
          the matrix onexit*diag(D_onexit). \n
 * @param[in] MV
          MV is INTEGER \n
          If JOBV = 'A', then MV rows of V are post-multipled by a
                           sequence of Jacobi rotations. \n
          If JOBV = 'N',  then MV is not referenced. \n
 * @param[in,out] V
          V is REAL array, dimension (LDV,N) \n
          If JOBV = 'V' then N rows of V are post-multipled by a
                           sequence of Jacobi rotations. \n
          If JOBV = 'A' then MV rows of V are post-multipled by a
                           sequence of Jacobi rotations. \n
          If JOBV = 'N',  then V is not referenced. \n
 * @param[in] LDV
          LDV is INTEGER \n
          The leading dimension of the array V, LDV >= 1. \n
          If JOBV = 'V', LDV >= N. \n
          If JOBV = 'A', LDV >= MV. \n
 * @param[in] EPS
          EPS is REAL \n
          EPS = SLAMCH('Epsilon') \n
 * @param[in] SFMIN
          SFMIN is REAL \n
          SFMIN = SLAMCH('Safe Minimum') \n
 * @param[in] TOL
          TOL is REAL \n
          TOL is the threshold for Jacobi rotations. For a pair
          A(:,p), A(:,q) of pivot columns, the Jacobi rotation is
          applied only if ABS(COS(angle(A(:,p),A(:,q)))) > TOL. \n
 * @param[in] NSWEEP
          NSWEEP is INTEGER \n
          NSWEEP is the number of sweeps of Jacobi rotations to be
          performed. \n
 * @param[out] WORK
          WORK is REAL array, dimension (LWORK) \n
 * @param[in] LWORK
          LWORK is INTEGER \n
          LWORK is the dimension of WORK. LWORK >= M. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, then the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer gsvj1(char *jobv, integer *m, integer *n, integer *n1, T *a, integer *lda, T *d, T *sva, integer *mv, T *v, integer *ldv, T *eps, T *sfmin, T *tol, integer *nsweep, T *work, integer *lwork, integer *info)
{
  return gsvj1(jobv, m, n, n1, a, lda, d, sva, mv, v, ldv, eps, sfmin, tol, nsweep, work, lwork, info);
}
template< typename T, typename Ta >
integer gsvj1(char *jobv, integer *m, integer *n, integer *n1, T *a, integer *lda, T *d, Ta *sva, integer *mv, T *v, integer *ldv, Ta *eps, Ta *sfmin, Ta *tol, integer *nsweep, T *work, integer *lwork, integer *info)
{
  return gsvj1(jobv, m, n, n1, a, lda, d, sva, mv, v, ldv, eps, sfmin, tol, nsweep, work, lwork, info);
}

/*! @brief GTTS2 solves a system of linear equations with a tridiagonal matrix using the LU factorization computed by sgttrf

 * @details
 * \b Purpose:
    \verbatim 
    GTTS2 solves one of the systems of equations
       A*X = B  or  A**T*X = B,
    with a tridiagonal matrix A using the LU factorization computed
    by GTTRF.
    \endverbatim 

 * @param[in] ITRANS
          ITRANS is INTEGER \n
          Specifies the form of the system of equations. \n
          = 0:  A * X = B  (No transpose) \n
          = 1:  A**T* X = B  (Transpose) \n
          = 2:  A**T* X = B  (Conjugate transpose = Transpose) \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in] DL
          DL is REAL array, dimension (N-1) \n
          The (n-1) multipliers that define the matrix L from the
          LU factorization of A. \n
 * @param[in] D
          D is REAL array, dimension (N) \n
          The n diagonal elements of the upper triangular matrix U from
          the LU factorization of A. \n
 * @param[in] DU
          DU is REAL array, dimension (N-1) \n
          The (n-1) elements of the first super-diagonal of U. \n
 * @param[in] DU2
          DU2 is REAL array, dimension (N-2) \n
          The (n-2) elements of the second super-diagonal of U. \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          The pivot indices; for 1 <= i <= n, row i of the matrix was
          interchanged with row IPIV(i).  IPIV(i) will always be either
          i or i+1; IPIV(i) = i indicates a row interchange was not
          required. \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,NRHS) \n
          On entry, the matrix of right hand side vectors B.
          On exit, B is overwritten by the solution vectors X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer gtts2(integer *itrans, integer *n, integer *nrhs, T *dl, T *d, T *du, T *du2, integer *ipiv, T *b, integer * ldb)
{
  return gtts2(itrans, n, nrhs, dl, d, du, du2, ipiv, b, ldb);
}

/*! @brief HB2ST_KERNELS is an internal routine used by the HETRD_HB2ST subroutine

 * @details
 * \b Purpose:
    \verbatim 
    HB2ST_KERNELS is an internal routine used by the CHETRD_HB2ST
    subroutine.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
 * @param[in] WANTZ
          WANTZ is LOGICAL which indicate if Eigenvalue are requested or both
          Eigenvalue/Eigenvectors. \n
 * @param[in] TTYPE
          TTYPE is INTEGER \n
 * @param[in] ST
          ST is INTEGER \n
          internal parameter for indices. \n
 * @param[in] ED
          ED is INTEGER \n
          internal parameter for indices. \n
 * @param[in] SWEEP
          SWEEP is INTEGER \n
          internal parameter for indices. \n
 * @param[in] N
          N is INTEGER. The order of the matrix A. \n
 * @param[in] NB
          NB is INTEGER. The size of the band. \n
 * @param[in] IB
          IB is INTEGER. \n
 * @param[in, out] A
          A is COMPLEX array. A pointer to the matrix A. \n
 * @param[in] LDA
          LDA is INTEGER. The leading dimension of the matrix A. \n
 * @param[out] V
          V is COMPLEX array, dimension 2*n if eigenvalues only are
          requested or to be queried for vectors. \n
 * @param[out] TAU
          TAU is COMPLEX array, dimension (2*n).
          The scalar factors of the Householder reflectors are stored
          in this array. \n
 * @param[in] LDVT
          LDVT is INTEGER. \n
 * @param[out] WORK
          WORK is COMPLEX array. Workspace of size nb. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer hb2st_kernels(char *uplo, logical *wantz, integer * ttype, integer *st, integer *ed, integer *sweep, integer *n, integer * nb, integer *ib, T *a, integer *lda, T *v, T *tau, integer *ldvt, T *work)
{
  return hb2st_kernels(uplo, wantz, ttype, st, ed, sweep, n, nb, ib, a, lda, v, tau, ldvt, work);
}

/*! @brief HECON_ROOK estimates the reciprocal of the condition number fort HE matrices \n
     using factorization obtained with one of the bounded diagonal pivoting methods (max 2 interchanges)

 * @details
 * \b Purpose:
    \verbatim 
    HECON_ROOK estimates the reciprocal of the condition number of a complex
    Hermitian matrix A using the factorization A = U*D*U**H or
    A = L*D*L**H computed by CHETRF_ROOK.

    An estimate is obtained for norm(inv(A)), and the reciprocal of the
    condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the details of the factorization are stored
          as an upper or lower triangular matrix. \n
          = 'U':  Upper triangular, form is A = U*D*U**H; \n
          = 'L':  Lower triangular, form is A = L*D*L**H. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] A
          A is COMPLEX array, dimension (LDA,N) \n
          The block diagonal matrix D and the multipliers used to
          obtain the factor U or L as computed by CHETRF_ROOK. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D
          as determined by CHETRF_ROOK. \n
 * @param[in] ANORM
          ANORM is REAL \n
          The 1-norm of the original matrix A. \n
 * @param[out] RCOND
          RCOND is REAL \n
          The reciprocal of the condition number of the matrix A,
          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
          estimate of the 1-norm of inv(A) computed in this routine. \n
 * @param[out] WORK
          WORK is COMPLEX array, dimension (2*N) \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T, typename Ta >
integer hecon_rook(char *uplo, integer *n, T *a, integer *lda, integer *ipiv, Ta *anorm, Ta *rcond, T *work, integer *info)
{
  return hecon_rook(uplo, n, a, lda, ipiv, anorm, rcond, work, info); 
}

/*! @brief HESV_ROOK computes the solution to a system of linear equations A * X = B \n
     for HE matrices using the bounded Bunch-Kaufman ("rook") diagonal pivoting method

 * @details
 * \b Purpose:
    \verbatim 
    HESV_ROOK computes the solution to a complex system of linear equations
       A * X = B,
    where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
    matrices.

    The bounded Bunch-Kaufman ("rook") diagonal pivoting method is used
    to factor A as
       A = U * D * U**T, if UPLO = 'U', or
       A = L * D * L**T, if UPLO = 'L',
    where U (or L) is a product of permutation and unit upper (lower)
    triangular matrices, and D is Hermitian and block diagonal with
    1-by-1 and 2-by-2 diagonal blocks.

    CHETRF_ROOK is called to compute the factorization of a complex
    Hermition matrix A using the bounded Bunch-Kaufman ("rook") diagonal
    pivoting method.

    The factored form of A is then used to solve the system
    of equations A * X = B by calling CHETRS_ROOK (uses BLAS 2).
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in,out] A
          A is COMPLEX array, dimension (LDA,N) \n
          On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
          N-by-N upper triangular part of A contains the upper
          triangular part of the matrix A, and the strictly lower
          triangular part of A is not referenced.  If UPLO = 'L', the
          leading N-by-N lower triangular part of A contains the lower
          triangular part of the matrix A, and the strictly upper
          triangular part of A is not referenced. \n
 \n
          On exit, if INFO = 0, the block diagonal matrix D and the
          multipliers used to obtain the factor U or L from the
          factorization A = U*D*U**H or A = L*D*L**H as computed by
          CHETRF_ROOK. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D. \n
 \n
          If UPLO = 'U': \n
             Only the last KB elements of IPIV are set.
 \n
             If IPIV(k) > 0, then rows and columns k and IPIV(k) were
             interchanged and D(k,k) is a 1-by-1 diagonal block.
 \n
             If IPIV(k) < 0 and IPIV(k-1) < 0, then rows and
             columns k and -IPIV(k) were interchanged and rows and
             columns k-1 and -IPIV(k-1) were inerchaged,
             D(k-1:k,k-1:k) is a 2-by-2 diagonal block. \n
 \n
          If UPLO = 'L': \n
             Only the first KB elements of IPIV are set.
 \n
             If IPIV(k) > 0, then rows and columns k and IPIV(k)
             were interchanged and D(k,k) is a 1-by-1 diagonal block.
 \n
             If IPIV(k) < 0 and IPIV(k+1) < 0, then rows and
             columns k and -IPIV(k) were interchanged and rows and
             columns k+1 and -IPIV(k+1) were inerchaged,
             D(k:k+1,k:k+1) is a 2-by-2 diagonal block. \n
 * @param[in,out] B
          B is COMPLEX array, dimension (LDB,NRHS) \n
          On entry, the N-by-NRHS right hand side matrix B.
          On exit, if INFO = 0, the N-by-NRHS solution matrix X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out] WORK
          WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1)   returns the optimal LWORK. \n
 * @param[in] LWORK
          LWORK is INTEGER \n
          The length of WORK.  LWORK >= 1, and for best performance
          LWORK >= max(1,N*NB), where NB is the optimal blocksize for
          CHETRF_ROOK. \n
          for LWORK < N, TRS will be done with Level BLAS 2 \n
          for LWORK >= N, TRS will be done with Level BLAS 3 \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array,   returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n
          > 0: if INFO = i, D(i,i) is exactly zero.  The factorization
               has been completed, but the block diagonal matrix D is
               exactly singular, so the solution could not be computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer hesv_rook(char *uplo, integer *n, integer *nrhs, T *a, integer *lda, integer *ipiv, T *b, integer *ldb, T *work, integer *lwork, integer *info)
{
  return hesv_rook(uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork, info);
}

/*! @brief HETF2 computes the factorization of a complex Hermitian matrix, using the 
     diagonal pivoting method (unblocked algorithm calling Level 2 BLAS).

 * @details
 * \b Purpose:
    \verbatim 
    HETF2 computes the factorization of a complex Hermitian matrix A
    using the Bunch-Kaufman diagonal pivoting method:

       A = U*D*U**H  or  A = L*D*L**H

    where U (or L) is a product of permutation and unit upper (lower)
    triangular matrices, U**H is the conjugate transpose of U, and D is
    Hermitian and block diagonal with 1-by-1 and 2-by-2 diagonal blocks.

    This is the unblocked version of the algorithm, calling Level 2 BLAS.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the upper or lower triangular part of the
          Hermitian matrix A is stored: \n
          = 'U':  Upper triangular \n
          = 'L':  Lower triangular \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is COMPLEX array, dimension (LDA,N) \n
          On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
          n-by-n upper triangular part of A contains the upper
          triangular part of the matrix A, and the strictly lower
          triangular part of A is not referenced.  If UPLO = 'L', the
          leading n-by-n lower triangular part of A contains the lower
          triangular part of the matrix A, and the strictly upper
          triangular part of A is not referenced. \n
 \n
          On exit, the block diagonal matrix D and the multipliers used
          to obtain the factor U or L (see below for further details). \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D. \n
 \n
          If UPLO = 'U': \n
             If IPIV(k) > 0, then rows and columns k and IPIV(k) were
             interchanged and D(k,k) is a 1-by-1 diagonal block. \n
 \n
             If IPIV(k) = IPIV(k-1) < 0, then rows and columns
             k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
             is a 2-by-2 diagonal block. \n
 \n
          If UPLO = 'L': \n
             If IPIV(k) > 0, then rows and columns k and IPIV(k) were
             interchanged and D(k,k) is a 1-by-1 diagonal block. \n
 \n
             If IPIV(k) = IPIV(k+1) < 0, then rows and columns
             k+1 and -IPIV(k) were interchanged and D(k:k+1,k:k+1)
             is a 2-by-2 diagonal block. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -k, the k-th argument had an illegal value \n
          > 0: if INFO = k, D(k,k) is exactly zero.  The factorization
               has been completed, but the block diagonal matrix D is
               exactly singular, and division by zero will occur if it
               is used to solve a system of equations. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer hetf2(char *uplo, integer *n, T *a, integer *lda, integer *ipiv, integer *info)
{
  return hetf2(uplo, n, a, lda, ipiv, info); 
}

/*! @brief HETF2_RK computes the factorization of a complex Hermitian indefinite matrix \n
     using the bounded Bunch-Kaufman (rook) diagonal pivoting method (BLAS2 unblocked algorithm).

 * @details
 * \b Purpose:
    \verbatim 
    HETF2_RK computes the factorization of a complex Hermitian matrix A
    using the bounded Bunch-Kaufman (rook) diagonal pivoting method:

       A = P*U*D*(U**H)*(P**T) or A = P*L*D*(L**H)*(P**T),

    where U (or L) is unit upper (or lower) triangular matrix,
    U**H (or L**H) is the conjugate of U (or L), P is a permutation
    matrix, P**T is the transpose of P, and D is Hermitian and block
    diagonal with 1-by-1 and 2-by-2 diagonal blocks.

    This is the unblocked version of the algorithm, calling Level 2 BLAS.
    For more information see Further Details section.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the upper or lower triangular part of the
          Hermitian matrix A is stored: \n
          = 'U':  Upper triangular \n
          = 'L':  Lower triangular \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is COMPLEX array, dimension (LDA,N) \n
          On entry, the Hermitian matrix A. \n
            If UPLO = 'U': the leading N-by-N upper triangular part
            of A contains the upper triangular part of the matrix A,
            and the strictly lower triangular part of A is not
            referenced. \n
 \n
            If UPLO = 'L': the leading N-by-N lower triangular part
            of A contains the lower triangular part of the matrix A,
            and the strictly upper triangular part of A is not
            referenced. \n
 \n
          On exit, contains: \n
            a) ONLY diagonal elements of the Hermitian block diagonal
               matrix D on the diagonal of A, i.e. D(k,k) = A(k,k);
               (superdiagonal (or subdiagonal) elements of D
                are stored on exit in array E), and \n
            b) If UPLO = 'U': factor U in the superdiagonal part of A.
               If UPLO = 'L': factor L in the subdiagonal part of A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] E
          E is COMPLEX array, dimension (N) \n
          On exit, contains the superdiagonal (or subdiagonal)
          elements of the Hermitian block diagonal matrix D
          with 1-by-1 or 2-by-2 diagonal blocks, where
          If UPLO = 'U': E(i) = D(i-1,i), i=2:N, E(1) is set to 0;
          If UPLO = 'L': E(i) = D(i+1,i), i=1:N-1, E(N) is set to 0. \n
 \n
          NOTE: For 1-by-1 diagonal block D(k), where
          1 <= k <= N, the element E(k) is set to 0 in both
          UPLO = 'U' or UPLO = 'L' cases. \n
 * @param[out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          IPIV describes the permutation matrix P in the factorization
          of matrix A as follows. The absolute value of IPIV(k)
          represents the index of row and column that were
          interchanged with the k-th row and column. The value of UPLO
          describes the order in which the interchanges were applied.
          Also, the sign of IPIV represents the block structure of
          the Hermitian block diagonal matrix D with 1-by-1 or 2-by-2
          diagonal blocks which correspond to 1 or 2 interchanges
          at each factorization step. For more info see Further
          Details section. \n
 \n
          If UPLO = 'U',
          (in factorization order, k decreases from N to 1): \n
            a) A single positive entry IPIV(k) > 0 means:
               D(k,k) is a 1-by-1 diagonal block.
               If IPIV(k) != k, rows and columns k and IPIV(k) were
               interchanged in the matrix A(1:N,1:N);
               If IPIV(k) = k, no interchange occurred. \n
 \n
            b) A pair of consecutive negative entries
               IPIV(k) < 0 and IPIV(k-1) < 0 means:
               D(k-1:k,k-1:k) is a 2-by-2 diagonal block.
               (NOTE: negative entries in IPIV appear ONLY in pairs). \n
               1) If -IPIV(k) != k, rows and columns
                  k and -IPIV(k) were interchanged
                  in the matrix A(1:N,1:N).
                  If -IPIV(k) = k, no interchange occurred. \n
               2) If -IPIV(k-1) != k-1, rows and columns
                  k-1 and -IPIV(k-1) were interchanged
                  in the matrix A(1:N,1:N).
                  If -IPIV(k-1) = k-1, no interchange occurred. \n
 \n
            c) In both cases a) and b), always ABS(IPIV(k)) <= k. \n
 \n
            d) NOTE: Any entry IPIV(k) is always NONZERO on output. \n
 \n
          If UPLO = 'L',
          (in factorization order, k increases from 1 to N): \n
            a) A single positive entry IPIV(k) > 0 means:
               D(k,k) is a 1-by-1 diagonal block.
               If IPIV(k) != k, rows and columns k and IPIV(k) were
               interchanged in the matrix A(1:N,1:N).
               If IPIV(k) = k, no interchange occurred. \n
 \n
            b) A pair of consecutive negative entries
               IPIV(k) < 0 and IPIV(k+1) < 0 means:
               D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
               (NOTE: negative entries in IPIV appear ONLY in pairs). \n
               1) If -IPIV(k) != k, rows and columns
                  k and -IPIV(k) were interchanged
                  in the matrix A(1:N,1:N).
                  If -IPIV(k) = k, no interchange occurred. \n
               2) If -IPIV(k+1) != k+1, rows and columns
                  k-1 and -IPIV(k-1) were interchanged
                  in the matrix A(1:N,1:N).
                  If -IPIV(k+1) = k+1, no interchange occurred. \n
 \n
            c) In both cases a) and b), always ABS(IPIV(k)) >= k. \n
 \n
            d) NOTE: Any entry IPIV(k) is always NONZERO on output. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: If INFO = -k, the k-th argument had an illegal value \n
          > 0: If INFO = k, the matrix A is singular, because: \n
                 If UPLO = 'U': column k in the upper
                 triangular part of A contains all zeros. \n
                 If UPLO = 'L': column k in the lower
                 triangular part of A contains all zeros. \n
 \n
               Therefore D(k,k) is exactly zero, and superdiagonal
               elements of column k of U (or subdiagonal elements of
               column k of L) are all zeros. The factorization has
               been completed, but the block diagonal matrix D is
               exactly singular, and division by zero will occur if
               it is used to solve a system of equations. \n
 \n
               NOTE: INFO only stores the first occurrence of
               a singularity, any subsequent occurrence of singularity
               is not stored in INFO even though the factorization
               always completes. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer hetf2_rk(char *uplo, integer *n, T *a, integer *lda, T *e, integer *ipiv, integer *info)
{
  return hetf2_rk(uplo, n, a, lda, e, ipiv, info); 
}

/*! @brief HETF2_ROOK computes the factorization of a complex Hermitian indefinite matrix \n
     using the bounded Bunch-Kaufman ("rook") diagonal pivoting method (unblocked algorithm).
 * @details
 * \b Purpose:
    \verbatim 
    HETF2_ROOK computes the factorization of a complex Hermitian matrix A
    using the bounded Bunch-Kaufman ("rook") diagonal pivoting method:

       A = U*D*U**H  or  A = L*D*L**H

    where U (or L) is a product of permutation and unit upper (lower)
    triangular matrices, U**H is the conjugate transpose of U, and D is
    Hermitian and block diagonal with 1-by-1 and 2-by-2 diagonal blocks.

    This is the unblocked version of the algorithm, calling Level 2 BLAS.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the upper or lower triangular part of the
          Hermitian matrix A is stored: \n
          = 'U':  Upper triangular \n
          = 'L':  Lower triangular \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is COMPLEX array, dimension (LDA,N) \n
          On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
          n-by-n upper triangular part of A contains the upper
          triangular part of the matrix A, and the strictly lower
          triangular part of A is not referenced.  If UPLO = 'L', the
          leading n-by-n lower triangular part of A contains the lower
          triangular part of the matrix A, and the strictly upper
          triangular part of A is not referenced. \n
 \n
          On exit, the block diagonal matrix D and the multipliers used
          to obtain the factor U or L (see below for further details). \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D. \n
 \n
          If UPLO = 'U': \n
             If IPIV(k) > 0, then rows and columns k and IPIV(k) were
             interchanged and D(k,k) is a 1-by-1 diagonal block. \n
 \n
             If IPIV(k) < 0 and IPIV(k-1) < 0, then rows and
             columns k and -IPIV(k) were interchanged and rows and
             columns k-1 and -IPIV(k-1) were inerchaged,
             D(k-1:k,k-1:k) is a 2-by-2 diagonal block. \n
 \n
          If UPLO = 'L': \n
             If IPIV(k) > 0, then rows and columns k and IPIV(k)
             were interchanged and D(k,k) is a 1-by-1 diagonal block. \n
 \n
             If IPIV(k) < 0 and IPIV(k+1) < 0, then rows and
             columns k and -IPIV(k) were interchanged and rows and
             columns k+1 and -IPIV(k+1) were inerchaged,
             D(k:k+1,k:k+1) is a 2-by-2 diagonal block. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -k, the k-th argument had an illegal value \n
          > 0: if INFO = k, D(k,k) is exactly zero.  The factorization
               has been completed, but the block diagonal matrix D is
               exactly singular, and division by zero will occur if it
               is used to solve a system of equations. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer hetf2_rook(char *uplo, integer *n, T *a, integer *lda, integer *ipiv, integer *info)
{
  return hetf2_rook(uplo, n, a, lda, ipiv, info); 
}

/*! @brief HETRD_2STAGE reduces a complex Hermitian matrix A to real symmetric \n
     tridiagonal form T 
 * @details
 * \b Purpose:
    \verbatim 
    HETRD_2STAGE reduces a complex Hermitian matrix A to real symmetric
    tridiagonal form T by a unitary similarity transformation:
    Q1**H Q2**H* A * Q2 * Q1 = T.
    \endverbatim  

 * @param[in] VECT
          VECT is CHARACTER*1 \n
          = 'N':  No need for the Housholder representation, 
                  in particular for the second stage (Band to
                  tridiagonal) and thus LHOUS2 is of size max(1, 4*N); \n
          = 'V':  the Householder representation is needed to 
                  either generate Q1 Q2 or to apply Q1 Q2, 
                  then LHOUS2 is to be queried and computed.
                  (NOT AVAILABLE IN THIS RELEASE). \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is COMPLEX array, dimension (LDA,N) \n
          On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
          N-by-N upper triangular part of A contains the upper
          triangular part of the matrix A, and the strictly lower
          triangular part of A is not referenced.  If UPLO = 'L', the
          leading N-by-N lower triangular part of A contains the lower
          triangular part of the matrix A, and the strictly upper
          triangular part of A is not referenced. \n
          On exit, if UPLO = 'U', the band superdiagonal
          of A are overwritten by the corresponding elements of the
          internal band-diagonal matrix AB, and the elements above 
          the KD superdiagonal, with the array TAU, represent the unitary
          matrix Q1 as a product of elementary reflectors; if UPLO
          = 'L', the diagonal and band subdiagonal of A are over-
          written by the corresponding elements of the internal band-diagonal
          matrix AB, and the elements below the KD subdiagonal, with
          the array TAU, represent the unitary matrix Q1 as a product
          of elementary reflectors. See Further Details. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] D
          D is REAL array, dimension (N) \n
          The diagonal elements of the tridiagonal matrix T. \n
 * @param[out] E
          E is REAL array, dimension (N-1) \n
          The off-diagonal elements of the tridiagonal matrix T. \n
 * @param[out] TAU
          TAU is COMPLEX array, dimension (N-KD) \n
          The scalar factors of the elementary reflectors of 
          the first stage (see Further Details). \n
 * @param[out] HOUS2
          HOUS2 is COMPLEX array, dimension (LHOUS2) \n
          Stores the Householder representation of the stage2
          band to tridiagonal. \n
 * @param[in] LHOUS2
          LHOUS2 is INTEGER \n
          The dimension of the array HOUS2. \n
          If LWORK = -1, or LHOUS2=-1,
          then a query is assumed; the routine
          only calculates the optimal size of the HOUS2 array,   returns
          this value as the first entry of the HOUS2 array, and no error
          message related to LHOUS2 is issued by XERBLA. \n
          If VECT='N', LHOUS2 = max(1, 4*n); \n
          if VECT='V', option not yet available. \n
 * @param[out] WORK
          WORK is COMPLEX array, dimension (LWORK) \n
 * @param[in] LWORK
          LWORK is INTEGER \n
          The dimension of the array WORK. LWORK = MAX(1, dimension) \n
          If LWORK = -1, or LHOUS2 = -1,
          then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array,   returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA.
          LWORK = MAX(1, dimension) where \n
          dimension   = max(stage1,stage2) + (KD+1)*N \n
                      = N*KD + N*max(KD+1,FACTOPTNB)  \n
                        + max(2*KD*KD, KD*NTHREADS)  \n
                        + (KD+1)*N  \n
          where KD is the blocking size of the reduction,
          FACTOPTNB is the blocking used by the QR or LQ
          algorithm, usually FACTOPTNB=128 is a good choice
          NTHREADS is the number of threads used when
          openMP compilation is enabled, otherwise =1. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T, typename Ta >
integer hetrd_2stage(char *vect, char *uplo, integer *n, T *a, integer *lda, Ta *d, Ta *e, T *tau, T *hous2, integer *lhous2, T *work, integer *lwork, integer *info)
{
  return hetrd_2stage(vect, uplo, n, a, lda, d, e, tau, hous2, lhous2, work, lwork, info);   
}

/*! @brief HBTRD_HB2ST reduces a complex Hermitian band matrix A to real symmetric tridiagonal form T

 * @details
 * \b Purpose:
    \verbatim 
    HETRD_HB2ST reduces a complex Hermitian band matrix A to real symmetric
    tridiagonal form T by a unitary similarity transformation:
    Q**H * A * Q = T.
    \endverbatim   

  * @param[in] STAGE1
           STAGE1 is CHARACTER*1 \n
           = 'N':  "No": to mention that the stage 1 of the reduction  
                   from dense to band using the chetrd_he2hb routine
                   was not called before this routine to reproduce AB. 
                   In other term this routine is called as standalone.  \n
           = 'Y':  "Yes": to mention that the stage 1 of the 
                   reduction from dense to band using the chetrd_he2hb 
                   routine has been called to produce AB (e.g., AB is
                   the output of chetrd_he2hb. \n
  * @param[in] VECT
           VECT is CHARACTER*1 \n
           = 'N':  No need for the Housholder representation, 
                   and thus LHOUS is of size max(1, 4*N); \n
           = 'V':  the Householder representation is needed to 
                   either generate or to apply Q later on, 
                   then LHOUS is to be queried and computed.
                   (NOT AVAILABLE IN THIS RELEASE). \n
  * @param[in] UPLO
           UPLO is CHARACTER*1 \n
           = 'U':  Upper triangle of A is stored; \n
           = 'L':  Lower triangle of A is stored. \n
  * @param[in] N
           N is INTEGER \n
           The order of the matrix A.  N >= 0. \n
  * @param[in] KD
           KD is INTEGER \n
           The number of superdiagonals of the matrix A if UPLO = 'U',
           or the number of subdiagonals if UPLO = 'L'.  KD >= 0. \n
  * @param[in,out] AB
           AB is COMPLEX array, dimension (LDAB,N) \n
           On entry, the upper or lower triangle of the Hermitian band
           matrix A, stored in the first KD+1 rows of the array.  The
           j-th column of A is stored in the j-th column of the array AB
           as follows: \n
           if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j; \n
           if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd). \n \n
           On exit, the diagonal elements of AB are overwritten by the
           diagonal elements of the tridiagonal matrix T; if KD > 0, the
           elements on the first superdiagonal (if UPLO = 'U') or the
           first subdiagonal (if UPLO = 'L') are overwritten by the
           off-diagonal elements of T; the rest of AB is overwritten by
           values generated during the reduction. \n
  * @param[in] LDAB
           LDAB is INTEGER \n
           The leading dimension of the array AB.  LDAB >= KD+1. \n
  * @param[out] D
           D is REAL array, dimension (N) \n
           The diagonal elements of the tridiagonal matrix T. \n
  * @param[out] E
           E is REAL array, dimension (N-1) \n
           The off-diagonal elements of the tridiagonal matrix T:
           E(i) = T(i,i+1) if UPLO = 'U'; E(i) = T(i+1,i) if UPLO = 'L'. \n
  * @param[out] HOUS
           HOUS is COMPLEX array, dimension LHOUS, that
           store the Householder representation. \n
  * @param[in] LHOUS
           LHOUS is INTEGER \n
           The dimension of the array HOUS. LHOUS = MAX(1, dimension) \n
           If LWORK = -1, or LHOUS=-1,
           then a query is assumed; the routine
           only calculates the optimal size of the HOUS array,   returns
           this value as the first entry of the HOUS array, and no error
           message related to LHOUS is issued by XERBLA. \n
           LHOUS = MAX(1, dimension) where \n
           dimension = 4*N if VECT='N' \n
           not available now if VECT='H' \n
  * @param[out] WORK
           WORK is COMPLEX array, dimension LWORK. \n
  * @param[in] LWORK
           LWORK is INTEGER \n
           The dimension of the array WORK. LWORK = MAX(1, dimension) \n
           If LWORK = -1, or LHOUS=-1,
           then a workspace query is assumed; the routine
           only calculates the optimal size of the WORK array,   returns
           this value as the first entry of the WORK array, and no error
           message related to LWORK is issued by XERBLA.
           LWORK = MAX(1, dimension) where \n
           dimension   = (2KD+1)*N + KD*NTHREADS \n
           where KD is the blocking size of the reduction,
           FACTOPTNB is the blocking used by the QR or LQ
           algorithm, usually FACTOPTNB=128 is a good choice
           NTHREADS is the number of threads used when
           openMP compilation is enabled, otherwise =1. \n
  * @param[out] INFO
           INFO is INTEGER \n
           = 0:  successful exit \n
           < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T, typename Ta >
integer hetrd_hb2st(char *stage1, char *vect, char *uplo, integer *n, integer *kd, T *ab, integer *ldab, Ta *d, Ta * e, T *hous, integer *lhous, T *work, integer *lwork, integer *info)
{
  return hetrd_hb2st(stage1, vect, uplo, n, kd, ab, ldab, d, e, hous, lhous, work, lwork, info);
}

/*! @brief HETRD_HE2HB reduces a complex Hermitian matrix A to complex Hermitian band-diagonal form AB

 * @details
 * \b Purpose:
    \verbatim 
    HETRD_HE2HB reduces a complex Hermitian matrix A to complex Hermitian
    band-diagonal form AB by a unitary similarity transformation:
    Q**H * A * Q = AB.
    \endverbatim
    
  * @param[in] UPLO
           UPLO is CHARACTER*1 \n
           = 'U':  Upper triangle of A is stored; \n
           = 'L':  Lower triangle of A is stored. \n
  * @param[in] N
           N is INTEGER \n
           The order of the matrix A.  N >= 0. \n
  * @param[in] KD
           KD is INTEGER \n
           The number of superdiagonals of the reduced matrix if UPLO = 'U',
           or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
           The reduced matrix is stored in the array AB. \n
  * @param[in,out] A
           A is COMPLEX array, dimension (LDA,N) \n
           On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
           N-by-N upper triangular part of A contains the upper
           triangular part of the matrix A, and the strictly lower
           triangular part of A is not referenced.  If UPLO = 'L', the
           leading N-by-N lower triangular part of A contains the lower
           triangular part of the matrix A, and the strictly upper
           triangular part of A is not referenced. \n \n
           On exit, if UPLO = 'U', the diagonal and first superdiagonal
           of A are overwritten by the corresponding elements of the
           tridiagonal matrix T, and the elements above the first
           superdiagonal, with the array TAU, represent the unitary
           matrix Q as a product of elementary reflectors; if UPLO
           = 'L', the diagonal and first subdiagonal of A are over-
           written by the corresponding elements of the tridiagonal
           matrix T, and the elements below the first subdiagonal, with
           the array TAU, represent the unitary matrix Q as a product
           of elementary reflectors. See Further Details. \n
  * @param[in] LDA
           LDA is INTEGER \n
           The leading dimension of the array A.  LDA >= max(1,N). \n
  * @param[out] AB
           AB is COMPLEX array, dimension (LDAB,N) \n
           On exit, the upper or lower triangle of the Hermitian band
           matrix A, stored in the first KD+1 rows of the array.  The
           j-th column of A is stored in the j-th column of the array AB
           as follows: \n
           if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j; \n
           if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd). \n
  * @param[in] LDAB
           LDAB is INTEGER \n
           The leading dimension of the array AB.  LDAB >= KD+1. \n
  * @param[out] TAU
           TAU is COMPLEX array, dimension (N-KD) \n
           The scalar factors of the elementary reflectors (see Further
           Details). \n
  * @param[out] WORK
           WORK is COMPLEX array, dimension (LWORK) \n
           On exit, if INFO = 0, or if LWORK=-1, 
           WORK(1)   returns the size of LWORK. \n
  * @param[in] LWORK
           LWORK is INTEGER \n
           The dimension of the array WORK which should be calculated
           by a workspace query. LWORK = MAX(1, LWORK_QUERY) \n
           If LWORK = -1, then a workspace query is assumed; the routine
           only calculates the optimal size of the WORK array,   returns
           this value as the first entry of the WORK array, and no error
           message related to LWORK is issued by XERBLA. \n
           LWORK_QUERY = N*KD + N*max(KD,FACTOPTNB) + 2*KD*KD \n
           where FACTOPTNB is the blocking used by the QR or LQ
           algorithm, usually FACTOPTNB=128 is a good choice otherwise
           putting LWORK=-1 will provide the size of WORK. \n
  * @param[out] INFO
           INFO is INTEGER \n
           = 0:  successful exit \n
           < 0:  if INFO = -i, the i-th argument had an illegal value  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer hetrd_he2hb(char *uplo, integer *n, integer *kd, T *a, integer *lda, T *ab, integer *ldab, T *tau, T *work, integer *lwork, integer *info)
{
  return hetrd_he2hb(uplo, n, kd, a, lda, ab, ldab, tau, work, lwork, info);
}

/*! @brief HETRI_3X computes the inverse of a complex Hermitian indefinite matrix A

 * @details
 * \b Purpose:
    \verbatim 
    HETRI_3X computes the inverse of a complex Hermitian indefinite
    matrix A using the factorization computed by CHETRF_RK or CHETRF_BK:

        A = P*U*D*(U**H)*(P**T) or A = P*L*D*(L**H)*(P**T),

    where U (or L) is unit upper (or lower) triangular matrix,
    U**H (or L**H) is the conjugate of U (or L), P is a permutation
    matrix, P**T is the transpose of P, and D is Hermitian and block
    diagonal with 1-by-1 and 2-by-2 diagonal blocks.

    This is the blocked version of the algorithm, calling Level 3 BLAS.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the details of the factorization are
          stored as an upper or lower triangular matrix. \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is COMPLEX array, dimension (LDA,N) \n
          On entry, diagonal of the block diagonal matrix D and
          factors U or L as computed by CHETRF_RK and CHETRF_BK: \n
            a) ONLY diagonal elements of the Hermitian block diagonal
               matrix D on the diagonal of A, i.e. D(k,k) = A(k,k);
               (superdiagonal (or subdiagonal) elements of D
                should be provided on entry in array E), and \n
            b) If UPLO = 'U': factor U in the superdiagonal part of A.
               If UPLO = 'L': factor L in the subdiagonal part of A. \n
 \n
          On exit, if INFO = 0, the Hermitian inverse of the original
          matrix. \n
             If UPLO = 'U': the upper triangular part of the inverse
             is formed and the part of A below the diagonal is not
             referenced; \n
             If UPLO = 'L': the lower triangular part of the inverse
             is formed and the part of A above the diagonal is not
             referenced. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] E
          E is COMPLEX array, dimension (N) \n
          On entry, contains the superdiagonal (or subdiagonal)
          elements of the Hermitian block diagonal matrix D
          with 1-by-1 or 2-by-2 diagonal blocks, where \n
          If UPLO = 'U': E(i) = D(i-1,i), i=2:N, E(1) not referenced; \n
          If UPLO = 'L': E(i) = D(i+1,i), i=1:N-1, E(N) not referenced. \n
 \n
          NOTE: For 1-by-1 diagonal block D(k), where
          1 <= k <= N, the element E(k) is not referenced in both
          UPLO = 'U' or UPLO = 'L' cases. \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D
          as determined by CHETRF_RK or CHETRF_BK. \n
 * @param[out] WORK
          WORK is COMPLEX array, dimension (N+NB+1,NB+3). \n
 * @param[in] NB
          NB is INTEGER \n
          Block size. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n
          > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its
               inverse could not be computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer hetri_3x(char *uplo, integer *n, T *a, integer * lda, T *e, integer *ipiv, T *work, integer *nb, integer * info)
{
  return hetri_3x(uplo, n, a, lda, e, ipiv, work, nb, info);
}

/*! @brief HETRI_ROOK computes the inverse of HE matrix using the factorization \n
     obtained with the bounded Bunch-Kaufman ("rook") diagonal pivoting method

 * @details
 * \b Purpose:
    \verbatim 
    HETRI_ROOK computes the inverse of a complex Hermitian indefinite matrix
    A using the factorization A = U*D*U**H or A = L*D*L**H computed by
    HETRF_ROOK.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the details of the factorization are stored
          as an upper or lower triangular matrix. \n
          = 'U':  Upper triangular, form is A = U*D*U**H; \n
          = 'L':  Lower triangular, form is A = L*D*L**H. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is COMPLEX array, dimension (LDA,N) \n
          On entry, the block diagonal matrix D and the multipliers
          used to obtain the factor U or L as computed by CHETRF_ROOK. \n
 \n
          On exit, if INFO = 0, the (Hermitian) inverse of the original
          matrix.  If UPLO = 'U', the upper triangular part of the
          inverse is formed and the part of A below the diagonal is not
          referenced; if UPLO = 'L' the lower triangular part of the
          inverse is formed and the part of A above the diagonal is
          not referenced. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D
          as determined by CHETRF_ROOK. \n
 * @param[out] WORK
          WORK is COMPLEX array, dimension (N) \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n
          > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its
               inverse could not be computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer hetri_rook(char *uplo, integer *n, T *a, integer * lda, integer *ipiv, T *work, integer * info)
{
  return hetri_rook(uplo, n, a, lda, ipiv, work, info);
}

/*! @brief CHLA_TRANSTYPE subroutine translates from a BLAST-specified integer constant \n
     to the character string specifying a transposition operation

 * @details
 * \b Purpose:
    \verbatim 
    This subroutine translates from a BLAST-specified integer constant to
    the character string specifying a transposition operation.

    CHLA_TRANSTYPE   returns an CHARACTER*1.  If CHLA_TRANSTYPE is 'X',
    then input is not an integer indicating a transposition operator.
    Otherwise CHLA_TRANSTYPE   returns the constant value corresponding to
    TRANS.
    \endverbatim 
 * */
void hla_transtype(char *ret_val, integer *trans)
{
  return chla_transtype_(ret_val, trans);
} 

/*! @brief ISNAN tests input for NaN

 * @details
 * \b Purpose:
    \verbatim 
    ISNAN   returns .TRUE. if its argument is NaN, and .FALSE.
    otherwise.  To be replaced by the Fortran 2003 intrinsic in the
    future.
    \endverbatim 

 * @param[in] SIN
          SIN is REAL \n
          Input to test for NaN. \n
 * */ 
template< typename T >
integer isnan(T *sin)
{
  return isnan(sin);
}

/*! @brief PBTF2 computes the Cholesky factorization of a symmetric/Hermitian  \n
     positive definite band matrix (unblocked algorithm)

 * @details
 * \b Purpose:
    \verbatim 
    PBTF2 computes the Cholesky factorization of a real symmetric
    positive definite band matrix A.

    The factorization has the form
       A = U**T * U , if UPLO = 'U', or
       A = L  * L**T, if UPLO = 'L',
    where U is an upper triangular matrix, U**T is the transpose of U, and
    L is lower triangular.

    This is the unblocked version of the algorithm, calling Level 2 BLAS.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the upper or lower triangular part of the
          symmetric matrix A is stored: \n
          = 'U':  Upper triangular \n
          = 'L':  Lower triangular \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] KD
          KD is INTEGER \n
          The number of super-diagonals of the matrix A if UPLO = 'U',
          or the number of sub-diagonals if UPLO = 'L'.  KD >= 0. \n
 * @param[in,out] AB
          AB is REAL array, dimension (LDAB,N) \n
          On entry, the upper or lower triangle of the symmetric band
          matrix A, stored in the first KD+1 rows of the array.  The
          j-th column of A is stored in the j-th column of the array AB
          as follows: \n
          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j; \n
          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd). \n
 \n
          On exit, if INFO = 0, the triangular factor U or L from the
          Cholesky factorization A = U**T*U or A = L*L**T of the band
          matrix A, in the same storage format as A. \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          The leading dimension of the array AB.  LDAB >= KD+1. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -k, the k-th argument had an illegal value \n
          > 0: if INFO = k, the leading minor of order k is not
               positive definite, and the factorization could not be
               completed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer pbtf2(char *uplo, integer *n, integer *kd, T *ab, integer *ldab, integer *info)
{
  return pbtf2(uplo, n, kd, ab, ldab, info);
}

/*! @brief PSTF2 computes the Cholesky factorization with complete pivoting \n
     of a real symmetric positive semidefinite matrix
 * @details
 * \b Purpose:
    \verbatim 
    PSTF2 computes the Cholesky factorization with complete
    pivoting of a real symmetric positive semidefinite matrix A.

    The factorization has the form
       P**T * A * P = U**T * U , if UPLO = 'U',
       P**T * A * P = L  * L**T, if UPLO = 'L',
    where U is an upper triangular matrix and L is lower triangular, and
    P is stored as vector PIV.

    This algorithm does not attempt to check that A is positive
    semidefinite. This version of the algorithm calls level 2 BLAS.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the upper or lower triangular part of the
          symmetric matrix A is stored. \n
          = 'U':  Upper triangular \n
          = 'L':  Lower triangular \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
          n by n upper triangular part of A contains the upper
          triangular part of the matrix A, and the strictly lower
          triangular part of A is not referenced.  If UPLO = 'L', the
          leading n by n lower triangular part of A contains the lower
          triangular part of the matrix A, and the strictly upper
          triangular part of A is not referenced. \n
 \n
          On exit, if INFO = 0, the factor U or L from the Cholesky
          factorization as above. \n
 * @param[out] PIV
          PIV is INTEGER array, dimension (N) \n
          PIV is such that the nonzero entries are P(PIV(K), K) = 1. \n
 * @param[out] RANK
          RANK is INTEGER \n
          The rank of A given by the number of steps the algorithm
          completed. \n
 * @param[in] TOL
          TOL is REAL \n
          User defined tolerance. If TOL < 0, then N*U*MAX(A(K,K))
          will be used. The algorithm terminates at the (K-1)st step
          if the pivot <= TOL. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] WORK
          WORK is REAL array, dimension (2*N) \n
          Work space. \n
 * @param[out] INFO
          INFO is INTEGER \n
          < 0: If INFO = -K, the K-th argument had an illegal value, \n
          = 0: algorithm completed successfully, and \n
          > 0: the matrix A is either rank deficient with computed rank
               as   returned in RANK, or is not positive semidefinite. See
               Section 7 of LAPACK Working Note #161 for further
               information. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer pstf2(char *uplo, integer *n, T *a, integer *lda, integer *piv, integer *rank, T *tol, T *work, integer *info)
{
  return pstf2(uplo, n, a, lda, piv, rank, tol, work, info);
}
template< typename T, typename Ta >
integer pstf2(char *uplo, integer *n, T *a, integer *lda, integer *piv, integer *rank, Ta *tol, Ta *work, integer *info)
{
  return pstf2(uplo, n, a, lda, piv, rank, tol, work, info);
}

/*! @brief PTTS2 solves a tridiagonal system of the form AX=B using \n
     the L D LH factorization computed by spttrf
 * @details
 * \b Purpose:
    \verbatim 
    PTTS2 solves a tridiagonal system of the form
       A * X = B
    using the L*D*L**T factorization of A computed by SPTTRF.  D is a
    diagonal matrix specified in the vector D, L is a unit bidiagonal
    matrix whose subdiagonal is specified in the vector E, and X and B
    are N by NRHS matrices.
    \endverbatim  

 * @param[in] N
          N is INTEGER \n
          The order of the tridiagonal matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in] D
          D is REAL array, dimension (N) \n
          The n diagonal elements of the diagonal matrix D from the
          L*D*L**T factorization of A. \n
 * @param[in] E
          E is REAL array, dimension (N-1) \n
          The (n-1) subdiagonal elements of the unit bidiagonal factor
          L from the L*D*L**T factorization of A.  E can also be regarded
          as the superdiagonal of the unit bidiagonal factor U from the
          factorization A = U**T*D*U. \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,NRHS) \n
          On entry, the right hand side vectors B for the system of
          linear equations. \n
          On exit, the solution vectors, X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer ptts2(integer *n, integer *nrhs, T *d, T *e, T *b, integer *ldb)
{
  return ptts2(n, nrhs, d, e, b, ldb);
}
template< typename T, typename Ta >
integer ptts2(integer* iuplo, integer *n, integer *nrhs, Ta *d, T *e, T *b, integer *ldb)
{
  return ptts2(iuplo, n, nrhs, d, e, b, ldb);
}

/*! @brief ROT applies a plane rotation with real cosine and complex sine to a pair of complex vectors

 * @details
 * \b Purpose:
    \verbatim 
    ROT   applies a plane rotation, where the cos (C) is real and the
    sin (S) is complex, and the vectors CX and CY are complex.
    \endverbatim  

 * @param[in] N
          N is INTEGER \n
          The number of elements in the vectors CX and CY. \n
 * @param[in,out] CX
          CX is COMPLEX array, dimension (N) \n
          On input, the vector X.
          On output, CX is overwritten with C*X + S*Y. \n
 * @param[in] INCX
          INCX is INTEGER \n
          The increment between successive values of CY.  INCX <> 0. \n
 * @param[in,out] CY
          CY is COMPLEX array, dimension (N) \n
          On input, the vector Y.
          On output, CY is overwritten with -CONJG(S)*X + C*Y. \n
 * @param[in] INCY
          INCY is INTEGER \n
          The increment between successive values of CY.  INCX <> 0. \n
 * @param[in] C
          C is REAL \n
 * @param[in] S
          S is COMPLEX \n
          C and S define a rotation \n
             [  C          S  ] \n
             [ -conjg(S)   C  ] \n
          where C*C + S*CONJG(S) = 1.0. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T, typename Ta >
integer rot(integer *n, T *cx, integer *incx, T * cy, integer *incy, Ta *c, T *s)
{
  return rot(n, cx, incx, cy, incy, c, s);
}

/*! @brief RSCL multiplies a vector by the reciprocal of a real scalar

 * @details
 * \b Purpose:
    \verbatim 
    RSCL multiplies an n-element real vector x by the real scalar 1/a.
    This is done without overflow or underflow as long as
    the final result x/a does not overflow or underflow.
    \endverbatim 

 * @param[in] N
          N is INTEGER \n
          The number of components of the vector x. \n
 * @param[in] SA
          SA is REAL \n
          The scalar a which is used to divide each component of x.
          SA must be >= 0, or the subroutine will divide by zero. \n
 * @param[in,out] SX
          SX is REAL array, dimension
                         (1+(N-1)*abs(INCX)) \n
          The n-element vector x. \n
 * @param[in] INCX
          INCX is INTEGER \n
          The increment between successive values of the vector SX. \n
          > 0:  SX(1) = X(1) and SX(1+(i-1)*INCX) = x(i),    1< i<= n \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer rscl(integer *n, T *sa, T *sx, integer *incx)
{
  return rscl(n, sa, sx, incx);
}
template< typename T, typename Ta >
integer rscl(integer *n, Ta *sa, T *sx, integer *incx)
{
  return rscl(n, sa, sx, incx);
}

/*! @brief SB2ST_KERNELS is an internal routine used by the SYTRD_SB2ST subroutine

 * @details
 * \b Purpose:
    \verbatim 
    SB2ST_KERNELS is an internal routine used by the SYTRD_SB2ST
    subroutine.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
 * @param[in] WANTZ
          WANTZ is LOGICAL which indicate if Eigenvalue are requested or both
          Eigenvalue/Eigenvectors. \n
 * @param[in] TTYPE
          TTYPE is INTEGER \n
 * @param[in] ST
          ST is INTEGER \n
          internal parameter for indices. \n
 * @param[in] ED
          ED is INTEGER \n
          internal parameter for indices. \n
 * @param[in] SWEEP
          SWEEP is INTEGER \n
          internal parameter for indices. \n
 * @param[in] N
          N is INTEGER. The order of the matrix A. \n
 * @param[in] NB
          NB is INTEGER. The size of the band. \n
 * @param[in] IB
          IB is INTEGER. \n
 * @param[in, out] A
          A is REAL array. A pointer to the matrix A. \n
 * @param[in] LDA
          LDA is INTEGER. The leading dimension of the matrix A. \n
 * @param[out] V
          V is REAL array, dimension 2*n if eigenvalues only are
          requested or to be queried for vectors. \n
 * @param[out] TAU
          TAU is REAL array, dimension (2*n). \n
          The scalar factors of the Householder reflectors are stored
          in this array. \n
 * @param[in] LDVT
          LDVT is INTEGER. \n
 * @param[out] WORK
          WORK is REAL array. Workspace of size nb. \n

 * @return INTEGER Return value of the function.
 * */         
template< typename T >
integer sb2st_kernels(char *uplo, logical *wantz, integer * ttype, integer *st, integer *ed, integer *sweep, integer *n, integer * nb, integer *ib, T *a, integer *lda, T *v, T *tau, integer *ldvt, T *work)
{
  return sb2st_kernels(uplo, wantz, ttype, st, ed, sweep, n, nb, ib, a, lda, v, tau, ldvt, work);
}

/*! @brief SPMV computes a matrix-vector product for complex vectors using a complex symmetric packed matrix

 * @details
 * \b Purpose:
    \verbatim 
    SPMV  performs the matrix-vector operation

       y := alpha*A*x + beta*y,

    where alpha and beta are scalars, x and y are n element vectors and
    A is an n by n symmetric matrix, supplied in packed form.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          On entry, UPLO specifies whether the upper or lower
          triangular part of the matrix A is supplied in the packed
          array AP as follows: \n
            UPLO = 'U' or 'u'   The upper triangular part of A is
                                supplied in AP. \n
            UPLO = 'L' or 'l'   The lower triangular part of A is
                                supplied in AP. \n
          Unchanged on exit. \n
 * @param[in] N
          N is INTEGER \n
          On entry, N specifies the order of the matrix A.
          N must be at least zero.
          Unchanged on exit. \n
 * @param[in] ALPHA
          ALPHA is COMPLEX \n
          On entry, ALPHA specifies the scalar alpha.
          Unchanged on exit. \n
 * @param[in] AP
          AP is COMPLEX array, dimension at least
          ((N*(N + 1))/2). \n
          Before entry, with UPLO = 'U' or 'u', the array AP must
          contain the upper triangular part of the symmetric matrix
          packed sequentially, column by column, so that AP(1)
          contains a(1, 1), AP(2) and AP(3) contain a(1, 2)
          and a(2, 2) respectively, and so on. \n
          Before entry, with UPLO = 'L' or 'l', the array AP must
          contain the lower triangular part of the symmetric matrix
          packed sequentially, column by column, so that AP(1)
          contains a(1, 1), AP(2) and AP(3) contain a(2, 1)
          and a(3, 1) respectively, and so on. \n
          Unchanged on exit. \n
 * @param[in] X
          X is COMPLEX array, dimension at least
          (1 + (N - 1)*abs(INCX)). \n
          Before entry, the incremented array X must contain the N-
          element vector x. \n
          Unchanged on exit. \n
 * @param[in] INCX
          INCX is INTEGER \n
          On entry, INCX specifies the increment for the elements of
          X. INCX must not be zero. \n
          Unchanged on exit. \n
 * @param[in] BETA
          BETA is COMPLEX \n
          On entry, BETA specifies the scalar beta. When BETA is
          supplied as zero then Y need not be set on input. \n
          Unchanged on exit. \n
 * @param[in,out] Y
          Y is COMPLEX array, dimension at least
          (1 + (N - 1)*abs(INCY)). \n
          Before entry, the incremented array Y must contain the n
          element vector y. On exit, Y is overwritten by the updated
          vector y. \n
 * @param[in] INCY
          INCY is INTEGER \n
          On entry, INCY specifies the increment for the elements of
          Y. INCY must not be zero. \n
          Unchanged on exit. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer spmv(char *uplo, integer *n, T *alpha, T *ap, T *x, integer *incx, T *beta, T *y, integer * incy)
{
  return spmv(uplo, n, alpha, ap, x, incx, beta, y, incy);
}

/*! @brief SPR performs the symmetrical rank-1 update of a complex symmetric packed matrix

 * @details
 * \b Purpose:
    \verbatim 
    SPR performs the symmetric rank 1 operation

       A := alpha*x*x**H + A,

    where alpha is a complex scalar, x is an n element vector and A is an
    n by n symmetric matrix, supplied in packed form.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          On entry, UPLO specifies whether the upper or lower
          triangular part of the matrix A is supplied in the packed
          array AP as follows: \n
              UPLO = 'U' or 'u'   The upper triangular part of A is
                                  supplied in AP. \n
              UPLO = 'L' or 'l'   The lower triangular part of A is
                                  supplied in AP. \n
          Unchanged on exit. \n
 * @param[in] N
          N is INTEGER \n
          On entry, N specifies the order of the matrix A.
          N must be at least zero. \n
          Unchanged on exit. \n
 * @param[in] ALPHA
          ALPHA is COMPLEX \n
          On entry, ALPHA specifies the scalar alpha.
          Unchanged on exit. \n
 * @param[in] X
          X is COMPLEX array, dimension at least
          (1 + (N - 1)*abs(INCX)). \n
          Before entry, the incremented array X must contain the N-
          element vector x. \n
          Unchanged on exit. \n
 * @param[in] INCX
          INCX is INTEGER \n
          On entry, INCX specifies the increment for the elements of
          X. INCX must not be zero. \n
          Unchanged on exit. \n
 * @param[in,out] AP
          AP is COMPLEX array, dimension at least
          ((N*(N + 1))/2). \n
          Before entry, with  UPLO = 'U' or 'u', the array AP must
          contain the upper triangular part of the symmetric matrix
          packed sequentially, column by column, so that AP(1)
          contains a(1, 1), AP(2) and AP(3) contain a(1, 2)
          and a(2, 2) respectively, and so on. On exit, the array
          AP is overwritten by the upper triangular part of the
          updated matrix. \n
          Before entry, with UPLO = 'L' or 'l', the array AP must
          contain the lower triangular part of the symmetric matrix
          packed sequentially, column by column, so that AP(1)
          contains a(1, 1), AP(2) and AP(3) contain a(2, 1)
          and a(3, 1) respectively, and so on. On exit, the array
          AP is overwritten by the lower triangular part of the
          updated matrix. \n
          Note that the imaginary parts of the diagonal elements need
          not be set, they are assumed to be zero, and on exit they
          are set to zero. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer spr(char *uplo, integer *n, T *alpha, T *x, integer *incx, T *ap)
{
  return spr(uplo, n, alpha, x, incx, ap);
}

/*! @brief SYMV computes a matrix-vector product for a complex symmetric matrix

 * @details
 * \b Purpose:
    \verbatim 
    SYMV  performs the matrix-vector  operation

       y := alpha*A*x + beta*y,

    where alpha and beta are scalars, x and y are n element vectors and
    A is an n by n symmetric matrix.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          On entry, UPLO specifies whether the upper or lower
          triangular part of the array A is to be referenced as
          follows: \n
              UPLO = 'U' or 'u'   Only the upper triangular part of A
                                  is to be referenced. \n
              UPLO = 'L' or 'l'   Only the lower triangular part of A
                                  is to be referenced. \n
          Unchanged on exit. \n
 * @param[in] N
          N is INTEGER \n
          On entry, N specifies the order of the matrix A.
          N must be at least zero. \n
          Unchanged on exit. \n
 * @param[in] ALPHA
          ALPHA is COMPLEX \n
          On entry, ALPHA specifies the scalar alpha.
          Unchanged on exit. \n
 * @param[in] A
          A is COMPLEX array, dimension (LDA, N) \n
          Before entry, with  UPLO = 'U' or 'u', the leading n by n
          upper triangular part of the array A must contain the upper
          triangular part of the symmetric matrix and the strictly
          lower triangular part of A is not referenced.
          Before entry, with UPLO = 'L' or 'l', the leading n by n
          lower triangular part of the array A must contain the lower
          triangular part of the symmetric matrix and the strictly
          upper triangular part of A is not referenced. \n
          Unchanged on exit. \n
 * @param[in] LDA
          LDA is INTEGER \n
          On entry, LDA specifies the first dimension of A as declared
          in the calling (sub) program. LDA must be at least
          max(1, N). \n
          Unchanged on exit. \n
 * @param[in] X
          X is COMPLEX array, dimension at least
          (1 + (N - 1)*abs(INCX)). \n
          Before entry, the incremented array X must contain the N-
          element vector x.
          Unchanged on exit. \n
 * @param[in] INCX
          INCX is INTEGER \n
          On entry, INCX specifies the increment for the elements of
          X. INCX must not be zero. \n
          Unchanged on exit. \n
 * @param[in] BETA
          BETA is COMPLEX \n
          On entry, BETA specifies the scalar beta. When BETA is
          supplied as zero then Y need not be set on input. \n
          Unchanged on exit. \n
 * @param[in,out] Y
          Y is COMPLEX array, dimension at least
          (1 + (N - 1)*abs(INCY)). \n
          Before entry, the incremented array Y must contain the n
          element vector y. On exit, Y is overwritten by the updated
          vector y. \n
 * @param[in] INCY
          INCY is INTEGER \n
          On entry, INCY specifies the increment for the elements of
          Y. INCY must not be zero. \n
          Unchanged on exit.  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer symv(char *uplo, integer *n, T *alpha, T * a, integer *lda, T *x, integer *incx, T *beta, T *y, integer *incy)
{
  return symv(uplo, n, alpha, a, lda, x, incx, beta, y, incy); 
}

/*! @brief SYTRD_2STAGE reduces a real symmetric matrix A to real symmetric tridiagonal form T

 * @details
 * \b Purpose:
    \verbatim 
    SYTRD_2STAGE reduces a real symmetric matrix A to real symmetric
    tridiagonal form T by a orthogonal similarity transformation:
    Q1**T Q2**T* A * Q2 * Q1 = T.
    \endverbatim  

 * @param[in] VECT
          VECT is CHARACTER*1 \n
          = 'N':  No need for the Housholder representation, 
                  in particular for the second stage (Band to
                  tridiagonal) and thus LHOUS2 is of size max(1, 4*N); \n
          = 'V':  the Householder representation is needed to 
                  either generate Q1 Q2 or to apply Q1 Q2, 
                  then LHOUS2 is to be queried and computed.
                  (NOT AVAILABLE IN THIS RELEASE). \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
          N-by-N upper triangular part of A contains the upper
          triangular part of the matrix A, and the strictly lower
          triangular part of A is not referenced.  If UPLO = 'L', the
          leading N-by-N lower triangular part of A contains the lower
          triangular part of the matrix A, and the strictly upper
          triangular part of A is not referenced. \n \n
          On exit, if UPLO = 'U', the band superdiagonal
          of A are overwritten by the corresponding elements of the
          internal band-diagonal matrix AB, and the elements above 
          the KD superdiagonal, with the array TAU, represent the orthogonal
          matrix Q1 as a product of elementary reflectors; if UPLO
          = 'L', the diagonal and band subdiagonal of A are over-
          written by the corresponding elements of the internal band-diagonal
          matrix AB, and the elements below the KD subdiagonal, with
          the array TAU, represent the orthogonal matrix Q1 as a product
          of elementary reflectors. See Further Details. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] D
          D is REAL array, dimension (N) \n
          The diagonal elements of the tridiagonal matrix T. \n
 * @param[out] E
          E is REAL array, dimension (N-1) \n
          The off-diagonal elements of the tridiagonal matrix T. \n
 * @param[out] TAU
          TAU is REAL array, dimension (N-KD) \n
          The scalar factors of the elementary reflectors of 
          the first stage (see Further Details). \n
 * @param[out] HOUS2
          HOUS2 is REAL array, dimension (LHOUS2) \n
          Stores the Householder representation of the stage2
          band to tridiagonal. \n
 * @param[in] LHOUS2
          LHOUS2 is INTEGER \n
          The dimension of the array HOUS2.
          If LWORK = -1, or LHOUS2 = -1,
          then a query is assumed; the routine
          only calculates the optimal size of the HOUS2 array, returns
          this value as the first entry of the HOUS2 array, and no error
          message related to LHOUS2 is issued by XERBLA. \n
          If VECT='N', LHOUS2 = max(1, 4*n); \n
          if VECT='V', option not yet available. \n
 * @param[out] WORK
          WORK is REAL array, dimension (LWORK) \n
 * @param[in] LWORK
          LWORK is INTEGER \n
          The dimension of the array WORK. LWORK = MAX(1, dimension) \n
          If LWORK = -1, or LHOUS2=-1,
          then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array,   returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA.
          LWORK = MAX(1, dimension) where \n
          dimension   = max(stage1,stage2) + (KD+1)*N \n
                      = N*KD + N*max(KD+1,FACTOPTNB)  \n
                        + max(2*KD*KD, KD*NTHREADS)  \n
                        + (KD+1)*N  \n
          where KD is the blocking size of the reduction,
          FACTOPTNB is the blocking used by the QR or LQ
          algorithm, usually FACTOPTNB=128 is a good choice
          NTHREADS is the number of threads used when
          openMP compilation is enabled, otherwise =1. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sytrd_2stage(char *vect, char *uplo, integer *n, T *a, integer *lda, T *d, T *e, T *tau, T *hous2, integer *lhous2, T *work, integer *lwork, integer *info)
{
  return sytrd_2stage(vect, uplo, n, a, lda, d, e, tau, hous2, lhous2, work, lwork, info);   
}

/*! @brief SYTRD_SB2ST reduces a real symmetric band matrix A to real symmetric tridiagonal form T

 * @details
 * \b Purpose:
    \verbatim 
    SYTRD_SB2ST reduces a real symmetric band matrix A to real symmetric
    tridiagonal form T by a orthogonal similarity transformation:
    Q**T * A * Q = T.
    \endverbatim  

  * @param[in] STAGE1
           STAGE1 is CHARACTER*1 \n
           = 'N':  "No": to mention that the stage 1 of the reduction  
                   from dense to band using the ssytrd_sy2sb routine
                   was not called before this routine to reproduce AB. 
                   In other term this routine is called as standalone.  \n
           = 'Y':  "Yes": to mention that the stage 1 of the 
                   reduction from dense to band using the ssytrd_sy2sb 
                   routine has been called to produce AB (e.g., AB is
                   the output of ssytrd_sy2sb. \n
  * @param[in] VECT
           VECT is CHARACTER*1 \n
           = 'N':  No need for the Housholder representation, 
                   and thus LHOUS is of size max(1, 4*N); \n
           = 'V':  the Householder representation is needed to 
                   either generate or to apply Q later on, 
                   then LHOUS is to be queried and computed.
                   (NOT AVAILABLE IN THIS RELEASE). \n
  * @param[in] UPLO
           UPLO is CHARACTER*1 \n
           = 'U':  Upper triangle of A is stored; \n
           = 'L':  Lower triangle of A is stored. \n
  * @param[in] N
           N is INTEGER \n
           The order of the matrix A.  N >= 0. \n
  * @param[in] KD
           KD is INTEGER \n
           The number of superdiagonals of the matrix A if UPLO = 'U',
           or the number of subdiagonals if UPLO = 'L'.  KD >= 0. \n
  * @param[in,out] AB
           AB is REAL array, dimension (LDAB,N) \n
           On entry, the upper or lower triangle of the symmetric band
           matrix A, stored in the first KD+1 rows of the array.  The
           j-th column of A is stored in the j-th column of the array AB
           as follows: \n
           if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j; \n
           if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd). \n
           On exit, the diagonal elements of AB are overwritten by the
           diagonal elements of the tridiagonal matrix T; if KD > 0, the
           elements on the first superdiagonal (if UPLO = 'U') or the
           first subdiagonal (if UPLO = 'L') are overwritten by the
           off-diagonal elements of T; the rest of AB is overwritten by
           values generated during the reduction. \n
  * @param[in] LDAB
           LDAB is INTEGER \n
           The leading dimension of the array AB.  LDAB >= KD+1. \n
  * @param[out] D
           D is REAL array, dimension (N) \n
           The diagonal elements of the tridiagonal matrix T. \n
  * @param[out] E
           E is REAL array, dimension (N-1) \n
           The off-diagonal elements of the tridiagonal matrix T: \n
           E(i) = T(i,i+1) if UPLO = 'U'; E(i) = T(i+1,i) if UPLO = 'L'. \n
  * @param[out] HOUS
           HOUS is REAL array, dimension LHOUS, that
           store the Householder representation. \n
  * @param[in] LHOUS
           LHOUS is INTEGER \n
           The dimension of the array HOUS. LHOUS = MAX(1, dimension) \n
           If LWORK = -1, or LHOUS=-1,
           then a query is assumed; the routine
           only calculates the optimal size of the HOUS array,   returns
           this value as the first entry of the HOUS array, and no error
           message related to LHOUS is issued by XERBLA. \n
           LHOUS = MAX(1, dimension) where \n
           dimension = 4*N if VECT='N' \n
           not available now if VECT='H' \n
  * @param[out] WORK
           WORK is REAL array, dimension LWORK. \n
  * @param[in] LWORK
           LWORK is INTEGER \n
           The dimension of the array WORK. LWORK = MAX(1, dimension) \n
           If LWORK = -1, or LHOUS=-1,
           then a workspace query is assumed; the routine
           only calculates the optimal size of the WORK array,   returns
           this value as the first entry of the WORK array, and no error
           message related to LWORK is issued by XERBLA. \n
           LWORK = MAX(1, dimension) where
           dimension   = (2KD+1)*N + KD*NTHREADS \n
           where KD is the blocking size of the reduction,
           FACTOPTNB is the blocking used by the QR or LQ
           algorithm, usually FACTOPTNB=128 is a good choice
           NTHREADS is the number of threads used when
           openMP compilation is enabled, otherwise =1. \n
  * @param[out] INFO
           INFO is INTEGER \n
           = 0:  successful exit \n
           < 0:  if INFO = -i, the i-th argument had an illegal value  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sytrd_sb2st(char *stage1, char *vect, char *uplo, integer *n, integer *kd, T *ab, integer *ldab, T *d, T * e, T *hous, integer *lhous, T *work, integer *lwork, integer *info)
{
  return hetrd_hb2st(stage1, vect, uplo, n, kd, ab, ldab, d, e, hous, lhous, work, lwork, info);
}

/*! @brief SYTRD_SY2SB reduces a real symmetric matrix A to real symmetric band-diagonal form AB

 * @details
 * \b Purpose:
    \verbatim 
    SYTRD_SY2SB reduces a real symmetric matrix A to real symmetric
    band-diagonal form AB by a orthogonal similarity transformation:
    Q**T * A * Q = AB.
    \endverbatim   

  * @param[in] UPLO
           UPLO is CHARACTER*1 \n
           = 'U':  Upper triangle of A is stored; \n
           = 'L':  Lower triangle of A is stored. \n
  * @param[in] N
           N is INTEGER \n
           The order of the matrix A.  N >= 0. \n
  * @param[in] KD
           KD is INTEGER \n
           The number of superdiagonals of the reduced matrix if UPLO = 'U',
           or the number of subdiagonals if UPLO = 'L'.  KD >= 0. \n
           The reduced matrix is stored in the array AB. \n
  * @param[in,out] A
           A is REAL array, dimension (LDA,N) \n
           On entry, the symmetric matrix A.  If UPLO = 'U', the leading
           N-by-N upper triangular part of A contains the upper
           triangular part of the matrix A, and the strictly lower
           triangular part of A is not referenced.  If UPLO = 'L', the
           leading N-by-N lower triangular part of A contains the lower
           triangular part of the matrix A, and the strictly upper
           triangular part of A is not referenced. \n \n
           On exit, if UPLO = 'U', the diagonal and first superdiagonal
           of A are overwritten by the corresponding elements of the
           tridiagonal matrix T, and the elements above the first
           superdiagonal, with the array TAU, represent the orthogonal
           matrix Q as a product of elementary reflectors; if UPLO
           = 'L', the diagonal and first subdiagonal of A are over-
           written by the corresponding elements of the tridiagonal
           matrix T, and the elements below the first subdiagonal, with
           the array TAU, represent the orthogonal matrix Q as a product
           of elementary reflectors. See Further Details. \n
  * @param[in] LDA
           LDA is INTEGER \n
           The leading dimension of the array A.  LDA >= max(1,N). \n
  * @param[out] AB
           AB is REAL array, dimension (LDAB,N) \n
           On exit, the upper or lower triangle of the symmetric band
           matrix A, stored in the first KD+1 rows of the array.  The
           j-th column of A is stored in the j-th column of the array AB
           as follows: \n
           if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j; \n
           if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd). \n
  * @param[in] LDAB
           LDAB is INTEGER \n
           The leading dimension of the array AB.  LDAB >= KD+1. \n
  * @param[out] TAU
           TAU is REAL array, dimension (N-KD) \n
           The scalar factors of the elementary reflectors (see Further
           Details). \n
  * @param[out] WORK
           WORK is REAL array, dimension (LWORK) \n
           On exit, if INFO = 0, or if LWORK=-1, 
           WORK(1)   returns the size of LWORK. \n
  * @param[in] LWORK
           LWORK is INTEGER \n
           The dimension of the array WORK which should be calculated
           by a workspace query. LWORK = MAX(1, LWORK_QUERY) \n
           If LWORK = -1, then a workspace query is assumed; the routine
           only calculates the optimal size of the WORK array, returns
           this value as the first entry of the WORK array, and no error
           message related to LWORK is issued by XERBLA. \n
           LWORK_QUERY = N*KD + N*max(KD,FACTOPTNB) + 2*KD*KD
           where FACTOPTNB is the blocking used by the QR or LQ
           algorithm, usually FACTOPTNB=128 is a good choice otherwise
           putting LWORK=-1 will provide the size of WORK. \n
  * @param[out] INFO
           INFO is INTEGER \n
           = 0:  successful exit \n
           < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sytrd_sy2sb(char *uplo, integer *n, integer *kd, T *a, integer *lda, T *ab, integer *ldab, T *tau, T *work, integer *lwork, integer *info)
{
  return sytrd_sy2sb(uplo, n, kd, a, lda, ab, ldab, tau, work, lwork, info);
}

/*! @brief SYCON_ROOK estimates the reciprocal of the condition number of a real symmetric matrix A

 * @details
 * \b Purpose:
    \verbatim 
    SYCON_ROOK estimates the reciprocal of the condition number (in the
    1-norm) of a real symmetric matrix A using the factorization
    A = U*D*U**T or A = L*D*L**T computed by SSYTRF_ROOK.

    An estimate is obtained for norm(inv(A)), and the reciprocal of the
    condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the details of the factorization are stored
          as an upper or lower triangular matrix. \n
          = 'U':  Upper triangular, form is A = U*D*U**T; \n
          = 'L':  Lower triangular, form is A = L*D*L**T. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          The block diagonal matrix D and the multipliers used to
          obtain the factor U or L as computed by SSYTRF_ROOK. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D
          as determined by SSYTRF_ROOK. \n
 * @param[in] ANORM
          ANORM is REAL \n
          The 1-norm of the original matrix A. \n
 * @param[out] RCOND
          RCOND is REAL \n
          The reciprocal of the condition number of the matrix A,
          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
          estimate of the 1-norm of inv(A) computed in this routine. \n
 * @param[out] WORK
          WORK is REAL array, dimension (2*N) \n
 * @param[out] IWORK
          IWORK is INTEGER array, dimension (N) \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sycon_rook(char *uplo, integer *n, T *a, integer * lda, integer *ipiv, T *anorm, T *rcond, T *work, integer * iwork, integer *info)
{
  return sycon_rook(*uplo, *n, a, *lda, *ipiv, anorm, rcond, work, *iwork, *info);
}
template< typename T, typename Ta >
integer sycon_rook(char *uplo, integer *n, T *a, integer * lda, integer *ipiv, Ta *anorm, Ta *rcond, T *work, integer * iwork, integer *info)
{
  return sycon_rook(*uplo, *n, a, *lda, *ipiv, anorm, rcond, work, *iwork, *info);
}

/*! @brief SYCONVF converts the factorization output format

 * @details
 * \b Purpose:
    \verbatim 
    If parameter WAY = 'C':
    SYCONVF converts the factorization output format used in
    SYTRF provided on entry in parameter A into the factorization
    output format used in SYTRF_RK (or SYTRF_BK) that is stored
    on exit in parameters A and E. It also coverts in place details of
    the intechanges stored in IPIV from the format used in SYTRF into
    the format used in SYTRF_RK (or SYTRF_BK).

    If parameter WAY = 'R':
    SYCONVF performs the conversion in reverse direction, i.e.
    converts the factorization output format used in SYTRF_RK
    (or SYTRF_BK) provided on entry in parameters A and E into
    the factorization output format used in SSYTRF that is stored
    on exit in parameter A. It also coverts in place details of
    the intechanges stored in IPIV from the format used in SYTRF_RK
    (or SYTRF_BK) into the format used in SYTRF.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the details of the factorization are
          stored as an upper or lower triangular matrix A. \n
          = 'U':  Upper triangular \n
          = 'L':  Lower triangular \n
 * @param[in] WAY
          WAY is CHARACTER*1 \n
          = 'C': Convert \n
          = 'R': Revert \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
 \n
          1) If WAY ='C':
 \n
          On entry, contains factorization details in format used in
          SSYTRF: \n
            a) all elements of the symmetric block diagonal
               matrix D on the diagonal of A and on superdiagonal
               (or subdiagonal) of A, and \n
            b) If UPLO = 'U': multipliers used to obtain factor U
               in the superdiagonal part of A.
               If UPLO = 'L': multipliers used to obtain factor L
               in the superdiagonal part of A. \n
 \n
          On exit, contains factorization details in format used in
          SSYTRF_RK or SSYTRF_BK: \n
            a) ONLY diagonal elements of the symmetric block diagonal
               matrix D on the diagonal of A, i.e. D(k,k) = A(k,k);
               (superdiagonal (or subdiagonal) elements of D
                are stored on exit in array E), and \n
            b) If UPLO = 'U': factor U in the superdiagonal part of A. \n
               If UPLO = 'L': factor L in the subdiagonal part of A. \n
 \n
          2) If WAY = 'R':
 \n
          On entry, contains factorization details in format used in
          SSYTRF_RK or SSYTRF_BK: \n
            a) ONLY diagonal elements of the symmetric block diagonal
               matrix D on the diagonal of A, i.e. D(k,k) = A(k,k);
               (superdiagonal (or subdiagonal) elements of D
                are stored on exit in array E), and \n
            b) If UPLO = 'U': factor U in the superdiagonal part of A. \n
               If UPLO = 'L': factor L in the subdiagonal part of A. \n
 \n
          On exit, contains factorization details in format used in
          SSYTRF: \n
            a) all elements of the symmetric block diagonal
               matrix D on the diagonal of A and on superdiagonal
               (or subdiagonal) of A, and \n
            b) If UPLO = 'U': multipliers used to obtain factor U
               in the superdiagonal part of A.
               If UPLO = 'L': multipliers used to obtain factor L
               in the superdiagonal part of A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in,out] E
          E is REAL array, dimension (N) \n
 \n
          1) If WAY ='C':
 \n
          On entry, just a workspace.
 \n
          On exit, contains the superdiagonal (or subdiagonal)
          elements of the symmetric block diagonal matrix D
          with 1-by-1 or 2-by-2 diagonal blocks, where
          If UPLO = 'U': E(i) = D(i-1,i), i=2:N, E(1) is set to 0;
          If UPLO = 'L': E(i) = D(i+1,i), i=1:N-1, E(N) is set to 0.
 \n
          2) If WAY = 'R':
 \n
          On entry, contains the superdiagonal (or subdiagonal)
          elements of the symmetric block diagonal matrix D
          with 1-by-1 or 2-by-2 diagonal blocks, where
          If UPLO = 'U': E(i) = D(i-1,i),i=2:N, E(1) not referenced;
          If UPLO = 'L': E(i) = D(i+1,i),i=1:N-1, E(N) not referenced.
 \n
          On exit, is not changed \n
 * @param[in,out] IPIV
          IPIV is INTEGER array, dimension (N) \n
 \n
          1) If WAY ='C': \n
          On entry, details of the interchanges and the block
          structure of D in the format used in SSYTRF. \n
          On exit, details of the interchanges and the block
          structure of D in the format used in SSYTRF_RK
          (or SSYTRF_BK). \n
 \n
          1) If WAY ='R': \n
          On entry, details of the interchanges and the block
          structure of D in the format used in SSYTRF_RK
          (or SSYTRF_BK). \n
          On exit, details of the interchanges and the block
          structure of D in the format used in SSYTRF. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer syconvf(char *uplo, char *way, integer *n, T *a, integer *lda, T *e, integer *ipiv, integer *info)
{
  return syconvf(uplo, way, n, a, lda, e, ipiv, info);
}

/*! @brief SYCONVF_ROOK converts the factorization output format

 * @details
 * \b Purpose:
    \verbatim 
    If parameter WAY = 'C':
    SSYCONVF_ROOK converts the factorization output format used in
    SSYTRF_ROOK provided on entry in parameter A into the factorization
    output format used in SSYTRF_RK (or SSYTRF_BK) that is stored
    on exit in parameters A and E. IPIV format for SSYTRF_ROOK and
    SSYTRF_RK (or SSYTRF_BK) is the same and is not converted.

    If parameter WAY = 'R':
    SSYCONVF_ROOK performs the conversion in reverse direction, i.e.
    converts the factorization output format used in SSYTRF_RK
    (or SSYTRF_BK) provided on entry in parameters A and E into
    the factorization output format used in SSYTRF_ROOK that is stored
    on exit in parameter A. IPIV format for SSYTRF_ROOK and
    SSYTRF_RK (or SSYTRF_BK) is the same and is not converted.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the details of the factorization are
          stored as an upper or lower triangular matrix A. \n
          = 'U':  Upper triangular \n
          = 'L':  Lower triangular \n
 * @param[in] WAY
          WAY is CHARACTER*1 \n
          = 'C': Convert \n
          = 'R': Revert \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
 \n
          1) If WAY ='C':
 \n
          On entry, contains factorization details in format used in
          SSYTRF_ROOK: \n
            a) all elements of the symmetric block diagonal
               matrix D on the diagonal of A and on superdiagonal
               (or subdiagonal) of A, and \n
            b) If UPLO = 'U': multipliers used to obtain factor U
               in the superdiagonal part of A.
               If UPLO = 'L': multipliers used to obtain factor L
               in the superdiagonal part of A. \n
 \n
          On exit, contains factorization details in format used in
          SSYTRF_RK or SSYTRF_BK: \n
            a) ONLY diagonal elements of the symmetric block diagonal
               matrix D on the diagonal of A, i.e. D(k,k) = A(k,k);
               (superdiagonal (or subdiagonal) elements of D
                are stored on exit in array E), and \n
            b) If UPLO = 'U': factor U in the superdiagonal part of A.
               If UPLO = 'L': factor L in the subdiagonal part of A. \n
 \n
          2) If WAY = 'R':
 \n
          On entry, contains factorization details in format used in
          SSYTRF_RK or SSYTRF_BK: \n
            a) ONLY diagonal elements of the symmetric block diagonal
               matrix D on the diagonal of A, i.e. D(k,k) = A(k,k);
               (superdiagonal (or subdiagonal) elements of D
                are stored on exit in array E), and \n
            b) If UPLO = 'U': factor U in the superdiagonal part of A.
               If UPLO = 'L': factor L in the subdiagonal part of A.
 \n
          On exit, contains factorization details in format used in
          SSYTRF_ROOK: \n
            a) all elements of the symmetric block diagonal
               matrix D on the diagonal of A and on superdiagonal
               (or subdiagonal) of A, and \n
            b) If UPLO = 'U': multipliers used to obtain factor U
               in the superdiagonal part of A.
               If UPLO = 'L': multipliers used to obtain factor L
               in the superdiagonal part of A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in,out] E
          E is REAL array, dimension (N) \n
 \n
          1) If WAY ='C':
 \n
          On entry, just a workspace.
 \n
          On exit, contains the superdiagonal (or subdiagonal)
          elements of the symmetric block diagonal matrix D
          with 1-by-1 or 2-by-2 diagonal blocks, where
          If UPLO = 'U': E(i) = D(i-1,i), i=2:N, E(1) is set to 0;
          If UPLO = 'L': E(i) = D(i+1,i), i=1:N-1, E(N) is set to 0.
 \n
          2) If WAY = 'R':
 \n
          On entry, contains the superdiagonal (or subdiagonal)
          elements of the symmetric block diagonal matrix D
          with 1-by-1 or 2-by-2 diagonal blocks, where \n
          If UPLO = 'U': E(i) = D(i-1,i),i=2:N, E(1) not referenced; \n
          If UPLO = 'L': E(i) = D(i+1,i),i=1:N-1, E(N) not referenced. \n
 \n
          On exit, is not changed \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          On entry, details of the interchanges and the block
          structure of D as determined: \n
          1) by SSYTRF_ROOK, if WAY ='C'; \n
          2) by SSYTRF_RK (or SSYTRF_BK), if WAY ='R'.
          The IPIV format is the same for all these routines. \n
 \n
          On exit, is not changed. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer syconvf_rook(char *uplo, char *way, integer *n, T *a, integer *lda, T *e, integer *ipiv, integer *info)
{
  return syconvf_rook(uplo, way, n, a, lda, e, ipiv, info);
}

/*! @brief SYTF2 computes the factorization of a real symmetric indefinite matrix, using the diagonal pivoting method

 * @details
 * \b Purpose:
    \verbatim 
    SYTF2 computes the factorization of a real symmetric matrix A using
    the Bunch-Kaufman diagonal pivoting method:

       A = U*D*U**T  or  A = L*D*L**T

    where U (or L) is a product of permutation and unit upper (lower)
    triangular matrices, U**T is the transpose of U, and D is symmetric and
    block diagonal with 1-by-1 and 2-by-2 diagonal blocks.

    This is the unblocked version of the algorithm, calling Level 2 BLAS.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the upper or lower triangular part of the
          symmetric matrix A is stored: \n
          = 'U':  Upper triangular \n
          = 'L':  Lower triangular \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
          n-by-n upper triangular part of A contains the upper
          triangular part of the matrix A, and the strictly lower
          triangular part of A is not referenced.  If UPLO = 'L', the
          leading n-by-n lower triangular part of A contains the lower
          triangular part of the matrix A, and the strictly upper
          triangular part of A is not referenced. \n
 \n
          On exit, the block diagonal matrix D and the multipliers used
          to obtain the factor U or L (see below for further details). \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D.
 \n
          If UPLO = 'U': \n
             If IPIV(k) > 0, then rows and columns k and IPIV(k) were
             interchanged and D(k,k) is a 1-by-1 diagonal block.
 \n
             If IPIV(k) = IPIV(k-1) < 0, then rows and columns
             k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
             is a 2-by-2 diagonal block.
 \n
          If UPLO = 'L': \n
             If IPIV(k) > 0, then rows and columns k and IPIV(k) were
             interchanged and D(k,k) is a 1-by-1 diagonal block.
 \n
             If IPIV(k) = IPIV(k+1) < 0, then rows and columns
             k+1 and -IPIV(k) were interchanged and D(k:k+1,k:k+1)
             is a 2-by-2 diagonal block. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -k, the k-th argument had an illegal value \n
          > 0: if INFO = k, D(k,k) is exactly zero.  The factorization
               has been completed, but the block diagonal matrix D is
               exactly singular, and division by zero will occur if it
               is used to solve a system of equations. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sytf2(char *uplo, integer *n, T *a, integer *lda, integer *ipiv, integer *info)
{
  return sytf2(uplo, n, a, lda, ipiv, info);
}

/*! @brief SYTF2_RK computes the factorization of a real symmetric indefinite \n
     matrix using the bounded Bunch-Kaufman (rook) diagonal pivoting method

 * @details
 * \b Purpose:
    \verbatim 
    SYTF2_RK computes the factorization of a real symmetric matrix A
    using the bounded Bunch-Kaufman (rook) diagonal pivoting method:

       A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),

    where U (or L) is unit upper (or lower) triangular matrix,
    U**T (or L**T) is the transpose of U (or L), P is a permutation
    matrix, P**T is the transpose of P, and D is symmetric and block
    diagonal with 1-by-1 and 2-by-2 diagonal blocks.

    This is the unblocked version of the algorithm, calling Level 2 BLAS.
    For more information see Further Details section.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the upper or lower triangular part of the
          symmetric matrix A is stored: \n
          = 'U':  Upper triangular \n
          = 'L':  Lower triangular \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the symmetric matrix A. \n
            If UPLO = 'U': the leading N-by-N upper triangular part
            of A contains the upper triangular part of the matrix A,
            and the strictly lower triangular part of A is not
            referenced.
 \n
            If UPLO = 'L': the leading N-by-N lower triangular part
            of A contains the lower triangular part of the matrix A,
            and the strictly upper triangular part of A is not
            referenced.
 \n
          On exit, contains: \n
            a) ONLY diagonal elements of the symmetric block diagonal
               matrix D on the diagonal of A, i.e. D(k,k) = A(k,k);
               (superdiagonal (or subdiagonal) elements of D
                are stored on exit in array E), and \n
            b) If UPLO = 'U': factor U in the superdiagonal part of A. \n
               If UPLO = 'L': factor L in the subdiagonal part of A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] E
          E is REAL array, dimension (N) \n
          On exit, contains the superdiagonal (or subdiagonal)
          elements of the symmetric block diagonal matrix D
          with 1-by-1 or 2-by-2 diagonal blocks, where
          If UPLO = 'U': E(i) = D(i-1,i), i=2:N, E(1) is set to 0;
          If UPLO = 'L': E(i) = D(i+1,i), i=1:N-1, E(N) is set to 0.
 \n
          NOTE: For 1-by-1 diagonal block D(k), where
          1 <= k <= N, the element E(k) is set to 0 in both
          UPLO = 'U' or UPLO = 'L' cases. \n
 * @param[out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          IPIV describes the permutation matrix P in the factorization
          of matrix A as follows. The absolute value of IPIV(k)
          represents the index of row and column that were
          interchanged with the k-th row and column. The value of UPLO
          describes the order in which the interchanges were applied.
          Also, the sign of IPIV represents the block structure of
          the symmetric block diagonal matrix D with 1-by-1 or 2-by-2
          diagonal blocks which correspond to 1 or 2 interchanges
          at each factorization step. For more info see Further
          Details section. \n
 \n
          If UPLO = 'U',
          (in factorization order, k decreases from N to 1): \n
            a) A single positive entry IPIV(k) > 0 means:
               D(k,k) is a 1-by-1 diagonal block.
               If IPIV(k) != k, rows and columns k and IPIV(k) were
               interchanged in the matrix A(1:N,1:N);
               If IPIV(k) = k, no interchange occurred. \n
 \n
            b) A pair of consecutive negative entries
               IPIV(k) < 0 and IPIV(k-1) < 0 means:
               D(k-1:k,k-1:k) is a 2-by-2 diagonal block.
               (NOTE: negative entries in IPIV appear ONLY in pairs). \n
               1) If -IPIV(k) != k, rows and columns
                  k and -IPIV(k) were interchanged
                  in the matrix A(1:N,1:N).
                  If -IPIV(k) = k, no interchange occurred. \n
               2) If -IPIV(k-1) != k-1, rows and columns
                  k-1 and -IPIV(k-1) were interchanged
                  in the matrix A(1:N,1:N).
                  If -IPIV(k-1) = k-1, no interchange occurred. \n
 \n
            c) In both cases a) and b), always ABS(IPIV(k)) <= k. \n
 \n
            d) NOTE: Any entry IPIV(k) is always NONZERO on output. \n
 \n
          If UPLO = 'L',
          (in factorization order, k increases from 1 to N): \n
            a) A single positive entry IPIV(k) > 0 means:
               D(k,k) is a 1-by-1 diagonal block.
               If IPIV(k) != k, rows and columns k and IPIV(k) were
               interchanged in the matrix A(1:N,1:N).
               If IPIV(k) = k, no interchange occurred.
 \n
            b) A pair of consecutive negative entries
               IPIV(k) < 0 and IPIV(k+1) < 0 means:
               D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
               (NOTE: negative entries in IPIV appear ONLY in pairs). \n
               1) If -IPIV(k) != k, rows and columns
                  k and -IPIV(k) were interchanged
                  in the matrix A(1:N,1:N).
                  If -IPIV(k) = k, no interchange occurred. \n
               2) If -IPIV(k+1) != k+1, rows and columns
                  k-1 and -IPIV(k-1) were interchanged
                  in the matrix A(1:N,1:N).
                  If -IPIV(k+1) = k+1, no interchange occurred. \n
 \n
            c) In both cases a) and b), always ABS(IPIV(k)) >= k. \n
 \n
            d) NOTE: Any entry IPIV(k) is always NONZERO on output. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: If INFO = -k, the k-th argument had an illegal value \n
          > 0: If INFO = k, the matrix A is singular, because: \n
                 If UPLO = 'U': column k in the upper
                 triangular part of A contains all zeros. \n
                 If UPLO = 'L': column k in the lower
                 triangular part of A contains all zeros. \n
 \n
               Therefore D(k,k) is exactly zero, and superdiagonal
               elements of column k of U (or subdiagonal elements of
               column k of L) are all zeros. The factorization has
               been completed, but the block diagonal matrix D is
               exactly singular, and division by zero will occur if
               it is used to solve a system of equations.
 \n
               NOTE: INFO only stores the first occurrence of
               a singularity, any subsequent occurrence of singularity
               is not stored in INFO even though the factorization
               always completes. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sytf2_rk(char *uplo, integer *n, T *a, integer * lda, T *e, integer *ipiv, integer *info)
{
  return sytf2_rk(uplo, n, a, lda, e, ipiv, info);
}

/*! @brief SYTF2_ROOK computes the factorization of a real symmetric indefinite \n
     matrix using the bounded Bunch-Kaufman ("rook") diagonal pivoting method
 * @details
 * \b Purpose:
    \verbatim 
    SYTF2_ROOK computes the factorization of a real symmetric matrix A
    using the bounded Bunch-Kaufman ("rook") diagonal pivoting method:

       A = U*D*U**T  or  A = L*D*L**T

    where U (or L) is a product of permutation and unit upper (lower)
    triangular matrices, U**T is the transpose of U, and D is symmetric and
    block diagonal with 1-by-1 and 2-by-2 diagonal blocks.

    This is the unblocked version of the algorithm, calling Level 2 BLAS.
    \endverbatim     

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the upper or lower triangular part of the
          symmetric matrix A is stored: \n
          = 'U':  Upper triangular \n
          = 'L':  Lower triangular \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
          n-by-n upper triangular part of A contains the upper
          triangular part of the matrix A, and the strictly lower
          triangular part of A is not referenced.  If UPLO = 'L', the
          leading n-by-n lower triangular part of A contains the lower
          triangular part of the matrix A, and the strictly upper
          triangular part of A is not referenced. \n
 \n
          On exit, the block diagonal matrix D and the multipliers used
          to obtain the factor U or L (see below for further details). \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D. \n
 \n
          If UPLO = 'U': \n
             If IPIV(k) > 0, then rows and columns k and IPIV(k)
             were interchanged and D(k,k) is a 1-by-1 diagonal block.
 \n
             If IPIV(k) < 0 and IPIV(k-1) < 0, then rows and
             columns k and -IPIV(k) were interchanged and rows and
             columns k-1 and -IPIV(k-1) were inerchaged,
             D(k-1:k,k-1:k) is a 2-by-2 diagonal block.
 \n
          If UPLO = 'L': \n
             If IPIV(k) > 0, then rows and columns k and IPIV(k)
             were interchanged and D(k,k) is a 1-by-1 diagonal block.
 \n
             If IPIV(k) < 0 and IPIV(k+1) < 0, then rows and
             columns k and -IPIV(k) were interchanged and rows and
             columns k+1 and -IPIV(k+1) were inerchaged,
             D(k:k+1,k:k+1) is a 2-by-2 diagonal block. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -k, the k-th argument had an illegal value \n
          > 0: if INFO = k, D(k,k) is exactly zero.  The factorization
               has been completed, but the block diagonal matrix D is
               exactly singular, and division by zero will occur if it
               is used to solve a system of equations. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sytf2_rook(char *uplo, integer *n, T *a, integer * lda, integer *ipiv, integer *info)
{
  return sytf2_rook(uplo, n, a, lda, ipiv, info);
}

/*! @brief SYTRI_3X computes the inverse of a real symmetric indefinite matrix A

 * @details
 * \b Purpose:
    \verbatim 
    SYTRI_3X computes the inverse of a real symmetric indefinite
    matrix A using the factorization computed by SSYTRF_RK or SSYTRF_BK:

        A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),

    where U (or L) is unit upper (or lower) triangular matrix,
    U**T (or L**T) is the transpose of U (or L), P is a permutation
    matrix, P**T is the transpose of P, and D is symmetric and block
    diagonal with 1-by-1 and 2-by-2 diagonal blocks.

    This is the blocked version of the algorithm, calling Level 3 BLAS.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the details of the factorization are
          stored as an upper or lower triangular matrix. \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, diagonal of the block diagonal matrix D and
          factors U or L as computed by SYTRF_RK and SSYTRF_BK: \n
            a) ONLY diagonal elements of the symmetric block diagonal
               matrix D on the diagonal of A, i.e. D(k,k) = A(k,k);
               (superdiagonal (or subdiagonal) elements of D
                should be provided on entry in array E), and \n
            b) If UPLO = 'U': factor U in the superdiagonal part of A.
               If UPLO = 'L': factor L in the subdiagonal part of A.
 \n
          On exit, if INFO = 0, the symmetric inverse of the original
          matrix. \n
             If UPLO = 'U': the upper triangular part of the inverse
             is formed and the part of A below the diagonal is not
             referenced; \n
             If UPLO = 'L': the lower triangular part of the inverse
             is formed and the part of A above the diagonal is not
             referenced. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] E
          E is REAL array, dimension (N) \n
          On entry, contains the superdiagonal (or subdiagonal)
          elements of the symmetric block diagonal matrix D
          with 1-by-1 or 2-by-2 diagonal blocks, where \n
          If UPLO = 'U': E(i) = D(i-1,i), i=2:N, E(1) not referenced; \n
          If UPLO = 'L': E(i) = D(i+1,i), i=1:N-1, E(N) not referenced. \n
 \n
          NOTE: For 1-by-1 diagonal block D(k), where
          1 <= k <= N, the element E(k) is not referenced in both
          UPLO = 'U' or UPLO = 'L' cases. \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D
          as determined by SSYTRF_RK or SSYTRF_BK. \n
 * @param[out] WORK
          WORK is REAL array, dimension (N+NB+1,NB+3). \n
 * @param[in] NB
          NB is INTEGER \n
          Block size. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n
          > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its
               inverse could not be computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sytri_3x(char *uplo, integer *n, T *a, integer * lda, T *e, integer *ipiv, T *work, integer *nb, integer *info)
{
  return sytri_3x(uplo, n, a, lda, e, ipiv, work, nb, info);
}

/*! @brief SYTRI_ROOK computes the inverse of a real symmetric matrix A

 * @details
 * \b Purpose:
    \verbatim 
    SYTRI_ROOK computes the inverse of a real symmetric
    matrix A using the factorization A = U*D*U**T or A = L*D*L**T
    computed by SSYTRF_ROOK.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the details of the factorization are stored
          as an upper or lower triangular matrix. \n
          = 'U':  Upper triangular, form is A = U*D*U**T; \n
          = 'L':  Lower triangular, form is A = L*D*L**T. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the block diagonal matrix D and the multipliers
          used to obtain the factor U or L as computed by SSYTRF_ROOK.
 \n
          On exit, if INFO = 0, the (symmetric) inverse of the original
          matrix.  If UPLO = 'U', the upper triangular part of the
          inverse is formed and the part of A below the diagonal is not
          referenced; if UPLO = 'L' the lower triangular part of the
          inverse is formed and the part of A above the diagonal is
          not referenced. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D
          as determined by SSYTRF_ROOK. \n
 * @param[out] WORK
          WORK is REAL array, dimension (N) \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n
          > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its
               inverse could not be computed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer sytri_rook(char *uplo, integer *n, T *a, integer * lda, integer *ipiv, T *work, integer *info)
{
  return sytri_rook(uplo, n, a, lda, ipiv, work, info);
}

/*! @brief TGEX2 swaps adjacent diagonal blocks in an upper (quasi) triangular matrix pair by an orthogonal equivalence transformation

 * @details
 * \b Purpose:
    \verbatim 
    TGEX2 swaps adjacent diagonal blocks (A11, B11) and (A22, B22)
    of size 1-by-1 or 2-by-2 in an upper (quasi) triangular matrix pair
    (A, B) by an orthogonal equivalence transformation.

    (A, B) must be in generalized real Schur canonical form (as   returned
    by SGGES), i.e. A is block upper triangular with 1-by-1 and 2-by-2
    diagonal blocks. B is upper triangular.

    Optionally, the matrices Q and Z of generalized Schur vectors are
    updated.

           Q(in) * A(in) * Z(in)**T = Q(out) * A(out) * Z(out)**T
           Q(in) * B(in) * Z(in)**T = Q(out) * B(out) * Z(out)**T
    \endverbatim
 
 * @param[in] WANTQ
          WANTQ is LOGICAL \n
          .TRUE. : update the left transformation matrix Q;
          .FALSE.: do not update Q. \n
 * @param[in] WANTZ
          WANTZ is LOGICAL \n
          .TRUE. : update the right transformation matrix Z;
          .FALSE.: do not update Z. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrices A and B. N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the matrix A in the pair (A, B).
          On exit, the updated matrix A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A. LDA >= max(1,N). \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,N) \n
          On entry, the matrix B in the pair (A, B).
          On exit, the updated matrix B. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B. LDB >= max(1,N). \n
 * @param[in,out] Q
          Q is REAL array, dimension (LDQ,N) \n
          On entry, if WANTQ = .TRUE., the orthogonal matrix Q.
          On exit, the updated matrix Q.
          Not referenced if WANTQ = .FALSE.. \n
 * @param[in] LDQ
          LDQ is INTEGER \n
          The leading dimension of the array Q. LDQ >= 1.
          If WANTQ = .TRUE., LDQ >= N. \n
 * @param[in,out] Z
          Z is REAL array, dimension (LDZ,N) \n
          On entry, if WANTZ =.TRUE., the orthogonal matrix Z.
          On exit, the updated matrix Z.
          Not referenced if WANTZ = .FALSE.. \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of the array Z. LDZ >= 1.
          If WANTZ = .TRUE., LDZ >= N. \n
 * @param[in] J1
          J1 is INTEGER \n
          The index to the first block (A11, B11). 1 <= J1 <= N. \n
 * @param[in] N1
          N1 is INTEGER \n
          The order of the first block (A11, B11). N1 = 0, 1 or 2. \n
 * @param[in] N2
          N2 is INTEGER \n
          The order of the second block (A22, B22). N2 = 0, 1 or 2. \n
 * @param[out] WORK
          WORK is REAL array, dimension (MAX(1,LWORK)). \n
 * @param[in] LWORK
          LWORK is INTEGER \n
          The dimension of the array WORK.
          LWORK >=  MAX(N*(N2+N1), (N2+N1)*(N2+N1)*2) \n
 * @param[out] INFO
          INFO is INTEGER \n
            =0: Successful exit \n
            >0: If INFO = 1, the transformed matrix (A, B) would be
                too far from generalized Schur form; the blocks are
                not swapped and (A, B) and (Q, Z) are unchanged.
                The problem of swapping is too ill-conditioned. \n
            <0: If INFO = -16: LWORK is too small. Appropriate value
                for LWORK is   returned in WORK(1).  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer tgex2(logical *wantq, logical *wantz, integer *n, T *a, integer *lda, T *b, integer *ldb, T *q, integer *ldq, T * z, integer *ldz, integer *j1, integer *n1, integer *n2, T *work, integer *lwork, integer *info)
{
  return tgex2(wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, j1, n1, n2, work, lwork, info);
}

/*! @brief TGSY2 solves the generalized Sylvester equation (unblocked algorithm)

 * @details
 * \b Purpose:
    \verbatim 
    TGSY2 solves the generalized Sylvester equation:

                A * R - L * B = scale * C                (1)
                D * R - L * E = scale * F,

    using Level 1 and 2 BLAS. where R and L are unknown M-by-N matrices,
    (A, D), (B, E) and (C, F) are given matrix pairs of size M-by-M,
    N-by-N and M-by-N, respectively, with real entries. (A, D) and (B, E)
    must be in generalized Schur canonical form, i.e. A, B are upper
    quasi triangular and D, E are upper triangular. The solution (R, L)
    overwrites (C, F). 0 <= SCALE <= 1 is an output scaling factor
    chosen to avoid overflow.

    In matrix notation solving equation (1) corresponds to solve
    Z*x = scale*b, where Z is defined as

           Z = [ kron(In, A)  -kron(B**T, Im) ]             (2)
               [ kron(In, D)  -kron(E**T, Im) ],

    Ik is the identity matrix of size k and X**T is the transpose of X.
    kron(X, Y) is the Kronecker product between the matrices X and Y.
    In the process of solving (1), we solve a number of such systems
    where Dim(In), Dim(In) = 1 or 2.

    If TRANS = 'T', solve the transposed system Z**T*y = scale*b for y,
    which is equivalent to solve for R and L in

                A**T * R  + D**T * L   = scale * C           (3)
                R  * B**T + L  * E**T  = scale * -F

    This case is used to compute an estimate of Dif[(A, D), (B, E)] =
    sigma_min(Z) using reverse communication with SLACON.

    STGSY2 also (IJOB >= 1) contributes to the computation in STGSYL
    of an upper bound on the separation between to matrix pairs. Then
    the input (A, D), (B, E) are sub-pencils of the matrix pair in
    STGSYL. See STGSYL for details.
    \endverbatim  

 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          = 'N': solve the generalized Sylvester equation (1). \n
          = 'T': solve the 'transposed' system (3). \n
 * @param[in] IJOB
          IJOB is INTEGER \n
          Specifies what kind of functionality to be performed. \n
          = 0: solve (1) only. \n
          = 1: A contribution from this subsystem to a Frobenius
               norm-based estimate of the separation between two matrix
               pairs is computed. (look ahead strategy is used). \n
          = 2: A contribution from this subsystem to a Frobenius
               norm-based estimate of the separation between two matrix
               pairs is computed. (SGECON on sub-systems is used.) \n
          Not referenced if TRANS = 'T'. \n
 * @param[in] M
          M is INTEGER \n
          On entry, M specifies the order of A and D, and the row
          dimension of C, F, R and L. \n
 * @param[in] N
          N is INTEGER \n
          On entry, N specifies the order of B and E, and the column
          dimension of C, F, R and L. \n
 * @param[in] A
          A is REAL array, dimension (LDA, M) \n
          On entry, A contains an upper quasi triangular matrix. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the matrix A. LDA >= max(1, M). \n
 * @param[in] B
          B is REAL array, dimension (LDB, N) \n
          On entry, B contains an upper quasi triangular matrix. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the matrix B. LDB >= max(1, N). \n
 * @param[in,out] C
          C is REAL array, dimension (LDC, N) \n
          On entry, C contains the right-hand-side of the first matrix
          equation in (1). \n
          On exit, if IJOB = 0, C has been overwritten by the
          solution R. \n
 * @param[in] LDC
          LDC is INTEGER \n
          The leading dimension of the matrix C. LDC >= max(1, M). \n
 * @param[in] D
          D is REAL array, dimension (LDD, M) \n
          On entry, D contains an upper triangular matrix. \n
 * @param[in] LDD
          LDD is INTEGER \n
          The leading dimension of the matrix D. LDD >= max(1, M). \n
 * @param[in] E
          E is REAL array, dimension (LDE, N) \n
          On entry, E contains an upper triangular matrix. \n
 * @param[in] LDE
          LDE is INTEGER \n
          The leading dimension of the matrix E. LDE >= max(1, N). \n
 * @param[in,out] F
          F is REAL array, dimension (LDF, N) \n
          On entry, F contains the right-hand-side of the second matrix
          equation in (1). \n
          On exit, if IJOB = 0, F has been overwritten by the
          solution L. \n
 * @param[in] LDF
          LDF is INTEGER \n
          The leading dimension of the matrix F. LDF >= max(1, M). \n
 * @param[out] SCALE
          SCALE is REAL \n
          On exit, 0 <= SCALE <= 1. If 0 < SCALE < 1, the solutions
          R and L (C and F on entry) will hold the solutions to a
          slightly perturbed system but the input matrices A, B, D and
          E have not been changed. If SCALE = 0, R and L will hold the
          solutions to the homogeneous system with C = F = 0. Normally,
          SCALE = 1. \n
 * @param[in,out] RDSUM
          RDSUM is REAL \n
          On entry, the sum of squares of computed contributions to
          the Dif-estimate under computation by STGSYL, where the
          scaling factor RDSCAL (see below) has been factored out.
          On exit, the corresponding sum of squares updated with the
          contributions from the current sub-system.
          If TRANS = 'T' RDSUM is not touched. \n
          NOTE: RDSUM only makes sense when STGSY2 is called by STGSYL. \n
 * @param[in,out] RDSCAL
          RDSCAL is REAL \n
          On entry, scaling factor used to prevent overflow in RDSUM. \n
          On exit, RDSCAL is updated w.r.t. the current contributions
          in RDSUM.
          If TRANS = 'T', RDSCAL is not touched. \n
          NOTE: RDSCAL only makes sense when STGSY2 is called by
                STGSYL. \n
 * @param[out] IWORK
          IWORK is INTEGER array, dimension (M+N+2) \n
 * @param[out] PQ
          PQ is INTEGER \n
          On exit, the number of subsystems (of size 2-by-2, 4-by-4 and
          8-by-8) solved by this routine. \n
 * @param[out] INFO
          INFO is INTEGER \n
          On exit, if INFO is set to \n
            =0: Successful exit \n
            <0: If INFO = -i, the i-th argument had an illegal value. \n
            >0: The matrix pairs (A, D) and (B, E) have common or very
                close eigenvalues. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer tgsy2(char *trans, integer *ijob, integer *m, integer * n, T *a, integer *lda, T *b, integer *ldb, T *c, integer * ldc, T *d, integer *ldd, T *e, integer *lde, T *f, integer *ldf, T *scale, T *rdsum, T *rdscal, integer *iwork, integer *pq, integer *info)
{
  return tgsy2(trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, rdsum, rdscal, iwork, pq, info);
}
template< typename T, typename Ta >
integer tgsy2(char *trans, integer *ijob, integer *m, integer * n, T *a, integer *lda, T *b, integer *ldb, T *c, integer * ldc, T *d, integer *ldd, T *e, integer *lde, T *f, integer *ldf, Ta *scale, Ta *rdsum, Ta *rdscal, integer *info)
{
  return tgsy2(trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, rdsum, rdscal, info);
}

/*! @brief TPLQT computes a blocked LQ factorization of a real "triangular-pentagonal" matrix C

 * @details
 * \b Purpose:
    \verbatim 
    TPLQT computes a blocked LQ factorization of a real
    "triangular-pentagonal" matrix C, which is composed of a
    triangular block A and pentagonal block B, using the compact
    WY representation for Q.
    \endverbatim 

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix B, and the order of the
          triangular matrix A. \n
          M >= 0.
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix B.
          N >= 0. \n
 * @param[in] L
          L is INTEGER \n
          The number of rows of the lower trapezoidal part of B.
          MIN(M,N) >= L >= 0.  See Further Details. \n
 * @param[in] MB
          MB is INTEGER \n
          The block size to be used in the blocked QR.  M >= MB >= 1. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,M) \n
          On entry, the lower triangular M-by-M matrix A.
          On exit, the elements on and below the diagonal of the array
          contain the lower triangular matrix L. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,M). \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,N) \n
          On entry, the pentagonal M-by-N matrix B.  The first N-L columns
          are rectangular, and the last L columns are lower trapezoidal.
          On exit, B contains the pentagonal matrix V.  See Further Details. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,M). \n
 * @param[out] T
          T is REAL array, dimension (LDT,N) \n
          The lower triangular block reflectors stored in compact form
          as a sequence of upper triangular blocks.  See Further Details. \n
 * @param[in] LDT
          LDT is INTEGER \n
          The leading dimension of the array T.  LDT >= MB. \n
 * @param[out] WORK
          WORK is REAL array, dimension (MB*M) \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer tplqt(integer *m, integer *n, integer *l, integer *mb, T *a, integer *lda, T *b, integer *ldb, T *t, integer *ldt, T *work, integer *info)
{
  return tplqt(m, n, l, mb, a, lda, b, ldb, t, ldt, work, info);
}

/*! @brief TPLQT2 computes a LQ factorization of a real or complex "triangular-pentagonal" matrix

 * @details
 * \b Purpose:
    \verbatim 
    TPLQT2 computes a LQ a factorization of a real "triangular-pentagonal"
    matrix C, which is composed of a triangular block A and pentagonal block B,
    using the compact WY representation for Q.
    \endverbatim  

 * @param[in] M
          M is INTEGER \n
          The total number of rows of the matrix B.
          M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix B, and the order of
          the triangular matrix A.
          N >= 0. \n
 * @param[in] L
          L is INTEGER \n
          The number of rows of the lower trapezoidal part of B.
          MIN(M,N) >= L >= 0.  See Further Details. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,M) \n
          On entry, the lower triangular M-by-M matrix A. \n
          On exit, the elements on and below the diagonal of the array
          contain the lower triangular matrix L. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,M). \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,N) \n
          On entry, the pentagonal M-by-N matrix B.  The first N-L columns
          are rectangular, and the last L columns are lower trapezoidal. \n
          On exit, B contains the pentagonal matrix V.  See Further Details. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,M). \n
 * @param[out] T
          T is REAL array, dimension (LDT,M) \n
          The N-by-N upper triangular factor T of the block reflector.
          See Further Details. \n
 * @param[in] LDT
          LDT is INTEGER \n
          The leading dimension of the array T.  LDT >= max(1,M) \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer tplqt2(integer *m, integer *n, integer *l, T *a, integer *lda, T *b, integer *ldb, T *t, integer *ldt, integer * info)
{
  return tplqt2(m, n, l, a, lda, b, ldb, t, ldt, info);
}

/*! @brief TPMLQT applies a real orthogonal matrix Q obtained from a "triangular-pentagonal" real block reflector

 * @details
 * \b Purpose:
    \verbatim 
    TPMLQT applies a real orthogonal matrix Q obtained from a
    "triangular-pentagonal" real block reflector H to a general
    real matrix C, which consists of two blocks A and B.
    \endverbatim 

 * @param[in] SIDE
          SIDE is CHARACTER*1 \n
          = 'L': apply Q or Q**T from the Left; \n
          = 'R': apply Q or Q**T from the Right. \n
 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          = 'N':  No transpose, apply Q; \n
          = 'T':  Transpose, apply Q**T. \n
 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix B. M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix B. N >= 0. \n
 * @param[in] K
          K is INTEGER \n
          The number of elementary reflectors whose product defines
          the matrix Q. \n
 * @param[in] L
          L is INTEGER \n
          The order of the trapezoidal part of V.
          K >= L >= 0.  See Further Details. \n
 * @param[in] MB
          MB is INTEGER \n
          The block size used for the storage of T.  K >= MB >= 1.
          This must be the same value of MB used to generate T
          in DTPLQT. \n
 * @param[in] V
          V is REAL array, dimension (LDV,K) \n
          The i-th row must contain the vector which defines the
          elementary reflector H(i), for i = 1,2,...,k, as   returned by
          DTPLQT in B.  See Further Details. \n
 * @param[in] LDV
          LDV is INTEGER \n
          The leading dimension of the array V. \n
          If SIDE = 'L', LDV >= max(1,M); \n
          if SIDE = 'R', LDV >= max(1,N). \n
 * @param[in] T
          T is REAL array, dimension (LDT,K) \n
          The upper triangular factors of the block reflectors
          as   returned by DTPLQT, stored as a MB-by-K matrix. \n
 * @param[in] LDT
          LDT is INTEGER \n
          The leading dimension of the array T.  LDT >= MB. \n
 * @param[in,out] A
          A is REAL array, dimension
          (LDA,N) if SIDE = 'L' or
          (LDA,K) if SIDE = 'R' \n
          On entry, the K-by-N or M-by-K matrix A. \n
          On exit, A is overwritten by the corresponding block of
          Q*C or Q**T*C or C*Q or C*Q**T.  See Further Details. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A. \n
          If SIDE = 'L', LDC >= max(1,K); \n
          If SIDE = 'R', LDC >= max(1,M). \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,N) \n
          On entry, the M-by-N matrix B. \n
          On exit, B is overwritten by the corresponding block of
          Q*C or Q**T*C or C*Q or C*Q**T.  See Further Details. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.
          LDB >= max(1,M). \n
 * @param[out] WORK
          WORK is REAL array. The dimension of WORK is
           N*MB if SIDE = 'L', or  M*MB if SIDE = 'R'. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer tpmlqt(char *side, char *trans, integer *m, integer *n, integer *k, integer *l, integer *mb, T *v, integer *ldv, T *t, integer *ldt, T *a, integer *lda, T *b, integer *ldb, T * work, integer *info)
{
  return tpmlqt(side, trans, m, n, k, l, mb, v, ldv, t, ldt, a, lda, b, ldb, work, info);
}

/*! @brief TREVC3 computes some or all of the right and/or left eigenvectors \n
     of a real upper quasi-triangular matrix T

 * @details
 * \b Purpose:
    \verbatim 
    TREVC3 computes some or all of the right and/or left eigenvectors of
    a complex upper triangular matrix T.
    Matrices of this type are produced by the Schur factorization of
    a complex general matrix:  A = Q*T*Q**H, as computed by CHSEQR.

    The right eigenvector x and the left eigenvector y of T corresponding
    to an eigenvalue w are defined by:

                 T*x = w*x,    (y**H)*T = w*(y**H)

    where y**H denotes the conjugate transpose of the vector y.
    The eigenvalues are not input to this routine, but are read directly
    from the diagonal of T.

    This routine   returns the matrices X and/or Y of right and left
    eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
    input matrix. If Q is the unitary factor that reduces a matrix A to
    Schur form T, then Q*X and Q*Y are the matrices of right and left
    eigenvectors of A.

    This uses a Level 3 BLAS version of the back transformation.
    \endverbatim 

 * @param[in] SIDE
          SIDE is CHARACTER*1 \n
          = 'R':  compute right eigenvectors only; \n
          = 'L':  compute left eigenvectors only; \n
          = 'B':  compute both right and left eigenvectors. \n
 * @param[in] HOWMNY
          HOWMNY is CHARACTER*1 \n
          = 'A':  compute all right and/or left eigenvectors; \n
          = 'B':  compute all right and/or left eigenvectors,
                  backtransformed using the matrices supplied in
                  VR and/or VL; \n
          = 'S':  compute selected right and/or left eigenvectors,
                  as indicated by the logical array SELECT. \n
 * @param[in] SELECT
          SELECT is LOGICAL array, dimension (N) \n
          If HOWMNY = 'S', SELECT specifies the eigenvectors to be
          computed. \n
          The eigenvector corresponding to the j-th eigenvalue is
          computed if SELECT(j) = .TRUE..
          Not referenced if HOWMNY = 'A' or 'B'. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix T. N >= 0. \n
 * @param[in,out] T
          T is COMPLEX array, dimension (LDT,N) \n
          The upper triangular matrix T.  T is modified, but restored
          on exit. \n
 * @param[in] LDT
          LDT is INTEGER \n
          The leading dimension of the array T. LDT >= max(1,N). \n
 * @param[in,out] VL
          VL is COMPLEX array, dimension (LDVL,MM) \n
          On entry, if SIDE = 'L' or 'B' and HOWMNY = 'B', VL must
          contain an N-by-N matrix Q (usually the unitary matrix Q of
          Schur vectors   returned by CHSEQR). \n
          On exit, if SIDE = 'L' or 'B', VL contains: \n
          if HOWMNY = 'A', the matrix Y of left eigenvectors of T; \n
          if HOWMNY = 'B', the matrix Q*Y; \n
          if HOWMNY = 'S', the left eigenvectors of T specified by
                           SELECT, stored consecutively in the columns
                           of VL, in the same order as their
                           eigenvalues. \n
          Not referenced if SIDE = 'R'. \n
 * @param[in] LDVL
          LDVL is INTEGER \n
          The leading dimension of the array VL. \n
          LDVL >= 1, and if SIDE = 'L' or 'B', LDVL >= N. \n
 * @param[in,out] VR
          VR is COMPLEX array, dimension (LDVR,MM) \n
          On entry, if SIDE = 'R' or 'B' and HOWMNY = 'B', VR must
          contain an N-by-N matrix Q (usually the unitary matrix Q of
          Schur vectors   returned by CHSEQR). \n
          On exit, if SIDE = 'R' or 'B', VR contains: \n
          if HOWMNY = 'A', the matrix X of right eigenvectors of T; \n
          if HOWMNY = 'B', the matrix Q*X; \n
          if HOWMNY = 'S', the right eigenvectors of T specified by
                           SELECT, stored consecutively in the columns
                           of VR, in the same order as their
                           eigenvalues. \n
          Not referenced if SIDE = 'L'. \n
 * @param[in] LDVR
          LDVR is INTEGER \n
          The leading dimension of the array VR. \n
          LDVR >= 1, and if SIDE = 'R' or 'B', LDVR >= N. \n
 * @param[in] MM
          MM is INTEGER \n
          The number of columns in the arrays VL and/or VR. MM >= M. \n
 * @param[out] M
          M is INTEGER \n
          The number of columns in the arrays VL and/or VR actually
          used to store the eigenvectors. \n
          If HOWMNY = 'A' or 'B', M is set to N.
          Each selected eigenvector occupies one column. \n
 * @param[out] WORK
          WORK is COMPLEX array, dimension (MAX(1,LWORK)) \n
 * @param[in] LWORK
          LWORK is INTEGER \n
          The dimension of array WORK. LWORK >= max(1,2*N). \n
          For optimum performance, LWORK >= N + 2*N*NB, where NB is
          the optimal blocksize. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array,   returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out] RWORK
          RWORK is REAL array, dimension (LRWORK) \n
 * @param[in] LRWORK
          LRWORK is INTEGER \n
          The dimension of array RWORK. LRWORK >= max(1,N). \n
 \n
          If LRWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the RWORK array,   returns
          this value as the first entry of the RWORK array, and no error
          message related to LRWORK is issued by XERBLA. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer trevc3(char *side, char *howmny, logical *select, integer *n, T *t, integer *ldt, T *vl, integer *ldvl, T *vr, integer *ldvr, integer *mm, integer *m, T *work, integer *lwork, integer *info)
{
  return trevc3(side, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m, work, lwork, info);
}
template< typename T, typename Ta >
integer trevc3(char *side, char *howmny, logical *select, integer *n, T *t, integer *ldt, T *vl, integer *ldvl, T *vr, integer *ldvr, integer *mm, integer *m, T *work, integer *lwork, Ta *rwork, integer *lrwork, integer *info)
{
  return trevc3(side, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m, work, lwork, rwork, lrwork, info);
}

/*! @brief ORBDB1 simultaneously bidiagonalizes the blocks of a tall and skinny \n
     matrix X with orthonomal columns
 * @details
 * \b Purpose:
    \verbatim 
    ORBDB1 simultaneously bidiagonalizes the blocks of a tall and skinny
    matrix X with orthonomal columns:

                               [ B11 ]
         [ X11 ]   [ P1 |    ] [  0  ]
         [-----] = [---------] [-----] Q1**T .
         [ X21 ]   [    | P2 ] [ B21 ]
                               [  0  ]

    X11 is P-by-Q, and X21 is (M-P)-by-Q. Q must be no larger than P,
    M-P, or M-Q. Routines SORBDB2, SORBDB3, and SORBDB4 handle cases in
    which Q is not the minimum dimension.

    The orthogonal matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P),
    and (M-Q)-by-(M-Q), respectively. They are represented implicitly by
    Householder vectors.

    B11 and B12 are Q-by-Q bidiagonal matrices represented implicitly by
    angles THETA, PHI.
    \endverbatim 

 * @param[in] M
          M is INTEGER \n
          The number of rows X11 plus the number of rows in X21. \n
 * @param[in] P
          P is INTEGER \n
          The number of rows in X11. 0 <= P <= M. \n
 * @param[in] Q
          Q is INTEGER \n
          The number of columns in X11 and X21. 0 <= Q <=
          MIN(P,M-P,M-Q). \n
 * @param[in,out] X11
          X11 is REAL array, dimension (LDX11,Q) \n
          On entry, the top block of the matrix X to be reduced. On
          exit, the columns of tril(X11) specify reflectors for P1 and
          the rows of triu(X11,1) specify reflectors for Q1. \n
 * @param[in] LDX11
          LDX11 is INTEGER \n
          The leading dimension of X11. LDX11 >= P. \n
 * @param[in,out] X21
          X21 is REAL array, dimension (LDX21,Q) \n
          On entry, the bottom block of the matrix X to be reduced. On
          exit, the columns of tril(X21) specify reflectors for P2. \n
 * @param[in] LDX21
          LDX21 is INTEGER \n
          The leading dimension of X21. LDX21 >= M-P. \n
 * @param[out] THETA
          THETA is REAL array, dimension (Q) \n
          The entries of the bidiagonal blocks B11, B21 are defined by
          THETA and PHI. See Further Details. \n
 * @param[out] PHI
          PHI is REAL array, dimension (Q-1) \n
          The entries of the bidiagonal blocks B11, B21 are defined by
          THETA and PHI. See Further Details. \n
 * @param[out] TAUP1
          TAUP1 is REAL array, dimension (P) \n
          The scalar factors of the elementary reflectors that define
          P1. \n
 * @param[out] TAUP2
          TAUP2 is REAL array, dimension (M-P) \n
          The scalar factors of the elementary reflectors that define
          P2. \n
 * @param[out] TAUQ1
          TAUQ1 is REAL array, dimension (Q) \n
          The scalar factors of the elementary reflectors that define
          Q1. \n
 * @param[out] WORK
          WORK is REAL array, dimension (LWORK) \n
 * @param[in] LWORK
          LWORK is INTEGER \n
          The dimension of the array WORK. LWORK >= M-Q.
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array,   returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer orbdb1(integer *m, integer *p, integer *q, T *x11, integer *ldx11, T *x21, integer *ldx21, T *theta, T *phi, T *taup1, T *taup2, T *tauq1, T *work, integer *lwork, integer *info)
{
  return orbdb1(m, p, q, x11, ldx11, x21, ldx21, theta, phi, taup1, taup2, tauq1, work, lwork, info);
}
template< typename T, typename Ta >
integer unbdb1(integer *m, integer *p, integer *q, T *x11, integer *ldx11, T *x21, integer *ldx21, Ta *theta, Ta *phi, T *taup1, T *taup2, T *tauq1, T *work, integer *lwork, integer *info)
{
  return unbdb1(m, p, q, x11, ldx11, x21, ldx21, theta, phi, taup1, taup2, tauq1, work, lwork, info);
}

/*! @brief ORBDB2 simultaneously bidiagonalizes the blocks of a tall and skinny  \n
     matrix X with orthonomal columns
 * @details
 * \b Purpose:
    \verbatim 
    ORBDB2 simultaneously bidiagonalizes the blocks of a tall and skinny
    matrix X with orthonomal columns:

                               [ B11 ]
         [ X11 ]   [ P1 |    ] [  0  ]
         [-----] = [---------] [-----] Q1**T .
         [ X21 ]   [    | P2 ] [ B21 ]
                               [  0  ]

    X11 is P-by-Q, and X21 is (M-P)-by-Q. P must be no larger than M-P,
    Q, or M-Q. Routines SORBDB1, SORBDB3, and SORBDB4 handle cases in
    which P is not the minimum dimension.

    The orthogonal matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P),
    and (M-Q)-by-(M-Q), respectively. They are represented implicitly by
    Householder vectors.

    B11 and B12 are P-by-P bidiagonal matrices represented implicitly by
    angles THETA, PHI.
    \endverbatim 

 * @param[in] M
          M is INTEGER \n
          The number of rows X11 plus the number of rows in X21. \n
 * @param[in] P
          P is INTEGER \n
          The number of rows in X11. 0 <= P <= min(M-P,Q,M-Q). \n
 * @param[in] Q
          Q is INTEGER \n
          The number of columns in X11 and X21. 0 <= Q <= M. \n
 * @param[in,out] X11
          X11 is REAL array, dimension (LDX11,Q) \n
          On entry, the top block of the matrix X to be reduced. On
          exit, the columns of tril(X11) specify reflectors for P1 and
          the rows of triu(X11,1) specify reflectors for Q1. \n
 * @param[in] LDX11
          LDX11 is INTEGER \n
          The leading dimension of X11. LDX11 >= P. \n
 * @param[in,out] X21
          X21 is REAL array, dimension (LDX21,Q) \n
          On entry, the bottom block of the matrix X to be reduced. On
          exit, the columns of tril(X21) specify reflectors for P2. \n
 * @param[in] LDX21
          LDX21 is INTEGER \n
          The leading dimension of X21. LDX21 >= M-P. \n
 * @param[out] THETA
          THETA is REAL array, dimension (Q) \n
          The entries of the bidiagonal blocks B11, B21 are defined by
          THETA and PHI. See Further Details. \n
 * @param[out] PHI
          PHI is REAL array, dimension (Q-1) \n
          The entries of the bidiagonal blocks B11, B21 are defined by
          THETA and PHI. See Further Details. \n
 * @param[out] TAUP1
          TAUP1 is REAL array, dimension (P) \n
          The scalar factors of the elementary reflectors that define
          P1. \n
 * @param[out] TAUP2
          TAUP2 is REAL array, dimension (M-P) \n
          The scalar factors of the elementary reflectors that define
          P2. \n
 * @param[out] TAUQ1
          TAUQ1 is REAL array, dimension (Q) \n
          The scalar factors of the elementary reflectors that define
          Q1. \n
 * @param[out] WORK
          WORK is REAL array, dimension (LWORK) \n
 * @param[in] LWORK
          LWORK is INTEGER \n
          The dimension of the array WORK. LWORK >= M-Q.
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array,   returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, the i-th argument had an illegal value.  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer orbdb2(integer *m, integer *p, integer *q, T *x11, integer *ldx11, T *x21, integer *ldx21, T *theta, T *phi, T *taup1, T *taup2, T *tauq1, T *work, integer *lwork, integer *info)
{
  return orbdb2(m, p, q, x11, ldx11, x21, ldx21, theta, phi, taup1, taup2, tauq1, work, lwork, info);
}
template< typename T, typename Ta >
integer unbdb2(integer *m, integer *p, integer *q, T *x11, integer *ldx11, T *x21, integer *ldx21, Ta *theta, Ta *phi, T *taup1, T *taup2, T *tauq1, T *work, integer *lwork, integer *info)
{
  return unbdb2(m, p, q, x11, ldx11, x21, ldx21, theta, phi, taup1, taup2, tauq1, work, lwork, info);
}

/*! @brief ORBDB3 simultaneously bidiagonalizes the blocks of a tall and skinny  \n
     matrix X with orthonomal columns
 * @details
 * \b Purpose:
    \verbatim 
    ORBDB3 simultaneously bidiagonalizes the blocks of a tall and skinny
    matrix X with orthonomal columns:

                               [ B11 ]
         [ X11 ]   [ P1 |    ] [  0  ]
         [-----] = [---------] [-----] Q1**T .
         [ X21 ]   [    | P2 ] [ B21 ]
                               [  0  ]

    X11 is P-by-Q, and X21 is (M-P)-by-Q. M-P must be no larger than P,
    Q, or M-Q. Routines SORBDB1, SORBDB2, and SORBDB4 handle cases in
    which M-P is not the minimum dimension.

    The orthogonal matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P),
    and (M-Q)-by-(M-Q), respectively. They are represented implicitly by
    Householder vectors.

    B11 and B12 are (M-P)-by-(M-P) bidiagonal matrices represented
    implicitly by angles THETA, PHI.
    \endverbatim

 * @param[in] M
          M is INTEGER \n
          The number of rows X11 plus the number of rows in X21. \n
 * @param[in] P
          P is INTEGER \n
          The number of rows in X11. 0 <= P <= M. M-P <= min(P,Q,M-Q). \n
 * @param[in] Q
          Q is INTEGER \n
          The number of columns in X11 and X21. 0 <= Q <= M. \n
 * @param[in,out] X11
          X11 is REAL array, dimension (LDX11,Q) \n
          On entry, the top block of the matrix X to be reduced. On
          exit, the columns of tril(X11) specify reflectors for P1 and
          the rows of triu(X11,1) specify reflectors for Q1. \n
 * @param[in] LDX11
          LDX11 is INTEGER \n
          The leading dimension of X11. LDX11 >= P. \n
 * @param[in,out] X21
          X21 is REAL array, dimension (LDX21,Q) \n
          On entry, the bottom block of the matrix X to be reduced. On
          exit, the columns of tril(X21) specify reflectors for P2. \n
 * @param[in] LDX21
          LDX21 is INTEGER \n
          The leading dimension of X21. LDX21 >= M-P. \n
 * @param[out] THETA
          THETA is REAL array, dimension (Q) \n
          The entries of the bidiagonal blocks B11, B21 are defined by
          THETA and PHI. See Further Details. \n
 * @param[out] PHI
          PHI is REAL array, dimension (Q-1) \n
          The entries of the bidiagonal blocks B11, B21 are defined by
          THETA and PHI. See Further Details. \n
 * @param[out] TAUP1
          TAUP1 is REAL array, dimension (P) \n
          The scalar factors of the elementary reflectors that define
          P1. \n
 * @param[out] TAUP2
          TAUP2 is REAL array, dimension (M-P) \n
          The scalar factors of the elementary reflectors that define
          P2. \n
 * @param[out] TAUQ1
          TAUQ1 is REAL array, dimension (Q) \n
          The scalar factors of the elementary reflectors that define
          Q1. \n
 * @param[out] WORK
          WORK is REAL array, dimension (LWORK) \n
 * @param[in] LWORK
          LWORK is INTEGER \n
          The dimension of the array WORK. LWORK >= M-Q.
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array,   returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer orbdb3(integer *m, integer *p, integer *q, T *x11, integer *ldx11, T *x21, integer *ldx21, T *theta, T *phi, T *taup1, T *taup2, T *tauq1, T *work, integer *lwork, integer *info)
{
  return orbdb3(m, p, q, x11, ldx11, x21, ldx21, theta, phi, taup1, taup2, tauq1, work, lwork, info);
}
template< typename T, typename Ta >
integer unbdb3(integer *m, integer *p, integer *q, T *x11, integer *ldx11, T *x21, integer *ldx21, Ta *theta, Ta *phi, T *taup1, T *taup2, T *tauq1, T *work, integer *lwork, integer *info)
{
  return unbdb3(m, p, q, x11, ldx11, x21, ldx21, theta, phi, taup1, taup2, tauq1, work, lwork, info);
}

/*! @brief ORBDB4 simultaneously bidiagonalizes the blocks of a tall and skinny \n
     matrix X with orthonomal columns
 * @details
 * \b Purpose:
    \verbatim 
    ORBDB4 simultaneously bidiagonalizes the blocks of a tall and skinny
    matrix X with orthonomal columns:

                               [ B11 ]
         [ X11 ]   [ P1 |    ] [  0  ]
         [-----] = [---------] [-----] Q1**T .
         [ X21 ]   [    | P2 ] [ B21 ]
                               [  0  ]

    X11 is P-by-Q, and X21 is (M-P)-by-Q. M-Q must be no larger than P,
    M-P, or Q. Routines SORBDB1, SORBDB2, and SORBDB3 handle cases in
    which M-Q is not the minimum dimension.

    The orthogonal matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P),
    and (M-Q)-by-(M-Q), respectively. They are represented implicitly by
    Householder vectors.

    B11 and B12 are (M-Q)-by-(M-Q) bidiagonal matrices represented
    implicitly by angles THETA, PHI.
    \endverbatim 

 * @param[in] M
          M is INTEGER \n
          The number of rows X11 plus the number of rows in X21. \n
 * @param[in] P
          P is INTEGER \n
          The number of rows in X11. 0 <= P <= M. \n
 * @param[in] Q
          Q is INTEGER \n
          The number of columns in X11 and X21. 0 <= Q <= M and
          M-Q <= min(P,M-P,Q). \n
 * @param[in,out] X11
          X11 is REAL array, dimension (LDX11,Q) \n
          On entry, the top block of the matrix X to be reduced. On
          exit, the columns of tril(X11) specify reflectors for P1 and
          the rows of triu(X11,1) specify reflectors for Q1. \n
 * @param[in] LDX11
          LDX11 is INTEGER \n
          The leading dimension of X11. LDX11 >= P. \n
 * @param[in,out] X21
          X21 is REAL array, dimension (LDX21,Q) \n
          On entry, the bottom block of the matrix X to be reduced. On
          exit, the columns of tril(X21) specify reflectors for P2. \n
 * @param[in] LDX21
          LDX21 is INTEGER \n
          The leading dimension of X21. LDX21 >= M-P. \n
 * @param[out] THETA
          THETA is REAL array, dimension (Q) \n
          The entries of the bidiagonal blocks B11, B21 are defined by
          THETA and PHI. See Further Details. \n
 * @param[out] PHI
          PHI is REAL array, dimension (Q-1) \n
          The entries of the bidiagonal blocks B11, B21 are defined by
          THETA and PHI. See Further Details. \n
 * @param[out] TAUP1
          TAUP1 is REAL array, dimension (P) \n
          The scalar factors of the elementary reflectors that define
          P1. \n
 * @param[out] TAUP2
          TAUP2 is REAL array, dimension (M-P) \n
          The scalar factors of the elementary reflectors that define
          P2. \n
 * @param[out] TAUQ1
          TAUQ1 is REAL array, dimension (Q) \n
          The scalar factors of the elementary reflectors that define
          Q1. \n
 * @param[out] PHANTOM
          PHANTOM is REAL array, dimension (M) \n
          The routine computes an M-by-1 column vector Y that is
          orthogonal to the columns of [ X11; X21 ]. PHANTOM(1:P) and
          PHANTOM(P+1:M) contain Householder vectors for Y(1:P) and
          Y(P+1:M), respectively. \n
 * @param[out] WORK
          WORK is REAL array, dimension (LWORK) \n
 * @param[in] LWORK
          LWORK is INTEGER \n
          The dimension of the array WORK. LWORK >= M-Q.
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array,   returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer orbdb4(integer *m, integer *p, integer *q, T *x11, integer *ldx11, T *x21, integer *ldx21, T *theta, T *phi, T *taup1, T *phantom, T *taup2, T *tauq1, T *work, integer *lwork, integer *info)
{
  return orbdb4(m, p, q, x11, ldx11, x21, ldx21, theta, phi, taup1, taup2, tauq1, phantom, work, lwork, info);
}
template< typename T, typename Ta >
integer unbdb4(integer *m, integer *p, integer *q, T *x11, integer *ldx11, T *x21, integer *ldx21, Ta *theta, Ta *phi, T *taup1, T *phantom, T *taup2, T *tauq1, T *work, integer *lwork, integer *info)
{
  return unbdb4(m, p, q, x11, ldx11, x21, ldx21, theta, phi, taup1, taup2, tauq1, phantom, work, lwork, info);
}

/*! @brief ORBDB5 orthogonalizes the column vector

 * @details
 * \b Purpose:
    \verbatim 
    ORBDB5 orthogonalizes the column vector
         X = [ X1 ]
             [ X2 ]
    with respect to the columns of
         Q = [ Q1 ] .
             [ Q2 ]
    The columns of Q must be orthonormal.

    If the projection is zero according to Kahan's "twice is enough"
    criterion, then some other vector from the orthogonal complement
    is   returned. This vector is chosen in an arbitrary but deterministic
    way.
    \endverbatim

 * @param[in] M1
          M1 is INTEGER \n
          The dimension of X1 and the number of rows in Q1. 0 <= M1. \n
 * @param[in] M2
          M2 is INTEGER \n
          The dimension of X2 and the number of rows in Q2. 0 <= M2. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns in Q1 and Q2. 0 <= N. \n
 * @param[in,out] X1
          X1 is REAL array, dimension (M1) \n
          On entry, the top part of the vector to be orthogonalized.
          On exit, the top part of the projected vector. \n
 * @param[in] INCX1
          INCX1 is INTEGER \n
          Increment for entries of X1. \n
 * @param[in,out] X2
          X2 is REAL array, dimension (M2) \n
          On entry, the bottom part of the vector to be
          orthogonalized. On exit, the bottom part of the projected
          vector. \n
 * @param[in] INCX2
          INCX2 is INTEGER \n
          Increment for entries of X2. \n
 * @param[in] Q1
          Q1 is REAL array, dimension (LDQ1, N) \n
          The top part of the orthonormal basis matrix. \n
 * @param[in] LDQ1
          LDQ1 is INTEGER \n
          The leading dimension of Q1. LDQ1 >= M1. \n
 * @param[in] Q2
          Q2 is REAL array, dimension (LDQ2, N) \n
          The bottom part of the orthonormal basis matrix. \n
 * @param[in] LDQ2
          LDQ2 is INTEGER \n
          The leading dimension of Q2. LDQ2 >= M2. \n
 * @param[out] WORK
          WORK is REAL array, dimension (LWORK) \n
 * @param[in] LWORK
          LWORK is INTEGER \n
          The dimension of the array WORK. LWORK >= N. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer orbdb5(integer *m1, integer *m2, integer *n, T *x1, integer *incx1, T *x2, integer *incx2, T *q1, integer *ldq1, T *q2, integer *ldq2, T *work, integer *lwork, integer *info)
{
  return orbdb5(m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2, ldq2, work, lwork, info);
}
template< typename T >
integer unbdb5(integer *m1, integer *m2, integer *n, T *x1, integer *incx1, T *x2, integer *incx2, T *q1, integer *ldq1, T *q2, integer *ldq2, T *work, integer *lwork, integer *info)
{
  return unbdb5(m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2, ldq2, work, lwork, info);
}

/*! @brief ORBDB6 orthogonalizes the column vector

 * @details
 * \b Purpose:
    \verbatim 
    ORBDB6 orthogonalizes the column vector
         X = [ X1 ]
             [ X2 ]
    with respect to the columns of
         Q = [ Q1 ] .
             [ Q2 ]
    The columns of Q must be orthonormal.

    If the projection is zero according to Kahan's "twice is enough"
    criterion, then the zero vector is   returned.
    \endverbatim 

 * @param[in] M1
          M1 is INTEGER \n
          The dimension of X1 and the number of rows in Q1. 0 <= M1. \n
 * @param[in] M2
          M2 is INTEGER \n
          The dimension of X2 and the number of rows in Q2. 0 <= M2. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns in Q1 and Q2. 0 <= N. \n
 * @param[in,out] X1
          X1 is REAL array, dimension (M1) \n
          On entry, the top part of the vector to be orthogonalized.
          On exit, the top part of the projected vector. \n
 * @param[in] INCX1
          INCX1 is INTEGER \n
          Increment for entries of X1. \n
 * @param[in,out] X2
          X2 is REAL array, dimension (M2) \n
          On entry, the bottom part of the vector to be
          orthogonalized. On exit, the bottom part of the projected
          vector. \n
 * @param[in] INCX2
          INCX2 is INTEGER \n
          Increment for entries of X2. \n
 * @param[in] Q1
          Q1 is REAL array, dimension (LDQ1, N) \n
          The top part of the orthonormal basis matrix. \n
 * @param[in] LDQ1
          LDQ1 is INTEGER \n
          The leading dimension of Q1. LDQ1 >= M1. \n
 * @param[in] Q2
          Q2 is REAL array, dimension (LDQ2, N) \n
          The bottom part of the orthonormal basis matrix. \n
 * @param[in] LDQ2
          LDQ2 is INTEGER \n
          The leading dimension of Q2. LDQ2 >= M2. \n
 * @param[out] WORK
          WORK is REAL array, dimension (LWORK) \n
 * @param[in] LWORK
          LWORK is INTEGER \n
          The dimension of the array WORK. LWORK >= N. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer orbdb6(integer *m1, integer *m2, integer *n, T *x1, integer *incx1, T *x2, integer *incx2, T *q1, integer *ldq1, T *q2, integer *ldq2, T *work, integer *lwork, integer *info)
{
  return orbdb6(m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2, ldq2, work, lwork, info);
}
template< typename T >
integer unbdb6(integer *m1, integer *m2, integer *n, T *x1, integer *incx1, T *x2, integer *incx2, T *q1, integer *ldq1, T *q2, integer *ldq2, T *work, integer *lwork, integer *info)
{
  return unbdb6(m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2, ldq2, work, lwork, info);
}

/*! @brief ORG2L generates all or part of the orthogonal matrix Q from a QL factorization determined by sgeqlf.

 * @details
 * \b Purpose:
    \verbatim 
    ORG2L generates an m by n real matrix Q with orthonormal columns,
    which is defined as the last n columns of a product of k elementary
    reflectors of order m

          Q  =  H(k) . . . H(2) H(1)

    as   returned by GEQLF.
    \endverbatim 

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix Q. M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix Q. M >= N >= 0. \n
 * @param[in] K
          K is INTEGER \n
          The number of elementary reflectors whose product defines the
          matrix Q. N >= K >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the (n-k+i)-th column must contain the vector which
          defines the elementary reflector H(i), for i = 1,2,...,k, as
          returned by SGEQLF in the last k columns of its array
          argument A. \n
          On exit, the m by n matrix Q. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The first dimension of the array A. LDA >= max(1,M). \n
 * @param[in] TAU
          TAU is REAL array, dimension (K) \n
          TAU(i) must contain the scalar factor of the elementary
          reflector H(i), as   returned by SGEQLF. \n
 * @param[out] WORK
          WORK is REAL array, dimension (N) \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument has an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer org2l(integer *m, integer *n, integer *k, T *a, integer *lda, T *tau, T *work, integer *info)
{
  return org2l(m, n, k, a, lda, tau, work, info);
}
template< typename T >
integer ung2l(integer *m, integer *n, integer *k, T *a, integer *lda, T *tau, T *work, integer *info)
{
  return ung2l(m, n, k, a, lda, tau, work, info);
}

/*! @brief ORG2R generates all or part of the orthogonal matrix Q from a QR factorization determined by sgeqrf.

 * @details
 * \b Purpose:
    \verbatim 
    ORG2R generates an m by n real matrix Q with orthonormal columns,
    which is defined as the first n columns of a product of k elementary
    reflectors of order m

          Q  =  H(1) H(2) . . . H(k)

    as   returned by GEQRF.
    \endverbatim  

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix Q. M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix Q. M >= N >= 0. \n
 * @param[in] K
          K is INTEGER \n
          The number of elementary reflectors whose product defines the
          matrix Q. N >= K >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the i-th column must contain the vector which
          defines the elementary reflector H(i), for i = 1,2,...,k, as
          returned by SGEQRF in the first k columns of its array
          argument A. \n
          On exit, the m-by-n matrix Q. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The first dimension of the array A. LDA >= max(1,M). \n
 * @param[in] TAU
          TAU is REAL array, dimension (K) \n
          TAU(i) must contain the scalar factor of the elementary
          reflector H(i), as   returned by SGEQRF. \n
 * @param[out] WORK
          WORK is REAL array, dimension (N) \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument has an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer org2r(integer *m, integer *n, integer *k, T *a, integer *lda, T *tau, T *work, integer *info)
{
  return org2r(m, n, k, a, lda, tau, work, info);
}
template< typename T >
integer ung2r(integer *m, integer *n, integer *k, T *a, integer *lda, T *tau, T *work, integer *info)
{
  return ung2r(m, n, k, a, lda, tau, work, info);
}

/*! @brief ORGL2 generates an m by n real matrix Q with orthonormal rows

 * @details
 * \b Purpose:
    \verbatim 
    ORGL2 generates an m by n real matrix Q with orthonormal rows,
    which is defined as the first m rows of a product of k elementary
    reflectors of order n

          Q  =  H(k) . . . H(2) H(1)

    as   returned by GELQF.
    \endverbatim  
 
 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix Q. M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix Q. N >= M. \n
 * @param[in] K
          K is INTEGER \n
          The number of elementary reflectors whose product defines the
          matrix Q. M >= K >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the i-th row must contain the vector which defines
          the elementary reflector H(i), for i = 1,2,...,k, as   returned
          by SGELQF in the first k rows of its array argument A. \n
          On exit, the m-by-n matrix Q. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The first dimension of the array A. LDA >= max(1,M). \n
 * @param[in] TAU
          TAU is REAL array, dimension (K) \n
          TAU(i) must contain the scalar factor of the elementary
          reflector H(i), as   returned by SGELQF. \n
 * @param[out] WORK
          WORK is REAL array, dimension (M) \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument has an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer orgl2(integer *m, integer *n, integer *k, T *a, integer *lda, T *tau, T *work, integer *info)
{
  return orgl2(m, n, k, a, lda, tau, work, info);
}
template< typename T >
integer ungl2(integer *m, integer *n, integer *k, T *a, integer *lda, T *tau, T *work, integer *info)
{
  return ungl2(m, n, k, a, lda, tau, work, info);
}

/*! @brief ORGR2 generates all or part of the orthogonal matrix Q from an RQ factorization determined by sgerqf

 * @details
 * \b Purpose:
    \verbatim 
    ORGR2 generates an m by n real matrix Q with orthonormal rows,
    which is defined as the last m rows of a product of k elementary
    reflectors of order n

          Q  =  H(1) H(2) . . . H(k)

    as   returned by SGERQF.
    \endverbatim  

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix Q. M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix Q. N >= M. \n
 * @param[in] K
          K is INTEGER \n
          The number of elementary reflectors whose product defines the
          matrix Q. M >= K >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the (m-k+i)-th row must contain the vector which
          defines the elementary reflector H(i), for i = 1,2,...,k, as
          returned by SGERQF in the last k rows of its array argument
          A. \n
          On exit, the m by n matrix Q. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The first dimension of the array A. LDA >= max(1,M). \n
 * @param[in] TAU
          TAU is REAL array, dimension (K) \n
          TAU(i) must contain the scalar factor of the elementary
          reflector H(i), as   returned by SGERQF. \n
 * @param[out] WORK
          WORK is REAL array, dimension (M) \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument has an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer orgr2(integer *m, integer *n, integer *k, T *a, integer *lda, T *tau, T *work, integer *info)
{
  return orgr2(m, n, k, a, lda, tau, work, info);
}
template< typename T >
integer ungr2(integer *m, integer *n, integer *k, T *a, integer *lda, T *tau, T *work, integer *info)
{
  return ungr2(m, n, k, a, lda, tau, work, info);
}

/*! @brief ORGTSQR generates an M-by-N real matrix Q_out with orthonormal columns

 * @details
 * \b Purpose:
    \verbatim 
    ORGTSQR generates an M-by-N real matrix Q_out with orthonormal columns,
    which are the first N columns of a product of real orthogonal
    matrices of order M which are   returned by SLATSQR
   
         Q_out = first_N_columns_of(Q(1)_in * Q(2)_in * ... * Q(k)_in).
   
    See the documentation for LATSQR.
    \endverbatim   

  * @param[in] M
           M is INTEGER \n
           The number of rows of the matrix A.  M >= 0. \n
  * @param[in] N
           N is INTEGER \n
           The number of columns of the matrix A. M >= N >= 0. \n
  * @param[in] MB
           MB is INTEGER \n
           The row block size used by SLATSQR to   return
           arrays A and T. MB > N. \n
           (Note that if MB > M, then M is used instead of MB
           as the row block size). \n
  * @param[in] NB
           NB is INTEGER \n
           The column block size used by SLATSQR to   return
           arrays A and T. NB >= 1. \n
           (Note that if NB > N, then N is used instead of NB
           as the column block size). \n
  * @param[in,out] A
           A is REAL array, dimension (LDA,N) \n
  \n
           On entry:
  \n
              The elements on and above the diagonal are not accessed.
              The elements below the diagonal represent the unit
              lower-trapezoidal blocked matrix V computed by SLATSQR
              that defines the input matrices Q_in(k) (ones on the
              diagonal are not stored) (same format as the output A
              below the diagonal in SLATSQR). \n
  \n
           On exit:
  \n
              The array A contains an M-by-N orthonormal matrix Q_out,
              i.e the columns of A are orthogonal unit vectors. \n
  * @param[in] LDA
           LDA is INTEGER \n
           The leading dimension of the array A.  LDA >= max(1,M). \n
  * @param[in] T
           T is REAL array,
           dimension (LDT, N * NIRB) \n
           where NIRB = Number_of_input_row_blocks \n
                      = MAX(1, CEIL((M-N)/(MB-N))) \n
           Let NICB = Number_of_input_col_blocks \n
                    = CEIL(N/NB) \n
  \n
           The upper-triangular block reflectors used to define the
           input matrices Q_in(k), k=(1:NIRB*NICB). The block
           reflectors are stored in compact form in NIRB block
           reflector sequences. Each of NIRB block reflector sequences
           is stored in a larger NB-by-N column block of T and consists
           of NICB smaller NB-by-NB upper-triangular column blocks.
           (same format as the output T in SLATSQR). \n
  * @param[in] LDT
           LDT is INTEGER \n
           The leading dimension of the array T.
           LDT >= max(1,min(NB1,N)). \n
  * @param[out] WORK
           (workspace) REAL array, dimension (MAX(2,LWORK)) \n
           On exit, if INFO = 0, WORK(1)   returns the optimal LWORK. \n
  * @param[in] LWORK
           The dimension of the array WORK.  LWORK >= (M+NB)*N. \n
           If LWORK = -1, then a workspace query is assumed. \n
           The routine only calculates the optimal size of the WORK
           array,   returns this value as the first entry of the WORK
           array, and no error message related to LWORK is issued
           by XERBLA. \n
  * @param[out] INFO
           INFO is INTEGER \n
           = 0:  successful exit \n
           < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer orgtsqr(integer *m, integer *n, integer *mb, integer * nb, T *a, integer *lda, T *t, integer *ldt, T *work, integer *lwork, integer *info)
{
  return orgtsqr(m, n, mb, nb, a, lda, t, ldt, work, lwork, info);
}
template< typename T >
integer ungtsqr(integer *m, integer *n, integer *mb, integer * nb, T *a, integer *lda, T *t, integer *ldt, T *work, integer *lwork, integer *info)
{
  return ungtsqr(m, n, mb, nb, a, lda, t, ldt, work, lwork, info);
}

/*! @brief ORHR_COL takes an M-by-N real matrix Q_in with orthonormal columns \n
     as input and performs Householder Reconstruction

 * @details
 * \b Purpose:
    \verbatim 
    ORHR_COL takes an M-by-N real matrix Q_in with orthonormal columns
    as input, stored in A, and performs Householder Reconstruction (HR),
    i.e. reconstructs Householder vectors V(i) implicitly representing
    another M-by-N matrix Q_out, with the property that Q_in = Q_out*S,
    where S is an N-by-N diagonal matrix with diagonal entries
    equal to +1 or -1. The Householder vectors (columns V(i) of V) are
    stored in A on output, and the diagonal entries of S are stored in D.
    Block reflectors are also   returned in T
    (same output format as SGEQRT).
    \endverbatim   

  * @param[in] M
           M is INTEGER \n
           The number of rows of the matrix A. M >= 0. \n
  * @param[in] N
           N is INTEGER \n
           The number of columns of the matrix A. M >= N >= 0. \n
  * @param[in] NB
           NB is INTEGER \n
           The column block size to be used in the reconstruction
           of Householder column vector blocks in the array A and
           corresponding block reflectors in the array T. NB >= 1.
           (Note that if NB > N, then N is used instead of NB
           as the column block size.) \n
  * @param[in,out] A
           A is REAL array, dimension (LDA,N) \n
  \n
           On entry:
  \n
              The array A contains an M-by-N orthonormal matrix Q_in,
              i.e the columns of A are orthogonal unit vectors. \n
  \n
           On exit:
  \n
              The elements below the diagonal of A represent the unit
              lower-trapezoidal matrix V of Householder column vectors
              V(i). The unit diagonal entries of V are not stored
              (same format as the output below the diagonal in A from
              SGEQRT). The matrix T and the matrix V stored on output
              in A implicitly define Q_out.
  \n
              The elements above the diagonal contain the factor U
              of the "modified" LU-decomposition: \n
                 Q_in - (S) = V * U \n
                        (0) \n
              where 0 is a (M-N)-by-(M-N) zero matrix. \n
  * @param[in] LDA
           LDA is INTEGER \n
           The leading dimension of the array A.  LDA >= max(1,M). \n
  * @param[out] T
           T is REAL array,
           dimension (LDT, N) \n
  \n
           Let NOCB = Number_of_output_col_blocks \n
                    = CEIL(N/NB) \n
  \n
           On exit, T(1:NB, 1:N) contains NOCB upper-triangular
           block reflectors used to define Q_out stored in compact
           form as a sequence of upper-triangular NB-by-NB column
           blocks (same format as the output T in SGEQRT).
           The matrix T and the matrix V stored on output in A
           implicitly define Q_out. NOTE: The lower triangles
           below the upper-triangular blcoks will be filled with
           zeros. See Further Details. \n
  * @param[in] LDT
           LDT is INTEGER \n
           The leading dimension of the array T.
           LDT >= max(1,min(NB,N)). \n
  * @param[out] D
           D is REAL array, dimension min(M,N). \n
           The elements can be only plus or minus one.
  \n
           D(i) is constructed as D(i) = -SIGN(Q_in_i(i,i)), where
           1 <= i <= min(M,N), and Q_in_i is Q_in after performing
           i-1 steps of modified Gaussian elimination.
           See Further Details. \n
  * @param[out] INFO
           INFO is INTEGER \n
           = 0:  successful exit \n
           < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer orhr_col(integer *m, integer *n, integer *nb, T *a, integer *lda, T *t, integer *ldt, T *d, integer *info)
{
  return orhr_col(m, n, nb, a, lda, t, ldt, d, info);
}
template< typename T >
integer unhr_col(integer *m, integer *n, integer *nb, T *a, integer *lda, T *t, integer *ldt, T *d, integer *info)
{
  return unhr_col(m, n, nb, a, lda, t, ldt, d, info);
}

/*! @brief ORM2L multiplies a general matrix by the orthogonal matrix from a QL factorization determined by sgeqlf

 * @details
 * \b Purpose:
    \verbatim 
    ORM2L overwrites the general real m by n matrix C with

          Q * C  if SIDE = 'L' and TRANS = 'N', or

          Q**T * C  if SIDE = 'L' and TRANS = 'T', or

          C * Q  if SIDE = 'R' and TRANS = 'N', or

          C * Q**T if SIDE = 'R' and TRANS = 'T',

    where Q is a real orthogonal matrix defined as the product of k
    elementary reflectors

          Q = H(k) . . . H(2) H(1)

    as   returned by SGEQLF. Q is of order m if SIDE = 'L' and of order n
    if SIDE = 'R'.
    \endverbatim 

 * @param[in] SIDE
          SIDE is CHARACTER*1 \n
          = 'L': apply Q or Q**T from the Left \n
          = 'R': apply Q or Q**T from the Right \n
 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          = 'N': apply Q  (No transpose) \n
          = 'T': apply Q**T (Transpose) \n
 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix C. M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix C. N >= 0. \n
 * @param[in] K
          K is INTEGER \n
          The number of elementary reflectors whose product defines
          the matrix Q. \n
          If SIDE = 'L', M >= K >= 0; \n
          if SIDE = 'R', N >= K >= 0. \n
 * @param[in] A
          A is REAL array, dimension (LDA,K) \n
          The i-th column must contain the vector which defines the
          elementary reflector H(i), for i = 1,2,...,k, as   returned by
          SGEQLF in the last k columns of its array argument A.
          A is modified by the routine but restored on exit. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A. \n
          If SIDE = 'L', LDA >= max(1,M); \n
          if SIDE = 'R', LDA >= max(1,N). \n
 * @param[in] TAU
          TAU is REAL array, dimension (K) \n
          TAU(i) must contain the scalar factor of the elementary
          reflector H(i), as   returned by SGEQLF. \n
 * @param[in,out] C
          C is REAL array, dimension (LDC,N) \n
          On entry, the m by n matrix C. \n
          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q. \n
 * @param[in] LDC
          LDC is INTEGER \n
          The leading dimension of the array C. LDC >= max(1,M). \n
 * @param[out] WORK
          WORK is REAL array, dimension \n
                                   (N) if SIDE = 'L', \n
                                   (M) if SIDE = 'R' \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer orm2l(char *side, char *trans, integer *m, integer *n, integer *k, T *a, integer *lda, T *tau, T *c, integer *ldc, T *work, integer *info)
{
  return orm2l(side, trans, m, n, k, a, lda, tau, c, ldc, work, info);
}
template< typename T >
integer unm2l(char *side, char *trans, integer *m, integer *n, integer *k, T *a, integer *lda, T *tau, T *c, integer *ldc, T *work, integer *info)
{
  return unm2l(side, trans, m, n, k, a, lda, tau, c, ldc, work, info);
}

/*! @brief ORM22 multiplies a general matrix by a banded orthogonal matrix

 * @details
 * \b Purpose:
    \verbatim 
    ORM22 overwrites the general real M-by-N matrix C with

                    SIDE = 'L'     SIDE = 'R'
    TRANS = 'N':      Q * C          C * Q
    TRANS = 'T':      Q**T * C       C * Q**T

    where Q is a real orthogonal matrix of order NQ, with NQ = M if
    SIDE = 'L' and NQ = N if SIDE = 'R'.
    The orthogonal matrix Q processes a 2-by-2 block structure

           [  Q11  Q12  ]
       Q = [            ]
           [  Q21  Q22  ],

    where Q12 is an N1-by-N1 lower triangular matrix and Q21 is an
    N2-by-N2 upper triangular matrix.
    \endverbatim 

 * @param[in] SIDE
          SIDE is CHARACTER*1 \n
          = 'L': apply Q or Q**T from the Left; \n
          = 'R': apply Q or Q**T from the Right. \n
 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          = 'N':  apply Q (No transpose); \n
          = 'C':  apply Q**T (Conjugate transpose). \n
 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix C. M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix C. N >= 0. \n
 * @param[in] N1
 * @param[in] N2
          N1 is INTEGER \n
          N2 is INTEGER \n
          The dimension of Q12 and Q21, respectively. N1, N2 >= 0.
          The following requirement must be satisfied: \n
          N1 + N2 = M if SIDE = 'L' and N1 + N2 = N if SIDE = 'R'. \n
 * @param[in] Q
          Q is REAL array, dimension \n
                              (LDQ,M) if SIDE = 'L' \n
                              (LDQ,N) if SIDE = 'R' \n
 * @param[in] LDQ
          LDQ is INTEGER \n
          The leading dimension of the array Q. \n
          LDQ >= max(1,M) if SIDE = 'L'; LDQ >= max(1,N) if SIDE = 'R'. \n
 * @param[in,out] C
          C is REAL array, dimension (LDC,N) \n
          On entry, the M-by-N matrix C. \n
          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q. \n
 * @param[in] LDC
          LDC is INTEGER \n
          The leading dimension of the array C. LDC >= max(1,M). \n
 * @param[out] WORK
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1)   returns the optimal LWORK. \n
 * @param[in] LWORK
          LWORK is INTEGER \n
          The dimension of the array WORK. \n
          If SIDE = 'L', LWORK >= max(1,N); \n
          if SIDE = 'R', LWORK >= max(1,M). \n
          For optimum performance LWORK >= M*N. \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array,   returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer orm22(char *side, char *trans, integer *m, integer *n, integer *n1, integer *n2, T *q, integer *ldq, T *c, integer * ldc, T *work, integer *lwork, integer *info)
{
  return orm22(side, trans, m, n, n1, n2, q, ldq, c, ldc, work, lwork, info);
}
template< typename T >
integer unm22(char *side, char *trans, integer *m, integer *n, integer *n1, integer *n2, T *q, integer *ldq, T *c, integer * ldc, T *work, integer *lwork, integer *info)
{
  return unm22(side, trans, m, n, n1, n2, q, ldq, c, ldc, work, lwork, info);
}

/*! @brief ORMR2 multiplies a general matrix by the orthogonal matrix from a RQ factorization determined by sgerqf

 * @details
 * \b Purpose:
    \verbatim 
    ORMR2 overwrites the general real m by n matrix C with

          Q * C  if SIDE = 'L' and TRANS = 'N', or

          Q**T* C  if SIDE = 'L' and TRANS = 'T', or

          C * Q  if SIDE = 'R' and TRANS = 'N', or

          C * Q**T if SIDE = 'R' and TRANS = 'T',

    where Q is a real orthogonal matrix defined as the product of k
    elementary reflectors

          Q = H(1) H(2) . . . H(k)

    as   returned by SGERQF. Q is of order m if SIDE = 'L' and of order n
    if SIDE = 'R'.
    \endverbatim 

 * @param[in] SIDE
          SIDE is CHARACTER*1 \n
          = 'L': apply Q or Q**T from the Left \n
          = 'R': apply Q or Q**T from the Right \n
 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          = 'N': apply Q  (No transpose) \n
          = 'T': apply Q' (Transpose) \n
 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix C. M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix C. N >= 0. \n
 * @param[in] K
          K is INTEGER \n
          The number of elementary reflectors whose product defines
          the matrix Q. \n
          If SIDE = 'L', M >= K >= 0; \n
          if SIDE = 'R', N >= K >= 0. \n
 * @param[in] A
          A is REAL array, dimension \n
                               (LDA,M) if SIDE = 'L', \n
                               (LDA,N) if SIDE = 'R' \n
          The i-th row must contain the vector which defines the
          elementary reflector H(i), for i = 1,2,...,k, as   returned by
          SGERQF in the last k rows of its array argument A.
          A is modified by the routine but restored on exit. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A. LDA >= max(1,K). \n
 * @param[in] TAU
          TAU is REAL array, dimension (K) \n
          TAU(i) must contain the scalar factor of the elementary
          reflector H(i), as   returned by SGERQF. \n
 * @param[in,out] C
          C is REAL array, dimension (LDC,N) \n
          On entry, the m by n matrix C. \n
          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q. \n
 * @param[in] LDC
          LDC is INTEGER \n
          The leading dimension of the array C. LDC >= max(1,M). \n
 * @param[out] WORK
          WORK is REAL array, dimension \n
                                   (N) if SIDE = 'L', \n
                                   (M) if SIDE = 'R' \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer ormr2(char *side, char *trans, integer *m, integer *n, integer *k, T *a, integer *lda, T *tau, T *c, integer *ldc, T *work, integer *info)
{
  return ormr2(side, trans, m, n, k, a, lda, tau, c, ldc, work, info);
}
template< typename T >
integer unmr2(char *side, char *trans, integer *m, integer *n, integer *k, T *a, integer *lda, T *tau, T *c, integer *ldc, T *work, integer *info)
{
  return unmr2(side, trans, m, n, k, a, lda, tau, c, ldc, work, info);
}

/*! @brief ORMR3 multiplies a general matrix by the orthogonal matrix from a RZ factorization determined by stzrzf

 * @details
 * \b Purpose:
    \verbatim 
    ORMR3 overwrites the general real m by n matrix C with

          Q * C  if SIDE = 'L' and TRANS = 'N', or

          Q**T* C  if SIDE = 'L' and TRANS = 'C', or

          C * Q  if SIDE = 'R' and TRANS = 'N', or

          C * Q**T if SIDE = 'R' and TRANS = 'C',

    where Q is a real orthogonal matrix defined as the product of k
    elementary reflectors

          Q = H(1) H(2) . . . H(k)

    as   returned by STZRZF. Q is of order m if SIDE = 'L' and of order n
    if SIDE = 'R'.
    \endverbatim 

 * @param[in] SIDE
          SIDE is CHARACTER*1 \n
          = 'L': apply Q or Q**T from the Left \n
          = 'R': apply Q or Q**T from the Right \n
 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          = 'N': apply Q  (No transpose) \n
          = 'T': apply Q**T (Transpose) \n
 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix C. M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix C. N >= 0. \n
 * @param[in] K
          K is INTEGER \n
          The number of elementary reflectors whose product defines
          the matrix Q. \n
          If SIDE = 'L', M >= K >= 0; \n
          if SIDE = 'R', N >= K >= 0. \n
 * @param[in] L
          L is INTEGER \n
          The number of columns of the matrix A containing
          the meaningful part of the Householder reflectors. \n
          If SIDE = 'L', M >= L >= 0, if SIDE = 'R', N >= L >= 0. \n
 * @param[in] A
          A is REAL array, dimension \n
                               (LDA,M) if SIDE = 'L', \n
                               (LDA,N) if SIDE = 'R' \n
          The i-th row must contain the vector which defines the
          elementary reflector H(i), for i = 1,2,...,k, as   returned by
          STZRZF in the last k rows of its array argument A. \n
          A is modified by the routine but restored on exit. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A. LDA >= max(1,K). \n
 * @param[in] TAU
          TAU is REAL array, dimension (K) \n
          TAU(i) must contain the scalar factor of the elementary
          reflector H(i), as   returned by STZRZF. \n
 * @param[in,out] C
          C is REAL array, dimension (LDC,N) \n
          On entry, the m-by-n matrix C. \n
          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q. \n
 * @param[in] LDC
          LDC is INTEGER \n
          The leading dimension of the array C. LDC >= max(1,M). \n
 * @param[out] WORK
          WORK is REAL array, dimension \n
                                   (N) if SIDE = 'L', \n
                                   (M) if SIDE = 'R' \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer ormr3(char *side, char *trans, integer *m, integer *n, integer *k, integer *l, T *a, integer *lda, T *tau, T *c, integer *ldc, T *work, integer *info)
{
  return ormr3(side, trans, m, n, k, l, a, lda, tau, c, ldc, work, info);
}
template< typename T >
integer unmr3(char *side, char *trans, integer *m, integer *n, integer *k, integer *l, T *a, integer *lda, T *tau, T *c, integer *ldc, T *work, integer *info)
{
  return unmr3(side, trans, m, n, k, l, a, lda, tau, c, ldc, work, info);
}

/*! @brief LA_GBAMV performs a matrix-vector operation to calculate error bounds

 * @details
 * \b Purpose:
    \verbatim 
    LA_GBAMV  performs one of the matrix-vector operations

            y := alpha*abs(A)*abs(x) + beta*abs(y),
       or   y := alpha*abs(A)**T*abs(x) + beta*abs(y),

    where alpha and beta are scalars, x and y are vectors and A is an
    m by n matrix.

    This function is primarily used in calculating error bounds.
    To protect against underflow during evaluation, components in
    the resulting vector are perturbed away from zero by (N+1)
    times the underflow threshold.  To prevent unnecessarily large
    errors for block-structure embedded in general matrices,
    "symbolically" zero components are not perturbed.  A zero
    entry is considered "symbolic" if all multiplications involved
    in computing that entry have at least one zero multiplicand.
    Level 2 Blas routine.
    \endverbatim 

 * @param[in] TRANS
          TRANS is INTEGER \n
          On entry, TRANS specifies the operation to be performed as
          follows: \n
 \n
            BLAS_NO_TRANS      y := alpha*abs(A)*abs(x) + beta*abs(y) \n
            BLAS_TRANS         y := alpha*abs(A**T)*abs(x) + beta*abs(y) \n
            BLAS_CONJ_TRANS    y := alpha*abs(A**T)*abs(x) + beta*abs(y) \n
 \n
          Unchanged on exit. \n
 * @param[in] M
          M is INTEGER \n
          On entry, M specifies the number of rows of the matrix A.
          M must be at least zero. \n
          Unchanged on exit. \n
 * @param[in] N
          N is INTEGER \n
          On entry, N specifies the number of columns of the matrix A.
          N must be at least zero. \n
          Unchanged on exit. \n
 * @param[in] KL
          KL is INTEGER \n
          The number of subdiagonals within the band of A.  KL >= 0. \n
 * @param[in] KU
          KU is INTEGER \n
          The number of superdiagonals within the band of A.  KU >= 0. \n
 * @param[in] ALPHA
          ALPHA is REAL \n
          On entry, ALPHA specifies the scalar alpha.
          Unchanged on exit. \n
 * @param[in] AB
          AB is REAL array, dimension (LDAB, n) \n
          Before entry, the leading m by n part of the array AB must
          contain the matrix of coefficients. \n
          Unchanged on exit. \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          On entry, LDA specifies the first dimension of AB as declared
          in the calling (sub) program. LDAB must be at least
          max(1, m). \n
          Unchanged on exit. \n
 * @param[in] X
          X is REAL array, dimension
          (1 + (n - 1)*abs(INCX)) when TRANS = 'N' or 'n' \n
          and at least
          (1 + (m - 1)*abs(INCX)) otherwise.
          Before entry, the incremented array X must contain the
          vector x. \n
          Unchanged on exit. \n
 * @param[in] INCX
          INCX is INTEGER \n
          On entry, INCX specifies the increment for the elements of
          X. INCX must not be zero. \n
          Unchanged on exit. \n
 * @param[in] BETA
          BETA is REAL \n
          On entry, BETA specifies the scalar beta. When BETA is
          supplied as zero then Y need not be set on input. \n
          Unchanged on exit. \n
 * @param[in,out] Y
          Y is REAL array, dimension
          (1 + (m - 1)*abs(INCY)) when TRANS = 'N' or 'n' \n
          and at least
          (1 + (n - 1)*abs(INCY)) otherwise. \n
          Before entry with BETA non-zero, the incremented array Y
          must contain the vector y. On exit, Y is overwritten by the
          updated vector y. \n
 * @param[in] INCY
          INCY is INTEGER \n
          On entry, INCY specifies the increment for the elements of
          Y. INCY must not be zero. \n
          Unchanged on exit. \n

 * @return INTEGER Return value of the function.
 * */         
template< typename T >
integer la_gbamv(integer *trans, integer *m, integer *n, integer *kl, integer *ku, T *alpha, T *ab, integer *ldab, T * x, integer *incx, T *beta, T *y, integer *incy)
{
  return la_gbamv(trans, m, n, kl, ku, alpha, ab, ldab, x, incx, beta, y, incy);
}
template< typename T, typename Ta >
integer la_gbamv(integer *trans, integer *m, integer *n, integer *kl, integer *ku, Ta *alpha, T *ab, integer *ldab, T *x, integer *incx, Ta *beta, Ta *y, integer *incy)
{
  return la_gbamv(trans, m, n, kl, ku, alpha, ab, ldab, x, incx, beta, y, incy);
}

/*! @brief LA_GBRCOND estimates the Skeel condition number for a general banded matrix

 * @details
 * \b Purpose:
    \verbatim 
    LA_GBRCOND Estimates the Skeel condition number of  op(A) * op2(C)
    where op2 is determined by CMODE as follows
    CMODE =  1    op2(C) = C
    CMODE =  0    op2(C) = I
    CMODE = -1    op2(C) = inv(C)
    The Skeel condition number  cond(A) = norminf(|inv(A)||A|)
    is computed by computing scaling factors R such that
    diag(R)*A*op2(C) is row equilibrated and computing the standard
    infinity-norm condition number.
    \endverbatim

 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          Specifies the form of the system of equations: \n
           = 'N':  A * X = B     (No transpose) \n
           = 'T':  A**T * X = B  (Transpose) \n
           = 'C':  A**H * X = B  (Conjugate Transpose = Transpose) \n
 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] KL
          KL is INTEGER \n
          The number of subdiagonals within the band of A.  KL >= 0. \n
 * @param[in] KU
          KU is INTEGER \n
          The number of superdiagonals within the band of A.  KU >= 0. \n
 * @param[in] AB
          AB is REAL array, dimension (LDAB,N) \n
          On entry, the matrix A in band storage, in rows 1 to KL+KU+1.
          The j-th column of A is stored in the j-th column of the
          array AB as follows: \n
          AB(KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+kl) \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          The leading dimension of the array AB.  LDAB >= KL+KU+1. \n
 * @param[in] AFB
          AFB is REAL array, dimension (LDAFB,N) \n
          Details of the LU factorization of the band matrix A, as
          computed by SGBTRF.  U is stored as an upper triangular
          band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1,
          and the multipliers used during the factorization are stored
          in rows KL+KU+2 to 2*KL+KU+1. \n
 * @param[in] LDAFB
          LDAFB is INTEGER \n
          The leading dimension of the array AFB.  LDAFB >= 2*KL+KU+1. \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          The pivot indices from the factorization A = P*L*U \n
          as computed by SGBTRF; row i of the matrix was interchanged
          with row IPIV(i). \n
 * @param[in] CMODE
          CMODE is INTEGER \n
          Determines op2(C) in the formula op(A) * op2(C) as follows: \n
          CMODE =  1    op2(C) = C \n
          CMODE =  0    op2(C) = I \n
          CMODE = -1    op2(C) = inv(C) \n
 * @param[in] C
          C is REAL array, dimension (N) \n
          The vector C in the formula op(A) * op2(C). \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  Successful exit. \n
          i > 0:  The ith argument is invalid. \n
 * @param[out] WORK
          WORK is REAL array, dimension (5*N). \n
          Workspace. \n
 * @param[out] IWORK
          IWORK is INTEGER array, dimension (N). \n
          Workspace. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
T la_gbrcond(char *trans, integer *n, integer *kl, integer *ku, T * ab, integer *ldab, T *afb, integer *ldafb, integer *ipiv, integer * cmode, T *c, integer *info, T *work, integer *iwork)
{
  return la_gbrcond(trans, n, kl, ku, ab, ldab, afb, ldafb, ipiv, cmode, c, info, work, iwork);
}

/*! @brief LA_GBRCOND_C computes the infinity norm condition number of op(A)*inv(diag(c)) for general banded matrices

 * @details
 * \b Purpose:
    \verbatim    
    LA_GBRCOND_C Computes the infinity norm condition number of
    op(A) * inv(diag(C)) where C is a REAL vector.
    \endverbatim 

 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          Specifies the form of the system of equations: \n
            = 'N':  A * X = B     (No transpose) \n
            = 'T':  A**T * X = B  (Transpose) \n
            = 'C':  A**H * X = B  (Conjugate Transpose = Transpose) \n
 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] KL
          KL is INTEGER \n
          The number of subdiagonals within the band of A.  KL >= 0. \n
 * @param[in] KU
          KU is INTEGER \n
          The number of superdiagonals within the band of A.  KU >= 0. \n
 * @param[in] AB
          AB is COMPLEX array, dimension (LDAB,N) \n
          On entry, the matrix A in band storage, in rows 1 to KL+KU+1.
          The j-th column of A is stored in the j-th column of the
          array AB as follows: \n
          AB(KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+kl) \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          The leading dimension of the array AB.  LDAB >= KL+KU+1. \n
 * @param[in] AFB
          AFB is COMPLEX array, dimension (LDAFB,N) \n
          Details of the LU factorization of the band matrix A, as
          computed by CGBTRF.  U is stored as an upper triangular
          band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1,
          and the multipliers used during the factorization are stored
          in rows KL+KU+2 to 2*KL+KU+1. \n
 * @param[in] LDAFB
          LDAFB is INTEGER \n
          The leading dimension of the array AFB.  LDAFB >= 2*KL+KU+1. \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          The pivot indices from the factorization A = P*L*U
          as computed by CGBTRF; row i of the matrix was interchanged
          with row IPIV(i). \n
 * @param[in] C
          C is REAL array, dimension (N) \n
          The vector C in the formula op(A) * inv(diag(C)). \n
 * @param[in] CAPPLY
          CAPPLY is LOGICAL \n
          If .TRUE. then access the vector C in the formula above. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  Successful exit. \n
          i > 0:  The ith argument is invalid. \n
 * @param[out] WORK
          WORK is COMPLEX array, dimension (2*N). \n
          Workspace. \n
 * @param[out] RWORK
          RWORK is REAL array, dimension (N). \n
          Workspace. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T, typename Ta >
Ta la_gbrcond_c(char *trans, integer *n, integer *kl, integer *ku, T *ab, integer *ldab, T *afb, integer *ldafb, integer *ipiv, Ta *c, logical *capply, integer *info, T *work, Ta * rwork)
{
  return la_gbrcond_c(trans, n, kl, ku, ab, ldab, afb, ldafb, ipiv, c, capply, info, work, rwork);
}

/*! @brief LA_GBRCOND_X computes the infinity norm condition number of op(A)*diag(x) for general banded matrices

 * @details
 * \b Purpose:
    \verbatim
    LA_GBRCOND_X Computes the infinity norm condition number of
    op(A) * diag(X) where X is a COMPLEX vector.
    \endverbatim 

 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          Specifies the form of the system of equations: \n
            = 'N':  A * X = B     (No transpose) \n
            = 'T':  A**T * X = B  (Transpose) \n
            = 'C':  A**H * X = B  (Conjugate Transpose = Transpose) \n
 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] KL
          KL is INTEGER \n
          The number of subdiagonals within the band of A. KL >= 0. \n
 * @param[in] KU
          KU is INTEGER \n
          The number of superdiagonals within the band of A. KU >= 0. \n
 * @param[in] AB
          AB is COMPLEX array, dimension (LDAB,N) \n
          On entry, the matrix A in band storage, in rows 1 to KL+KU+1.
          The j-th column of A is stored in the j-th column of the
          array AB as follows: \n
          AB(KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+kl) \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          The leading dimension of the array AB.  LDAB >= KL+KU+1. \n
 * @param[in] AFB
          AFB is COMPLEX array, dimension (LDAFB,N) \n
          Details of the LU factorization of the band matrix A, as
          computed by CGBTRF.  U is stored as an upper triangular
          band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1,
          and the multipliers used during the factorization are stored
          in rows KL+KU+2 to 2*KL+KU+1. \n
 * @param[in] LDAFB
          LDAFB is INTEGER \n
          The leading dimension of the array AFB. LDAFB >= 2*KL+KU+1. \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          The pivot indices from the factorization A = P*L*U
          as computed by CGBTRF; row i of the matrix was interchanged
          with row IPIV(i). \n
 * @param[in] X
          X is COMPLEX array, dimension (N) \n
          The vector X in the formula op(A) * diag(X). \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  Successful exit. \n
          i > 0:  The ith argument is invalid. \n
 * @param[out] WORK
          WORK is COMPLEX array, dimension (2*N). \n
          Workspace. \n
 * @param[out] RWORK
          RWORK is REAL array, dimension (N). \n
          Workspace. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T, typename Ta >
Ta la_gbrcond_x(char *trans, integer *n, integer *kl, integer *ku, T *ab, integer *ldab, T *afb, integer *ldafb, integer *ipiv, T *x, integer *info, T *work, Ta *rwork)
{
  return la_gbrcond_x(trans, n, kl, ku, ab, ldab, afb, ldafb, ipiv, x, info, work, rwork);
}

/*! @brief LA_GBRFSX_EXTENDED improves the computed solution to a system of     \n
     linear equations for general banded matrices by performing extra-precise   \n
     iterative refinement and provides error bounds and backward error          \n
     estimates for the solution
 * @details
 * \b Purpose:
    \verbatim 
    LA_GBRFSX_EXTENDED improves the computed solution to a system of
    linear equations by performing extra-precise iterative refinement
    and provides error bounds and backward error estimates for the solution.
    This subroutine is called by SGBRFSX to perform iterative refinement.
    In addition to normwise error bound, the code provides maximum
    componentwise error bound if possible. See comments for ERR_BNDS_NORM
    and ERR_BNDS_COMP for details of the error bounds. Note that this
    subroutine is only resonsible for setting the second fields of
    ERR_BNDS_NORM and ERR_BNDS_COMP.
    \endverbatim 

 * @param[in] PREC_TYPE
          PREC_TYPE is INTEGER \n
          Specifies the intermediate precision to be used in refinement.
          The value is defined by ILAPREC(P) where P is a CHARACTER and P \n
               = 'S':  Single \n
               = 'D':  Double \n
               = 'I':  Indigenous \n
               = 'X' or 'E':  Extra \n
 * @param[in] TRANS_TYPE
          TRANS_TYPE is INTEGER \n
          Specifies the transposition operation on A. \n
          The value is defined by ILATRANS(T) where T is a CHARACTER and T \n
               = 'N':  No transpose \n
               = 'T':  Transpose \n
               = 'C':  Conjugate transpose \n
 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] KL
          KL is INTEGER \n
          The number of subdiagonals within the band of A.  KL >= 0. \n
 * @param[in] KU
          KU is INTEGER \n
          The number of superdiagonals within the band of A.  KU >= 0 \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right-hand-sides, i.e., the number of columns of the
          matrix B. \n
 * @param[in] AB
          AB is REAL array, dimension (LDAB,N) \n
          On entry, the N-by-N matrix AB. \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          The leading dimension of the array AB.  LDAB >= max(1,N). \n
 * @param[in] AFB
          AFB is REAL array, dimension (LDAFB,N) \n
          The factors L and U from the factorization
          A = P*L*U as computed by SGBTRF. \n
 * @param[in] LDAFB
          LDAFB is INTEGER \n
          The leading dimension of the array AF.  LDAFB >= max(1,N). \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          The pivot indices from the factorization A = P*L*U
          as computed by SGBTRF; row i of the matrix was interchanged
          with row IPIV(i). \n
 * @param[in] COLEQU
          COLEQU is LOGICAL \n
          If .TRUE. then column equilibration was done to A before calling
          this routine. This is needed to compute the solution and error
          bounds correctly. \n
 * @param[in] C
          C is REAL array, dimension (N) \n
          The column scale factors for A. If COLEQU = .FALSE., C
          is not accessed. If C is input, each element of C should be a power
          of the radix to ensure a reliable solution and error estimates.
          Scaling by powers of the radix does not cause rounding errors unless
          the result underflows or overflows. Rounding errors during scaling
          lead to refining with a matrix that is not equivalent to the
          input matrix, producing error estimates that may not be
          reliable. \n
 * @param[in] B
          B is REAL array, dimension (LDB,NRHS) \n
          The right-hand-side matrix B. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[in,out] Y
          Y is REAL array, dimension (LDY,NRHS) \n
          On entry, the solution matrix X, as computed by SGBTRS.
          On exit, the improved solution matrix Y. \n
 * @param[in] LDY
          LDY is INTEGER \n
          The leading dimension of the array Y.  LDY >= max(1,N). \n
 * @param[out] BERR_OUT
          BERR_OUT is REAL array, dimension (NRHS) \n
          On exit, BERR_OUT(j) contains the componentwise relative backward
          error for right-hand-side j from the formula \n
             max(i) (abs(RES(i)) / (abs(op(A_s))*abs(Y) + abs(B_s))(i)) \n
          where abs(Z) is the componentwise absolute value of the matrix
          or vector Z. This is computed by SLA_LIN_BERR. \n
 * @param[in] N_NORMS
          N_NORMS is INTEGER \n
          Determines which error bounds to   return (see ERR_BNDS_NORM
          and ERR_BNDS_COMP). \n
          If N_NORMS >= 1   return normwise error bounds. \n
          If N_NORMS >= 2   return componentwise error bounds. \n
 * @param[in,out] ERR_BNDS_NORM
          ERR_BNDS_NORM is REAL array, dimension (NRHS, N_ERR_BNDS) \n
          For each right-hand side, this array contains information about
          various error bounds and condition numbers corresponding to the
          normwise relative error, which is defined as follows: \n
 \n
          Normwise relative error in the ith solution vector: \n
                 max_j (abs(XTRUE(j,i) - X(j,i))) \n
                ------------------------------ \n
                      max_j abs(X(j,i)) \n
 \n
          The array is indexed by the type of error information as described
          below. There currently are up to three pieces of information
           returned. \n
 \n
          The first index in ERR_BNDS_NORM(i,:) corresponds to the ith
          right-hand side. \n
 \n
          The second index in ERR_BNDS_NORM(:,err) contains the following
          three fields: \n
          err = 1 "Trust/don't trust" boolean. Trust the answer if the
                  reciprocal condition number is less than the threshold
                  sqrt(n) * slamch('Epsilon').
 \n
          err = 2 "Guaranteed" error bound: The estimated forward error,
                  almost certainly within a factor of 10 of the true error
                  so long as the next entry is greater than the threshold
                  sqrt(n) * slamch('Epsilon'). This error bound should only
                  be trusted if the previous boolean is true.
 \n
          err = 3  Reciprocal condition number: Estimated normwise
                  reciprocal condition number.  Compared with the threshold
                  sqrt(n) * slamch('Epsilon') to determine if the error
                  estimate is "guaranteed". These reciprocal condition
                  numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
                  appropriately scaled matrix Z.
                  Let Z = S*A, where S scales each row by a power of the
                  radix so all absolute row sums of Z are approximately 1.
 \n
          This subroutine is only responsible for setting the second field
          above. \n
          See Lapack Working Note 165 for further details and extra
          cautions. \n
 * @param[in,out] ERR_BNDS_COMP
          ERR_BNDS_COMP is REAL array, dimension (NRHS, N_ERR_BNDS) \n
          For each right-hand side, this array contains information about
          various error bounds and condition numbers corresponding to the
          componentwise relative error, which is defined as follows: \n
 \n
          Componentwise relative error in the ith solution vector: \n
                        abs(XTRUE(j,i) - X(j,i)) \n
                 max_j ---------------------- \n
                             abs(X(j,i)) \n
 \n
          The array is indexed by the right-hand side i (on which the
          componentwise relative error depends), and the type of error
          information as described below. There currently are up to three
          pieces of information   returned for each right-hand side. If
          componentwise accuracy is not requested (PARAMS(3) = 0.0), then
          ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS < 3, then at most
          the first (:,N_ERR_BNDS) entries are returned. \n
 \n
          The first index in ERR_BNDS_COMP(i,:) corresponds to the ith
          right-hand side.
 \n
          The second index in ERR_BNDS_COMP(:,err) contains the following
          three fields: \n
          err = 1 "Trust/don't trust" boolean. Trust the answer if the
                  reciprocal condition number is less than the threshold
                  sqrt(n) * slamch('Epsilon').
 \n
          err = 2 "Guaranteed" error bound: The estimated forward error,
                  almost certainly within a factor of 10 of the true error
                  so long as the next entry is greater than the threshold
                  sqrt(n) * slamch('Epsilon'). This error bound should only
                  be trusted if the previous boolean is true.
 \n
          err = 3  Reciprocal condition number: Estimated componentwise
                  reciprocal condition number.  Compared with the threshold
                  sqrt(n) * slamch('Epsilon') to determine if the error
                  estimate is "guaranteed". These reciprocal condition
                  numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
                  appropriately scaled matrix Z.
                  Let Z = S*(A*diag(x)), where x is the solution for the
                  current right-hand side and S scales each row of
                  A*diag(x) by a power of the radix so all absolute row
                  sums of Z are approximately 1.
 \n
          This subroutine is only responsible for setting the second field
          above. \n
          See Lapack Working Note 165 for further details and extra
          cautions. \n
 * @param[in] RES
          RES is REAL array, dimension (N) \n
          Workspace to hold the intermediate residual. \n
 * @param[in] AYB
          AYB is REAL array, dimension (N) \n
          Workspace. This can be the same workspace passed for Y_TAIL. \n
 * @param[in] DY
          DY is REAL array, dimension (N) \n
          Workspace to hold the intermediate solution. \n
 * @param[in] Y_TAIL
          Y_TAIL is REAL array, dimension (N) \n
          Workspace to hold the trailing bits of the intermediate solution. \n
 * @param[in] RCOND
          RCOND is REAL \n
          Reciprocal scaled condition number. This is an estimate of the
          reciprocal Skeel condition number of the matrix A after
          equilibration (if done). If this is less than the machine
          precision (in particular, if it is zero), the matrix is singular
          to working precision. Note that the error may still be small even
          if this number is very small and the matrix appears ill-
          conditioned. \n
 * @param[in] ITHRESH
          ITHRESH is INTEGER \n
          The maximum number of residual computations allowed for
          refinement. The default is 10. For 'aggressive' set to 100 to
          permit convergence using approximate factorizations or
          factorizations other than LU. If the factorization uses a
          technique other than Gaussian elimination, the guarantees in
          ERR_BNDS_NORM and ERR_BNDS_COMP may no longer be trustworthy. \n
 * @param[in] RTHRESH
          RTHRESH is REAL \n
          Determines when to stop refinement if the error estimate stops
          decreasing. Refinement will stop when the next solution no longer
          satisfies norm(dx_{i+1}) < RTHRESH * norm(dx_i) where norm(Z) is
          the infinity norm of Z. RTHRESH satisfies 0 < RTHRESH <= 1. The
          default value is 0.5. For 'aggressive' set to 0.9 to permit
          convergence on extremely ill-conditioned matrices. See LAWN 165
          for more details. \n
 * @param[in] DZ_UB
          DZ_UB is REAL \n
          Determines when to start considering componentwise convergence.
          Componentwise convergence is only considered after each component
          of the solution Y is stable, which we definte as the relative
          change in each component being less than DZ_UB. The default value
          is 0.25, requiring the first bit to be stable. See LAWN 165 for
          more details. \n
 * @param[in] IGNORE_CWISE
          IGNORE_CWISE is LOGICAL \n
          If .TRUE. then ignore componentwise convergence. Default value
          is .FALSE.. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  Successful exit. \n
          < 0:  if INFO = -i, the ith argument to SGBTRS had an illegal
                value  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer la_gbrfsx_extended(integer *prec_type, integer * trans_type, integer *n, integer *kl, integer *ku, integer *nrhs, T *ab, integer *ldab, T *afb, integer *ldafb, integer *ipiv, logical *colequ, T *c, T *b, integer *ldb, T *y, integer * ldy, T *berr_out, integer *n_norms, T *err_bnds_norm, T *err_bnds_comp, T *res, T *ayb, T *dy, T *y_tail, T *rcond, integer *ithresh, T *rthresh, T *dz_ub, logical *ignore_cwise, integer *info)
{
  return la_gbrfsx_extended(prec_type, trans_type, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, colequ, c, b, ldb, y, ldy, berr_out, n_norms, err_bnds_norm, err_bnds_comp, res, ayb, dy, y_tail, rcond, ithresh, rthresh, dz_ub, ignore_cwise, info);
}
template< typename T, typename Ta >
integer la_gbrfsx_extended(integer *prec_type, integer * trans_type, integer *n, integer *kl, integer *ku, integer *nrhs, T *ab, integer *ldab, T *afb, integer *ldafb, integer * ipiv, logical *colequ, Ta *c, T *b, integer *ldb, T * y, integer *ldy, Ta *berr_out, integer *n_norms, Ta * err_bnds_norm, Ta *err_bnds_comp, T *res, Ta *ayb, T *dy, T *y_tail, Ta *rcond, integer *ithresh, Ta * rthresh, Ta *dz_ub, logical *ignore_cwise, integer *info)
{
  return la_gbrfsx_extended(prec_type, trans_type, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, colequ, c, b, ldb, y, ldy, berr_out, n_norms, err_bnds_norm, err_bnds_comp, res, ayb, dy, y_tail, rcond, ithresh, rthresh, dz_ub, ignore_cwise, info);
}

/*! @brief LA_GERFSX_EXTENDED improves the computed solution to a system of      \n
     linear equations for general matrices by performing extra-precise iterative \n
     refinement and provides error bounds and backward error estimates           \n
     for the solution
 * @details
 * \b Purpose:
    \verbatim 
    LA_GERFSX_EXTENDED improves the computed solution to a system of
    linear equations by performing extra-precise iterative refinement
    and provides error bounds and backward error estimates for the solution.
    This subroutine is called by SGERFSX to perform iterative refinement.
    In addition to normwise error bound, the code provides maximum
    componentwise error bound if possible. See comments for ERRS_N
    and ERRS_C for details of the error bounds. Note that this
    subroutine is only resonsible for setting the second fields of
    ERRS_N and ERRS_C.
    \endverbatim 

 * @param[in] PREC_TYPE
          PREC_TYPE is INTEGER \n
          Specifies the intermediate precision to be used in refinement.
          The value is defined by ILAPREC(P) where P is a CHARACTER and P \n
              = 'S':  Single \n
              = 'D':  Double \n
              = 'I':  Indigenous \n
              = 'X' or 'E':  Extra \n
 * @param[in] TRANS_TYPE
          TRANS_TYPE is INTEGER \n
          Specifies the transposition operation on A. \n
          The value is defined by ILATRANS(T) where T is a CHARACTER and T \n
              = 'N':  No transpose \n
              = 'T':  Transpose \n
              = 'C':  Conjugate transpose \n
 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right-hand-sides, i.e., the number of columns of the
          matrix B. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the N-by-N matrix A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] AF
          AF is REAL array, dimension (LDAF,N) \n
          The factors L and U from the factorization
          A = P*L*U as computed by SGETRF. \n
 * @param[in] LDAF
          LDAF is INTEGER \n
          The leading dimension of the array AF.  LDAF >= max(1,N). \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          The pivot indices from the factorization A = P*L*U
          as computed by SGETRF; row i of the matrix was interchanged
          with row IPIV(i). \n
 * @param[in] COLEQU
          COLEQU is LOGICAL \n
          If .TRUE. then column equilibration was done to A before calling
          this routine. This is needed to compute the solution and error
          bounds correctly. \n
 * @param[in] C
          C is REAL array, dimension (N) \n
          The column scale factors for A. If COLEQU = .FALSE., C
          is not accessed. If C is input, each element of C should be a power
          of the radix to ensure a reliable solution and error estimates.
          Scaling by powers of the radix does not cause rounding errors unless
          the result underflows or overflows. Rounding errors during scaling
          lead to refining with a matrix that is not equivalent to the
          input matrix, producing error estimates that may not be
          reliable. \n
 * @param[in] B
          B is REAL array, dimension (LDB,NRHS) \n
          The right-hand-side matrix B. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[in,out] Y
          Y is REAL array, dimension (LDY,NRHS) \n
          On entry, the solution matrix X, as computed by SGETRS.
          On exit, the improved solution matrix Y. \n
 * @param[in] LDY
          LDY is INTEGER \n
          The leading dimension of the array Y.  LDY >= max(1,N). \n
 * @param[out] BERR_OUT
          BERR_OUT is REAL array, dimension (NRHS) \n
          On exit, BERR_OUT(j) contains the componentwise relative backward
          error for right-hand-side j from the formula \n
             max(i) (abs(RES(i)) / (abs(op(A_s))*abs(Y) + abs(B_s))(i)) \n
          where abs(Z) is the componentwise absolute value of the matrix
          or vector Z. This is computed by SLA_LIN_BERR. \n
 * @param[in] N_NORMS
          N_NORMS is INTEGER \n
          Determines which error bounds to   return (see ERRS_N
          and ERRS_C). \n
          If N_NORMS >= 1   return normwise error bounds. \n
          If N_NORMS >= 2   return componentwise error bounds. \n
 * @param[in,out] ERRS_N
          ERRS_N is REAL array, dimension (NRHS, N_ERR_BNDS) \n
          For each right-hand side, this array contains information about
          various error bounds and condition numbers corresponding to the
          normwise relative error, which is defined as follows: \n
 \n
          Normwise relative error in the ith solution vector: \n
                 max_j (abs(XTRUE(j,i) - X(j,i))) \n
                ------------------------------ \n
                      max_j abs(X(j,i)) \n
 \n
          The array is indexed by the type of error information as described
          below. There currently are up to three pieces of information
           returned. \n
 \n
          The first index in ERRS_N(i,:) corresponds to the ith
          right-hand side. \n
 \n
          The second index in ERRS_N(:,err) contains the following
          three fields: \n
          err = 1 "Trust/don't trust" boolean. Trust the answer if the
                  reciprocal condition number is less than the threshold
                  sqrt(n) * slamch('Epsilon').
 \n
          err = 2 "Guaranteed" error bound: The estimated forward error,
                  almost certainly within a factor of 10 of the true error
                  so long as the next entry is greater than the threshold
                  sqrt(n) * slamch('Epsilon'). This error bound should only
                  be trusted if the previous boolean is true.
 \n
          err = 3  Reciprocal condition number: Estimated normwise
                  reciprocal condition number.  Compared with the threshold
                  sqrt(n) * slamch('Epsilon') to determine if the error
                  estimate is "guaranteed". These reciprocal condition
                  numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
                  appropriately scaled matrix Z.
                  Let Z = S*A, where S scales each row by a power of the
                  radix so all absolute row sums of Z are approximately 1.
 \n
          This subroutine is only responsible for setting the second field
          above. \n
          See Lapack Working Note 165 for further details and extra
          cautions. \n
 * @param[in,out] ERRS_C
          ERRS_C is REAL array, dimension (NRHS, N_ERR_BNDS) \n
          For each right-hand side, this array contains information about
          various error bounds and condition numbers corresponding to the
          componentwise relative error, which is defined as follows: \n
 \n
          Componentwise relative error in the ith solution vector: \n
                        abs(XTRUE(j,i) - X(j,i)) \n
                 max_j ---------------------- \n
                             abs(X(j,i)) \n
 \n
          The array is indexed by the right-hand side i (on which the
          componentwise relative error depends), and the type of error
          information as described below. There currently are up to three
          pieces of information   returned for each right-hand side. If
          componentwise accuracy is not requested (PARAMS(3) = 0.0), then
          ERRS_C is not accessed.  If N_ERR_BNDS < 3, then at most
          the first (:,N_ERR_BNDS) entries are returned. \n
 \n
          The first index in ERRS_C(i,:) corresponds to the ith
          right-hand side. \n
 \n
          The second index in ERRS_C(:,err) contains the following
          three fields: \n
          err = 1 "Trust/don't trust" boolean. Trust the answer if the
                  reciprocal condition number is less than the threshold
                  sqrt(n) * slamch('Epsilon').
 \n
          err = 2 "Guaranteed" error bound: The estimated forward error,
                  almost certainly within a factor of 10 of the true error
                  so long as the next entry is greater than the threshold
                  sqrt(n) * slamch('Epsilon'). This error bound should only
                  be trusted if the previous boolean is true.
 \n
          err = 3  Reciprocal condition number: Estimated componentwise
                  reciprocal condition number.  Compared with the threshold
                  sqrt(n) * slamch('Epsilon') to determine if the error
                  estimate is "guaranteed". These reciprocal condition
                  numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
                  appropriately scaled matrix Z.
                  Let Z = S*(A*diag(x)), where x is the solution for the
                  current right-hand side and S scales each row of
                  A*diag(x) by a power of the radix so all absolute row
                  sums of Z are approximately 1.
 \n
          This subroutine is only responsible for setting the second field
          above. \n
          See Lapack Working Note 165 for further details and extra
          cautions. \n
 * @param[in] RES
          RES is REAL array, dimension (N) \n
          Workspace to hold the intermediate residual. \n
 * @param[in] AYB
          AYB is REAL array, dimension (N) \n
          Workspace. This can be the same workspace passed for Y_TAIL. \n
 * @param[in] DY
          DY is REAL array, dimension (N) \n
          Workspace to hold the intermediate solution. \n
 * @param[in] Y_TAIL
          Y_TAIL is REAL array, dimension (N) \n
          Workspace to hold the trailing bits of the intermediate solution. \n
 * @param[in] RCOND
          RCOND is REAL \n
          Reciprocal scaled condition number.  This is an estimate of the
          reciprocal Skeel condition number of the matrix A after
          equilibration (if done).  If this is less than the machine
          precision (in particular, if it is zero), the matrix is singular
          to working precision.  Note that the error may still be small even
          if this number is very small and the matrix appears ill-
          conditioned. \n
 * @param[in] ITHRESH
          ITHRESH is INTEGER \n
          The maximum number of residual computations allowed for
          refinement. The default is 10. For 'aggressive' set to 100 to
          permit convergence using approximate factorizations or
          factorizations other than LU. If the factorization uses a
          technique other than Gaussian elimination, the guarantees in
          ERRS_N and ERRS_C may no longer be trustworthy. \n
 * @param[in] RTHRESH
          RTHRESH is REAL \n
          Determines when to stop refinement if the error estimate stops
          decreasing. Refinement will stop when the next solution no longer
          satisfies norm(dx_{i+1}) < RTHRESH * norm(dx_i) where norm(Z) is
          the infinity norm of Z. RTHRESH satisfies 0 < RTHRESH <= 1. The
          default value is 0.5. For 'aggressive' set to 0.9 to permit
          convergence on extremely ill-conditioned matrices. See LAWN 165
          for more details. \n
 * @param[in] DZ_UB
          DZ_UB is REAL \n
          Determines when to start considering componentwise convergence.
          Componentwise convergence is only considered after each component
          of the solution Y is stable, which we definte as the relative
          change in each component being less than DZ_UB. The default value
          is 0.25, requiring the first bit to be stable. See LAWN 165 for
          more details. \n
 * @param[in] IGNORE_CWISE
          IGNORE_CWISE is LOGICAL \n
          If .TRUE. then ignore componentwise convergence. Default value
          is .FALSE.. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  Successful exit. \n
          < 0:  if INFO = -i, the ith argument to SGETRS had an illegal
                value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer la_gerfsx_extended(integer *prec_type, integer * trans_type, integer *n, integer *nrhs, T *a, integer *lda, T * af, integer *ldaf, integer *ipiv, logical *colequ, T *c, T *b, integer *ldb, T *y, integer *ldy, T *berr_out, integer * n_norms, T *errs_n, T *errs_c, T *res, T *ayb, T *dy, T *y_tail, T *rcond, integer *ithresh, T *rthresh, T *dz_ub, logical *ignore_cwise, integer *info)
{
  return la_gerfsx_extended(prec_type, trans_type, n, nrhs, a, lda, af, ldaf, ipiv, colequ, c, b, ldb, y, ldy, berr_out, n_norms, errs_n, errs_c, res, ayb, dy, y_tail, rcond, ithresh, rthresh, dz_ub, ignore_cwise, info);
}
template< typename T, typename Ta >
integer la_gerfsx_extended(integer *prec_type, integer * trans_type, integer *n, integer *nrhs, T *a, integer *lda, T *af, integer *ldaf, integer *ipiv, logical *colequ, Ta *c, T *b, integer *ldb, T *y, integer *ldy, Ta *berr_out, integer *n_norms, Ta *errs_n, Ta *errs_c, T *res, Ta *ayb, T *dy, T *y_tail, Ta *rcond, integer * ithresh, Ta *rthresh, Ta *dz_ub, logical *ignore_cwise, integer *info)
{
  return la_gerfsx_extended(prec_type, trans_type, n, nrhs, a, lda, af, ldaf, ipiv, colequ, c, b, ldb, y, ldy, berr_out, n_norms, errs_n, errs_c, res, ayb, dy, y_tail, rcond, ithresh, rthresh, dz_ub, ignore_cwise, info);
}

/*! @brief LA_PORFSX_EXTENDED improves the computed solution to a system of \n
     linear equations for symmetric or Hermitian positive-definite matrices \n
     by performing extra-precise iterative refinement and provides error    \n
     bounds and backward error estimates for the solution
 * @details
 * \b Purpose:
    \verbatim 
    LA_PORFSX_EXTENDED improves the computed solution to a system of
    linear equations by performing extra-precise iterative refinement
    and provides error bounds and backward error estimates for the solution.
    This subroutine is called by SPORFSX to perform iterative refinement.
    In addition to normwise error bound, the code provides maximum
    componentwise error bound if possible. See comments for ERR_BNDS_NORM
    and ERR_BNDS_COMP for details of the error bounds. Note that this
    subroutine is only resonsible for setting the second fields of
    ERR_BNDS_NORM and ERR_BNDS_COMP.
    \endverbatim  

 * @param[in] PREC_TYPE
          PREC_TYPE is INTEGER \n
          Specifies the intermediate precision to be used in refinement. \n
          The value is defined by ILAPREC(P) where P is a CHARACTER and P \n
              = 'S':  Single \n
              = 'D':  Double \n
              = 'I':  Indigenous \n
              = 'X' or 'E':  Extra \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right-hand-sides, i.e., the number of columns of the
          matrix B. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the N-by-N matrix A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] AF
          AF is REAL array, dimension (LDAF,N) \n
          The triangular factor U or L from the Cholesky factorization
          A = U**T*U or A = L*L**T, as computed by SPOTRF. \n
 * @param[in] LDAF
          LDAF is INTEGER \n
          The leading dimension of the array AF.  LDAF >= max(1,N). \n
 * @param[in] COLEQU
          COLEQU is LOGICAL \n
          If .TRUE. then column equilibration was done to A before calling
          this routine. This is needed to compute the solution and error
          bounds correctly. \n
 * @param[in] C
          C is REAL array, dimension (N) \n
          The column scale factors for A. If COLEQU = .FALSE., C
          is not accessed. If C is input, each element of C should be a power
          of the radix to ensure a reliable solution and error estimates.
          Scaling by powers of the radix does not cause rounding errors unless
          the result underflows or overflows. Rounding errors during scaling
          lead to refining with a matrix that is not equivalent to the
          input matrix, producing error estimates that may not be
          reliable. \n
 * @param[in] B
          B is REAL array, dimension (LDB,NRHS) \n
          The right-hand-side matrix B. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[in,out] Y
          Y is REAL array, dimension (LDY,NRHS) \n
          On entry, the solution matrix X, as computed by SPOTRS.
          On exit, the improved solution matrix Y. \n
 * @param[in] LDY
          LDY is INTEGER \n
          The leading dimension of the array Y.  LDY >= max(1,N). \n
 * @param[out] BERR_OUT
          BERR_OUT is REAL array, dimension (NRHS) \n
          On exit, BERR_OUT(j) contains the componentwise relative backward
          error for right-hand-side j from the formula \n
             max(i) (abs(RES(i)) / (abs(op(A_s))*abs(Y) + abs(B_s))(i)) \n
          where abs(Z) is the componentwise absolute value of the matrix
          or vector Z. This is computed by SLA_LIN_BERR. \n
 * @param[in] N_NORMS
          N_NORMS is INTEGER \n
          Determines which error bounds to   return (see ERR_BNDS_NORM
          and ERR_BNDS_COMP). \n
          If N_NORMS >= 1   return normwise error bounds. \n
          If N_NORMS >= 2   return componentwise error bounds. \n
 * @param[in,out] ERR_BNDS_NORM
          ERR_BNDS_NORM is REAL array, dimension (NRHS, N_ERR_BNDS)
          For each right-hand side, this array contains information about
          various error bounds and condition numbers corresponding to the
          normwise relative error, which is defined as follows: \n
 \n
          Normwise relative error in the ith solution vector: \n
                 max_j (abs(XTRUE(j,i) - X(j,i))) \n
                ------------------------------ \n
                      max_j abs(X(j,i)) \n
 \n
          The array is indexed by the type of error information as described
          below. There currently are up to three pieces of information
          returned. \n
 \n
          The first index in ERR_BNDS_NORM(i,:) corresponds to the ith
          right-hand side. \n
 \n
          The second index in ERR_BNDS_NORM(:,err) contains the following
          three fields: \n
          err = 1 "Trust/don't trust" boolean. Trust the answer if the
                  reciprocal condition number is less than the threshold
                  sqrt(n) * slamch('Epsilon').
 \n
          err = 2 "Guaranteed" error bound: The estimated forward error,
                  almost certainly within a factor of 10 of the true error
                  so long as the next entry is greater than the threshold
                  sqrt(n) * slamch('Epsilon'). This error bound should only
                  be trusted if the previous boolean is true.
 \n
          err = 3  Reciprocal condition number: Estimated normwise
                  reciprocal condition number.  Compared with the threshold
                  sqrt(n) * slamch('Epsilon') to determine if the error
                  estimate is "guaranteed". These reciprocal condition
                  numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
                  appropriately scaled matrix Z.
                  Let Z = S*A, where S scales each row by a power of the
                  radix so all absolute row sums of Z are approximately 1.
 \n
          This subroutine is only responsible for setting the second field
          above. \n
          See Lapack Working Note 165 for further details and extra
          cautions. \n
 * @param[in,out] ERR_BNDS_COMP
          ERR_BNDS_COMP is REAL array, dimension (NRHS, N_ERR_BNDS) \n
          For each right-hand side, this array contains information about
          various error bounds and condition numbers corresponding to the
          componentwise relative error, which is defined as follows: \n
 \n
          Componentwise relative error in the ith solution vector: \n
                        abs(XTRUE(j,i) - X(j,i)) \n
                 max_j ---------------------- \n
                             abs(X(j,i)) \n
 \n
          The array is indexed by the right-hand side i (on which the
          componentwise relative error depends), and the type of error
          information as described below. There currently are up to three
          pieces of information   returned for each right-hand side. If
          componentwise accuracy is not requested (PARAMS(3) = 0.0), then
          ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS < 3, then at most
          the first (:,N_ERR_BNDS) entries are returned.
 \n
          The first index in ERR_BNDS_COMP(i,:) corresponds to the ith
          right-hand side.
 \n
          The second index in ERR_BNDS_COMP(:,err) contains the following
          three fields: \n
          err = 1 "Trust/don't trust" boolean. Trust the answer if the
                  reciprocal condition number is less than the threshold
                  sqrt(n) * slamch('Epsilon').
 \n
          err = 2 "Guaranteed" error bound: The estimated forward error,
                  almost certainly within a factor of 10 of the true error
                  so long as the next entry is greater than the threshold
                  sqrt(n) * slamch('Epsilon'). This error bound should only
                  be trusted if the previous boolean is true.
 \n
          err = 3  Reciprocal condition number: Estimated componentwise
                  reciprocal condition number.  Compared with the threshold
                  sqrt(n) * slamch('Epsilon') to determine if the error
                  estimate is "guaranteed". These reciprocal condition
                  numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
                  appropriately scaled matrix Z.
                  Let Z = S*(A*diag(x)), where x is the solution for the
                  current right-hand side and S scales each row of
                  A*diag(x) by a power of the radix so all absolute row
                  sums of Z are approximately 1.
 \n
          This subroutine is only responsible for setting the second field
          above. \n
          See Lapack Working Note 165 for further details and extra
          cautions. \n
 * @param[in] RES
          RES is REAL array, dimension (N) \n
          Workspace to hold the intermediate residual. \n
 * @param[in] AYB
          AYB is REAL array, dimension (N) \n
          Workspace. This can be the same workspace passed for Y_TAIL. \n
 * @param[in] DY
          DY is REAL array, dimension (N) \n
          Workspace to hold the intermediate solution. \n
 * @param[in] Y_TAIL
          Y_TAIL is REAL array, dimension (N) \n
          Workspace to hold the trailing bits of the intermediate solution. \n
 * @param[in] RCOND
          RCOND is REAL \n
          Reciprocal scaled condition number.  This is an estimate of the
          reciprocal Skeel condition number of the matrix A after
          equilibration (if done).  If this is less than the machine
          precision (in particular, if it is zero), the matrix is singular
          to working precision.  Note that the error may still be small even
          if this number is very small and the matrix appears ill-
          conditioned. \n
 * @param[in] ITHRESH
          ITHRESH is INTEGER \n
          The maximum number of residual computations allowed for
          refinement. The default is 10. For 'aggressive' set to 100 to
          permit convergence using approximate factorizations or
          factorizations other than LU. If the factorization uses a
          technique other than Gaussian elimination, the guarantees in
          ERR_BNDS_NORM and ERR_BNDS_COMP may no longer be trustworthy. \n
 * @param[in] RTHRESH
          RTHRESH is REAL \n
          Determines when to stop refinement if the error estimate stops
          decreasing. Refinement will stop when the next solution no longer
          satisfies norm(dx_{i+1}) < RTHRESH * norm(dx_i) where norm(Z) is
          the infinity norm of Z. RTHRESH satisfies 0 < RTHRESH <= 1. The
          default value is 0.5. For 'aggressive' set to 0.9 to permit
          convergence on extremely ill-conditioned matrices. See LAWN 165
          for more details. \n
 * @param[in] DZ_UB
          DZ_UB is REAL \n
          Determines when to start considering componentwise convergence.
          Componentwise convergence is only considered after each component
          of the solution Y is stable, which we definte as the relative
          change in each component being less than DZ_UB. The default value
          is 0.25, requiring the first bit to be stable. See LAWN 165 for
          more details. \n
 * @param[in] IGNORE_CWISE
          IGNORE_CWISE is LOGICAL \n
          If .TRUE. then ignore componentwise convergence. Default value
          is .FALSE.. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  Successful exit. \n
          < 0:  if INFO = -i, the ith argument to SPOTRS had an illegal
                value  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer la_porfsx_extended(integer *prec_type, char *uplo, integer *n, integer *nrhs, T *a, integer *lda, T *af, integer * ldaf, logical *colequ, T *c, T *b, integer *ldb, T *y, integer *ldy, T *berr_out, integer *n_norms, T * err_bnds_norm, T *err_bnds_comp, T *res, T *ayb, T * dy, T *y_tail, T *rcond, integer *ithresh, T *rthresh, T *dz_ub, logical *ignore_cwise, integer *info)
{
  return la_porfsx_extended(prec_type, uplo, n, nrhs, a, lda, af, ldaf, colequ, c, b, ldb, y, ldy, berr_out, n_norms, err_bnds_norm, err_bnds_comp, res, ayb, dy, y_tail, rcond, ithresh, rthresh, dz_ub, ignore_cwise, info);
}
template< typename T, typename Ta >
integer la_porfsx_extended(integer *prec_type, char *uplo, integer *n, integer *nrhs, T *a, integer *lda, T *af, integer *ldaf, logical *colequ, Ta *c, T *b, integer *ldb, T *y, integer *ldy, Ta *berr_out, integer *n_norms, Ta * err_bnds_norm, Ta *err_bnds_comp, T *res, Ta *ayb, T *dy, T *y_tail, Ta *rcond, integer *ithresh, Ta * rthresh, Ta *dz_ub, logical *ignore_cwise, integer *info)
{
  return la_porfsx_extended(prec_type, uplo, n, nrhs, a, lda, af, ldaf, colequ, c, b, ldb, y, ldy, berr_out, n_norms, err_bnds_norm, err_bnds_comp, res, ayb, dy, y_tail, rcond, ithresh, rthresh, dz_ub, ignore_cwise, info);
}

/*! @brief LA_SYRFSX_EXTENDED improves the computed solution to a system \n
     of linear equations for symmetric indefinite matrices by performing \n
     extra-precise iterative refinement and provides error bounds and    \n
     backward error estimates for the solution
 * @details
 * \b Purpose:
    \verbatim 
    LA_SYRFSX_EXTENDED improves the computed solution to a system of
    linear equations by performing extra-precise iterative refinement
    and provides error bounds and backward error estimates for the solution.
    This subroutine is called by SSYRFSX to perform iterative refinement.
    In addition to normwise error bound, the code provides maximum
    componentwise error bound if possible. See comments for ERR_BNDS_NORM
    and ERR_BNDS_COMP for details of the error bounds. Note that this
    subroutine is only resonsible for setting the second fields of
    ERR_BNDS_NORM and ERR_BNDS_COMP.
    \endverbatim  

 * @param[in] PREC_TYPE
          PREC_TYPE is INTEGER \n
          Specifies the intermediate precision to be used in refinement. \n
          The value is defined by ILAPREC(P) where P is a CHARACTER and P \n
              = 'S':  Single \n
              = 'D':  Double \n
              = 'I':  Indigenous \n
              = 'X' or 'E':  Extra \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right-hand-sides, i.e., the number of columns of the
          matrix B. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the N-by-N matrix A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] AF
          AF is REAL array, dimension (LDAF,N) \n
          The block diagonal matrix D and the multipliers used to
          obtain the factor U or L as computed by SSYTRF. \n
 * @param[in] LDAF
          LDAF is INTEGER \n
          The leading dimension of the array AF.  LDAF >= max(1,N). \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D
          as determined by SSYTRF. \n
 * @param[in] COLEQU
          COLEQU is LOGICAL \n
          If .TRUE. then column equilibration was done to A before calling
          this routine. This is needed to compute the solution and error
          bounds correctly. \n
 * @param[in] C
          C is REAL array, dimension (N) \n
          The column scale factors for A. If COLEQU = .FALSE., C
          is not accessed. If C is input, each element of C should be a power
          of the radix to ensure a reliable solution and error estimates.
          Scaling by powers of the radix does not cause rounding errors unless
          the result underflows or overflows. Rounding errors during scaling
          lead to refining with a matrix that is not equivalent to the
          input matrix, producing error estimates that may not be
          reliable. \n
 * @param[in] B
          B is REAL array, dimension (LDB,NRHS) \n
          The right-hand-side matrix B. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[in,out] Y
          Y is REAL array, dimension (LDY,NRHS) \n
          On entry, the solution matrix X, as computed by SSYTRS. \n
          On exit, the improved solution matrix Y. \n
 * @param[in] LDY
          LDY is INTEGER \n
          The leading dimension of the array Y.  LDY >= max(1,N). \n
 * @param[out] BERR_OUT
          BERR_OUT is REAL array, dimension (NRHS) \n
          On exit, BERR_OUT(j) contains the componentwise relative backward
          error for right-hand-side j from the formula \n
             max(i) (abs(RES(i)) / (abs(op(A_s))*abs(Y) + abs(B_s))(i)) \n
          where abs(Z) is the componentwise absolute value of the matrix
          or vector Z. This is computed by SLA_LIN_BERR. \n
 * @param[in] N_NORMS
          N_NORMS is INTEGER \n
          Determines which error bounds to   return (see ERR_BNDS_NORM
          and ERR_BNDS_COMP). \n
          If N_NORMS >= 1   return normwise error bounds. \n
          If N_NORMS >= 2   return componentwise error bounds. \n
 * @param[in,out] ERR_BNDS_NORM
          ERR_BNDS_NORM is REAL array, dimension (NRHS, N_ERR_BNDS) \n
          For each right-hand side, this array contains information about
          various error bounds and condition numbers corresponding to the
          normwise relative error, which is defined as follows: \n
 \n
          Normwise relative error in the ith solution vector: \n
                 max_j (abs(XTRUE(j,i) - X(j,i))) \n
                ------------------------------ \n
                      max_j abs(X(j,i)) \n
 \n
          The array is indexed by the type of error information as described
          below. There currently are up to three pieces of information
           returned. \n
 \n
          The first index in ERR_BNDS_NORM(i,:) corresponds to the ith
          right-hand side. \n
 \n
          The second index in ERR_BNDS_NORM(:,err) contains the following
          three fields: \n
          err = 1 "Trust/don't trust" boolean. Trust the answer if the
                  reciprocal condition number is less than the threshold
                  sqrt(n) * slamch('Epsilon').
 \n
          err = 2 "Guaranteed" error bound: The estimated forward error,
                  almost certainly within a factor of 10 of the true error
                  so long as the next entry is greater than the threshold
                  sqrt(n) * slamch('Epsilon'). This error bound should only
                  be trusted if the previous boolean is true.
 \n
          err = 3  Reciprocal condition number: Estimated normwise
                  reciprocal condition number.  Compared with the threshold
                  sqrt(n) * slamch('Epsilon') to determine if the error
                  estimate is "guaranteed". These reciprocal condition
                  numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
                  appropriately scaled matrix Z.
                  Let Z = S*A, where S scales each row by a power of the
                  radix so all absolute row sums of Z are approximately 1.
 \n
          This subroutine is only responsible for setting the second field
          above. \n
          See Lapack Working Note 165 for further details and extra
          cautions. \n
 * @param[in,out] ERR_BNDS_COMP
          ERR_BNDS_COMP is REAL array, dimension (NRHS, N_ERR_BNDS) \n
          For each right-hand side, this array contains information about
          various error bounds and condition numbers corresponding to the
          componentwise relative error, which is defined as follows: \n
 \n
          Componentwise relative error in the ith solution vector: \n
                        abs(XTRUE(j,i) - X(j,i)) \n
                 max_j ---------------------- \n
                             abs(X(j,i)) \n
 \n
          The array is indexed by the right-hand side i (on which the
          componentwise relative error depends), and the type of error
          information as described below. There currently are up to three
          pieces of information   returned for each right-hand side. If
          componentwise accuracy is not requested (PARAMS(3) = 0.0), then
          ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS < 3, then at most
          the first (:,N_ERR_BNDS) entries are   returned. \n
 \n
          The first index in ERR_BNDS_COMP(i,:) corresponds to the ith
          right-hand side.
 \n
          The second index in ERR_BNDS_COMP(:,err) contains the following
          three fields: \n
          err = 1 "Trust/don't trust" boolean. Trust the answer if the
                  reciprocal condition number is less than the threshold
                  sqrt(n) * slamch('Epsilon').
 \n
          err = 2 "Guaranteed" error bound: The estimated forward error,
                  almost certainly within a factor of 10 of the true error
                  so long as the next entry is greater than the threshold
                  sqrt(n) * slamch('Epsilon'). This error bound should only
                  be trusted if the previous boolean is true.
 \n
          err = 3  Reciprocal condition number: Estimated componentwise
                  reciprocal condition number.  Compared with the threshold
                  sqrt(n) * slamch('Epsilon') to determine if the error
                  estimate is "guaranteed". These reciprocal condition
                  numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
                  appropriately scaled matrix Z.
                  Let Z = S*(A*diag(x)), where x is the solution for the
                  current right-hand side and S scales each row of
                  A*diag(x) by a power of the radix so all absolute row
                  sums of Z are approximately 1.
 \n
          This subroutine is only responsible for setting the second field
          above. \n
          See Lapack Working Note 165 for further details and extra
          cautions. \n
 * @param[in] RES
          RES is REAL array, dimension (N) \n
          Workspace to hold the intermediate residual. \n
 * @param[in] AYB
          AYB is REAL array, dimension (N) \n
          Workspace. This can be the same workspace passed for Y_TAIL. \n
 * @param[in] DY
          DY is REAL array, dimension (N) \n
          Workspace to hold the intermediate solution. \n
 * @param[in] Y_TAIL
          Y_TAIL is REAL array, dimension (N) \n
          Workspace to hold the trailing bits of the intermediate solution. \n
 * @param[in] RCOND
          RCOND is REAL \n
          Reciprocal scaled condition number.  This is an estimate of the
          reciprocal Skeel condition number of the matrix A after
          equilibration (if done).  If this is less than the machine
          precision (in particular, if it is zero), the matrix is singular
          to working precision.  Note that the error may still be small even
          if this number is very small and the matrix appears ill-
          conditioned. \n
 * @param[in] ITHRESH
          ITHRESH is INTEGER \n
          The maximum number of residual computations allowed for
          refinement. The default is 10. For 'aggressive' set to 100 to
          permit convergence using approximate factorizations or
          factorizations other than LU. If the factorization uses a
          technique other than Gaussian elimination, the guarantees in
          ERR_BNDS_NORM and ERR_BNDS_COMP may no longer be trustworthy. \n
 * @param[in] RTHRESH
          RTHRESH is REAL \n
          Determines when to stop refinement if the error estimate stops
          decreasing. Refinement will stop when the next solution no longer
          satisfies norm(dx_{i+1}) < RTHRESH * norm(dx_i) where norm(Z) is
          the infinity norm of Z. RTHRESH satisfies 0 < RTHRESH <= 1. The
          default value is 0.5. For 'aggressive' set to 0.9 to permit
          convergence on extremely ill-conditioned matrices. See LAWN 165
          for more details. \n
 * @param[in] DZ_UB
          DZ_UB is REAL \n
          Determines when to start considering componentwise convergence.
          Componentwise convergence is only considered after each component
          of the solution Y is stable, which we definte as the relative
          change in each component being less than DZ_UB. The default value
          is 0.25, requiring the first bit to be stable. See LAWN 165 for
          more details. \n
 * @param[in] IGNORE_CWISE
          IGNORE_CWISE is LOGICAL \n
          If .TRUE. then ignore componentwise convergence. Default value
          is .FALSE.. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  Successful exit. \n
          < 0:  if INFO = -i, the ith argument to SLA_SYRFSX_EXTENDED had an illegal
                value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer la_syrfsx_extended(integer *prec_type, char *uplo, integer *n, integer *nrhs, T *a, integer *lda, T *af, integer * ldaf, integer *ipiv, logical *colequ, T *c, T *b, integer * ldb, T *y, integer *ldy, T *berr_out, integer *n_norms, T *err_bnds_norm, T *err_bnds_comp, T *res, T *ayb, T *dy, T *y_tail, T *rcond, integer *ithresh, T * rthresh, T *dz_ub, logical *ignore_cwise, integer *info)
{
  return la_syrfsx_extended(prec_type, uplo, n, nrhs, a, lda, af, ldaf, ipiv, colequ, c, b, ldb, y, ldy, berr_out, n_norms, err_bnds_norm, err_bnds_comp, res, ayb, dy, y_tail, rcond, ithresh, rthresh, dz_ub, ignore_cwise, info);
}
template< typename T, typename Ta >
integer la_syrfsx_extended(integer *prec_type, char *uplo, integer *n, integer *nrhs, T *a, integer *lda, T *af, integer *ldaf, integer *ipiv, logical *colequ, Ta *c, T *b, integer *ldb, T *y, integer *ldy, Ta *berr_out, integer * n_norms, Ta *err_bnds_norm, Ta *err_bnds_comp, T *res, Ta *ayb, T *dy, T *y_tail, Ta *rcond, integer * ithresh, Ta *rthresh, Ta *dz_ub, logical *ignore_cwise, integer *info)
{
  return la_syrfsx_extended(prec_type, uplo, n, nrhs, a, lda, af, ldaf, ipiv, colequ, c, b, ldb, y, ldy, berr_out, n_norms, err_bnds_norm, err_bnds_comp, res, ayb, dy, y_tail, rcond, ithresh, rthresh, dz_ub, ignore_cwise, info);
}

/*! @brief LA_HERFSX_EXTENDED improves the computed solution to a system \n
     of linear equations for Hermitian indefinite matrices by performing \n
     extra-precise iterative refinement and provides error bounds and    \n
     backward error estimates for the solution
 * @details
 * \b Purpose:
    \verbatim 
    LA_HERFSX_EXTENDED improves the computed solution to a system of
    linear equations by performing extra-precise iterative refinement
    and provides error bounds and backward error estimates for the solution.
    This subroutine is called by CHERFSX to perform iterative refinement.
    In addition to normwise error bound, the code provides maximum
    componentwise error bound if possible. See comments for ERR_BNDS_NORM
    and ERR_BNDS_COMP for details of the error bounds. Note that this
    subroutine is only resonsible for setting the second fields of
    ERR_BNDS_NORM and ERR_BNDS_COMP.
    \endverbatim  

 * @param[in] PREC_TYPE
          PREC_TYPE is INTEGER \n
          Specifies the intermediate precision to be used in refinement. \n
          The value is defined by ILAPREC(P) where P is a CHARACTER and P \n
              = 'S':  Single \n
              = 'D':  Double \n
              = 'I':  Indigenous \n
              = 'X' or 'E':  Extra \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right-hand-sides, i.e., the number of columns of the
          matrix B. \n
 * @param[in] A
          A is COMPLEX array, dimension (LDA,N) \n
          On entry, the N-by-N matrix A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] AF
          AF is COMPLEX array, dimension (LDAF,N) \n
          The block diagonal matrix D and the multipliers used to
          obtain the factor U or L as computed by CHETRF. \n
 * @param[in] LDAF
          LDAF is INTEGER \n
          The leading dimension of the array AF.  LDAF >= max(1,N). \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D
          as determined by CHETRF. \n
 * @param[in] COLEQU
          COLEQU is LOGICAL \n
          If .TRUE. then column equilibration was done to A before calling
          this routine. This is needed to compute the solution and error
          bounds correctly. \n
 * @param[in] C
          C is REAL array, dimension (N) \n
          The column scale factors for A. If COLEQU = .FALSE., C
          is not accessed. If C is input, each element of C should be a power
          of the radix to ensure a reliable solution and error estimates.
          Scaling by powers of the radix does not cause rounding errors unless
          the result underflows or overflows. Rounding errors during scaling
          lead to refining with a matrix that is not equivalent to the
          input matrix, producing error estimates that may not be
          reliable. \n
 * @param[in] B
          B is COMPLEX array, dimension (LDB,NRHS) \n
          The right-hand-side matrix B. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[in,out] Y
          Y is COMPLEX array, dimension (LDY,NRHS) \n
          On entry, the solution matrix X, as computed by CHETRS.
          On exit, the improved solution matrix Y. \n
 * @param[in] LDY
          LDY is INTEGER \n
          The leading dimension of the array Y.  LDY >= max(1,N). \n
 * @param[out] BERR_OUT
          BERR_OUT is REAL array, dimension (NRHS) \n
          On exit, BERR_OUT(j) contains the componentwise relative backward
          error for right-hand-side j from the formula \n
             max(i) (abs(RES(i)) / (abs(op(A_s))*abs(Y) + abs(B_s))(i)) \n
          where abs(Z) is the componentwise absolute value of the matrix
          or vector Z. This is computed by CLA_LIN_BERR. \n
 * @param[in] N_NORMS
          N_NORMS is INTEGER
          Determines which error bounds to   return (see ERR_BNDS_NORM
          and ERR_BNDS_COMP). \n
          If N_NORMS >= 1   return normwise error bounds. \n
          If N_NORMS >= 2   return componentwise error bounds. \n
 * @param[in,out] ERR_BNDS_NORM
          ERR_BNDS_NORM is REAL array, dimension (NRHS, N_ERR_BNDS) \n
          For each right-hand side, this array contains information about
          various error bounds and condition numbers corresponding to the
          normwise relative error, which is defined as follows: \n
 \n
          Normwise relative error in the ith solution vector: \n
                 max_j (abs(XTRUE(j,i) - X(j,i))) \n
                ------------------------------ \n
                      max_j abs(X(j,i)) \n
 \n
          The array is indexed by the type of error information as described
          below. There currently are up to three pieces of information
          returned. \n
 \n
          The first index in ERR_BNDS_NORM(i,:) corresponds to the ith
          right-hand side. \n
 \n
          The second index in ERR_BNDS_NORM(:,err) contains the following
          three fields: \n
          err = 1 "Trust/don't trust" boolean. Trust the answer if the
                  reciprocal condition number is less than the threshold
                  sqrt(n) * slamch('Epsilon').
 \n
          err = 2 "Guaranteed" error bound: The estimated forward error,
                  almost certainly within a factor of 10 of the true error
                  so long as the next entry is greater than the threshold
                  sqrt(n) * slamch('Epsilon'). This error bound should only
                  be trusted if the previous boolean is true.
 \n
          err = 3  Reciprocal condition number: Estimated normwise
                  reciprocal condition number.  Compared with the threshold
                  sqrt(n) * slamch('Epsilon') to determine if the error
                  estimate is "guaranteed". These reciprocal condition
                  numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
                  appropriately scaled matrix Z.
                  Let Z = S*A, where S scales each row by a power of the
                  radix so all absolute row sums of Z are approximately 1.
 \n
          This subroutine is only responsible for setting the second field
          above. \n
          See Lapack Working Note 165 for further details and extra
          cautions. \n
 * @param[in,out] ERR_BNDS_COMP
          ERR_BNDS_COMP is REAL array, dimension (NRHS, N_ERR_BNDS) \n
          For each right-hand side, this array contains information about
          various error bounds and condition numbers corresponding to the
          componentwise relative error, which is defined as follows: \n
 \n
          Componentwise relative error in the ith solution vector: \n
                        abs(XTRUE(j,i) - X(j,i)) \n
                 max_j ---------------------- \n
                             abs(X(j,i)) \n
 \n
          The array is indexed by the right-hand side i (on which the
          componentwise relative error depends), and the type of error
          information as described below. There currently are up to three
          pieces of information   returned for each right-hand side. If
          componentwise accuracy is not requested (PARAMS(3) = 0.0), then
          ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS < 3, then at most
          the first (:,N_ERR_BNDS) entries are   returned. \n
 \n
          The first index in ERR_BNDS_COMP(i,:) corresponds to the ith
          right-hand side. \n
 \n
          The second index in ERR_BNDS_COMP(:,err) contains the following
          three fields: \n
          err = 1 "Trust/don't trust" boolean. Trust the answer if the
                  reciprocal condition number is less than the threshold
                  sqrt(n) * slamch('Epsilon').
 \n
          err = 2 "Guaranteed" error bound: The estimated forward error,
                  almost certainly within a factor of 10 of the true error
                  so long as the next entry is greater than the threshold
                  sqrt(n) * slamch('Epsilon'). This error bound should only
                  be trusted if the previous boolean is true.
 \n
          err = 3  Reciprocal condition number: Estimated componentwise
                  reciprocal condition number.  Compared with the threshold
                  sqrt(n) * slamch('Epsilon') to determine if the error
                  estimate is "guaranteed". These reciprocal condition
                  numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
                  appropriately scaled matrix Z.
                  Let Z = S*(A*diag(x)), where x is the solution for the
                  current right-hand side and S scales each row of
                  A*diag(x) by a power of the radix so all absolute row
                  sums of Z are approximately 1.
 \n
          This subroutine is only responsible for setting the second field
          above. \n
          See Lapack Working Note 165 for further details and extra
          cautions. \n
 * @param[in] RES
          RES is COMPLEX array, dimension (N) \n
          Workspace to hold the intermediate residual. \n
 * @param[in] AYB
          AYB is REAL array, dimension (N) \n
          Workspace. \n
 * @param[in] DY
          DY is COMPLEX array, dimension (N) \n
          Workspace to hold the intermediate solution. \n
 * @param[in] Y_TAIL
          Y_TAIL is COMPLEX array, dimension (N) \n
          Workspace to hold the trailing bits of the intermediate solution. \n
 * @param[in] RCOND
          RCOND is REAL \n
          Reciprocal scaled condition number.  This is an estimate of the
          reciprocal Skeel condition number of the matrix A after
          equilibration (if done).  If this is less than the machine
          precision (in particular, if it is zero), the matrix is singular
          to working precision.  Note that the error may still be small even
          if this number is very small and the matrix appears ill-
          conditioned. \n
 * @param[in] ITHRESH
          ITHRESH is INTEGER \n
          The maximum number of residual computations allowed for
          refinement. The default is 10. For 'aggressive' set to 100 to
          permit convergence using approximate factorizations or
          factorizations other than LU. If the factorization uses a
          technique other than Gaussian elimination, the guarantees in
          ERR_BNDS_NORM and ERR_BNDS_COMP may no longer be trustworthy. \n
 * @param[in] RTHRESH
          RTHRESH is REAL \n
          Determines when to stop refinement if the error estimate stops
          decreasing. Refinement will stop when the next solution no longer
          satisfies norm(dx_{i+1}) < RTHRESH * norm(dx_i) where norm(Z) is
          the infinity norm of Z. RTHRESH satisfies 0 < RTHRESH <= 1. The
          default value is 0.5. For 'aggressive' set to 0.9 to permit
          convergence on extremely ill-conditioned matrices. See LAWN 165
          for more details. \n
 * @param[in] DZ_UB
          DZ_UB is REAL \n
          Determines when to start considering componentwise convergence.
          Componentwise convergence is only considered after each component
          of the solution Y is stable, which we definte as the relative
          change in each component being less than DZ_UB. The default value
          is 0.25, requiring the first bit to be stable. See LAWN 165 for
          more details. \n
 * @param[in] IGNORE_CWISE
          IGNORE_CWISE is LOGICAL \n
          If .TRUE. then ignore componentwise convergence. Default value
          is .FALSE.. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  Successful exit. \n
          < 0:  if INFO = -i, the ith argument to CLA_HERFSX_EXTENDED had an illegal
                value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T, typename Ta >
integer la_herfsx_extended(integer *prec_type, char *uplo, integer *n, integer *nrhs, T *a, integer *lda, T *af, integer *ldaf, integer *ipiv, logical *colequ, Ta *c, T *b, integer *ldb, T *y, integer *ldy, Ta *berr_out, integer * n_norms, Ta *err_bnds_norm, Ta *err_bnds_comp, T *res, Ta *ayb, T *dy, T *y_tail, Ta *rcond, integer * ithresh, Ta *rthresh, Ta *dz_ub, logical *ignore_cwise, integer *info)
{
  return la_herfsx_extended(prec_type, uplo, n, nrhs, a, lda, af, ldaf, ipiv, colequ, c, b, ldb, y, ldy, berr_out, n_norms, err_bnds_norm, err_bnds_comp, res, ayb, dy, y_tail, rcond, ithresh, rthresh, dz_ub, ignore_cwise, info);
}

/*! @brief LA_GBRPVGRW computes the reciprocal pivot growth factor norm(A)/norm(U) for a general banded matrix.

 * @details
 * \b Purpose:
    \verbatim 
    LA_GBRPVGRW computes the reciprocal pivot growth factor
    norm(A)/norm(U). The "max absolute element" norm is used. If this is
    much less than 1, the stability of the LU factorization of the
    (equilibrated) matrix A could be poor. This also means that the
    solution X, estimated condition numbers, and error bounds could be
    unreliable.
    \endverbatim  

 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] KL
          KL is INTEGER \n
          The number of subdiagonals within the band of A.  KL >= 0. \n
 * @param[in] KU
          KU is INTEGER \n
          The number of superdiagonals within the band of A.  KU >= 0. \n
 * @param[in] NCOLS
          NCOLS is INTEGER \n
          The number of columns of the matrix A.  NCOLS >= 0. \n
 * @param[in] AB
          AB is REAL array, dimension (LDAB,N) \n
          On entry, the matrix A in band storage, in rows 1 to KL+KU+1.
          The j-th column of A is stored in the j-th column of the
          array AB as follows: \n
          AB(KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+kl) \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          The leading dimension of the array AB.  LDAB >= KL+KU+1. \n
 * @param[in] AFB
          AFB is REAL array, dimension (LDAFB,N) \n
          Details of the LU factorization of the band matrix A, as
          computed by SGBTRF.  U is stored as an upper triangular
          band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1,
          and the multipliers used during the factorization are stored
          in rows KL+KU+2 to 2*KL+KU+1. \n
 * @param[in] LDAFB
          LDAFB is INTEGER \n
          The leading dimension of the array AFB.  LDAFB >= 2*KL+KU+1. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
T la_gbrpvgrw(integer *n, integer *kl, integer *ku, integer *ncols, T *ab, integer *ldab, T *afb, integer *ldafb)
{
  return la_gbrpvgrw(n, kl, ku, ncols, ab, ldab, afb, ldafb);
}
template< typename T, typename Ta >
Ta la_gbrpvgrw(integer *n, integer *kl, integer *ku, integer *ncols, T *ab, integer *ldab, T *afb, integer *ldafb)
{
  return la_gbrpvgrw(n, kl, ku, ncols, ab, ldab, afb, ldafb);
}

/*! @brief LA_GEAMV computes a matrix-vector product using a general matrix to calculate error bounds

 * @details
 * \b Purpose:
    \verbatim 
    LA_GEAMV  performs one of the matrix-vector operations

            y := alpha*abs(A)*abs(x) + beta*abs(y),
       or   y := alpha*abs(A)**T*abs(x) + beta*abs(y),

    where alpha and beta are scalars, x and y are vectors and A is an
    m by n matrix.

    This function is primarily used in calculating error bounds.
    To protect against underflow during evaluation, components in
    the resulting vector are perturbed away from zero by (N+1)
    times the underflow threshold.  To prevent unnecessarily large
    errors for block-structure embedded in general matrices,
    "symbolically" zero components are not perturbed.  A zero
    entry is considered "symbolic" if all multiplications involved
    in computing that entry have at least one zero multiplicand.
    
    Level 2 Blas routine.
    \endverbatim 

 * @param[in] TRANS
          TRANS is INTEGER \n
          On entry, TRANS specifies the operation to be performed as
          follows: \n
 \n
            BLAS_NO_TRANS      y := alpha*abs(A)*abs(x) + beta*abs(y) \n
            BLAS_TRANS         y := alpha*abs(A**T)*abs(x) + beta*abs(y) \n
            BLAS_CONJ_TRANS    y := alpha*abs(A**T)*abs(x) + beta*abs(y) \n
 \n
          Unchanged on exit. \n
 * @param[in] M
          M is INTEGER \n
          On entry, M specifies the number of rows of the matrix A.
          M must be at least zero. \n
          Unchanged on exit. \n
 * @param[in] N
          N is INTEGER \n
          On entry, N specifies the number of columns of the matrix A.
          N must be at least zero. \n
          Unchanged on exit. \n
 * @param[in] ALPHA
          ALPHA is REAL \n
          On entry, ALPHA specifies the scalar alpha.
          Unchanged on exit. \n
 * @param[in] A
          A is REAL array, dimension (LDA, n) \n
          Before entry, the leading m by n part of the array A must
          contain the matrix of coefficients. \n
          Unchanged on exit. \n
 * @param[in] LDA
          LDA is INTEGER \n
          On entry, LDA specifies the first dimension of A as declared
          in the calling (sub) program. LDA must be at least
          max(1, m). \n
          Unchanged on exit. \n
 * @param[in] X
          X is REAL array, dimension
          (1 + (n - 1)*abs(INCX)) when TRANS = 'N' or 'n' \n
          and at least
          (1 + (m - 1)*abs(INCX)) otherwise. \n
          Before entry, the incremented array X must contain the
          vector x. \n
          Unchanged on exit. \n
 * @param[in] INCX
          INCX is INTEGER \n
          On entry, INCX specifies the increment for the elements of
          X. INCX must not be zero. \n
          Unchanged on exit. \n
 * @param[in] BETA
          BETA is REAL \n
          On entry, BETA specifies the scalar beta. When BETA is
          supplied as zero then Y need not be set on input. \n
          Unchanged on exit. \n
 * @param[in,out] Y
          Y is REAL array,
          dimension at least
          (1 + (m - 1)*abs(INCY)) when TRANS = 'N' or 'n' \n
          and at least
          (1 + (n - 1)*abs(INCY)) otherwise. \n
          Before entry with BETA non-zero, the incremented array Y
          must contain the vector y. On exit, Y is overwritten by the
          updated vector y. \n
 * @param[in] INCY
          INCY is INTEGER \n
          On entry, INCY specifies the increment for the elements of
          Y. INCY must not be zero. \n
          Unchanged on exit. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer la_geamv(integer *trans, integer *m, integer *n, T *alpha, T *a, integer *lda, T *x, integer *incx, T * beta, T *y, integer *incy)
{
  return la_geamv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy);
}
template< typename T, typename Ta >
integer la_geamv(integer *trans, integer *m, integer *n, Ta *alpha, T *a, integer *lda, T *x, integer *incx, Ta * beta, Ta *y, integer *incy)
{
  return la_geamv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy);
}

/*! @brief LA_GERCOND estimates the Skeel condition number for a general matrix

 * @details
 * \b Purpose:
    \verbatim 
    LA_GERCOND estimates the Skeel condition number of op(A) * op2(C)
    where op2 is determined by CMODE as follows
    CMODE =  1    op2(C) = C
    CMODE =  0    op2(C) = I
    CMODE = -1    op2(C) = inv(C)
    The Skeel condition number cond(A) = norminf(|inv(A)||A|)
    is computed by computing scaling factors R such that
    diag(R)*A*op2(C) is row equilibrated and computing the standard
    infinity-norm condition number.
    \endverbatim  

 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          Specifies the form of the system of equations: \n
            = 'N':  A * X = B     (No transpose) \n
            = 'T':  A**T * X = B  (Transpose) \n
            = 'C':  A**H * X = B  (Conjugate Transpose = Transpose) \n
 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the N-by-N matrix A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] AF
          AF is REAL array, dimension (LDAF,N) \n
          The factors L and U from the factorization
          A = P*L*U as computed by SGETRF. \n
 * @param[in] LDAF
          LDAF is INTEGER \n
          The leading dimension of the array AF.  LDAF >= max(1,N). \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          The pivot indices from the factorization A = P*L*U
          as computed by SGETRF; row i of the matrix was interchanged
          with row IPIV(i). \n
 * @param[in] CMODE
          CMODE is INTEGER \n
          Determines op2(C) in the formula op(A) * op2(C) as follows: \n
          CMODE =  1    op2(C) = C \n
          CMODE =  0    op2(C) = I \n
          CMODE = -1    op2(C) = inv(C) \n
 * @param[in] C
          C is REAL array, dimension (N) \n
          The vector C in the formula op(A) * op2(C). \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  Successful exit. \n
          i > 0:  The ith argument is invalid. \n
 * @param[out] WORK
          WORK is REAL array, dimension (3*N). \n
          Workspace. \n
 * @param[out] IWORK
          IWORK is INTEGER array, dimension (N). \n
          Workspace.2 \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
T la_gercond(char *trans, integer *n, T *a, integer *lda, T *af, integer *ldaf, integer *ipiv, integer *cmode, T *c, integer * info, T *work, integer *iwork)
{
  return la_gercond(*trans, *n, a, *lda, af, *ldaf, *ipiv, *cmode, c, * info, work, *iwork); 
}
template< typename T, typename Ta >
Ta la_gercond_x(char *trans, integer *n, T *a, integer *lda, T *af, integer *ldaf, integer *ipiv, T *x, integer *info, T *work, Ta *rwork)
{
    return cla_gercond_x(*trans, *n, a, *lda, af, *ldaf, *ipiv, x, *info, work, *rwork); 
}
template< typename T, typename Ta >
Ta la_gercond_c(char *trans, integer *n, T *a, integer *lda, T *af, integer *ldaf, integer *ipiv, Ta *c, logical *capply, integer *info, T *work, Ta *rwork)
{
    return cla_gercond_c(*trans, *n, a, *lda, af, *ldaf, *ipiv, c, *capply, *info, work, *rwork); 
}

/*! @brief LA_GERPVGRW computes the reciprocal pivot growth factor norm(A)/norm(U)

 * @details
 * \b Purpose:
    \verbatim 
    LA_GERPVGRW computes the reciprocal pivot growth factor
    norm(A)/norm(U). The "max absolute element" norm is used. If this is
    much less than 1, the stability of the LU factorization of the
    (equilibrated) matrix A could be poor. This also means that the
    solution X, estimated condition numbers, and error bounds could be
    unreliable.
    \endverbatim  

 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] NCOLS
          NCOLS is INTEGER \n
          The number of columns of the matrix A. NCOLS >= 0. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the N-by-N matrix A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] AF
          AF is REAL array, dimension (LDAF,N) \n
          The factors L and U from the factorization
          A = P*L*U as computed by SGETRF. \n
 * @param[in] LDAF
          LDAF is INTEGER \n
          The leading dimension of the array AF.  LDAF >= max(1,N). \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
T la_gerpvgrw(integer *n, integer *ncols, T *a, integer *lda, T * af, integer *ldaf)
{
  return la_gerpvgrw(n, ncols, a, lda, af, ldaf);
}

/*! @brief LA_HEAMV computes a matrix-vector product using a Hermitian indefinite matrix to calculate error bounds

 * @details
 * \b Purpose:
    \verbatim 
    LA_HEAMV  performs the matrix-vector operation

            y := alpha*abs(A)*abs(x) + beta*abs(y),

    where alpha and beta are scalars, x and y are vectors and A is an
    n by n symmetric matrix.

    This function is primarily used in calculating error bounds.
    To protect against underflow during evaluation, components in
    the resulting vector are perturbed away from zero by (N+1)
    times the underflow threshold.  To prevent unnecessarily large
    errors for block-structure embedded in general matrices,
    "symbolically" zero components are not perturbed.  A zero
    entry is considered "symbolic" if all multiplications involved
    in computing that entry have at least one zero multiplicand.
    \endverbatim  

 * @param[in] UPLO
          UPLO is INTEGER \n
          On entry, UPLO specifies whether the upper or lower
          triangular part of the array A is to be referenced as
          follows: \n
 \n
              UPLO = BLAS_UPPER   Only the upper triangular part of A
                                  is to be referenced.
 \n
              UPLO = BLAS_LOWER   Only the lower triangular part of A
                                  is to be referenced.
 \n
          Unchanged on exit. \n
 * @param[in] N
          N is INTEGER \n
          On entry, N specifies the number of columns of the matrix A.
          N must be at least zero. \n
          Unchanged on exit. \n
 * @param[in] ALPHA
          ALPHA is REAL . \n
          On entry, ALPHA specifies the scalar alpha.
          Unchanged on exit. \n
 * @param[in] A
          A is COMPLEX array, dimension (LDA, n). \n
          Before entry, the leading m by n part of the array A must
          contain the matrix of coefficients. \n
          Unchanged on exit. \n
 * @param[in] LDA
          LDA is INTEGER \n
          On entry, LDA specifies the first dimension of A as declared
          in the calling (sub) program. LDA must be at least
          max(1, n). \n
          Unchanged on exit. \n
 * @param[in] X
          X is COMPLEX array, dimension
          (1 + (n - 1)*abs(INCX)) \n
          Before entry, the incremented array X must contain the
          vector x. \n
          Unchanged on exit. \n
 * @param[in] INCX
          INCX is INTEGER \n
          On entry, INCX specifies the increment for the elements of
          X. INCX must not be zero. \n
          Unchanged on exit. \n
 * @param[in] BETA
          BETA is REAL. \n
          On entry, BETA specifies the scalar beta. When BETA is
          supplied as zero then Y need not be set on input.
          Unchanged on exit. \n
 * @param[in,out] Y
          Y is REAL array, dimension
          (1 + (n - 1)*abs(INCY)) \n
          Before entry with BETA non-zero, the incremented array Y
          must contain the vector y. On exit, Y is overwritten by the
          updated vector y. \n
 * @param[in] INCY
          INCY is INTEGER \n
          On entry, INCY specifies the increment for the elements of
          Y. INCY must not be zero. \n
          Unchanged on exit. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T, typename Ta >
integer la_heamv(integer *uplo, integer *n, Ta *alpha, T *a, integer *lda, T *x, integer *incx, Ta *beta, Ta *y, integer *incy)
{
  return la_heamv(uplo, n, alpha, a, lda, x, incx, beta, y, incy);
}

/*! @brief LA_HERCOND_C computes the infinity norm condition number of op(A)*inv(diag(c)) for Hermitian indefinite matrices

 * @details
 * \b Purpose:
    \verbatim 
    LA_HERCOND_C computes the infinity norm condition number of
    op(A) * inv(diag(C)) where C is a REAL vector.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] A
          A is COMPLEX array, dimension (LDA,N)
          On entry, the N-by-N matrix A \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] AF
          AF is COMPLEX array, dimension (LDAF,N) \n
          The block diagonal matrix D and the multipliers used to
          obtain the factor U or L as computed by CHETRF. \n
 * @param[in] LDAF
          LDAF is INTEGER \n
          The leading dimension of the array AF.  LDAF >= max(1,N). \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D
          as determined by CHETRF. \n
 * @param[in] C
          C is REAL array, dimension (N) \n
          The vector C in the formula op(A) * inv(diag(C)). \n
 * @param[in] CAPPLY
          CAPPLY is LOGICAL \n
          If .TRUE. then access the vector C in the formula above. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  Successful exit. \n
          i > 0:  The ith argument is invalid. \n
 * @param[out] WORK
          WORK is COMPLEX array, dimension (2*N). \n
          Workspace. \n
 * @param[out] RWORK
          RWORK is REAL array, dimension (N). \n
          Workspace. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T, typename Ta >
Ta la_hercond_c(char *uplo, integer *n, T *a, integer *lda, T *af, integer *ldaf, integer *ipiv, Ta *c, logical *capply, integer *info, T *work, Ta *rwork)
{
  return la_hercond_c(uplo, n, a, lda, af, ldaf, ipiv, c, capply, info, work, rwork);
}

/*! @brief LA_HERCOND_X computes the infinity norm condition number of op(A)*diag(x) for Hermitian indefinite matrices

 * @details
 * \b Purpose:
    \verbatim 
    LA_HERCOND_X computes the infinity norm condition number of
    op(A) * diag(X) where X is a COMPLEX vector.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] A
          A is COMPLEX array, dimension (LDA,N) \n
          On entry, the N-by-N matrix A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] AF
          AF is COMPLEX array, dimension (LDAF,N) \n
          The block diagonal matrix D and the multipliers used to
          obtain the factor U or L as computed by CHETRF. \n
 * @param[in] LDAF
          LDAF is INTEGER \n
          The leading dimension of the array AF.  LDAF >= max(1,N). \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D
          as determined by CHETRF. \n
 * @param[in] X
          X is COMPLEX array, dimension (N) \n
          The vector X in the formula op(A) * diag(X). \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  Successful exit. \n
          i > 0:  The ith argument is invalid. \n
 * @param[out] WORK
          WORK is COMPLEX array, dimension (2*N). \n
          Workspace. \n
 * @param[out] RWORK
          RWORK is REAL array, dimension (N). \n
          Workspace.  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T, typename Ta >
Ta la_hercond_x(char *uplo, integer *n, T *a, integer *lda, T *af, integer *ldaf, integer *ipiv, T *x, integer *info, T *work, Ta *rwork)
{
  return la_hercond_x(uplo, n, a, lda, af, ldaf, ipiv, x, info, work, rwork);
}

/*! @brief LA_HERPVGRW computes the reciprocal pivot growth factor norm(A)/norm(U)

 * @details
 * \b Purpose:
    \verbatim 
    LA_HERPVGRW computes the reciprocal pivot growth factor
    norm(A)/norm(U). The "max absolute element" norm is used. If this is
    much less than 1, the stability of the LU factorization of the
    (equilibrated) matrix A could be poor. This also means that the
    solution X, estimated condition numbers, and error bounds could be
    unreliable.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] INFO
          INFO is INTEGER \n
          The value of INFO returned from SSYTRF, .i.e., the pivot in
          column INFO is exactly 0. \n
 * @param[in] A
          A is COMPLEX array, dimension (LDA,N) \n
          On entry, the N-by-N matrix A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] AF
          AF is COMPLEX array, dimension (LDAF,N) \n
          The block diagonal matrix D and the multipliers used to
          obtain the factor U or L as computed by CHETRF. \n
 * @param[in] LDAF
          LDAF is INTEGER \n
          The leading dimension of the array AF.  LDAF >= max(1,N). \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D
          as determined by CHETRF. \n
 * @param[out] WORK
          WORK is REAL array, dimension (2*N) \n

 * @return INTEGER Return value of the function.
 * */
template< typename T, typename Ta >
Ta la_herpvgrw(char *uplo, integer *n, integer *info, T *a, integer *lda, T *af, integer *ldaf, integer *ipiv, Ta *work)
{
  return la_herpvgrw(uplo, n, info, a, lda, af, ldaf, ipiv, work); 
}

/*! @brief LA_LIN_BERR computes a component-wise relative backward error

 * @details
 * \b Purpose:
    \verbatim 
    LA_LIN_BERR computes componentwise relative backward error from
    the formula
        max(i) (abs(R(i)) / (abs(op(A_s))*abs(Y) + abs(B_s))(i))
    where abs(Z) is the componentwise absolute value of the matrix
    or vector Z.
    \endverbatim 

 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] NZ
          NZ is INTEGER \n
          We add (NZ+1)*SLAMCH('Safe minimum') to R(i) in the numerator to
          guard against spuriously zero residuals. Default value is N. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrices AYB, RES, and BERR.  NRHS >= 0. \n
 * @param[in] RES
          RES is REAL array, dimension (N,NRHS) \n
          The residual matrix, i.e., the matrix R in the relative backward
          error formula above. \n
 * @param[in] AYB
          AYB is REAL array, dimension (N, NRHS) \n
          The denominator in the relative backward error formula above, i.e.,
          the matrix abs(op(A_s))*abs(Y) + abs(B_s). The matrices A, Y, and B
          are from iterative refinement (see sla_gerfsx_extended.f). \n
 * @param[out] BERR
          BERR is REAL array, dimension (NRHS) \n
          The componentwise relative backward error from the formula above. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer la_lin_berr(integer *n, integer *nz, integer *nrhs, T *res, T *ayb, T *berr)
{
  return la_lin_berr(n, nz, nrhs, res, ayb, berr);
}
template< typename T, typename Ta >
integer la_lin_berr(integer *n, integer *nz, integer *nrhs, T *res, Ta *ayb, Ta *berr)
{
  return la_lin_berr(n, nz, nrhs, res, ayb, berr);
}

/*! @brief LA_PORCOND estimates the Skeel condition number for a symmetric positive-definite matrix

 * @details
 * \b Purpose:
    \verbatim 
    LA_PORCOND Estimates the Skeel condition number of  op(A) * op2(C)
    where op2 is determined by CMODE as follows
    CMODE =  1    op2(C) = C
    CMODE =  0    op2(C) = I
    CMODE = -1    op2(C) = inv(C)
    The Skeel condition number  cond(A) = norminf(|inv(A)||A|)
    is computed by computing scaling factors R such that
    diag(R)*A*op2(C) is row equilibrated and computing the standard
    infinity-norm condition number.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the N-by-N matrix A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] AF
          AF is REAL array, dimension (LDAF,N) \n
          The triangular factor U or L from the Cholesky factorization
          A = U**T*U or A = L*L**T, as computed by SPOTRF. \n
 * @param[in] LDAF
          LDAF is INTEGER \n
          The leading dimension of the array AF.  LDAF >= max(1,N). \n
 * @param[in] CMODE
          CMODE is INTEGER \n
          Determines op2(C) in the formula op(A) * op2(C) as follows: \n
          CMODE =  1    op2(C) = C \n
          CMODE =  0    op2(C) = I \n
          CMODE = -1    op2(C) = inv(C) \n
 * @param[in] C
          C is REAL array, dimension (N) \n
          The vector C in the formula op(A) * op2(C). \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  Successful exit. \n
          i > 0:  The ith argument is invalid. \n
 * @param[out] WORK
          WORK is REAL array, dimension (3*N). \n
          Workspace. \n
 * @param[out] IWORK
          IWORK is INTEGER array, dimension (N). \n
          Workspace. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
T la_porcond(char *uplo, integer *n, T *a, integer *lda, T *af, integer *ldaf, integer *cmode, T *c, integer *info, T *work, integer *iwork)
{
  return la_porcond(uplo, n, a, lda, af, ldaf, cmode, c, info, work, iwork); 
}

/*! @brief LA_PORCOND_X computes the infinity norm condition number of op(A)*diag(x) for Hermitian positive-definite matrices

 * @details
 * \b Purpose:
    \verbatim 
    LA_PORCOND_X Computes the infinity norm condition number of
    op(A) * diag(X) where X is a COMPLEX vector.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] A
          A is COMPLEX array, dimension (LDA,N) \n
          On entry, the N-by-N matrix A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] AF
          AF is COMPLEX array, dimension (LDAF,N) \n
          The triangular factor U or L from the Cholesky factorization
          A = U**H*U or A = L*L**H, as computed by CPOTRF. \n
 * @param[in] LDAF
          LDAF is INTEGER \n
          The leading dimension of the array AF.  LDAF >= max(1,N). \n
 * @param[in] X
          X is COMPLEX array, dimension (N) \n
          The vector X in the formula op(A) * diag(X). \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  Successful exit. \n
          i > 0:  The ith argument is invalid. \n
 * @param[out] WORK
          WORK is COMPLEX array, dimension (2*N). \n
          Workspace. \n
 * @param[out] RWORK
          RWORK is REAL array, dimension (N). \n
          Workspace. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T, typename Ta >
Ta la_porcond_x(char *uplo, integer *n, T *a, integer *lda, T *af, integer *ldaf, T *x, integer *info, T *work, Ta *rwork)
{
  return la_porcond_x(uplo, n, a, lda, af, ldaf, x, info, work, rwork); 
}

/*! @brief LA_PORCOND_C computes the infinity norm condition number of op(A)*inv(diag(c)) for Hermitian positive-definite matrices

 * @details
 * \b Purpose:
    \verbatim 
    LA_PORCOND_C Computes the infinity norm condition number of
    op(A) * inv(diag(C)) where C is a REAL vector
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] A
          A is COMPLEX array, dimension (LDA,N) \n
          On entry, the N-by-N matrix A \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] AF
          AF is COMPLEX array, dimension (LDAF,N) \n
          The triangular factor U or L from the Cholesky factorization
          A = U**H*U or A = L*L**H, as computed by CPOTRF. \n
 * @param[in] LDAF
          LDAF is INTEGER \n
          The leading dimension of the array AF.  LDAF >= max(1,N). \n
 * @param[in] C
          C is REAL array, dimension (N) \n
          The vector C in the formula op(A) * inv(diag(C)). \n
 * @param[in] CAPPLY
          CAPPLY is LOGICAL \n
          If .TRUE. then access the vector C in the formula above. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  Successful exit. \n
          i > 0:  The ith argument is invalid. \n
 * @param[out] WORK
          WORK is COMPLEX array, dimension (2*N). \n
          Workspace. \n
 * @param[out] RWORK
          RWORK is REAL array, dimension (N). \n
          Workspace.  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T, typename Ta >
Ta la_porcond_c(char *uplo, integer *n, T *a, integer *lda, T *af, integer *ldaf, Ta *c, logical *capply, integer *info, T *work, Ta *rwork)
{
  return la_porcond_c(uplo, n, a, lda, af, ldaf, c, capply, info, work, rwork); 
}

/*! @brief LA_SYAMV computes a matrix-vector product using a symmetric indefinite matrix to calculate error bounds

 * @details
 * \b Purpose:
    \verbatim 
    LA_SYAMV  performs the matrix-vector operation

            y := alpha*abs(A)*abs(x) + beta*abs(y),

    where alpha and beta are scalars, x and y are vectors and A is an
    n by n symmetric matrix.

    This function is primarily used in calculating error bounds.
    To protect against underflow during evaluation, components in
    the resulting vector are perturbed away from zero by (N+1)
    times the underflow threshold.  To prevent unnecessarily large
    errors for block-structure embedded in general matrices,
    "symbolically" zero components are not perturbed.  A zero
    entry is considered "symbolic" if all multiplications involved
    in computing that entry have at least one zero multiplicand.
    \endverbatim  

 * @param[in] UPLO
          UPLO is INTEGER \n
          On entry, UPLO specifies whether the upper or lower
          triangular part of the array A is to be referenced as
          follows: \n
 \n
              UPLO = BLAS_UPPER   Only the upper triangular part of A
                                  is to be referenced.
 \n
              UPLO = BLAS_LOWER   Only the lower triangular part of A
                                  is to be referenced.
 \n
          Unchanged on exit. \n
 * @param[in] N
          N is INTEGER \n
          On entry, N specifies the number of columns of the matrix A.
          N must be at least zero. \n
          Unchanged on exit. \n
 * @param[in] ALPHA
          ALPHA is REAL. \n
          On entry, ALPHA specifies the scalar alpha.
          Unchanged on exit. \n
 * @param[in] A
          A is REAL array, dimension (LDA, n). \n
          Before entry, the leading m by n part of the array A must
          contain the matrix of coefficients. \n
          Unchanged on exit. \n
 * @param[in] LDA
          LDA is INTEGER \n
          On entry, LDA specifies the first dimension of A as declared
          in the calling (sub) program. LDA must be at least
          max(1, n). \n
          Unchanged on exit. \n
 * @param[in] X
          X is REAL array, dimension
          (1 + (n - 1)*abs(INCX)) \n
          Before entry, the incremented array X must contain the
          vector x. \n
          Unchanged on exit. \n
 * @param[in] INCX
          INCX is INTEGER \n
          On entry, INCX specifies the increment for the elements of
          X. INCX must not be zero. \n
          Unchanged on exit. \n
 * @param[in] BETA
          BETA is REAL. \n
          On entry, BETA specifies the scalar beta. When BETA is
          supplied as zero then Y need not be set on input.
          Unchanged on exit. \n
 * @param[in,out] Y
          Y is REAL array, dimension
          (1 + (n - 1)*abs(INCY)) \n
          Before entry with BETA non-zero, the incremented array Y
          must contain the vector y. On exit, Y is overwritten by the
          updated vector y. \n
 * @param[in] INCY
          INCY is INTEGER \n
          On entry, INCY specifies the increment for the elements of
          Y. INCY must not be zero. \n
          Unchanged on exit. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer la_syamv(integer *uplo, integer *n, T *alpha, T *a, integer *lda, T *x, integer *incx, T *beta, T *y, integer *incy)
{
  return la_syamv(uplo, n, alpha, a, lda, x, incx, beta, y, incy);
}
template< typename T, typename Ta >
integer la_syamv(integer *uplo, integer *n, Ta *alpha, T *a, integer *lda, T *x, integer *incx, Ta *beta, Ta *y, integer *incy)
{
  return la_syamv(uplo, n, alpha, a, lda, x, incx, beta, y, incy);
}

/*! @brief LA_PORPVGRW computes the reciprocal pivot growth factor norm(A)/norm(U) for a symmetric or Hermitian positive-definite matrix

 * @details
 * \b Purpose:
    \verbatim 
    LA_PORPVGRW computes the reciprocal pivot growth factor
    norm(A)/norm(U). The "max absolute element" norm is used. If this is
    much less than 1, the stability of the LU factorization of the
    (equilibrated) matrix A could be poor. This also means that the
    solution X, estimated condition numbers, and error bounds could be
    unreliable.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] NCOLS
          NCOLS is INTEGER \n
          The number of columns of the matrix A. NCOLS >= 0. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the N-by-N matrix A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] AF
          AF is REAL array, dimension (LDAF,N) \n
          The triangular factor U or L from the Cholesky factorization
          A = U**T*U or A = L*L**T, as computed by SPOTRF. \n
 * @param[in] LDAF
          LDAF is INTEGER \n
          The leading dimension of the array AF.  LDAF >= max(1,N). \n
 * @param[out] WORK
          WORK is REAL array, dimension (2*N) \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer la_porpvgrw(char *uplo, integer *ncols, T *a, integer *lda, T * af, integer *ldaf, T *work)
{
  return la_porpvgrw(uplo, ncols, a, lda, af, ldaf, work);
}
template< typename T, typename Ta >
Ta la_porpvgrw(char *uplo, integer *ncols, T *a, integer *lda, T * af, integer *ldaf, Ta *work)
{
  return la_porpvgrw(uplo, ncols, a, lda, af, ldaf, work);
}

/*! @brief LA_SYRCOND estimates the Skeel condition number for a symmetric indefinite matrix

 * @details
 * \b Purpose:
    \verbatim 
    LA_SYRCOND estimates the Skeel condition number of  op(A) * op2(C)
    where op2 is determined by CMODE as follows
    CMODE =  1    op2(C) = C
    CMODE =  0    op2(C) = I
    CMODE = -1    op2(C) = inv(C)
    The Skeel condition number cond(A) = norminf(|inv(A)||A|)
    is computed by computing scaling factors R such that
    diag(R)*A*op2(C) is row equilibrated and computing the standard
    infinity-norm condition number.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the N-by-N matrix A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] AF
          AF is REAL array, dimension (LDAF,N) \n
          The block diagonal matrix D and the multipliers used to
          obtain the factor U or L as computed by SSYTRF. \n
 * @param[in] LDAF
          LDAF is INTEGER \n
          The leading dimension of the array AF.  LDAF >= max(1,N). \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D
          as determined by SSYTRF. \n
 * @param[in] CMODE
          CMODE is INTEGER \n
          Determines op2(C) in the formula op(A) * op2(C) as follows: \n
          CMODE =  1    op2(C) = C \n
          CMODE =  0    op2(C) = I \n
          CMODE = -1    op2(C) = inv(C) \n
 * @param[in] C
          C is REAL array, dimension (N) \n
          The vector C in the formula op(A) * op2(C). \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  Successful exit. \n
          i > 0:  The ith argument is invalid. \n
 * @param[out] WORK
          WORK is REAL array, dimension (3*N). \n
          Workspace. \n
 * @param[out] IWORK
          IWORK is INTEGER array, dimension (N). \n
          Workspace. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
T la_syrcond(char *uplo, integer *n, T *a, integer *lda, T *af, integer *ldaf, integer *ipiv, integer *cmode, T *c, integer * info, T *work, integer *iwork)
{
  return la_syrcond(uplo, n, a, lda, af, ldaf, ipiv, cmode, c, info, work, iwork); 
}

/*! @brief LA_SYRCOND_X computes the infinity norm condition number of op(A)*diag(x) for symmetric indefinite matrices

 * @details
 * \b Purpose:
    \verbatim 
    LA_SYRCOND_X Computes the infinity norm condition number of
    op(A) * diag(X) where X is a COMPLEX vector.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] A
          A is COMPLEX array, dimension (LDA,N) \n
          On entry, the N-by-N matrix A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] AF
          AF is COMPLEX array, dimension (LDAF,N) \n
          The block diagonal matrix D and the multipliers used to
          obtain the factor U or L as computed by CSYTRF. \n
 * @param[in] LDAF
          LDAF is INTEGER \n
          The leading dimension of the array AF.  LDAF >= max(1,N). \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D
          as determined by CSYTRF. \n
 * @param[in] X
          X is COMPLEX array, dimension (N) \n
          The vector X in the formula op(A) * diag(X). \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  Successful exit. \n
          i > 0:  The ith argument is invalid. \n
 * @param[out] WORK
          WORK is COMPLEX array, dimension (2*N). \n
          Workspace. \n
 * @param[out] RWORK
          RWORK is REAL array, dimension (N). \n
          Workspace.  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T, typename Ta >
Ta la_syrcond_x(char *uplo, integer *n, T *a, integer *lda, T *af, integer *ldaf, integer *ipiv, T *x, integer *info, T *work, Ta *rwork)
{
  return la_syrcond_x(uplo, *n, a, lda, af, ldaf, ipiv, x, info, work, rwork); 
}

/*! @brief LA_SYRCOND_C computes the infinity norm condition number of op(A)*inv(diag(c)) for symmetric indefinite matrices

 * @details
 * \b Purpose:
    \verbatim 
    LA_SYRCOND_C Computes the infinity norm condition number of
    op(A) * inv(diag(C)) where C is a REAL vector.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] A
          A is COMPLEX array, dimension (LDA,N) \n
          On entry, the N-by-N matrix A \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] AF
          AF is COMPLEX array, dimension (LDAF,N) \n
          The block diagonal matrix D and the multipliers used to
          obtain the factor U or L as computed by CSYTRF. \n
 * @param[in] LDAF
          LDAF is INTEGER \n
          The leading dimension of the array AF.  LDAF >= max(1,N). \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D
          as determined by CSYTRF. \n
 * @param[in] C
          C is REAL array, dimension (N) \n
          The vector C in the formula op(A) * inv(diag(C)). \n
 * @param[in] CAPPLY
          CAPPLY is LOGICAL \n
          If .TRUE. then access the vector C in the formula above. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  Successful exit. \n
          i > 0:  The ith argument is invalid. \n
 * @param[out] WORK
          WORK is COMPLEX array, dimension (2*N). \n
          Workspace. \n
 * @param[out] RWORK
          RWORK is REAL array, dimension (N). \n
          Workspace.  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T, typename Ta >
Ta la_syrcond_c(char *uplo, integer *n, T *a, integer *lda, T *af, integer *ldaf, integer *ipiv, Ta *c, logical *capply, integer *info, T *work, Ta *rwork)
{
  return la_syrcond_c(uplo, n, a, lda, af, ldaf, ipiv, c, capply, info, work, rwork); 
}

/*! @brief LA_SYRPVGRW computes the reciprocal pivot growth factor norm(A)/norm(U) for a symmetric indefinite matrix

 * @details
 * \b Purpose:
    \verbatim 
    LA_SYRPVGRW computes the reciprocal pivot growth factor
    norm(A)/norm(U). The "max absolute element" norm is used. If this is
    much less than 1, the stability of the LU factorization of the
    (equilibrated) matrix A could be poor. This also means that the
    solution X, estimated condition numbers, and error bounds could be
    unreliable.

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] N
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in] INFO
          INFO is INTEGER \n
          The value of INFO returned from SSYTRF, .i.e., the pivot in
          column INFO is exactly 0. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the N-by-N matrix A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in] AF
          AF is REAL array, dimension (LDAF,N) \n
          The block diagonal matrix D and the multipliers used to
          obtain the factor U or L as computed by SSYTRF. \n
 * @param[in] LDAF
          LDAF is INTEGER \n
          The leading dimension of the array AF.  LDAF >= max(1,N). \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D
          as determined by SSYTRF. \n
 * @param[out] WORK
          WORK is REAL array, dimension (2*N)  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
T la_syrpvgrw(char *uplo, integer *n, integer *info, T *a, integer * lda, T *af, integer *ldaf, integer *ipiv, T *work)
{
  return la_syrpvgrw(uplo, n, info, a, lda, af, ldaf, ipiv, work);
}
template< typename T, typename Ta >
Ta la_syrpvgrw(char *uplo, integer *n, integer *info, T *a, integer * lda, T *af, integer *ldaf, integer *ipiv, Ta *work)
{
  return la_syrpvgrw(uplo, n, info, a, lda, af, ldaf, ipiv, work);
}

/*! @brief LA_WWADDW adds a vector into a doubled-single vector

 * @details
 * \b Purpose:
    \verbatim 
    LA_WWADDW adds a vector W into a doubled-single vector (X, Y).

    This works for all extant IBM's hex and binary floating point
    arithmetic, but not for decimal.
    \endverbatim 

 * @param[in] N
          N is INTEGER \n
          The length of vectors X, Y, and W. \n
 * @param[in,out] X
          X is REAL array, dimension (N) \n
          The first part of the doubled-single accumulation vector. \n
 * @param[in,out] Y
          Y is REAL array, dimension (N) \n
          The second part of the doubled-single accumulation vector. \n
 * @param[in] W
          W is REAL array, dimension (N) \n
          The vector to be added.  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer la_wwaddw(integer *n, T *x, T *y, T *w)
{
  return la_wwaddw(n, x, y, w);
}

/*! @brief LABAD takes as input the values computed by LAMCH for underflow and  \n
     overflow, and   returns the square root of each of these values

 * @details
 * \b Purpose:
    \verbatim 
    LABAD takes as input the values computed by SLAMCH for underflow and
    overflow, and   returns the square root of each of these values if the
    log of LARGE is sufficiently large.  This subroutine is intended to
    identify machines with a large exponent range, such as the Crays, and
    redefine the underflow and overflow limits to be the square roots of
    the values computed by SLAMCH.  This subroutine is needed because
    SLAMCH does not compensate for poor arithmetic in the upper half of
    the exponent range, as is found on a Cray.
    \endverbatim  

 * @param[in,out] SMALL
          SMALL is REAL \n
          On entry, the underflow threshold as computed by SLAMCH.
          On exit, if LOG10(LARGE) is sufficiently large, the square
          root of SMALL, otherwise unchanged. \n
 * @param[in,out] LARGE
          LARGE is REAL \n
          On entry, the overflow threshold as computed by SLAMCH.
          On exit, if LOG10(LARGE) is sufficiently large, the square
          root of LARGE, otherwise unchanged. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer labad(T *small, T *large)
{
  return labad(small, large);
}

/*! @brief LABRD reduces the first nb rows and columns of a general matrix to a bidiagonal form

 * @details
 * \b Purpose:
    \verbatim 
    LABRD reduces the first NB rows and columns of a real general
    m by n matrix A to upper or lower bidiagonal form by an orthogonal
    transformation Q**T * A * P, and   returns the matrices X and Y which
    are needed to apply the transformation to the unreduced part of A.

    If m >= n, A is reduced to upper bidiagonal form; if m < n, to lower
    bidiagonal form.

    This is an auxiliary routine called by GEBRD
    \endverbatim 

 * @param[in] M
          M is INTEGER \n
          The number of rows in the matrix A. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns in the matrix A. \n
 * @param[in] NB
          NB is INTEGER \n
          The number of leading rows and columns of A to be reduced. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the m by n general matrix to be reduced.
          On exit, the first NB rows and columns of the matrix are
          overwritten; the rest of the array is unchanged. \n
          If m >= n, elements on and below the diagonal in the first NB
            columns, with the array TAUQ, represent the orthogonal
            matrix Q as a product of elementary reflectors; and
            elements above the diagonal in the first NB rows, with the
            array TAUP, represent the orthogonal matrix P as a product
            of elementary reflectors. \n
          If m < n, elements below the diagonal in the first NB
            columns, with the array TAUQ, represent the orthogonal
            matrix Q as a product of elementary reflectors, and
            elements on and above the diagonal in the first NB rows,
            with the array TAUP, represent the orthogonal matrix P as
            a product of elementary reflectors. \n
          See Further Details. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,M). \n
 * @param[out] D
          D is REAL array, dimension (NB) \n
          The diagonal elements of the first NB rows and columns of
          the reduced matrix.  D(i) = A(i,i). \n
 * @param[out] E
          E is REAL array, dimension (NB) \n
          The off-diagonal elements of the first NB rows and columns of
          the reduced matrix. \n
 * @param[out] TAUQ
          TAUQ is REAL array, dimension (NB) \n
          The scalar factors of the elementary reflectors which
          represent the orthogonal matrix Q. See Further Details. \n
 * @param[out] TAUP
          TAUP is REAL array, dimension (NB) \n
          The scalar factors of the elementary reflectors which
          represent the orthogonal matrix P. See Further Details. \n
 * @param[out] X
          X is REAL array, dimension (LDX,NB) \n
          The m-by-nb matrix X required to update the unreduced part
          of A. \n
 * @param[in] LDX
          LDX is INTEGER \n
          The leading dimension of the array X. LDX >= max(1,M). \n
 * @param[out] Y
          Y is REAL array, dimension (LDY,NB) \n
          The n-by-nb matrix Y required to update the unreduced part
          of A. \n
 * @param[in] LDY
          LDY is INTEGER \n
          The leading dimension of the array Y. LDY >= max(1,N).  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T, typename Ta >
integer labrd(integer *m, integer *n, integer *nb, T *a, integer *lda, Ta *d, Ta *e, T *tauq, T *taup, T *x, integer *ldx, T *y, integer *ldy)
{
  return labrd(m, n, nb, a, lda, d, e, tauq, taup, x, ldx, y, ldy);
}

/*! @brief LACON estimates the 1-norm of a square matrix, using reverse communication for evaluating matrix-vector products

 * @details
 * \b Purpose:
    \verbatim 
    LACON estimates the 1-norm of a square, real matrix A.
    Reverse communication is used for evaluating matrix-vector products.
    \endverbatim  

 * @param[in] N
          N is INTEGER \n
          The order of the matrix.  N >= 1. \n
 * @param[out] V
          V is REAL array, dimension (N) \n
          On the final   return, V = A*W, where  EST = norm(V)/norm(W)
          (W is not   returned). \n
 * @param[in,out] X
          X is REAL array, dimension (N) \n
          On an intermediate   return, X should be overwritten by \n
               A * X,  if KASE=1, \n
               A**T * X, if KASE=2, \n
          and SLACON must be re-called with all the other parameters
          unchanged. \n
 * @param[out] ISGN
          ISGN is INTEGER array, dimension (N) \n
 * @param[in,out] EST
          EST is REAL \n
          On entry with KASE = 1 or 2 and JUMP = 3, EST should be
          unchanged from the previous call to SLACON. \n
          On exit, EST is an estimate (a lower bound) for norm(A). \n
 * @param[in,out] KASE
          KASE is INTEGER \n
          On the initial call to SLACON, KASE should be 0.
          On an intermediate return, KASE will be 1 or 2, indicating
          whether X should be overwritten by A * X  or A**T * X.
          On the final return from SLACON, KASE will again be 0.  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lacon(integer *n, T *v, T *x, integer *isgn, T *est, integer *kase)
{
  return lacon(n, v, x, isgn, est, kase);
}
template< typename T, typename Ta >
integer lacon(integer *n, T *v, T *x, Ta *est, integer *kase)
{
  return lacon(n, v, x, est, kase);
}

/*! @brief LACRT performs a linear transformation of a pair of complex vectors

 * @details
 * \b Purpose:
    \verbatim 
    LACRT performs the operation

       ( c  s)(x)  ==> (x)
       (-s  c)(y)      (y)

    where c and s are complex and the vectors x and y are complex.
    \endverbatim 

 * @param[in] N
          N is INTEGER \n
          The number of elements in the vectors CX and CY. \n
 * @param[in,out] CX
          CX is COMPLEX array, dimension (N) \n
          On input, the vector x.
          On output, CX is overwritten with c*x + s*y. \n
 * @param[in] INCX
          INCX is INTEGER \n
          The increment between successive values of CX.  INCX <> 0. \n
 * @param[in,out] CY
          CY is COMPLEX array, dimension (N) \n
          On input, the vector y.
          On output, CY is overwritten with -s*x + c*y. \n
 * @param[in] INCY
          INCY is INTEGER \n
          The increment between successive values of CY.  INCY <> 0. \n
 * @param[in] C
          C is COMPLEX \n
 * @param[in] S
          S is COMPLEX \n
          C and S define the matrix \n
             [  C   S  ]. \n
             [ -S   C  ] \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lacrt(integer *n, T *cx, integer *incx, T * cy, integer *incy, T *c, T *s)
{
  return lacrt(n, cx, incx, cy, incy, c, s); 
}

/*! @brief LADIV performs complex division in real arithmetic, avoiding unnecessary overflow

 * @details
 * \b Purpose:
    \verbatim 
    LADIV performs complex division in  real arithmetic

                          a + i*b
               p + i*q = ---------
                          c + i*d

    The algorithm is due to Michael Baudin and Robert L. Smith
    and can be found in the paper
    "A Robust Complex Division in Scilab"
    \endverbatim 

 * @param[in] A
          A is REAL \n
 * @param[in] B
          B is REAL \n
 * @param[in] C
          C is REAL \n
 * @param[in] D
          D is REAL \n
          The scalars a, b, c, and d in the above expression. \n
 * @param[out] P
          P is REAL \n
 * @param[out] Q
          Q is REAL \n
          The scalars p and q in the above expression.  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer ladiv(T *a, T *b, T *c, T *d, T *p, T *q)
{
  return ladiv(a, b, c, d, p, q);
}

/*! @brief LADIV performs complex division in real arithmetic, avoiding unnecessary overflow

 * @details
 * \b Purpose:
    \verbatim 
    LADIV := X / Y, where X and Y are complex.  The computation of X / Y
    will not overflow on an intermediary step unless the results
    overflows.
    \endverbatim  

 * @param[in] X
          X is COMPLEX \n
 * @param[in] Y
          Y is COMPLEX \n
          The complex scalars X and Y. \n

 * @return INTEGER Return value of the function.
 * */
void cladiv(scomplex *ret_val, scomplex *x, scomplex *y)
{
  return cladiv_(ret_val, x, y);
}
void zladiv(dcomplex *ret_val, dcomplex *x, dcomplex *y)
{
  return zladiv_(ret_val, x, y);
}

/*! @brief LAE2 computes the eigenvalues of a 2-by-2 symmetric matrix

 * @details
 * \b Purpose:
    \verbatim 
    LAE2  computes the eigenvalues of a 2-by-2 symmetric matrix
       [  A   B  ]
       [  B   C  ].
    On   return, RT1 is the eigenvalue of larger absolute value, and RT2
    is the eigenvalue of smaller absolute value.
    \endverbatim  
    
 * @param[in] A
          A is REAL \n
          The (1,1) element of the 2-by-2 matrix. \n
 * @param[in] B
          B is REAL \n
          The (1,2) and (2,1) elements of the 2-by-2 matrix. \n
 * @param[in] C
          C is REAL \n
          The (2,2) element of the 2-by-2 matrix. \n
 * @param[out] RT1
          RT1 is REAL \n
          The eigenvalue of larger absolute value. \n
 * @param[out] RT2
          RT2 is REAL \n
          The eigenvalue of smaller absolute value. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lae2(T *a, T *b, T *c, T *rt1, T *rt2)
{
  return lae2(a, b, c, rt1, rt2);
}

/*! @brief LAEBZ computes the number of eigenvalues of a real symmetric tridiagonal \n
     matrix which are less than or equal to a given value, and performs other tasks \n
     required by the routine stebz
 * @details
 * \b Purpose:
    \verbatim 
    LAEBZ contains the iteration loops which compute and use the
    function N(w), which is the count of eigenvalues of a symmetric
    tridiagonal matrix T less than or equal to its argument  w.  It
    performs a choice of two types of loops:

    IJOB=1, followed by
    IJOB=2: It takes as input a list of intervals and   returns a list of
            sufficiently small intervals whose union contains the same
            eigenvalues as the union of the original intervals.
            The input intervals are (AB(j,1),AB(j,2)], j=1,...,MINP.
            The output interval (AB(j,1),AB(j,2)] will contain
            eigenvalues NAB(j,1)+1,...,NAB(j,2), where 1 <= j <= MOUT.

    IJOB=3: It performs a binary search in each input interval
            (AB(j,1),AB(j,2)] for a point  w(j)  such that
            N(w(j))=NVAL(j), and uses  C(j)  as the starting point of
            the search.  If such a w(j) is found, then on output
            AB(j,1)=AB(j,2)=w.  If no such w(j) is found, then on output
            (AB(j,1),AB(j,2)] will be a small interval containing the
            point where N(w) jumps through NVAL(j), unless that point
            lies outside the initial interval.

    Note that the intervals are in all cases half-open intervals,
    i.e., of the form  (a,b] , which includes  b  but not  a .

    To avoid underflow, the matrix should be scaled so that its largest
    element is no greater than  overflow**(1/2) * underflow**(1/4)
    in absolute value.  To assure the most accurate computation
    of small eigenvalues, the matrix should be scaled to be
    not much smaller than that, either.

    See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
    Matrix", Report CS41, Computer Science Dept., Stanford
    University, July 21, 1966

    Note: the arguments are, in general, *not* checked for unreasonable
    values.
    \endverbatim  

 * @param[in] IJOB
          IJOB is INTEGER \n
          Specifies what is to be done: \n
          = 1:  Compute NAB for the initial intervals. \n
          = 2:  Perform bisection iteration to find eigenvalues of T. \n
          = 3:  Perform bisection iteration to invert N(w), i.e.,
                to find a point which has a specified number of
                eigenvalues of T to its left. \n
          Other values will cause SLAEBZ to   return with INFO=-1. \n
 * @param[in] NITMAX
          NITMAX is INTEGER \n
          The maximum number of "levels" of bisection to be
          performed, i.e., an interval of width W will not be made
          smaller than 2^(-NITMAX) * W.  If not all intervals
          have converged after NITMAX iterations, then INFO is set
          to the number of non-converged intervals. \n
 * @param[in] N
          N is INTEGER \n
          The dimension n of the tridiagonal matrix T.  It must be at
          least 1. \n
 * @param[in] MMAX
          MMAX is INTEGER \n
          The maximum number of intervals. If more than MMAX intervals
          are generated, then SLAEBZ will quit with INFO=MMAX+1. \n
 * @param[in] MINP
          MINP is INTEGER \n
          The initial number of intervals.  It may not be greater than
          MMAX. \n
 * @param[in] NBMIN
          NBMIN is INTEGER \n
          The smallest number of intervals that should be processed
          using a vector loop.  If zero, then only the scalar loop
          will be used. \n
 * @param[in] ABSTOL
          ABSTOL is REAL \n
          The minimum (absolute) width of an interval.  When an
          interval is narrower than ABSTOL, or than RELTOL times the
          larger (in magnitude) endpoint, then it is considered to be
          sufficiently small, i.e., converged.  This must be at least
          zero. \n
 * @param[in] RELTOL
          RELTOL is REAL \n
          The minimum relative width of an interval.  When an interval
          is narrower than ABSTOL, or than RELTOL times the larger (in
          magnitude) endpoint, then it is considered to be
          sufficiently small, i.e., converged.  Note: this should
          always be at least radix*machine epsilon. \n
 * @param[in] PIVMIN
          PIVMIN is REAL \n
          The minimum absolute value of a "pivot" in the Sturm
          sequence loop.
          This must be at least  max |e(j)**2|*safe_min  and at
          least safe_min, where safe_min is at least
          the smallest number that can divide one without overflow. \n
 * @param[in] D
          D is REAL array, dimension (N) \n
          The diagonal elements of the tridiagonal matrix T. \n
 * @param[in] E
          E is REAL array, dimension (N) \n
          The offdiagonal elements of the tridiagonal matrix T in
          positions 1 through N-1.  E(N) is arbitrary. \n
 * @param[in] E2
          E2 is REAL array, dimension (N) \n
          The squares of the offdiagonal elements of the tridiagonal
          matrix T.  E2(N) is ignored. \n
 * @param[in,out] NVAL
          NVAL is INTEGER array, dimension (MINP) \n
          If IJOB=1 or 2, not referenced. \n
          If IJOB=3, the desired values of N(w).  The elements of NVAL
          will be reordered to correspond with the intervals in AB.
          Thus, NVAL(j) on output will not, in general be the same as
          NVAL(j) on input, but it will correspond with the interval
          (AB(j,1),AB(j,2)] on output. \n
 * @param[in,out] AB
          AB is REAL array, dimension (MMAX,2) \n
          The endpoints of the intervals.  AB(j,1) is  a(j), the left
          endpoint of the j-th interval, and AB(j,2) is b(j), the
          right endpoint of the j-th interval.  The input intervals
          will, in general, be modified, split, and reordered by the
          calculation. \n
 * @param[in,out] C
          C is REAL array, dimension (MMAX) \n
          If IJOB=1, ignored. \n
          If IJOB=2, workspace. \n
          If IJOB=3, then on input C(j) should be initialized to the
          first search point in the binary search. \n
 * @param[out] MOUT
          MOUT is INTEGER \n
          If IJOB=1, the number of eigenvalues in the intervals. \n
          If IJOB=2 or 3, the number of intervals output. \n
          If IJOB=3, MOUT will equal MINP. \n
 * @param[in,out] NAB
          NAB is INTEGER array, dimension (MMAX,2) \n
          If IJOB=1, then on output NAB(i,j) will be set to N(AB(i,j)). \n
          If IJOB=2, then on input, NAB(i,j) should be set.  It must
             satisfy the condition: \n
             N(AB(i,1)) <= NAB(i,1) <= NAB(i,2) <= N(AB(i,2)), \n
             which means that in interval i only eigenvalues
             NAB(i,1)+1,...,NAB(i,2) will be considered.  Usually,
             NAB(i,j)=N(AB(i,j)), from a previous call to SLAEBZ with
             IJOB=1. \n
             On output, NAB(i,j) will contain
             max(na(k),min(nb(k),N(AB(i,j)))), where k is the index of
             the input interval that the output interval
             (AB(j,1),AB(j,2)] came from, and na(k) and nb(k) are the
             the input values of NAB(k,1) and NAB(k,2). \n
          If IJOB=3, then on output, NAB(i,j) contains N(AB(i,j)),
             unless N(w) > NVAL(i) for all search points  w , in which
             case NAB(i,1) will not be modified, i.e., the output
             value will be the same as the input value (modulo
             reorderings -- see NVAL and AB), or unless N(w) < NVAL(i)
             for all search points  w , in which case NAB(i,2) will
             not be modified.  Normally, NAB should be set to some
             distinctive value(s) before SLAEBZ is called. \n
 * @param[out] WORK
          WORK is REAL array, dimension (MMAX) \n
          Workspace. \n
 * @param[out] IWORK
          IWORK is INTEGER array, dimension (MMAX) \n
          Workspace. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:       All intervals converged. \n
          = 1--MMAX: The last INFO intervals did not converge. \n
          = MMAX+1:  More than MMAX intervals were generated. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer laebz(integer *ijob, integer *nitmax, integer *n, integer *mmax, integer *minp, integer *nbmin, T *abstol, T * reltol, T *pivmin, T *d, T *e, T *e2, integer *nval, T *ab, T *c, integer *mout, integer *nab, T *work, integer *iwork, integer *info)
{
  return laebz(ijob, nitmax, n, mmax, minp, nbmin, abstol, reltol, pivmin, d, e, e2, nval, ab, c, mout, nab, work, iwork, info);
}

/*! @brief LAED0 used by sstedc. Computes all eigenvalues and corresponding \n
     eigenvectors of an unreduced symmetric tridiagonal matrix using the    \n
     divide and conquer method.
 * @details
 * \b Purpose:
    \verbatim 
    LAED0 computes all eigenvalues and corresponding eigenvectors of a
    symmetric tridiagonal matrix using the divide and conquer method.
    \endverbatim 

 * @param[in] ICOMPQ
          ICOMPQ is INTEGER \n
          = 0:  Compute eigenvalues only. \n
          = 1:  Compute eigenvectors of original dense symmetric matrix
                also.  On entry, Q contains the orthogonal matrix used
                to reduce the original matrix to tridiagonal form. \n
          = 2:  Compute eigenvalues and eigenvectors of tridiagonal
                matrix. \n
 * @param[in] QSIZ
          QSIZ is INTEGER \n
          The dimension of the orthogonal matrix used to reduce
          the full matrix to tridiagonal form.  QSIZ >= N if ICOMPQ = 1. \n
 * @param[in] N
          N is INTEGER \n
          The dimension of the symmetric tridiagonal matrix.  N >= 0. \n
 * @param[in,out] D
          D is REAL array, dimension (N) \n
          On entry, the main diagonal of the tridiagonal matrix.
          On exit, its eigenvalues. \n
 * @param[in] E
          E is REAL array, dimension (N-1) \n
          The off-diagonal elements of the tridiagonal matrix.
          On exit, E has been destroyed. \n
 * @param[in,out] Q
          Q is REAL array, dimension (LDQ, N) \n
          On entry, Q must contain an N-by-N orthogonal matrix. \n
          If ICOMPQ = 0    Q is not referenced. \n
          If ICOMPQ = 1    On entry, Q is a subset of the columns of the
                           orthogonal matrix used to reduce the full
                           matrix to tridiagonal form corresponding to
                           the subset of the full matrix which is being
                           decomposed at this time. \n
          If ICOMPQ = 2    On entry, Q will be the identity matrix.
                           On exit, Q contains the eigenvectors of the
                           tridiagonal matrix. \n
 * @param[in] LDQ
          LDQ is INTEGER \n
          The leading dimension of the array Q.  If eigenvectors are
          desired, then  LDQ >= max(1,N).  In any case, LDQ >= 1. \n
 * @param[out] QSTORE
          QSTORE is REAL array, dimension (LDQS, N) \n
          Referenced only when ICOMPQ = 1.  Used to store parts of
          the eigenvector matrix when the updating matrix multiplies
          take place. \n
 * @param[in] LDQS
          LDQS is INTEGER \n
          The leading dimension of the array QSTORE.  If ICOMPQ = 1,
          then  LDQS >= max(1,N).  In any case, LDQS >= 1. \n
 * @param[out] WORK
          WORK is REAL array, \n
          If ICOMPQ = 0 or 1, the dimension of WORK must be at least
                      1 + 3*N + 2*N*lg N + 3*N**2 \n
                      (lg(N) = smallest integer k
                                 such that 2^k >= N) \n
          If ICOMPQ = 2, the dimension of WORK must be at least
                      4*N + N**2. \n
 * @param[out] IWORK
          IWORK is INTEGER array, \n
          If ICOMPQ = 0 or 1, the dimension of IWORK must be at least
                         6 + 6*N + 5*N*lg N. \n
                         (lg(N) = smallest integer k
                                    such that 2^k >= N) \n
          If ICOMPQ = 2, the dimension of IWORK must be at least
                         3 + 5*N. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n
          > 0:  The algorithm failed to compute an eigenvalue while
                working on the submatrix lying in rows and columns
                INFO/(N+1) through mod(INFO,N+1).  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer laed0(integer *icompq, integer *qsiz, integer *n, T *d, T *e, T *q, integer *ldq, T *qstore, integer *ldqs, T *work, integer *iwork, integer *info)
{
  return laed0(qsiz, n, d, e, q, ldq, qstore, ldqs, work, iwork, info);
}
template< typename T, typename Ta >
integer laed0(integer *qsiz, integer *n, Ta *d, Ta *e, T *q, integer *ldq, T *qstore, integer *ldqs, Ta *rwork, integer *iwork, integer *info)
{
  return laed0(qsiz, n, d, e, q, ldq, qstore, ldqs, rwork, iwork, info);
}

/*! @brief LAED1 used by sstedc. Computes the updated eigensystem of a diagonal \n
     matrix after modification by a rank-one symmetric matrix. Used when the    \n
     original matrix is tridiagonal
 * @details
 * \b Purpose:
    \verbatim 
    LAED1 computes the updated eigensystem of a diagonal
    matrix after modification by a rank-one symmetric matrix.  This
    routine is used only for the eigenproblem which requires all
    eigenvalues and eigenvectors of a tridiagonal matrix.  SLAED7 handles
    the case in which eigenvalues only or eigenvalues and eigenvectors
    of a full symmetric matrix (which was reduced to tridiagonal form)
    are desired.

      T = Q(in) (D(in) + RHO * Z*Z**T) Q**T(in) = Q(out) * D(out) * Q**T(out)

       where Z = Q**T*u, u is a vector of length N with ones in the
       CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.

       The eigenvectors of the original matrix are stored in Q, and the
       eigenvalues are in D.  The algorithm consists of three stages:

          The first stage consists of deflating the size of the problem
          when there are multiple eigenvalues or if there is a zero in
          the Z vector.  For each such occurrence the dimension of the
          secular equation problem is reduced by one.  This stage is
          performed by the routine SLAED2.

          The second stage consists of calculating the updated
          eigenvalues. This is done by finding the roots of the secular
          equation via the routine SLAED4 (as called by SLAED3).
          This routine also calculates the eigenvectors of the current
          problem.

          The final stage consists of computing the updated eigenvectors
          directly using the updated eigenvalues.  The eigenvectors for
          the current problem are multiplied with the eigenvectors from
          the overall problem.
    \endverbatim

 * @param[in] N
          N is INTEGER \n
          The dimension of the symmetric tridiagonal matrix.  N >= 0. \n
 * @param[in,out] D
          D is REAL array, dimension (N) \n
          On entry, the eigenvalues of the rank-1-perturbed matrix.
          On exit, the eigenvalues of the repaired matrix. \n
 * @param[in,out] Q
          Q is REAL array, dimension (LDQ,N) \n
          On entry, the eigenvectors of the rank-1-perturbed matrix.
          On exit, the eigenvectors of the repaired tridiagonal matrix. \n
 * @param[in] LDQ
          LDQ is INTEGER \n
          The leading dimension of the array Q.  LDQ >= max(1,N). \n
 * @param[in,out] INDXQ
          INDXQ is INTEGER array, dimension (N) \n
          On entry, the permutation which separately sorts the two
          subproblems in D into ascending order. \n
          On exit, the permutation which will reintegrate the
          subproblems back into sorted order,
          i.e. D(INDXQ(I = 1, N)) will be in ascending order. \n
 * @param[in] RHO
          RHO is REAL \n
          The subdiagonal entry used to create the rank-1 modification. \n
 * @param[in] CUTPNT
          CUTPNT is INTEGER \n
          The location of the last eigenvalue in the leading sub-matrix.
          min(1,N) <= CUTPNT <= N/2. \n
 * @param[out] WORK
          WORK is REAL array, dimension (4*N + N**2) \n
 * @param[out] IWORK
          IWORK is INTEGER array, dimension (4*N) \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n
          > 0:  if INFO = 1, an eigenvalue did not converge \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer laed1(integer *n, T *d, T *q, integer *ldq, integer *indxq, T *rho, integer *cutpnt, T *work, integer * iwork, integer *info)
{
  return laed1(*n, d, q, *ldq, *indxq, rho, *cutpnt, work, * iwork, *info); 
}

/*! @brief LAED2 used by sstedc. Merges eigenvalues and deflates secular equation. \n
     Used when the original matrix is tridiagonal
 * @details
 * \b Purpose:
    \verbatim 
    LAED2 merges the two sets of eigenvalues together into a single
    sorted set.  Then it tries to deflate the size of the problem.
    There are two ways in which deflation can occur:  when two or more
    eigenvalues are close together or if there is a tiny entry in the
    Z vector.  For each such occurrence the order of the related secular
    equation problem is reduced by one.
    \endverbatim  

 * @param[out] K
          K is INTEGER \n
          The number of non-deflated eigenvalues, and the order of the
          related secular equation. 0 <= K <=N. \n
 * @param[in] N
          N is INTEGER \n
          The dimension of the symmetric tridiagonal matrix.  N >= 0. \n
 * @param[in] N1
          N1 is INTEGER \n
          The location of the last eigenvalue in the leading sub-matrix.
          min(1,N) <= N1 <= N/2. \n
 * @param[in,out] D
          D is REAL array, dimension (N) \n
          On entry, D contains the eigenvalues of the two submatrices to
          be combined. \n
          On exit, D contains the trailing (N-K) updated eigenvalues
          (those which were deflated) sorted into increasing order. \n
 * @param[in,out] Q
          Q is REAL array, dimension (LDQ, N) \n
          On entry, Q contains the eigenvectors of two submatrices in
          the two square blocks with corners at (1,1), (N1,N1)
          and (N1+1, N1+1), (N,N). \n
          On exit, Q contains the trailing (N-K) updated eigenvectors
          (those which were deflated) in its last N-K columns. \n
 * @param[in] LDQ
          LDQ is INTEGER \n
          The leading dimension of the array Q.  LDQ >= max(1,N). \n
 * @param[in,out] INDXQ
          INDXQ is INTEGER array, dimension (N) \n
          The permutation which separately sorts the two sub-problems
          in D into ascending order.  Note that elements in the second
          half of this permutation must first have N1 added to their
          values. Destroyed on exit. \n
 * @param[in,out] RHO
          RHO is REAL \n
          On entry, the off-diagonal element associated with the rank-1
          cut which originally split the two submatrices which are now
          being recombined. \n
          On exit, RHO has been modified to the value required by
          SLAED3. \n
 * @param[in] Z
          Z is REAL array, dimension (N) \n
          On entry, Z contains the updating vector (the last
          row of the first sub-eigenvector matrix and the first row of
          the second sub-eigenvector matrix). \n
          On exit, the contents of Z have been destroyed by the updating
          process. \n
 * @param[out] DLAMDA
          DLAMDA is REAL array, dimension (N) \n
          A copy of the first K eigenvalues which will be used by
          SLAED3 to form the secular equation. \n
 * @param[out] W
          W is REAL array, dimension (N) \n
          The first k values of the final deflation-altered z-vector
          which will be passed to SLAED3. \n
 * @param[out] Q2
          Q2 is REAL array, dimension (N1**2+(N-N1)**2) \n
          A copy of the first K eigenvectors which will be used by
          SLAED3 in a matrix multiply (SGEMM) to solve for the new
          eigenvectors. \n
 * @param[out] INDX
          INDX is INTEGER array, dimension (N) \n
          The permutation used to sort the contents of DLAMDA into
          ascending order. \n
 * @param[out] INDXC
          INDXC is INTEGER array, dimension (N) \n
          The permutation used to arrange the columns of the deflated
          Q matrix into three groups:  the first group contains non-zero
          elements only at and above N1, the second contains
          non-zero elements only below N1, and the third is dense. \n
 * @param[out] INDXP
          INDXP is INTEGER array, dimension (N) \n
          The permutation used to place deflated values of D at the end
          of the array.  INDXP(1:K) points to the nondeflated D-values
          and INDXP(K+1:N) points to the deflated eigenvalues. \n
 * @param[out] COLTYP
          COLTYP is INTEGER array, dimension (N) \n
          During execution, a label which will indicate which of the
          following types a column in the Q2 matrix is: \n
          1 : non-zero in the upper half only; \n
          2 : dense; \n
          3 : non-zero in the lower half only; \n
          4 : deflated. \n
          On exit, COLTYP(i) is the number of columns of type i,
          for i=1 to 4 only. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, the i-th argument had an illegal value.  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer laed2(integer *k, integer *n, integer *n1, T *d, T *q, integer *ldq, integer *indxq, T *rho, T *z, T * dlamda, T *w, T *q2, integer *indx, integer *indxc, integer * indxp, integer *coltyp, integer *info)
{
  return laed2(*k, *n, *n1, d, q, *ldq, *indxq, rho, z, dlamda, w, q2, *indx, *indxc, *indxp, *coltyp, *info); 
}

/*! @brief LAED3 used by sstedc. Finds the roots of the secular equation and \n
     updates the eigenvectors. Used when the original matrix is tridiagonal
 * @details
 * \b Purpose:
    \verbatim 
    LAED3 finds the roots of the secular equation, as defined by the
    values in D, W, and RHO, between 1 and K.  It makes the
    appropriate calls to SLAED4 and then updates the eigenvectors by
    multiplying the matrix of eigenvectors of the pair of eigensystems
    being combined by the matrix of eigenvectors of the K-by-K system
    which is solved here.

    This code makes very mild assumptions about floating point
    arithmetic. It will work on machines with a guard digit in
    add/subtract, or on those binary machines without guard digits
    which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
    It could conceivably fail on hexadecimal or decimal machines
    without guard digits, but we know of none.
    \endverbatim 

 * @param[in] K
          K is INTEGER \n
          The number of terms in the rational function to be solved by
          SLAED4.  K >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of rows and columns in the Q matrix.
          N >= K (deflation may result in N>K). \n
 * @param[in] N1
          N1 is INTEGER \n
          The location of the last eigenvalue in the leading submatrix.
          min(1,N) <= N1 <= N/2. \n
 * @param[out] D
          D is REAL array, dimension (N) \n
          D(I) contains the updated eigenvalues for
          1 <= I <= K. \n
 * @param[out] Q
          Q is REAL array, dimension (LDQ,N) \n
          Initially the first K columns are used as workspace.
          On output the columns 1 to K contain
          the updated eigenvectors. \n
 * @param[in] LDQ
          LDQ is INTEGER \n
          The leading dimension of the array Q.  LDQ >= max(1,N). \n
 * @param[in] RHO
          RHO is REAL \n
          The value of the parameter in the rank one update equation.
          RHO >= 0 required. \n
 * @param[in,out] DLAMDA
          DLAMDA is REAL array, dimension (K) \n
          The first K elements of this array contain the old roots
          of the deflated updating problem.  These are the poles
          of the secular equation. May be changed on output by
          having lowest order bit set to zero on Cray X-MP, Cray Y-MP,
          Cray-2, or Cray C-90, as described above. \n
 * @param[in] Q2
          Q2 is REAL array, dimension (LDQ2*N) \n
          The first K columns of this matrix contain the non-deflated
          eigenvectors for the split problem. \n
 * @param[in] INDX
          INDX is INTEGER array, dimension (N) \n
          The permutation used to arrange the columns of the deflated
          Q matrix into three groups (see SLAED2).
          The rows of the eigenvectors found by SLAED4 must be likewise
          permuted before the matrix multiply can take place. \n
 * @param[in] CTOT
          CTOT is INTEGER array, dimension (4) \n
          A count of the total number of the various types of columns
          in Q, as described in INDX.  The fourth column type is any
          column which has been deflated. \n
 * @param[in,out] W
          W is REAL array, dimension (K) \n
          The first K elements of this array contain the components
          of the deflation-adjusted updating vector. Destroyed on
          output. \n
 * @param[out] S
          S is REAL array, dimension (N1 + 1)*K \n
          Will contain the eigenvectors of the repaired matrix which
          will be multiplied by the previously accumulated eigenvectors
          to update the system. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n
          > 0:  if INFO = 1, an eigenvalue did not converge \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer laed3(integer *k, integer *n, integer *n1, T *d, T *q, integer *ldq, T *rho, T *dlamda, T *q2, integer * indx, integer *ctot, T *w, T *s, integer *info)
{
  return laed3(*k, *n, *n1, d, q, *ldq, rho, dlamda, q2, *indx, *ctot, w, s, *info); 
}

/*! @brief LAED4 used by sstedc. Finds a single root of the secular equation

 * @details
 * \b Purpose:
    \verbatim 
    This subroutine computes the I-th updated eigenvalue of a symmetric
    rank-one modification to a diagonal matrix whose elements are
    given in the array d, and that

               D(i) < D(j)  for  i < j

    and that RHO > 0.  This is arranged by the calling routine, and is
    no loss in generality.  The rank-one modified system is thus

               diag(D)  +  RHO * Z * Z_transpose.

    where we assume the Euclidean norm of Z is 1.

    The method consists of approximating the rational functions in the
    secular equation by simpler interpolating rational functions.
    \endverbatim 

 * @param[in] N
          N is INTEGER \n
          The length of all arrays. \n
 * @param[in] I
          I is INTEGER \n
          The index of the eigenvalue to be computed.  1 <= I <= N. \n
 * @param[in] D
          D is REAL array, dimension (N) \n
          The original eigenvalues.  It is assumed that they are in
          order, D(I) < D(J)  for I < J. \n
 * @param[in] Z
          Z is REAL array, dimension (N) \n
          The components of the updating vector. \n
 * @param[out] DELTA
          DELTA is REAL array, dimension (N) \n
          If N > 2, DELTA contains (D(j) - lambda_I) in its  j-th
          component.  If N = 1, then DELTA(1) = 1. If N = 2, see SLAED5
          for detail. The vector DELTA contains the information necessary
          to construct the eigenvectors by SLAED3 and SLAED9. \n
 * @param[in] RHO
          RHO is REAL \n
          The scalar in the symmetric updating formula. \n
 * @param[out] DLAM
          DLAM is REAL \n
          The computed lambda_I, the I-th updated eigenvalue. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit \n
          > 0:  if INFO = 1, the updating process failed.  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer laed4(integer *n, integer *i, T *d, T *z, T *delta, T *rho, T *dlam, integer *info)
{
  return laed4(*n, *i, d, z, delta, rho, dlam, *info); 
}

/*! @brief LAED5 used by sstedc. Solves the 2-by-2 secular equation

 * @details
 * \b Purpose:
    \verbatim 
    This subroutine computes the I-th eigenvalue of a symmetric rank-one
    modification of a 2-by-2 diagonal matrix

               diag(D)  +  RHO * Z * transpose(Z) .

    The diagonal elements in the array D are assumed to satisfy

               D(i) < D(j)  for  i < j .

    We also assume RHO > 0 and that the Euclidean norm of the vector
    Z is one.
    \endverbatim 

 * @param[in] I
          I is INTEGER \n
          The index of the eigenvalue to be computed.  I = 1 or I = 2. \n
 * @param[in] D
          D is REAL array, dimension (2) \n
          The original eigenvalues.  We assume D(1) < D(2). \n
 * @param[in] Z
          Z is REAL array, dimension (2) \n
          The components of the updating vector. \n
 * @param[out] DELTA
          DELTA is REAL array, dimension (2) \n
          The vector DELTA contains the information necessary
          to construct the eigenvectors. \n
 * @param[in] RHO
          RHO is REAL \n
          The scalar in the symmetric updating formula. \n
 * @param[out] DLAM
          DLAM is REAL \n
          The computed lambda_I, the I-th updated eigenvalue. \n 

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer laed5(integer *i, T *d, T *z, T *delta, T *rho, T *dlam)
{
  return laed5(*i, d, z, delta, rho, dlam);
}

/*! @brief LAED6 used by sstedc. Computes one Newton step in solution of the secular equation

 * @details
 * \b Purpose:
    \verbatim 
    LAED6 computes the positive or negative root (closest to the origin)
    of
                     z(1)        z(2)        z(3)
    f(x) =   rho + --------- + ---------- + ---------
                    d(1)-x      d(2)-x      d(3)-x

    It is assumed that

          if ORGATI = .true. the root is between d(2) and d(3);
          otherwise it is between d(1) and d(2)

    This routine will be called by SLAED4 when necessary. In most cases,
    the root sought is the smallest in magnitude, though it might not be
    in some extremely rare situations.
    \endverbatim 

 * @param[in] KNITER
          KNITER is INTEGER \n
          Refer to SLAED4 for its significance. \n
 * @param[in] ORGATI
          ORGATI is LOGICAL \n
          If ORGATI is true, the needed root is between d(2) and
          d(3); otherwise it is between d(1) and d(2).  See
          SLAED4 for further details. \n
 * @param[in] RHO
          RHO is REAL \n
          Refer to the equation f(x) above. \n
 * @param[in] D
          D is REAL array, dimension (3) \n
          D satisfies d(1) < d(2) < d(3). \n
 * @param[in] Z
          Z is REAL array, dimension (3) \n
          Each of the elements in z must be positive. \n
 * @param[in] FINIT
          FINIT is REAL \n
          The value of f at 0. It is more accurate than the one
          evaluated inside this routine (if someone wants to do
          so). \n
 * @param[out] TAU
          TAU is REAL \n
          The root of the equation f(x). \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0: successful exit \n
          > 0: if INFO = 1, failure to converge \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer laed6(integer *kniter, logical *orgati, T *rho, T *d, T *z, T *finit, T *tau, integer *info)
{
  return laed6(kniter, orgati, rho, d, z, finit, tau, *info);
}

/*! @brief LAED7 used by sstedc. Computes the updated eigensystem of a diagonal \n
     matrix after modification by a rank-one symmetric matrix. Used when the    \n
     original matrix is dense
 * @details
 * \b Purpose:
    \verbatim 
    LAED7 computes the updated eigensystem of a diagonal
    matrix after modification by a rank-one symmetric matrix. This
    routine is used only for the eigenproblem which requires all
    eigenvalues and optionally eigenvectors of a dense symmetric matrix
    that has been reduced to tridiagonal form.  SLAED1 handles
    the case in which all eigenvalues and eigenvectors of a symmetric
    tridiagonal matrix are desired.

      T = Q(in) (D(in) + RHO * Z*Z**T) Q**T(in) = Q(out) * D(out) * Q**T(out)

       where Z = Q**Tu, u is a vector of length N with ones in the
       CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.

       The eigenvectors of the original matrix are stored in Q, and the
       eigenvalues are in D.  The algorithm consists of three stages:

          The first stage consists of deflating the size of the problem
          when there are multiple eigenvalues or if there is a zero in
          the Z vector.  For each such occurrence the dimension of the
          secular equation problem is reduced by one.  This stage is
          performed by the routine SLAED8.

          The second stage consists of calculating the updated
          eigenvalues. This is done by finding the roots of the secular
          equation via the routine SLAED4 (as called by SLAED9).
          This routine also calculates the eigenvectors of the current
          problem.

          The final stage consists of computing the updated eigenvectors
          directly using the updated eigenvalues.  The eigenvectors for
          the current problem are multiplied with the eigenvectors from
          the overall problem.
    \endverbatim 

 * @param[in] ICOMPQ
          ICOMPQ is INTEGER \n
          = 0:  Compute eigenvalues only. \n
          = 1:  Compute eigenvectors of original dense symmetric matrix
                also.  On entry, Q contains the orthogonal matrix used
                to reduce the original matrix to tridiagonal form. \n
 * @param[in] N
          N is INTEGER \n
          The dimension of the symmetric tridiagonal matrix.  N >= 0. \n
 * @param[in] QSIZ
          QSIZ is INTEGER \n
          The dimension of the orthogonal matrix used to reduce
          the full matrix to tridiagonal form.  QSIZ >= N if ICOMPQ = 1. \n
 * @param[in] TLVLS
          TLVLS is INTEGER \n
          The total number of merging levels in the overall divide and
          conquer tree. \n
 * @param[in] CURLVL
          CURLVL is INTEGER \n
          The current level in the overall merge routine,
          0 <= CURLVL <= TLVLS. \n
 * @param[in] CURPBM
          CURPBM is INTEGER \n
          The current problem in the current level in the overall
          merge routine (counting from upper left to lower right). \n
 * @param[in,out] D
          D is REAL array, dimension (N) \n
          On entry, the eigenvalues of the rank-1-perturbed matrix.
          On exit, the eigenvalues of the repaired matrix. \n
 * @param[in,out] Q
          Q is REAL array, dimension (LDQ, N) \n
          On entry, the eigenvectors of the rank-1-perturbed matrix.
          On exit, the eigenvectors of the repaired tridiagonal matrix. \n
 * @param[in] LDQ
          LDQ is INTEGER \n
          The leading dimension of the array Q.  LDQ >= max(1,N). \n
 * @param[out] INDXQ
          INDXQ is INTEGER array, dimension (N) \n
          The permutation which will reintegrate the subproblem just
          solved back into sorted order, i.e., D(INDXQ(I = 1, N))
          will be in ascending order. \n
 * @param[in] RHO
          RHO is REAL \n
          The subdiagonal element used to create the rank-1
          modification. \n
 * @param[in] CUTPNT
          CUTPNT is INTEGER \n
          Contains the location of the last eigenvalue in the leading
          sub-matrix.  min(1,N) <= CUTPNT <= N. \n
 * @param[in,out] QSTORE
          QSTORE is REAL array, dimension (N**2+1) \n
          Stores eigenvectors of submatrices encountered during
          divide and conquer, packed together. QPTR points to
          beginning of the submatrices. \n
 * @param[in,out] QPTR
          QPTR is INTEGER array, dimension (N+2) \n
          List of indices pointing to beginning of submatrices stored
          in QSTORE. The submatrices are numbered starting at the
          bottom left of the divide and conquer tree, from left to
          right and bottom to top. \n
 * @param[in] PRMPTR
          PRMPTR is INTEGER array, dimension (N lg N) \n
          Contains a list of pointers which indicate where in PERM a
          level's permutation is stored.  PRMPTR(i+1) - PRMPTR(i)
          indicates the size of the permutation and also the size of
          the full, non-deflated problem. \n
 * @param[in] PERM
          PERM is INTEGER array, dimension (N lg N) \n
          Contains the permutations (from deflation and sorting) to be
          applied to each eigenblock. \n
 * @param[in] GIVPTR
          GIVPTR is INTEGER array, dimension (N lg N) \n
          Contains a list of pointers which indicate where in GIVCOL a
          level's Givens rotations are stored.  GIVPTR(i+1) - GIVPTR(i)
          indicates the number of Givens rotations. \n
 * @param[in] GIVCOL
          GIVCOL is INTEGER array, dimension (2, N lg N) \n
          Each pair of numbers indicates a pair of columns to take place
          in a Givens rotation. \n
 * @param[in] GIVNUM
          GIVNUM is REAL array, dimension (2, N lg N) \n
          Each number indicates the S value to be used in the
          corresponding Givens rotation. \n
 * @param[out] WORK
          WORK is REAL array, dimension (3*N+2*QSIZ*N) \n
 * @param[out] IWORK
          IWORK is INTEGER array, dimension (4*N) \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n
          > 0:  if INFO = 1, an eigenvalue did not converge \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer laed7(integer *icompq, integer *n, integer *qsiz, integer *tlvls, integer *curlvl, integer *curpbm, T *d, T *q, integer *ldq, integer *indxq, T *rho, integer *cutpnt, T * qstore, integer *qptr, integer *prmptr, integer *perm, integer * givptr, integer *givcol, T *givnum, T *work, integer *iwork, integer *info)
{
  return laed7(icompq, n, qsiz, tlvls, curlvl, curpbm, d, q, ldq, indxq,  rho, cutpnt, qstore, qptr, prmptr, perm, givptr, givcol, givnum, work, iwork, info);  
}
template< typename T, typename Ta >
integer laed7(integer *n, integer *cutpnt, integer *qsiz, integer *tlvls, integer *curlvl, integer *curpbm, Ta *d, T *q, integer *ldq, Ta *rho, integer *indxq, Ta *qstore, integer * qptr, integer *prmptr, integer *perm, integer *givptr, integer *givcol, Ta *givnum, T *work, Ta *rwork, integer *iwork, integer *info)
{
  return laed7(n, cutpnt, qsiz, tlvls, curlvl, curpbm, d, q, ldq, rho, indxq, qstore, qptr, prmptr, perm, givptr, givcol, givnum, work, rwork, iwork, info);  
}

/*! @brief LAED8 used by sstedc. Merges eigenvalues and deflates secular \n
     equation. Used when the original matrix is dense
 * @details
 * \b Purpose:
    \verbatim 
    LAED8 merges the two sets of eigenvalues together into a single
    sorted set.  Then it tries to deflate the size of the problem.
    There are two ways in which deflation can occur:  when two or more
    eigenvalues are close together or if there is a tiny element in the
    Z vector.  For each such occurrence the order of the related secular
    equation problem is reduced by one.
     \endverbatim

 * @param[in] ICOMPQ
          ICOMPQ is INTEGER \n
          = 0:  Compute eigenvalues only. \n
          = 1:  Compute eigenvectors of original dense symmetric matrix
                also.  On entry, Q contains the orthogonal matrix used
                to reduce the original matrix to tridiagonal form. \n
 * @param[out] K
          K is INTEGER \n
          The number of non-deflated eigenvalues, and the order of the
          related secular equation. \n
 * @param[in] N
          N is INTEGER \n
          The dimension of the symmetric tridiagonal matrix.  N >= 0. \n
 * @param[in] QSIZ
          QSIZ is INTEGER \n
          The dimension of the orthogonal matrix used to reduce
          the full matrix to tridiagonal form.  QSIZ >= N if ICOMPQ = 1. \n
 * @param[in,out] D
          D is REAL array, dimension (N) \n
          On entry, the eigenvalues of the two submatrices to be
          combined.  On exit, the trailing (N-K) updated eigenvalues
          (those which were deflated) sorted into increasing order. \n
 * @param[in,out] Q
          Q is REAL array, dimension (LDQ,N) \n
          If ICOMPQ = 0, Q is not referenced.  Otherwise,
          on entry, Q contains the eigenvectors of the partially solved
          system which has been previously updated in matrix
          multiplies with other partially solved eigensystems.
          On exit, Q contains the trailing (N-K) updated eigenvectors
          (those which were deflated) in its last N-K columns. \n
 * @param[in] LDQ
          LDQ is INTEGER \n
          The leading dimension of the array Q.  LDQ >= max(1,N). \n
 * @param[in] INDXQ
          INDXQ is INTEGER array, dimension (N) \n
          The permutation which separately sorts the two sub-problems
          in D into ascending order.  Note that elements in the second
          half of this permutation must first have CUTPNT added to
          their values in order to be accurate. \n
 * @param[in,out] RHO
          RHO is REAL \n
          On entry, the off-diagonal element associated with the rank-1
          cut which originally split the two submatrices which are now
          being recombined. \n
          On exit, RHO has been modified to the value required by
          SLAED3. \n
 * @param[in] CUTPNT
          CUTPNT is INTEGER \n
          The location of the last eigenvalue in the leading
          sub-matrix.  min(1,N) <= CUTPNT <= N. \n
 * @param[in] Z
          Z is REAL array, dimension (N) \n
          On entry, Z contains the updating vector (the last row of
          the first sub-eigenvector matrix and the first row of the
          second sub-eigenvector matrix). \n
          On exit, the contents of Z are destroyed by the updating
          process. \n
 * @param[out] DLAMDA
          DLAMDA is REAL array, dimension (N) \n
          A copy of the first K eigenvalues which will be used by
          SLAED3 to form the secular equation. \n
 * @param[out] Q2
          Q2 is REAL array, dimension (LDQ2,N) \n
          If ICOMPQ = 0, Q2 is not referenced.  Otherwise,
          a copy of the first K eigenvectors which will be used by
          SLAED7 in a matrix multiply (SGEMM) to update the new
          eigenvectors. \n
 * @param[in] LDQ2
          LDQ2 is INTEGER \n
          The leading dimension of the array Q2.  LDQ2 >= max(1,N). \n
 * @param[out] W
          W is REAL array, dimension (N) \n
          The first k values of the final deflation-altered z-vector and
          will be passed to SLAED3. \n
 * @param[out] PERM
          PERM is INTEGER array, dimension (N) \n
          The permutations (from deflation and sorting) to be applied
          to each eigenblock. \n
 * @param[out] GIVPTR
          GIVPTR is INTEGER \n
          The number of Givens rotations which took place in this
          subproblem. \n
 * @param[out] GIVCOL
          GIVCOL is INTEGER array, dimension (2, N) \n
          Each pair of numbers indicates a pair of columns to take place
          in a Givens rotation. \n
 * @param[out] GIVNUM
          GIVNUM is REAL array, dimension (2, N) \n
          Each number indicates the S value to be used in the
          corresponding Givens rotation. \n
 * @param[out] INDXP
          INDXP is INTEGER array, dimension (N) \n
          The permutation used to place deflated values of D at the end
          of the array.  INDXP(1:K) points to the nondeflated D-values
          and INDXP(K+1:N) points to the deflated eigenvalues. \n
 * @param[out] INDX
          INDX is INTEGER array, dimension (N) \n
          The permutation used to sort the contents of D into ascending
          order. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer laed8(integer *icompq, integer *k, integer *n, integer *qsiz, T *d, T *q, integer *ldq, integer *indxq, T *rho, integer *cutpnt, T *z, T *dlamda, T *q2, integer *ldq2, T *w, integer *perm, integer *givptr, integer *givcol, T * givnum, integer *indxp, integer *indx, integer *info)
{
  return laed8(icompq, k, n, qsiz, d, q, ldq, indxq, rho, cutpnt, z, dlamda, q2, ldq2, w, perm, givptr, givcol, givnum, indxp, indx, info); 
}
template< typename T, typename Ta >
integer laed8(integer *k, integer *n, integer *qsiz, T * q, integer *ldq, Ta *d, Ta *rho, integer *cutpnt, Ta *z, Ta *dlamda, T *q2, integer *ldq2, Ta *w, integer *indxp, integer *indx, integer *indxq, integer *perm, integer *givptr, integer *givcol, Ta *givnum, integer *info)
{
  return laed8(k, n, qsiz, q, ldq, d, rho, cutpnt, z, dlamda, q2, ldq2, w, indxp, indx, indxq, perm, givptr, givcol, givnum, info); 
}

/*! @brief LAED9 used by sstedc. Finds the roots of the secular equation and \n
     updates the eigenvectors. Used when the original matrix is dense
 * @details
 * \b Purpose:
    \verbatim 
    LAED9 finds the roots of the secular equation, as defined by the
    values in D, Z, and RHO, between KSTART and KSTOP.  It makes the
    appropriate calls to SLAED4 and then stores the new matrix of
    eigenvectors for use in calculating the next level of Z vectors.
    \endverbatim  

 * @param[in] K
          K is INTEGER \n
          The number of terms in the rational function to be solved by
          SLAED4.  K >= 0. \n
 * @param[in] KSTART
          KSTART is INTEGER \n
 * @param[in] KSTOP
          KSTOP is INTEGER \n
          The updated eigenvalues Lambda(I), KSTART <= I <= KSTOP
          are to be computed.  1 <= KSTART <= KSTOP <= K. \n
 * @param[in] N
          N is INTEGER \n
          The number of rows and columns in the Q matrix.
          N >= K (delation may result in N > K). \n
 * @param[out] D
          D is REAL array, dimension (N) \n
          D(I) contains the updated eigenvalues \n
          for KSTART <= I <= KSTOP. \n
 * @param[out] Q
          Q is REAL array, dimension (LDQ,N) \n
 * @param[in] LDQ
          LDQ is INTEGER \n
          The leading dimension of the array Q.  LDQ >= max(1, N). \n
 * @param[in] RHO
          RHO is REAL \n
          The value of the parameter in the rank one update equation.
          RHO >= 0 required. \n
 * @param[in] DLAMDA
          DLAMDA is REAL array, dimension (K) \n
          The first K elements of this array contain the old roots
          of the deflated updating problem.  These are the poles
          of the secular equation. \n
 * @param[in] W
          W is REAL array, dimension (K) \n
          The first K elements of this array contain the components
          of the deflation-adjusted updating vector. \n
 * @param[out] S
          S is REAL array, dimension (LDS, K) \n
          Will contain the eigenvectors of the repaired matrix which
          will be stored for subsequent Z vector calculation and
          multiplied by the previously accumulated eigenvectors
          to update the system. \n
 * @param[in] LDS
          LDS is INTEGER \n
          The leading dimension of S.  LDS >= max(1, K). \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n
          > 0:  if INFO = 1, an eigenvalue did not converge \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer laed9(integer *k, integer *kstart, integer *kstop, integer *n, T *d, T *q, integer *ldq, T *rho, T *dlamda, T *w, T *s, integer *lds, integer *info)
{
  return laed9(k, kstart, kstop, n, d, q, ldq, rho, dlamda, w, s, lds, info); 
}

/*! @brief LAEDA used by sstedc. Computes the Z vector determining the rank-one \n
     modification of the diagonal matrix. Used when the original matrix is dense
 * @details
 * \b Purpose:
    \verbatim 
    LAEDA computes the Z vector corresponding to the merge step in the
    CURLVLth step of the merge process with TLVLS steps for the CURPBMth
    problem.
    \endverbatim 

 * @param[in] N
          N is INTEGER \n
          The dimension of the symmetric tridiagonal matrix.  N >= 0. \n
 * @param[in] TLVLS
          TLVLS is INTEGER \n
          The total number of merging levels in the overall divide and
          conquer tree. \n
 * @param[in] CURLVL
          CURLVL is INTEGER \n
          The current level in the overall merge routine,
          0 <= curlvl <= tlvls. \n
 * @param[in] CURPBM
          CURPBM is INTEGER \n
          The current problem in the current level in the overall
          merge routine (counting from upper left to lower right). \n
 * @param[in] PRMPTR
          PRMPTR is INTEGER array, dimension (N lg N) \n
          Contains a list of pointers which indicate where in PERM a
          level's permutation is stored.  PRMPTR(i+1) - PRMPTR(i)
          indicates the size of the permutation and incidentally the
          size of the full, non-deflated problem. \n
 * @param[in] PERM
          PERM is INTEGER array, dimension (N lg N) \n
          Contains the permutations (from deflation and sorting) to be
          applied to each eigenblock. \n
 * @param[in] GIVPTR
          GIVPTR is INTEGER array, dimension (N lg N) \n
          Contains a list of pointers which indicate where in GIVCOL a
          level's Givens rotations are stored.  GIVPTR(i+1) - GIVPTR(i)
          indicates the number of Givens rotations. \n
 * @param[in] GIVCOL
          GIVCOL is INTEGER array, dimension (2, N lg N) \n
          Each pair of numbers indicates a pair of columns to take place
          in a Givens rotation. \n
 * @param[in] GIVNUM
          GIVNUM is REAL array, dimension (2, N lg N) \n
          Each number indicates the S value to be used in the
          corresponding Givens rotation. \n
 * @param[in] Q
          Q is REAL array, dimension (N**2) \n
          Contains the square eigenblocks from previous levels, the
          starting positions for blocks are given by QPTR. \n
 * @param[in] QPTR
          QPTR is INTEGER array, dimension (N+2) \n
          Contains a list of pointers which indicate where in Q an
          eigenblock is stored.  SQRT(QPTR(i+1) - QPTR(i)) indicates
          the size of the block. \n
 * @param[out] Z
          Z is REAL array, dimension (N) \n
          On output this vector contains the updating vector (the last
          row of the first sub-eigenvector matrix and the first row of
          the second sub-eigenvector matrix). \n
 * @param[out] ZTEMP
          ZTEMP is REAL array, dimension (N) \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer laeda(integer *n, integer *tlvls, integer *curlvl, integer *curpbm, integer *prmptr, integer *perm, integer *givptr, integer *givcol, float *givnum, float *q, integer *qptr, float *z, float *ztemp, integer *info)
{
  return laeda(n, tlvls, curlvl, curpbm, prmptr, perm, givptr, givcol, givnum, q, qptr, z, ztemp, info);
}

/*! @brief LAEIN computes a specified right or left eigenvector of an upper Hessenberg matrix by inverse iteration

 * @details
 * \b Purpose:
    \verbatim 
    LAEIN uses inverse iteration to find a right or left eigenvector
    corresponding to the eigenvalue (WR,WI) of a real upper Hessenberg
    matrix H.
    \endverbatim  

 * @param[in] RIGHTV
          RIGHTV is LOGICAL \n
          = .TRUE. : compute right eigenvector; \n
          = .FALSE.: compute left eigenvector. \n
 * @param[in] NOINIT
          NOINIT is LOGICAL \n
          = .TRUE. : no initial vector supplied in (VR,VI). \n
          = .FALSE.: initial vector supplied in (VR,VI). \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix H.  N >= 0. \n
 * @param[in] H
          H is REAL array, dimension (LDH,N) \n
          The upper Hessenberg matrix H. \n
 * @param[in] LDH
          LDH is INTEGER \n
          The leading dimension of the array H.  LDH >= max(1,N). \n
 * @param[in] WR
          WR is REAL \n
 * @param[in] WI
          WI is REAL \n
          The real and imaginary parts of the eigenvalue of H whose
          corresponding right or left eigenvector is to be computed. \n
 * @param[in,out] VR
          VR is REAL array, dimension (N) \n
 * @param[in,out] VI
          VI is REAL array, dimension (N) \n
          On entry, if NOINIT = .FALSE. and WI = 0.0, VR must contain
          a real starting vector for inverse iteration using the real
          eigenvalue WR; if NOINIT = .FALSE. and WI.ne.0.0, VR and VI
          must contain the real and imaginary parts of a complex
          starting vector for inverse iteration using the complex
          eigenvalue (WR,WI); otherwise VR and VI need not be set.
          On exit, if WI = 0.0 (real eigenvalue), VR contains the
          computed real eigenvector; if WI.ne.0.0 (complex eigenvalue),
          VR and VI contain the real and imaginary parts of the
          computed complex eigenvector. The eigenvector is normalized
          so that the component of largest magnitude has magnitude 1;
          here the magnitude of a complex number (x,y) is taken to be
          |x| + |y|.
          VI is not referenced if WI = 0.0. \n
 * @param[out] B
          B is REAL array, dimension (LDB,N) \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= N+1. \n
 * @param[out] WORK
          WORK is REAL array, dimension (N) \n
 * @param[in] EPS3
          EPS3 is REAL \n
          A small machine-dependent value which is used to perturb
          close eigenvalues, and to replace zero pivots. \n
 * @param[in] SMLNUM
          SMLNUM is REAL \n
          A machine-dependent value close to the underflow threshold. \n
 * @param[in] BIGNUM
          BIGNUM is REAL \n
          A machine-dependent value close to the overflow threshold. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit \n
          = 1:  inverse iteration did not converge; VR is set to the
                last iterate, and so is VI if WI.ne.0.0. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer laein(logical *rightv, logical *noinit, integer *n, T *h, integer *ldh, T *wr, T *wi, T *vr, T *vi, T *b, integer *ldb, T *work, T *eps3, T *smlnum, T *bignum, integer *info)
{
  return laein(rightv, noinit, n, h, ldh, wr, wi, vr, vi, b, ldb, work, eps3, smlnum, bignum, info); 
}
template< typename T, typename Ta >
integer laein(logical *rightv, logical *noinit, integer *n, T *h, integer *ldh, T *w, T *v, T *b, integer *ldb, Ta *rwork, Ta *eps3, Ta *smlnum, integer *info)
{
  return laein(rightv, noinit, n, h, ldh, w, v, b, ldb, rwork, eps3, smlnum, info);
}

/*! @brief LAESY computes the eigenvalues and eigenvectors of a 2-by-2 complex symmetric matrix

 * @details
 * \b Purpose:
    \verbatim 
    LAESY computes the eigendecomposition of a 2-by-2 symmetric matrix
       ((A, B);(B, C))
    provided the norm of the matrix of eigenvectors is larger than
    some threshold value.

    RT1 is the eigenvalue of larger absolute value, and RT2 of
    smaller absolute value.  If the eigenvectors are computed, then
    on   return (CS1, SN1) is the unit eigenvector for RT1, hence

    [  CS1     SN1   ] . [ A  B ] . [ CS1    -SN1   ] = [ RT1  0  ]
    [ -SN1     CS1   ]   [ B  C ]   [ SN1     CS1   ]   [  0  RT2 ]
    \endverbatim 

 * @param[in] A
          A is COMPLEX \n
          The (1, 1) element of input matrix. \n
 * @param[in] B
          B is COMPLEX \n
          The (1, 2) element of input matrix.  The (2, 1) element
          is also given by B, since the 2-by-2 matrix is symmetric. \n
 * @param[in] C
          C is COMPLEX \n
          The (2, 2) element of input matrix. \n
 * @param[out] RT1
          RT1 is COMPLEX \n
          The eigenvalue of larger modulus. \n
 * @param[out] RT2
          RT2 is COMPLEX \n
          The eigenvalue of smaller modulus. \n
 * @param[out] EVSCAL
          EVSCAL is COMPLEX \n
          The complex value by which the eigenvector matrix was scaled
          to make it orthonormal.  If EVSCAL is zero, the eigenvectors
          were not computed.  This means one of two things:  the 2-by-2
          matrix could not be diagonalized, or the norm of the matrix
          of eigenvectors before scaling was larger than the threshold
          value THRESH (set below). \n
 * @param[out] CS1
          CS1 is COMPLEX \n
 * @param[out] SN1
          SN1 is COMPLEX \n
          If EVSCAL .NE. 0, (CS1, SN1) is the unit right eigenvector
          for RT1. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer laesy(T *a, T *b, T *c, T * rt1, T *rt2, T *evscal, T *cs1, T *sn1)
{
  return laesy(a, b, c, rt1, rt2, evscal, cs1, sn1); 
}

/*! @brief LAEV2 computes the eigenvalues and eigenvectors of a 2-by-2 symmetric/Hermitian matrix

 * @details
 * \b Purpose:
    \verbatim 
    LAEV2 computes the eigendecomposition of a 2-by-2 symmetric matrix
       [  A   B  ]
       [  B   C  ].
    On   return, RT1 is the eigenvalue of larger absolute value, RT2 is the
    eigenvalue of smaller absolute value, and (CS1,SN1) is the unit right
    eigenvector for RT1, giving the decomposition

       [ CS1  SN1 ] [  A   B  ] [ CS1 -SN1 ]  =  [ RT1  0  ]
       [-SN1  CS1 ] [  B   C  ] [ SN1  CS1 ]     [  0  RT2 ].
    \endverbatim  

 * @param[in] A
          A is REAL \n
          The (1,1) element of the 2-by-2 matrix. \n
 * @param[in] B
          B is REAL \n
          The (1,2) element and the conjugate of the (2,1) element of
          the 2-by-2 matrix. \n
 * @param[in] C
          C is REAL \n
          The (2,2) element of the 2-by-2 matrix. \n
 * @param[out] RT1
          RT1 is REAL \n
          The eigenvalue of larger absolute value. \n
 * @param[out] RT2
          RT2 is REAL \n
          The eigenvalue of smaller absolute value. \n
 * @param[out] CS1
          CS1 is REAL \n
 * @param[out] SN1
          SN1 is REAL \n
          The vector (CS1, SN1) is a unit right eigenvector for RT1.  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer laev2(T *a, T *b, T *c, T *rt1, T * rt2, T *cs1, T *sn1)
{
  return laev2(a, b, c, rt1, rt2, cs1, sn1);
} 
template< typename T, typename Ta >
integer laev2(T *a, T *b, T *c, Ta *rt1, Ta * rt2, Ta *cs1, T *sn1)
{
  return laev2(a, b, c, rt1, rt2, cs1, sn1);
}

/*! @brief LAEXC swaps adjacent diagonal blocks of a real upper quasi-triangular \n
     matrix in Schur canonical form, by an orthogonal similarity transformation
 * @details
 * \b Purpose:
    \verbatim 
    LAEXC swaps adjacent diagonal blocks T11 and T22 of order 1 or 2 in
    an upper quasi-triangular matrix T by an orthogonal similarity
    transformation.

    T must be in Schur canonical form, that is, block upper triangular
    with 1-by-1 and 2-by-2 diagonal blocks; each 2-by-2 diagonal block
    has its diagonal elemnts equal and its off-diagonal elements of
    opposite sign.
    \endverbatim 

 * @param[in] WANTQ
          WANTQ is LOGICAL \n
          = .TRUE. : accumulate the transformation in the matrix Q; \n
          = .FALSE.: do not accumulate the transformation. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix T. N >= 0. \n
 * @param[in,out] T
          T is REAL array, dimension (LDT,N) \n
          On entry, the upper quasi-triangular matrix T, in Schur
          canonical form. \n
          On exit, the updated matrix T, again in Schur canonical form. \n
 * @param[in] LDT
          LDT is INTEGER \n
          The leading dimension of the array T. LDT >= max(1,N). \n
 * @param[in,out] Q
          Q is REAL array, dimension (LDQ,N) \n
          On entry, if WANTQ is .TRUE., the orthogonal matrix Q.
          On exit, if WANTQ is .TRUE., the updated matrix Q. \n
          If WANTQ is .FALSE., Q is not referenced. \n
 * @param[in] LDQ
          LDQ is INTEGER \n
          The leading dimension of the array Q.
          LDQ >= 1; and if WANTQ is .TRUE., LDQ >= N. \n
 * @param[in] J1
          J1 is INTEGER \n
          The index of the first row of the first block T11. \n
 * @param[in] N1
          N1 is INTEGER \n
          The order of the first block T11. N1 = 0, 1 or 2. \n
 * @param[in] N2
          N2 is INTEGER \n
          The order of the second block T22. N2 = 0, 1 or 2. \n
 * @param[out] WORK
          WORK is REAL array, dimension (N) \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0: successful exit \n
          = 1: the transformed matrix T would be too far from Schur
               form; the blocks are not swapped and T and Q are
               unchanged. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer laexc(logical *wantq, integer *n, T *t, integer * ldt, T *q, integer *ldq, integer *j1, integer *n1, integer *n2, T *work, integer *info)
{
    return laexc(wantq, n, t, ldt, q, ldq, j1, n1, n2, work, info); 
}

/*! @brief LAG2 computes the eigenvalues of a 2-by-2 generalized eigenvalue problem, \n
     with scaling as necessary to avoid over-/underflow
 * @details
 * \b Purpose:
    \verbatim 
    LAG2 computes the eigenvalues of a 2 x 2 generalized eigenvalue
    problem  A - w B, with scaling as necessary to avoid over-/underflow.

    The scaling factor "s" results in a modified eigenvalue equation

        s A - w B

    where  s  is a non-negative scaling factor chosen so that  w, w B,
    and  s A  do not overflow and, if possible, do not underflow, either.
    \endverbatim 

 * @param[in] A
          A is REAL array, dimension (LDA, 2) \n
          On entry, the 2 x 2 matrix A.  It is assumed that its 1-norm
          is less than 1/SAFMIN.  Entries less than
          sqrt(SAFMIN)*norm(A) are subject to being treated as zero. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= 2. \n
 * @param[in] B
          B is REAL array, dimension (LDB, 2) \n
          On entry, the 2 x 2 upper triangular matrix B.  It is
          assumed that the one-norm of B is less than 1/SAFMIN.  The
          diagonals should be at least sqrt(SAFMIN) times the largest
          element of B (in absolute value); if a diagonal is smaller
          than that, then  +/- sqrt(SAFMIN) will be used instead of
          that diagonal. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= 2. \n
 * @param[in] SAFMIN
          SAFMIN is REAL \n
          The smallest positive number s.t. 1/SAFMIN does not
          overflow.  (This should always be SLAMCH('S') -- it is an
          argument in order to avoid having to call SLAMCH frequently.) \n
 * @param[out] SCALE1
          SCALE1 is REAL \n
          A scaling factor used to avoid over-/underflow in the
          eigenvalue equation which defines the first eigenvalue.  If
          the eigenvalues are complex, then the eigenvalues are
          (WR1  +/-  WI i) / SCALE1  (which may lie outside the
          exponent range of the machine), SCALE1=SCALE2, and SCALE1
          will always be positive.  If the eigenvalues are real, then
          the first (real) eigenvalue is  WR1 / SCALE1 , but this may
          overflow or underflow, and in fact, SCALE1 may be zero or
          less than the underflow threshold if the exact eigenvalue
          is sufficiently large. \n
 * @param[out] SCALE2
          SCALE2 is REAL \n
          A scaling factor used to avoid over-/underflow in the
          eigenvalue equation which defines the second eigenvalue.  If
          the eigenvalues are complex, then SCALE2=SCALE1.  If the
          eigenvalues are real, then the second (real) eigenvalue is
          WR2 / SCALE2 , but this may overflow or underflow, and in
          fact, SCALE2 may be zero or less than the underflow
          threshold if the exact eigenvalue is sufficiently large. \n
 * @param[out] WR1
          WR1 is REAL \n
          If the eigenvalue is real, then WR1 is SCALE1 times the
          eigenvalue closest to the (2,2) element of A B**(-1).  If the
          eigenvalue is complex, then WR1=WR2 is SCALE1 times the real
          part of the eigenvalues. \n
 * @param[out] WR2
          WR2 is REAL \n
          If the eigenvalue is real, then WR2 is SCALE2 times the
          other eigenvalue.  If the eigenvalue is complex, then
          WR1=WR2 is SCALE1 times the real part of the eigenvalues. \n
 * @param[out] WI
          WI is REAL \n
          If the eigenvalue is real, then WI is zero. If the
          eigenvalue is complex, then WI is SCALE1 times the imaginary
          part of the eigenvalues. WI will always be non-negative. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lag2(T *a, integer *lda, T *b, integer *ldb, T *safmin, T *scale1, T *scale2, T *wr1, T *wr2, T * wi)
{
    return lag2(a, lda, b, ldb, safmin, scale1, scale2, wr1, wr2, wi);
}

/*! @brief LAGS2 computes 2-by-2 orthogonal matrices U, V, and Q, and applies them \n
     to matrices A and B such that the rows of the transformed A and B are parallel
 * @details
 * \b Purpose:
    \verbatim 
    LAGS2 computes 2-by-2 orthogonal matrices U, V and Q, such
    that if (UPPER) then

              U**T *A*Q = U**T *(A1 A2)*Q = (x  0 )
                                (0  A3)     (x  x )
    and
              V**T*B*Q = V**T *(B1 B2)*Q = (x  0 )
                               (0  B3)     (x  x )

    or if (.NOT.UPPER) then

              U**T *A*Q = U**T *(A1 0 )*Q = (x  x )
                                (A2 A3)     (0  x )
    and
              V**T*B*Q = V**T*(B1 0 )*Q = (x  x )
                              (B2 B3)     (0  x )

    The rows of the transformed A and B are parallel, where

      U = ( CSU  SNU), V = ( CSV SNV), Q = ( CSQ   SNQ)
          (-SNU  CSU)      (-SNV CSV)      (-SNQ   CSQ)

    Z**T denotes the transpose of Z.
    \endverbatim
 

 * @param[in] UPPER
          UPPER is LOGICAL \n
          = .TRUE.: the input matrices A and B are upper triangular. \n
          = .FALSE.: the input matrices A and B are lower triangular. \n
 * @param[in] A1
          A1 is REAL \n
 * @param[in] A2
          A2 is REAL \n
 * @param[in] A3
          A3 is REAL \n
          On entry, A1, A2 and A3 are elements of the input 2-by-2
          upper (lower) triangular matrix A. \n
 * @param[in] B1
          B1 is REAL \n
 * @param[in] B2
          B2 is REAL \n
 * @param[in] B3
          B3 is REAL \n
          On entry, B1, B2 and B3 are elements of the input 2-by-2
          upper (lower) triangular matrix B. \n
 * @param[out] CSU
          CSU is REAL \n
 * @param[out] SNU
          SNU is REAL \n
          The desired orthogonal matrix U. \n
 * @param[out] CSV
          CSV is REAL \n
 * @param[out] SNV
          SNV is REAL \n
          The desired orthogonal matrix V. \n
 * @param[out] CSQ
          CSQ is REAL \n
 * @param[out] SNQ
          SNQ is REAL \n
          The desired orthogonal matrix Q.  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lags2(logical *upper, T *a1, T *a2, T *a3, T *b1, T *b2, T *b3, T *csu, T *snu, T *csv, T * snv, T *csq, T *snq)
{
  return lags2(upper, a1, a2, a3, b1, b2, b3, csu, snu, csv, snv, csq, snq);
}
template< typename T, typename Ta >
integer lags2(logical *upper, Ta *a1, T *a2, Ta *a3, Ta *b1, T *b2, Ta *b3, Ta *csu, T *snu, Ta *csv, T *snv, Ta *csq, T *snq)
{
  return lags2(upper, a1, a2, a3, b1, b2, b3, csu, snu, csv, snv, csq, snq);
}

/*! @brief LAGTF computes an LU factorization of a matrix T-I, where T is a general  \n
     tridiagonal matrix, and  a scalar, using partial pivoting with row interchanges
 * @details
 * \b Purpose:
    \verbatim 
    LAGTF factorizes the matrix (T - lambda*I), where T is an n by n
    tridiagonal matrix and lambda is a scalar, as

       T - lambda*I = PLU,

    where P is a permutation matrix, L is a unit lower tridiagonal matrix
    with at most one non-zero sub-diagonal elements per column and U is
    an upper triangular matrix with at most two non-zero super-diagonal
    elements per column.

    The factorization is obtained by Gaussian elimination with partial
    pivoting and implicit row scaling.

    The parameter LAMBDA is included in the routine so that SLAGTF may
    be used, in conjunction with SLAGTS, to obtain eigenvectors of T by
    inverse iteration.
    \endverbatim 

 * @param[in] N
          N is INTEGER \n
          The order of the matrix T. \n
 * @param[in,out] A
          A is REAL array, dimension (N) \n
          On entry, A must contain the diagonal elements of T.
 \n
          On exit, A is overwritten by the n diagonal elements of the
          upper triangular matrix U of the factorization of T. \n
 * @param[in] LAMBDA
          LAMBDA is REAL \n
          On entry, the scalar lambda. \n
 * @param[in,out] B
          B is REAL array, dimension (N-1) \n
          On entry, B must contain the (n-1) super-diagonal elements of
          T.
 \n
          On exit, B is overwritten by the (n-1) super-diagonal
          elements of the matrix U of the factorization of T. \n
 * @param[in,out] C
          C is REAL array, dimension (N-1) \n
          On entry, C must contain the (n-1) sub-diagonal elements of
          T.
 \n
          On exit, C is overwritten by the (n-1) sub-diagonal elements
          of the matrix L of the factorization of T. \n
 * @param[in] TOL
          TOL is REAL \n
          On entry, a relative tolerance used to indicate whether or
          not the matrix (T - lambda*I) is nearly singular. TOL should
          normally be chose as approximately the largest relative error
          in the elements of T. For example, if the elements of T are
          correct to about 4 significant figures, then TOL should be
          set to about 5*10**(-4). If TOL is supplied as less than eps,
          where eps is the relative machine precision, then the value
          eps is used in place of TOL. \n
 * @param[out] D
          D is REAL array, dimension (N-2) \n
          On exit, D is overwritten by the (n-2) second super-diagonal
          elements of the matrix U of the factorization of T. \n
 * @param[out] IN
          IN is INTEGER array, dimension (N) \n
          On exit, IN contains details of the permutation matrix P. If
          an interchange occurred at the kth step of the elimination,
          then IN(k) = 1, otherwise IN(k) = 0. The element IN(n)
            returns the smallest positive integer j such that
 \n
             abs(u(j,j)) <= norm((T - lambda*I)(j))*TOL,
 \n
          where norm(A(j)) denotes the sum of the absolute values of
          the jth row of the matrix A. If no such j exists then IN(n)
          is   returned as zero. If IN(n) is   returned as positive, then a
          diagonal element of U is small, indicating that
          (T - lambda*I) is singular or nearly singular, \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -k, the kth argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lagtf(integer *n, T *a, T *lambda, T *b, T *c, T *tol, T *d, integer *in, integer *info)
{
  return lagtf(n, a, lambda, b, c, tol, d, in, info);
}

/*! @brief LAGTM performs a matrix-matrix product of the form C = AB+C, where A is a \n
     tridiagonal matrix, B and C are rectangular matrices, and  and  are scalars,   \n
     which may be 0, 1, or -1
 * @details
 * \b Purpose:
    \verbatim 
    LAGTM performs a matrix-vector product of the form

       B := alpha * A * X + beta * B

    where A is a tridiagonal matrix of order N, B and X are N by NRHS
    matrices, and alpha and beta are real scalars, each of which may be
    0., 1., or -1.
    \endverbatim 

 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          Specifies the operation applied to A. \n
          = 'N':  No transpose, B := alpha * A * X + beta * B \n
          = 'T':  Transpose,   B := alpha * A'* X + beta * B \n
          = 'C':  Conjugate transpose = Transpose \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrices X and B. \n
 * @param[in] ALPHA
          ALPHA is REAL \n
          The scalar alpha. ALPHA must be 0., 1., or -1.; otherwise,
          it is assumed to be 0. \n
 * @param[in] DL
          DL is REAL array, dimension (N-1) \n
          The (n-1) sub-diagonal elements of T. \n
 * @param[in] D
          D is REAL array, dimension (N) \n
          The diagonal elements of T. \n
 * @param[in] DU
          DU is REAL array, dimension (N-1) \n
          The (n-1) super-diagonal elements of T. \n
 * @param[in] X
          X is REAL array, dimension (LDX,NRHS) \n
          The N by NRHS matrix X. \n
 * @param[in] LDX
          LDX is INTEGER \n
          The leading dimension of the array X.  LDX >= max(N,1). \n
 * @param[in] BETA
          BETA is REAL \n
          The scalar beta. BETA must be 0., 1., or -1.; otherwise,
          it is assumed to be 1. \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,NRHS) \n
          On entry, the N by NRHS matrix B.
          On exit, B is overwritten by the matrix expression \n
          B := alpha * A * X + beta * B. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(N,1).  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lagtm(char *trans, integer *n, integer *nrhs, T *alpha, T *dl, T *d, T *du, T *x, integer *ldx, T * beta, T *b, integer *ldb)
{
  return lagtm(trans, n, nrhs, alpha, dl, d, du, x, ldx, beta, b, ldb);
}
template< typename T, typename Ta >
integer lagtm(char *trans, integer *n, integer *nrhs, Ta *alpha, T *dl, T *d, T *du, T *x, integer *ldx, Ta *beta, T *b, integer *ldb)
{
  return lagtm(trans, n, nrhs, alpha, dl, d, du, x, ldx, beta, b, ldb);
}

/*! @brief LAGTS solves the system of equations (T-I)x = y or (T-I)Tx = y,where T is a general \n
     tridiagonal matrix and  a scalar, using the LU factorization computed by slagtf
 * @details
 * \b Purpose:
    \verbatim 
    LAGTS may be used to solve one of the systems of equations

       (T - lambda*I)*x = y   or   (T - lambda*I)**T*x = y,

    where T is an n by n tridiagonal matrix, for x, following the
    factorization of (T - lambda*I) as

       (T - lambda*I) = P*L*U ,

    by routine LAGTF. The choice of equation to be solved is
    controlled by the argument JOB, and in each case there is an option
    to perturb zero or very small diagonal elements of U, this option
    being intended for use in applications such as inverse iteration.
    \endverbatim 

 * @param[in] JOB
          JOB is INTEGER \n
          Specifies the job to be performed by SLAGTS as follows: \n
          =  1: The equations  (T - lambda*I)x = y  are to be solved,
                but diagonal elements of U are not to be perturbed. \n
          = -1: The equations  (T - lambda*I)x = y  are to be solved
                and, if overflow would otherwise occur, the diagonal
                elements of U are to be perturbed. See argument TOL
                below. \n
          =  2: The equations  (T - lambda*I)**Tx = y  are to be solved,
                but diagonal elements of U are not to be perturbed. \n
          = -2: The equations  (T - lambda*I)**Tx = y  are to be solved
                and, if overflow would otherwise occur, the diagonal
                elements of U are to be perturbed. See argument TOL
                below. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix T. \n
 * @param[in] A
          A is REAL array, dimension (N) \n
          On entry, A must contain the diagonal elements of U as
          returned from SLAGTF. \n
 * @param[in] B
          B is REAL array, dimension (N-1) \n
          On entry, B must contain the first super-diagonal elements of
          U as returned from SLAGTF. \n
 * @param[in] C
          C is REAL array, dimension (N-1) \n
          On entry, C must contain the sub-diagonal elements of L as
          returned from SLAGTF. \n
 * @param[in] D
          D is REAL array, dimension (N-2) \n
          On entry, D must contain the second super-diagonal elements
          of U as returned from SLAGTF. \n
 * @param[in] IN
          IN is INTEGER array, dimension (N) \n
          On entry, IN must contain details of the matrix P as   returned
          from SLAGTF. \n
 * @param[in,out] Y
          Y is REAL array, dimension (N) \n
          On entry, the right hand side vector y.
          On exit, Y is overwritten by the solution vector x. \n
 * @param[in,out] TOL
          TOL is REAL \n
          On entry, with  JOB < 0, TOL should be the minimum
          perturbation to be made to very small diagonal elements of U.
          TOL should normally be chosen as about eps*norm(U), where eps
          is the relative machine precision, but if TOL is supplied as
          non-positive, then it is reset to eps*max(abs(u(i,j))).
          If  JOB > 0  then TOL is not referenced.
 \n
          On exit, TOL is changed as described above, only if TOL is
          non-positive on entry. Otherwise TOL is unchanged. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n
          > 0: overflow would occur when computing the INFO(th)
               element of the solution vector x. This can only occur
               when JOB is supplied as positive and either means
               that a diagonal element of U is very small, or that
               the elements of the right-hand side vector y are very
               large. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lagts(integer *job, integer *n, T *a, T *b, T *c, T *d, integer *in, T *y, T *tol, integer *info)
{
  return lagts(job, n, a, b, c, d, in, y, tol, info);
}

/*! @brief LAGV2 computes the Generalized Schur factorization of a real 2-by-2 \n
     matrix pencil (A,B) where B is upper triangular
 * @details
 * \b Purpose:
    \verbatim 
    LAGV2 computes the Generalized Schur factorization of a real 2-by-2
    matrix pencil (A,B) where B is upper triangular. This routine
    computes orthogonal (rotation) matrices given by CSL, SNL and CSR,
    SNR such that

    1) if the pencil (A,B) has two real eigenvalues (include 0/0 or 1/0
       types), then

       [ a11 a12 ] := [  CSL  SNL ] [ a11 a12 ] [  CSR -SNR ]
       [  0  a22 ]    [ -SNL  CSL ] [ a21 a22 ] [  SNR  CSR ]

       [ b11 b12 ] := [  CSL  SNL ] [ b11 b12 ] [  CSR -SNR ]
       [  0  b22 ]    [ -SNL  CSL ] [  0  b22 ] [  SNR  CSR ],

    2) if the pencil (A,B) has a pair of complex conjugate eigenvalues,
       then

       [ a11 a12 ] := [  CSL  SNL ] [ a11 a12 ] [  CSR -SNR ]
       [ a21 a22 ]    [ -SNL  CSL ] [ a21 a22 ] [  SNR  CSR ]

       [ b11  0  ] := [  CSL  SNL ] [ b11 b12 ] [  CSR -SNR ]
       [  0  b22 ]    [ -SNL  CSL ] [  0  b22 ] [  SNR  CSR ]

       where b11 >= b22 > 0.
    \endverbatim 

 * @param[in,out] A \n
          A is REAL array, dimension (LDA, 2)
          On entry, the 2 x 2 matrix A.
          On exit, A is overwritten by the ``A-part'' of the
          generalized Schur form. \n
 * @param[in] LDA
          LDA is INTEGER \n
          THe leading dimension of the array A.  LDA >= 2. \n
 * @param[in,out] B
          B is REAL array, dimension (LDB, 2) \n
          On entry, the upper triangular 2 x 2 matrix B.
          On exit, B is overwritten by the ``B-part'' of the
          generalized Schur form. \n
 * @param[in] LDB
          LDB is INTEGER \n
          THe leading dimension of the array B.  LDB >= 2. \n
 * @param[out] ALPHAR
          ALPHAR is REAL array, dimension (2) \n
 * @param[out] ALPHAI
          ALPHAI is REAL array, dimension (2) \n
 * @param[out] BETA
          BETA is REAL array, dimension (2) \n
          (ALPHAR(k)+i*ALPHAI(k))/BETA(k) are the eigenvalues of the
          pencil (A,B), k=1,2, i = sqrt(-1).  Note that BETA(k) may
          be zero. \n
 * @param[out] CSL
          CSL is REAL \n
          The cosine of the left rotation matrix. \n
 * @param[out] SNL
          SNL is REAL \n
          The sine of the left rotation matrix. \n
 * @param[out] CSR
          CSR is REAL \n
          The cosine of the right rotation matrix. \n
 * @param[out] SNR
          SNR is REAL \n
          The sine of the right rotation matrix. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lagv2(T *a, integer *lda, T *b, integer *ldb, T *alphar, T *alphai, T *beta, T *csl, T *snl, T * csr, T *snr)
{
  return lagv2(a, lda, b, ldb, alphar, alphai, beta, csl, snl, csr, snr);
}

/*! @brief LAHEF computes a partial factorization of a complex Hermitian indefinite \n
     matrix using the Bunch-Kaufman diagonal pivoting method                        \n
     (blocked algorithm, calling Level 3 BLAS)
 * @details
 * \b Purpose:
    \verbatim 
    LAHEF computes a partial factorization of a complex Hermitian
    matrix A using the Bunch-Kaufman diagonal pivoting method. The
    partial factorization has the form:

    A  =  (I  U12) (A11  0 ) ( I      0    )  if UPLO = 'U', or:
          (0  U22) ( 0   D ) (U12**H U22**H)

    A  =  (L11  0) ( D   0 ) (L11**H L21**H)  if UPLO = 'L'
          (L21  I) ( 0  A22) ( 0      I    )

    where the order of D is at most NB. The actual order is   returned in
    the argument KB, and is either NB or NB-1, or N if N <= NB.
    Note that U**H denotes the conjugate transpose of U.

    CLAHEF is an auxiliary routine called by CHETRF. It uses blocked code
    (calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or
    A22 (if UPLO = 'L').
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the upper or lower triangular part of the
          Hermitian matrix A is stored: \n
          = 'U':  Upper triangular \n
          = 'L':  Lower triangular \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NB
          NB is INTEGER \n
          The maximum number of columns of the matrix A that should be
          factored.  NB should be at least 2 to allow for 2-by-2 pivot
          blocks. \n
 * @param[out] KB
          KB is INTEGER \n
          The number of columns of A that were actually factored.
          KB is either NB-1 or NB, or N if N <= NB. \n
 * @param[in,out] A
          A is COMPLEX array, dimension (LDA,N) \n
          On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
          n-by-n upper triangular part of A contains the upper
          triangular part of the matrix A, and the strictly lower
          triangular part of A is not referenced.  If UPLO = 'L', the
          leading n-by-n lower triangular part of A contains the lower
          triangular part of the matrix A, and the strictly upper
          triangular part of A is not referenced. \n
          On exit, A contains details of the partial factorization. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D.
 \n
          If UPLO = 'U': \n
             Only the last KB elements of IPIV are set.
 \n
             If IPIV(k) > 0, then rows and columns k and IPIV(k) were
             interchanged and D(k,k) is a 1-by-1 diagonal block.
 \n
             If IPIV(k) = IPIV(k-1) < 0, then rows and columns
             k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
             is a 2-by-2 diagonal block.
 \n
          If UPLO = 'L': \n
             Only the first KB elements of IPIV are set.
 \n
             If IPIV(k) > 0, then rows and columns k and IPIV(k) were
             interchanged and D(k,k) is a 1-by-1 diagonal block.
 \n
             If IPIV(k) = IPIV(k+1) < 0, then rows and columns
             k+1 and -IPIV(k) were interchanged and D(k:k+1,k:k+1)
             is a 2-by-2 diagonal block. \n
 * @param[out] W
          W is COMPLEX array, dimension (LDW,NB) \n
 * @param[in] LDW
          LDW is INTEGER \n
          The leading dimension of the array W.  LDW >= max(1,N). \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0: successful exit \n
          > 0: if INFO = k, D(k,k) is exactly zero.  The factorization
               has been completed, but the block diagonal matrix D is
               exactly singular. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lahef(char *uplo, integer *n, integer *nb, integer *kb, T *a, integer *lda, integer *ipiv, T *w, integer *ldw, integer *info)
{
  return lahef(uplo, n, nb, kb, a, lda, ipiv, w, ldw, info);
}

/*! @brief LAHEF_AA factorizes a panel of a complex hermitian matrix A using the Aasen's algorithm

 * @details
 * \b Purpose:
    \verbatim 
    LAHEF_AA factorizes a panel of a complex hermitian matrix A using
    the Aasen's algorithm. The panel consists of a set of NB rows of A
    when UPLO is U, or a set of NB columns when UPLO is L.

    In order to factorize the panel, the Aasen's algorithm requires the
    last row, or column, of the previous panel. The first row, or column,
    of A is set to be the first row, or column, of an identity matrix,
    which is used to factorize the first panel.

    The resulting J-th row of U, or J-th column of L, is stored in the
    (J-1)-th row, or column, of A (without the unit diagonals), while
    the diagonal and subdiagonal of A are overwritten by those of T.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in] J1
          J1 is INTEGER \n
          The location of the first row, or column, of the panel
          within the submatrix of A, passed to this routine, e.g.,
          when called by CHETRF_AA, for the first panel, J1 is 1,
          while for the remaining panels, J1 is 2. \n
 * @param[in] M
          M is INTEGER \n
          The dimension of the submatrix. M >= 0. \n
 * @param[in] NB
          NB is INTEGER \n
          The dimension of the panel to be facotorized. \n
 * @param[in,out] A
          A is COMPLEX array, dimension (LDA,M) for
          the first panel, while dimension (LDA,M+1) for the
          remaining panels. \n
 \n
          On entry, A contains the last row, or column, of
          the previous panel, and the trailing submatrix of A
          to be factorized, except for the first panel, only
          the panel is passed. \n
 \n
          On exit, the leading panel is factorized. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the row and column interchanges,
          the row and column k were interchanged with the row and
          column IPIV(k). \n
 * @param[in,out] H
          H is COMPLEX workspace, dimension (LDH,NB). \n
 * @param[in] LDH
          LDH is INTEGER \n
          The leading dimension of the workspace H. LDH >= max(1,M). \n
 * @param[out] WORK
          WORK is COMPLEX workspace, dimension (M). \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lahef_aa(char *uplo, integer *j1, integer *m, integer *nb, T *a, integer *lda, integer *ipiv, T *h, integer * ldh, T *work) 
{
  return lahef_aa(uplo, j1, m, nb, a, lda, ipiv, h, ldh, work); 
}

/*! @brief LAHEF_RK computes a partial factorization of a complex Hermitian indefinite \n
     matrix using bounded Bunch-Kaufman (rook) diagonal pivoting method
 * @details
 * \b Purpose:
    \verbatim 
    LAHEF_RK computes a partial factorization of a complex Hermitian
    matrix A using the bounded Bunch-Kaufman (rook) diagonal
    pivoting method. The partial factorization has the form:

    A  =  (I  U12) (A11  0 ) ( I       0   )  if UPLO = 'U', or:
          (0  U22) ( 0   D ) (U12**H U22**H)

    A  =  (L11  0) ( D   0 ) (L11**H L21**H)  if UPLO = 'L',
          (L21  I) ( 0  A22) ( 0       I   )

    where the order of D is at most NB. The actual order is   returned in
    the argument KB, and is either NB or NB-1, or N if N <= NB.

    CLAHEF_RK is an auxiliary routine called by CHETRF_RK. It uses
    blocked code (calling Level 3 BLAS) to update the submatrix
    A11 (if UPLO = 'U') or A22 (if UPLO = 'L').
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the upper or lower triangular part of the
          Hermitian matrix A is stored: \n
          = 'U':  Upper triangular \n
          = 'L':  Lower triangular \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NB
          NB is INTEGER \n
          The maximum number of columns of the matrix A that should be
          factored. NB should be at least 2 to allow for 2-by-2 pivot
          blocks. \n
 * @param[out] KB
          KB is INTEGER \n
          The number of columns of A that were actually factored.
          KB is either NB-1 or NB, or N if N <= NB. \n
 * @param[in,out] A
          A is COMPLEX array, dimension (LDA,N) \n
          On entry, the Hermitian matrix A. \n
            If UPLO = 'U': the leading N-by-N upper triangular part
            of A contains the upper triangular part of the matrix A,
            and the strictly lower triangular part of A is not
            referenced. \n
 \n
            If UPLO = 'L': the leading N-by-N lower triangular part
            of A contains the lower triangular part of the matrix A,
            and the strictly upper triangular part of A is not
            referenced. \n
 \n
          On exit, contains: \n
            a) ONLY diagonal elements of the Hermitian block diagonal
               matrix D on the diagonal of A, i.e. D(k,k) = A(k,k);
               (superdiagonal (or subdiagonal) elements of D
                are stored on exit in array E), and \n
            b) If UPLO = 'U': factor U in the superdiagonal part of A. \n
               If UPLO = 'L': factor L in the subdiagonal part of A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] E
          E is COMPLEX array, dimension (N) \n
          On exit, contains the superdiagonal (or subdiagonal)
          elements of the Hermitian block diagonal matrix D
          with 1-by-1 or 2-by-2 diagonal blocks, where \n
          If UPLO = 'U': E(i) = D(i-1,i), i=2:N, E(1) is set to 0; \n
          If UPLO = 'L': E(i) = D(i+1,i), i=1:N-1, E(N) is set to 0. \n
 \n
          NOTE: For 1-by-1 diagonal block D(k), where
          1 <= k <= N, the element E(k) is set to 0 in both
          UPLO = 'U' or UPLO = 'L' cases. \n
 * @param[out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          IPIV describes the permutation matrix P in the factorization
          of matrix A as follows. The absolute value of IPIV(k)
          represents the index of row and column that were
          interchanged with the k-th row and column. The value of UPLO
          describes the order in which the interchanges were applied.
          Also, the sign of IPIV represents the block structure of
          the Hermitian block diagonal matrix D with 1-by-1 or 2-by-2
          diagonal blocks which correspond to 1 or 2 interchanges
          at each factorization step. \n
 \n
          If UPLO = 'U',
          (in factorization order, k decreases from N to 1): \n
            a) A single positive entry IPIV(k) > 0 means:
               D(k,k) is a 1-by-1 diagonal block.
               If IPIV(k) != k, rows and columns k and IPIV(k) were
               interchanged in the submatrix A(1:N,N-KB+1:N);
               If IPIV(k) = k, no interchange occurred. \n
 \n
            b) A pair of consecutive negative entries
               IPIV(k) < 0 and IPIV(k-1) < 0 means:
               D(k-1:k,k-1:k) is a 2-by-2 diagonal block.
               (NOTE: negative entries in IPIV appear ONLY in pairs). \n
               1) If -IPIV(k) != k, rows and columns
                  k and -IPIV(k) were interchanged
                  in the matrix A(1:N,N-KB+1:N).
                  If -IPIV(k) = k, no interchange occurred. \n
               2) If -IPIV(k-1) != k-1, rows and columns
                  k-1 and -IPIV(k-1) were interchanged
                  in the submatrix A(1:N,N-KB+1:N).
                  If -IPIV(k-1) = k-1, no interchange occurred. \n
 \n
            c) In both cases a) and b) is always ABS(IPIV(k)) <= k. \n
 \n
            d) NOTE: Any entry IPIV(k) is always NONZERO on output. \n
 \n
          If UPLO = 'L',
          (in factorization order, k increases from 1 to N): \n
            a) A single positive entry IPIV(k) > 0 means:
               D(k,k) is a 1-by-1 diagonal block.
               If IPIV(k) != k, rows and columns k and IPIV(k) were
               interchanged in the submatrix A(1:N,1:KB).
               If IPIV(k) = k, no interchange occurred.
 \n
            b) A pair of consecutive negative entries
               IPIV(k) < 0 and IPIV(k+1) < 0 means:
               D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
               (NOTE: negative entries in IPIV appear ONLY in pairs). \n
               1) If -IPIV(k) != k, rows and columns
                  k and -IPIV(k) were interchanged
                  in the submatrix A(1:N,1:KB).
                  If -IPIV(k) = k, no interchange occurred. \n
               2) If -IPIV(k+1) != k+1, rows and columns
                  k-1 and -IPIV(k-1) were interchanged
                  in the submatrix A(1:N,1:KB).
                  If -IPIV(k+1) = k+1, no interchange occurred. \n
 \n
            c) In both cases a) and b) is always ABS(IPIV(k)) >= k. \n
 \n
            d) NOTE: Any entry IPIV(k) is always NONZERO on output. \n
 * @param[out] W
          W is COMPLEX array, dimension (LDW,NB) \n
 * @param[in] LDW
          LDW is INTEGER \n
          The leading dimension of the array W.  LDW >= max(1,N). \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: If INFO = -k, the k-th argument had an illegal value \n
          > 0: If INFO = k, the matrix A is singular, because:
                 If UPLO = 'U': column k in the upper
                 triangular part of A contains all zeros.
                 If UPLO = 'L': column k in the lower
                 triangular part of A contains all zeros. \n
 \n
               Therefore D(k,k) is exactly zero, and superdiagonal
               elements of column k of U (or subdiagonal elements of
               column k of L) are all zeros. The factorization has
               been completed, but the block diagonal matrix D is
               exactly singular, and division by zero will occur if
               it is used to solve a system of equations. \n
 \n
               NOTE: INFO only stores the first occurrence of
               a singularity, any subsequent occurrence of singularity
               is not stored in INFO even though the factorization
               always completes.  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lahef_rk(char *uplo, integer *n, integer *nb, integer *kb, T *a, integer *lda, T *e, integer *ipiv, T *w, integer *ldw, integer *info)
{
  return lahef_rk(uplo, n, nb, kb, a, lda, e, ipiv, w, ldw, info);
}

/*! @brief LAHEF_ROOK computes a partial factorization of a complex Hermitian matrix \n
     A using the bounded Bunch-Kaufman ("rook") diagonal pivoting method
 * @details
 * \b Purpose:
    \verbatim 
    LAHEF_ROOK computes a partial factorization of a complex Hermitian
    matrix A using the bounded Bunch-Kaufman ("rook") diagonal pivoting
    method. The partial factorization has the form:

    A  =  (I  U12) (A11  0 ) ( I      0    )  if UPLO = 'U', or:
          (0  U22) ( 0   D ) (U12**H U22**H)

    A  =  (L11  0) ( D   0 ) (L11**H L21**H)  if UPLO = 'L'
          (L21  I) ( 0  A22) ( 0      I    )

    where the order of D is at most NB. The actual order is   returned in
    the argument KB, and is either NB or NB-1, or N if N <= NB.
    Note that U**H denotes the conjugate transpose of U.

    CLAHEF_ROOK is an auxiliary routine called by CHETRF_ROOK. It uses
    blocked code (calling Level 3 BLAS) to update the submatrix
    A11 (if UPLO = 'U') or A22 (if UPLO = 'L').
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the upper or lower triangular part of the
          Hermitian matrix A is stored: \n
          = 'U':  Upper triangular \n
          = 'L':  Lower triangular \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NB
          NB is INTEGER \n
          The maximum number of columns of the matrix A that should be
          factored.  NB should be at least 2 to allow for 2-by-2 pivot
          blocks. \n
 * @param[out] KB
          KB is INTEGER \n
          The number of columns of A that were actually factored.
          KB is either NB-1 or NB, or N if N <= NB. \n
 * @param[in,out] A
          A is COMPLEX array, dimension (LDA,N) \n
          On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
          n-by-n upper triangular part of A contains the upper
          triangular part of the matrix A, and the strictly lower
          triangular part of A is not referenced.  If UPLO = 'L', the
          leading n-by-n lower triangular part of A contains the lower
          triangular part of the matrix A, and the strictly upper
          triangular part of A is not referenced. \n
          On exit, A contains details of the partial factorization. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D. \n
 \n
          If UPLO = 'U': \n
             Only the last KB elements of IPIV are set.
 \n
             If IPIV(k) > 0, then rows and columns k and IPIV(k) were
             interchanged and D(k,k) is a 1-by-1 diagonal block.
 \n
             If IPIV(k) < 0 and IPIV(k-1) < 0, then rows and
             columns k and -IPIV(k) were interchanged and rows and
             columns k-1 and -IPIV(k-1) were inerchaged,
             D(k-1:k,k-1:k) is a 2-by-2 diagonal block.
 \n
          If UPLO = 'L': \n
             Only the first KB elements of IPIV are set.
 \n
             If IPIV(k) > 0, then rows and columns k and IPIV(k)
             were interchanged and D(k,k) is a 1-by-1 diagonal block.
 \n
             If IPIV(k) < 0 and IPIV(k+1) < 0, then rows and
             columns k and -IPIV(k) were interchanged and rows and
             columns k+1 and -IPIV(k+1) were inerchaged,
             D(k:k+1,k:k+1) is a 2-by-2 diagonal block. \n
 * @param[out] W
          W is COMPLEX array, dimension (LDW,NB) \n
 * @param[in] LDW
          LDW is INTEGER \n
          The leading dimension of the array W.  LDW >= max(1,N). \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0: successful exit \n
          > 0: if INFO = k, D(k,k) is exactly zero.  The factorization
               has been completed, but the block diagonal matrix D is
               exactly singular.  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lahef_rook(char *uplo, integer *n, integer *nb, integer *kb, T *a, integer *lda, integer *ipiv, T *w, integer *ldw, integer *info)
{
  return lahef_rook(uplo, n, nb, kb, a, lda, ipiv, w, ldw, info); 
}

/*! @brief LAHQR computes the eigenvalues and Schur factorization of an upper \n
     Hessenberg matrix, using the double-shift/single-shift QR algorithm
 * @details
 * \b Purpose:
    \verbatim 
    LAHQR is an auxiliary routine called by SHSEQR to update the
    eigenvalues and Schur decomposition already computed by SHSEQR, by
    dealing with the Hessenberg submatrix in rows and columns ILO to
    IHI.
    \endverbatim  

 * @param[in] WANTT
          WANTT is LOGICAL \n
          = .TRUE. : the full Schur form T is required; \n
          = .FALSE.: only eigenvalues are required. \n
 * @param[in] WANTZ
          WANTZ is LOGICAL \n
          = .TRUE. : the matrix of Schur vectors Z is required; \n
          = .FALSE.: Schur vectors are not required. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix H.  N >= 0. \n
 * @param[in] ILO
          ILO is INTEGER \n
 * @param[in] IHI
          IHI is INTEGER \n
          It is assumed that H is already upper quasi-triangular in
          rows and columns IHI+1:N, and that H(ILO,ILO-1) = 0 (unless
          ILO = 1). SLAHQR works primarily with the Hessenberg
          submatrix in rows and columns ILO to IHI, but applies
          transformations to all of H if WANTT is .TRUE.. \n
          1 <= ILO <= max(1,IHI); IHI <= N. \n
 * @param[in,out] H
          H is REAL array, dimension (LDH,N) \n
          On entry, the upper Hessenberg matrix H. \n
          On exit, if INFO is zero and if WANTT is .TRUE., H is upper
          quasi-triangular in rows and columns ILO:IHI, with any
          2-by-2 diagonal blocks in standard form. If INFO is zero
          and WANTT is .FALSE., the contents of H are unspecified on
          exit.  The output state of H if INFO is nonzero is given
          below under the description of INFO. \n
 * @param[in] LDH
          LDH is INTEGER \n
          The leading dimension of the array H. LDH >= max(1,N). \n
 * @param[out] WR
          WR is REAL array, dimension (N) \n
 * @param[out] WI
          WI is REAL array, dimension (N) \n
          The real and imaginary parts, respectively, of the computed
          eigenvalues ILO to IHI are stored in the corresponding
          elements of WR and WI. If two eigenvalues are computed as a
          complex conjugate pair, they are stored in consecutive
          elements of WR and WI, say the i-th and (i+1)th, with
          WI(i) > 0 and WI(i+1) < 0. If WANTT is .TRUE., the
          eigenvalues are stored in the same order as on the diagonal
          of the Schur form   returned in H, with WR(i) = H(i,i), and, if
          H(i:i+1,i:i+1) is a 2-by-2 diagonal block, \n
          WI(i) = sqrt(H(i+1,i)*H(i,i+1)) and WI(i+1) = -WI(i). \n
 * @param[in] ILOZ
          ILOZ is INTEGER \n
 * @param[in] IHIZ
          IHIZ is INTEGER \n
          Specify the rows of Z to which transformations must be
          applied if WANTZ is .TRUE.. \n
          1 <= ILOZ <= ILO; IHI <= IHIZ <= N. \n
 * @param[in,out] Z
          Z is REAL array, dimension (LDZ,N) \n
          If WANTZ is .TRUE., on entry Z must contain the current
          matrix Z of transformations accumulated by SHSEQR, and on
          exit Z has been updated; transformations are applied only to
          the submatrix Z(ILOZ:IHIZ,ILO:IHI). \n
          If WANTZ is .FALSE., Z is not referenced. \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of the array Z. LDZ >= max(1,N). \n
 * @param[out] INFO
          INFO is INTEGER \n
           = 0:   successful exit \n
           > 0:   If INFO = i, SLAHQR failed to compute all the
                  eigenvalues ILO to IHI in a total of 30 iterations
                  per eigenvalue; elements i+1:ihi of WR and WI
                  contain those eigenvalues which have been
                  successfully computed. \n
 \n
                  If INFO > 0 and WANTT is .FALSE., then on exit,
                  the remaining unconverged eigenvalues are the
                  eigenvalues of the upper Hessenberg matrix rows
                  and columns ILO through INFO of the final, output
                  value of H. \n
 \n
                  If INFO > 0 and WANTT is .TRUE., then on exit
          (*)       (initial value of H)*U  = U*(final value of H)
                  where U is an orthogonal matrix.    The final
                  value of H is upper Hessenberg and triangular in
                  rows and columns INFO+1 through IHI. \n
 \n
                  If INFO > 0 and WANTZ is .TRUE., then on exit
                      (final value of Z)  = (initial value of Z)*U
                  where U is the orthogonal matrix in (*)
                  (regardless of the value of WANTT.)  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lahqr(logical *wantt, logical *wantz, integer *n, integer *ilo, integer *ihi, T *h, integer *ldh, T *wr, T * wi, integer *iloz, integer *ihiz, T *z, integer *ldz, integer * info)
{
  return lahqr(wantt, wantz, n, ilo, ihi, h, ldh, wr, wi, iloz, ihiz, z, ldz, info);
}
template< typename T >
integer lahqr(logical *wantt, logical *wantz, integer *n, integer *ilo, integer *ihi, T *h, integer *ldh, T *w, integer *iloz, integer *ihiz, T *z, integer *ldz, integer * info)
{
  return lahqr(wantt, wantz, n, ilo, ihi, h, ldh, w, iloz, ihiz, z, ldz, info);
}

/*! @brief LAHR2 reduces the specified number of first columns of a general \n
     rectangular matrix A so that elements below the specified subdiagonal  \n
     are zero, and   returns auxiliary matrices which are needed to apply the \n
     transformation to the unreduced part of A
 * @details
 * \b Purpose:
    \verbatim 
    LAHR2 reduces the first NB columns of A real general n-BY-(n-k+1)
    matrix A so that elements below the k-th subdiagonal are zero. The
    reduction is performed by an orthogonal similarity transformation
    Q**T * A * Q. The routine   returns the matrices V and T which determine
    Q as a block reflector I - V*T*V**T, and also the matrix Y = A * V * T.

    This is an auxiliary routine called by GEHRD.
    \endverbatim 

 * @param[in] N
          N is INTEGER \n
          The order of the matrix A. \n
 * @param[in] K
          K is INTEGER \n
          The offset for the reduction. Elements below the k-th
          subdiagonal in the first NB columns are reduced to zero.
          K < N. \n
 * @param[in] NB
          NB is INTEGER \n
          The number of columns to be reduced. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N-K+1) \n
          On entry, the n-by-(n-k+1) general matrix A. \n
          On exit, the elements on and above the k-th subdiagonal in
          the first NB columns are overwritten with the corresponding
          elements of the reduced matrix; the elements below the k-th
          subdiagonal, with the array TAU, represent the matrix Q as a
          product of elementary reflectors. The other columns of A are
          unchanged. See Further Details. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] TAU
          TAU is REAL array, dimension (NB) \n
          The scalar factors of the elementary reflectors. See Further
          Details. \n
 * @param[out] T
          T is REAL array, dimension (LDT,NB) \n
          The upper triangular matrix T. \n
 * @param[in] LDT
          LDT is INTEGER \n
          The leading dimension of the array T.  LDT >= NB. \n
 * @param[out] Y
          Y is REAL array, dimension (LDY,NB) \n
          The n-by-nb matrix Y. \n
 * @param[in] LDY
          LDY is INTEGER \n
          The leading dimension of the array Y. LDY >= N.  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lahr2(integer *n, integer *k, integer *nb, T *a, integer *lda, T *tau, T *t, integer *ldt, T *y, integer *ldy)
{
  return lahr2(n, k, nb, a, lda, tau, t, ldt, y, ldy);
}

/*! @brief LAHRD reduces the first nb columns of a general rectangular matrix A \n
     so that elements below the k-th subdiagonal are zero, and   returns auxiliary 
 * @details
 * \b Purpose:
    \verbatim 
    This routine is deprecated and has been replaced by routine SLAHR2.
   
    SLAHRD reduces the first NB columns of a real general n-by-(n-k+1)
    matrix A so that elements below the k-th subdiagonal are zero. The
    reduction is performed by an orthogonal similarity transformation
    Q**T * A * Q. The routine   returns the matrices V and T which determine
    Q as a block reflector I - V*T*V**T, and also the matrix Y = A * V * T.
    \endverbatim   

  * @param[in] N
           N is INTEGER \n
           The order of the matrix A. \n
  * @param[in] K
           K is INTEGER \n
           The offset for the reduction. Elements below the k-th
           subdiagonal in the first NB columns are reduced to zero. \n
  * @param[in] NB
           NB is INTEGER \n
           The number of columns to be reduced. \n
  * @param[in,out] A
           A is REAL array, dimension (LDA,N-K+1) \n
           On entry, the n-by-(n-k+1) general matrix A. \n
           On exit, the elements on and above the k-th subdiagonal in
           the first NB columns are overwritten with the corresponding
           elements of the reduced matrix; the elements below the k-th
           subdiagonal, with the array TAU, represent the matrix Q as a
           product of elementary reflectors. The other columns of A are
           unchanged. See Further Details. \n
  * @param[in] LDA
           LDA is INTEGER \n
           The leading dimension of the array A.  LDA >= max(1,N). \n
  * @param[out] TAU
           TAU is REAL array, dimension (NB) \n
           The scalar factors of the elementary reflectors. See Further
           Details. \n
  * @param[out] T
           T is REAL array, dimension (LDT,NB) \n
           The upper triangular matrix T. \n
  * @param[in] LDT
           LDT is INTEGER \n
           The leading dimension of the array T.  LDT >= NB. \n
  * @param[out] Y
           Y is REAL array, dimension (LDY,NB) \n
           The n-by-nb matrix Y. \n
  * @param[in] LDY
           LDY is INTEGER \n
           The leading dimension of the array Y. LDY >= N.   \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lahrd(integer *n, integer *k, integer *nb, T *a, integer *lda, T *tau, T *t, integer *ldt, T *y, integer *ldy)
{
  return lahrd(n, k, nb, a, lda, tau, t, ldt, y, ldy);
}

/*! @brief LAIC1 applies one step of incremental condition estimation

 * @details
 * \b Purpose:
    \verbatim 
    LAIC1 applies one step of incremental condition estimation in
    its simplest version:

    Let x, twonorm(x) = 1, be an approximate singular vector of an j-by-j
    lower triangular matrix L, such that
             twonorm(L*x) = sest
    Then SLAIC1 computes sestpr, s, c such that
    the vector
                    [ s*x ]
             xhat = [  c  ]
    is an approximate singular vector of
                    [ L      0  ]
             Lhat = [ w**T gamma ]
    in the sense that
             twonorm(Lhat*xhat) = sestpr.

    Depending on JOB, an estimate for the largest or smallest singular
    value is computed.

    Note that [s c]**T and sestpr**2 is an eigenpair of the system

        diag(sest*sest, 0) + [alpha  gamma] * [ alpha ]
                                              [ gamma ]

    where  alpha =  x**T*w.
    \endverbatim 

 * @param[in] JOB
          JOB is INTEGER \n
          = 1: an estimate for the largest singular value is computed. \n
          = 2: an estimate for the smallest singular value is computed. \n
 * @param[in] J
          J is INTEGER \n
          Length of X and W \n
 * @param[in] X
          X is REAL array, dimension (J) \n
          The j-vector x. \n
 * @param[in] SEST
          SEST is REAL \n
          Estimated singular value of j by j matrix L \n
 * @param[in] W
          W is REAL array, dimension (J) \n
          The j-vector w. \n
 * @param[in] GAMMA
          GAMMA is REAL \n
          The diagonal element gamma. \n
 * @param[out] SESTPR
          SESTPR is REAL \n
          Estimated singular value of (j+1) by (j+1) matrix Lhat. \n
 * @param[out] S
          S is REAL \n
          Sine needed in forming xhat. \n
 * @param[out] C
          C is REAL \n
          Cosine needed in forming xhat. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer laic1(integer *job, integer *j, T *x, T *sest, T *w, T *gamma, T *sestpr, T *s, T *c__)
{
  return laic1(job, j, x, sest, w, gamma, sestpr, s, c__);
}
template< typename T, typename Ta >
integer laic1(integer *job, integer *j, T *x, Ta *sest, T *w, T *gamma, Ta *sestpr, T *s, T *c__)
{
  return laic1(job, j, x, sest, w, gamma, sestpr, s, c__);
}

/*! @brief LAISNAN tests input for NaN by comparing two arguments for inequality

 * @details
 * \b Purpose:
    \verbatim 
    This routine is not for general use.  It exists solely to avoid
    over-optimization in ISNAN.

    LAISNAN checks for NaNs by comparing its two arguments for
    inequality.  NaN is the only floating-point value where NaN != NaN
      returns .TRUE.  To check for NaNs, pass the same variable as both
    arguments.

    A compiler must assume that the two arguments are
    not the same variable, and the test will not be optimized away.
    Interprocedural or whole-program optimization may delete this
    test.  The ISNAN functions will be replaced by the correct
    Fortran 03 intrinsic once the intrinsic is widely available.
    \endverbatim 

 * @param[in] SIN1
          SIN1 is REAL \n
 * @param[in] SIN2
          SIN2 is REAL \n
          Two numbers to compare for inequality. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
logical laisnan(real *sin1, real *sin2)
{
  return laisnan(sin1, sin2);
}

/*! @brief LALN2 solves a 1-by-1 or 2-by-2 linear system of equations of the specified form

 * @details
 * \b Purpose:
    \verbatim 
    LALN2 solves a system of the form  (ca A - w D) X = s B
    or (ca A**T - w D) X = s B   with possible scaling ("s") and
    perturbation of A.  (A**T means A-transpose.)

    A is an NA x NA real matrix, ca is a real scalar, D is an NA x NA
    real diagonal matrix, w is a real or complex value, and X and B are
    NA x 1 matrices -- real if w is real, complex if w is complex.  NA
    may be 1 or 2.

    If w is complex, X and B are represented as NA x 2 matrices,
    the first column of each being the real part and the second
    being the imaginary part.

    "s" is a scaling factor (<= 1), computed by SLALN2, which is
    so chosen that X can be computed without overflow.  X is further
    scaled if necessary to assure that norm(ca A - w D)*norm(X) is less
    than overflow.

    If both singular values of (ca A - w D) are less than SMIN,
    SMIN*identity will be used instead of (ca A - w D).  If only one
    singular value is less than SMIN, one element of (ca A - w D) will be
    perturbed enough to make the smallest singular value roughly SMIN.
    If both singular values are at least SMIN, (ca A - w D) will not be
    perturbed.  In any case, the perturbation will be at most some small
    multiple of max(SMIN, ulp*norm(ca A - w D)).  The singular values
    are computed by infinity-norm approximations, and thus will only be
    correct to a factor of 2 or so.

    Note: all input quantities are assumed to be smaller than overflow
    by a reasonable factor.  (See BIGNUM.)
    \endverbatim 

 * @param[in] LTRANS
          LTRANS is LOGICAL \n
          =.TRUE.:  A-transpose will be used. \n
          =.FALSE.: A will be used (not transposed.) \n
 * @param[in] NA
          NA is INTEGER \n
          The size of the matrix A.  It may (only) be 1 or 2. \n
 * @param[in] NW
          NW is INTEGER \n
          1 if "w" is real, 2 if "w" is complex.  It may only be 1
          or 2. \n
 * @param[in] SMIN
          SMIN is REAL \n
          The desired lower bound on the singular values of A.  This
          should be a safe distance away from underflow or overflow,
          say, between (underflow/machine precision) and  (machine
          precision * overflow).  (See BIGNUM and ULP.) \n
 * @param[in] CA
          CA is REAL \n
          The coefficient c, which A is multiplied by. \n
 * @param[in] A
          A is REAL array, dimension (LDA,NA) \n
          The NA x NA matrix A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of A.  It must be at least NA. \n
 * @param[in] D1
          D1 is REAL \n
          The 1,1 element in the diagonal matrix D. \n
 * @param[in] D2
          D2 is REAL \n
          The 2,2 element in the diagonal matrix D.  Not used if NA=1. \n
 * @param[in] B
          B is REAL array, dimension (LDB,NW) \n
          The NA x NW matrix B (right-hand side).  If NW=2 ("w" is
          complex), column 1 contains the real part of B and column 2
          contains the imaginary part. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of B.  It must be at least NA. \n
 * @param[in] WR
          WR is REAL \n
          The real part of the scalar "w". \n
 * @param[in] WI
          WI is REAL \n
          The imaginary part of the scalar "w".  Not used if NW=1. \n
 * @param[out] X
          X is REAL array, dimension (LDX,NW) \n
          The NA x NW matrix X (unknowns), as computed by SLALN2.
          If NW=2 ("w" is complex), on exit, column 1 will contain
          the real part of X and column 2 will contain the imaginary
          part. \n
 * @param[in] LDX
          LDX is INTEGER \n
          The leading dimension of X.  It must be at least NA. \n
 * @param[out] SCALE
          SCALE is REAL \n
          The scale factor that B must be multiplied by to insure
          that overflow does not occur when computing X.  Thus,
          (ca A - w D) X  will be SCALE*B, not B (ignoring
          perturbations of A.)  It will be at most 1. \n
 * @param[out] XNORM
          XNORM is REAL \n
          The infinity-norm of X, when X is regarded as an NA x NW
          real matrix. \n
 * @param[out] INFO
          INFO is INTEGER \n
          An error flag.  It will be set to zero if no error occurs,
          a negative number if an argument is in error, or a positive
          number if  ca A - w D  had to be perturbed.
          The possible values are: \n
          = 0: No error occurred, and (ca A - w D) did not have to be
                 perturbed. \n
          = 1: (ca A - w D) had to be perturbed to make its smallest
               (or only) singular value greater than SMIN. \n
          NOTE: In the interests of speed, this routine does not
                check the inputs for errors. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer laln2(logical *ltrans, integer *na, integer *nw, float * smin, float *ca, float *a, integer *lda, float *d1, float *d2, float *b, integer *ldb, float *wr, float *wi, float *x, integer *ldx, float *scale, float *xnorm, integer *info)
{
  return laln2(ltrans, na, nw, smin, ca, a, lda, d1, d2, b, ldb, wr, wi, x, ldx, scale, xnorm, info);
}

/*! @brief LALS0 applies back multiplying factors in solving the least squares problem \n
     using divide and conquer SVD approach. Used by sgelsd
 * @details
 * \b Purpose:
    \verbatim 
    LALS0 applies back the multiplying factors of either the left or the
    right singular vector matrix of a diagonal matrix appended by a row
    to the right hand side matrix B in solving the least squares problem
    using the divide-and-conquer SVD approach.

    For the left singular vector matrix, three types of orthogonal
    matrices are involved:

    (1L) Givens rotations: the number of such rotations is GIVPTR; the
         pairs of columns/rows they were applied to are stored in GIVCOL;
         and the C- and S-values of these rotations are stored in GIVNUM.

    (2L) Permutation. The (NL+1)-st row of B is to be moved to the first
         row, and for J=2:N, PERM(J)-th row of B is to be moved to the
         J-th row.

    (3L) The left singular vector matrix of the remaining matrix.

    For the right singular vector matrix, four types of orthogonal
    matrices are involved:

    (1R) The right singular vector matrix of the remaining matrix.

    (2R) If SQRE = 1, one extra Givens rotation to generate the right
         null space.

    (3R) The inverse transformation of (2L).

    (4R) The inverse transformation of (1L).
    \endverbatim  

 * @param[in] ICOMPQ
          ICOMPQ is INTEGER \n
          Specifies whether singular vectors are to be computed in
          factored form: \n
          = 0: Left singular vector matrix. \n
          = 1: Right singular vector matrix. \n
 * @param[in] NL
          NL is INTEGER \n
          The row dimension of the upper block. NL >= 1. \n
 * @param[in] NR
          NR is INTEGER \n
          The row dimension of the lower block. NR >= 1. \n
 * @param[in] SQRE
          SQRE is INTEGER \n
          = 0: the lower block is an NR-by-NR square matrix. \n
          = 1: the lower block is an NR-by-(NR+1) rectangular matrix.
 \n
          The bidiagonal matrix has row dimension N = NL + NR + 1,
          and column dimension M = N + SQRE. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of columns of B and BX. NRHS must be at least 1. \n
 * @param[in,out] B
          B is REAL array, dimension (LDB, NRHS) \n
          On input, B contains the right hand sides of the least
          squares problem in rows 1 through M. On output, B contains
          the solution X in rows 1 through N. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of B. LDB must be at least
          max(1,MAX(M, N)). \n
 * @param[out] BX
          BX is REAL array, dimension (LDBX, NRHS) \n
 * @param[in] LDBX
          LDBX is INTEGER \n
          The leading dimension of BX. \n
 * @param[in] PERM
          PERM is INTEGER array, dimension (N) \n
          The permutations (from deflation and sorting) applied
          to the two blocks. \n
 * @param[in] GIVPTR
          GIVPTR is INTEGER \n
          The number of Givens rotations which took place in this
          subproblem. \n
 * @param[in] GIVCOL
          GIVCOL is INTEGER array, dimension (LDGCOL, 2) \n
          Each pair of numbers indicates a pair of rows/columns
          involved in a Givens rotation. \n
 * @param[in] LDGCOL
          LDGCOL is INTEGER \n
          The leading dimension of GIVCOL, must be at least N. \n
 * @param[in] GIVNUM
          GIVNUM is REAL array, dimension (LDGNUM, 2) \n
          Each number indicates the C or S value used in the
          corresponding Givens rotation. \n
 * @param[in] LDGNUM
          LDGNUM is INTEGER \n
          The leading dimension of arrays DIFR, POLES and
          GIVNUM, must be at least K. \n
 * @param[in] POLES
          POLES is REAL array, dimension (LDGNUM, 2) \n
          On entry, POLES(1:K, 1) contains the new singular
          values obtained from solving the secular equation, and
          POLES(1:K, 2) is an array containing the poles in the secular
          equation. \n
 * @param[in] DIFL
          DIFL is REAL array, dimension (K). \n
          On entry, DIFL(I) is the distance between I-th updated
          (undeflated) singular value and the I-th (undeflated) old
          singular value. \n
 * @param[in] DIFR
          DIFR is REAL array, dimension (LDGNUM, 2). \n
          On entry, DIFR(I, 1) contains the distances between I-th
          updated (undeflated) singular value and the I+1-th
          (undeflated) old singular value. And DIFR(I, 2) is the
          normalizing factor for the I-th right singular vector. \n
 * @param[in] Z
          Z is REAL array, dimension (K) \n
          Contain the components of the deflation-adjusted updating row
          vector. \n
 * @param[in] K
          K is INTEGER \n
          Contains the dimension of the non-deflated matrix,
          This is the order of the related secular equation. 1 <= K <=N. \n
 * @param[in] C
          C is REAL \n
          C contains garbage if SQRE =0 and the C-value of a Givens
          rotation related to the right null space if SQRE = 1. \n
 * @param[in] S
          S is REAL \n
          S contains garbage if SQRE =0 and the S-value of a Givens
          rotation related to the right null space if SQRE = 1. \n
 * @param[out] WORK
          WORK is REAL array, dimension (K) \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, the i-th argument had an illegal value.  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lals0(integer *icompq, integer *nl, integer *nr, integer *sqre, integer *nrhs, T *b, integer *ldb, T *bx, integer *ldbx, integer *perm, integer *givptr, integer *givcol, integer *ldgcol, T *givnum, integer *ldgnum, T *poles, T * difl, T *difr, T *z, integer *k, T *c, T *s, T * work, integer *info)
{
  return lals0(icompq, nl, nr, sqre, nrhs, b, ldb, bx, ldbx, perm, givptr, givcol, ldgcol, givnum, ldgnum, poles, difl, difr, z, k, c, s, work, info);
}
template< typename T, typename Ta >
integer lals0(integer *icompq, integer *nl, integer *nr, integer *sqre, integer *nrhs, T *b, integer *ldb, T *bx, integer *ldbx, integer *perm, integer *givptr, integer *givcol, integer *ldgcol, Ta *givnum, integer *ldgnum, Ta *poles, Ta *difl, Ta *difr, Ta *z, integer *k, Ta *c, Ta *s, Ta * work, integer *info)
{
  return lals0(icompq, nl, nr, sqre, nrhs, b, ldb, bx, ldbx, perm, givptr, givcol, ldgcol, givnum, ldgnum, poles, difl, difr, z, k, c, s, work, info);
}

/*! @brief LALSA computes the SVD of the coefficient matrix in compact form. Used by sgelsd

 * @details
 * \b Purpose:
    \verbatim 
    LALSA is an itermediate step in solving the least squares problem
    by computing the SVD of the coefficient matrix in compact form (The
    singular vectors are computed as products of simple orthorgonal
    matrices.).

    If ICOMPQ = 0, SLALSA applies the inverse of the left singular vector
    matrix of an upper bidiagonal matrix to the right hand side; and if
    ICOMPQ = 1, SLALSA applies the right singular vector matrix to the
    right hand side. The singular vector matrices were generated in
    compact form by SLALSA.
    \endverbatim 

 * @param[in] ICOMPQ
          ICOMPQ is INTEGER \n
          Specifies whether the left or the right singular vector
          matrix is involved. \n
          = 0: Left singular vector matrix \n
          = 1: Right singular vector matrix \n
 * @param[in] SMLSIZ
          SMLSIZ is INTEGER \n
          The maximum size of the subproblems at the bottom of the
          computation tree. \n
 * @param[in] N
          N is INTEGER \n
          The row and column dimensions of the upper bidiagonal matrix. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of columns of B and BX. NRHS must be at least 1. \n
 * @param[in,out] B
          B is REAL array, dimension (LDB, NRHS) \n
          On input, B contains the right hand sides of the least
          squares problem in rows 1 through M. \n
          On output, B contains the solution X in rows 1 through N. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of B in the calling subprogram.
          LDB must be at least max(1,MAX(M, N)). \n
 * @param[out] BX
          BX is REAL array, dimension (LDBX, NRHS) \n
          On exit, the result of applying the left or right singular
          vector matrix to B. \n
 * @param[in] LDBX
          LDBX is INTEGER \n
          The leading dimension of BX. \n
 * @param[in] U
          U is REAL array, dimension (LDU, SMLSIZ). \n
          On entry, U contains the left singular vector matrices of all
          subproblems at the bottom level. \n
 * @param[in] LDU
          LDU is INTEGER, LDU = > N. \n
         The leading dimension of arrays U, VT, DIFL, DIFR,
         POLES, GIVNUM, and Z. \n
 * @param[in] VT
          VT is REAL array, dimension (LDU, SMLSIZ+1). \n
         On entry, VT**T contains the right singular vector matrices of
         all subproblems at the bottom level. \n
 * @param[in] K
          K is INTEGER array, dimension (N). \n
 * @param[in] DIFL
          DIFL is REAL array, dimension (LDU, NLVL). \n
         where NLVL = INT(log_2 (N/(SMLSIZ+1))) + 1. \n
 * @param[in] DIFR
          DIFR is REAL array, dimension (LDU, 2 * NLVL). \n
          On entry, DIFL(*, I) and DIFR(*, 2 * I -1) record
          distances between singular values on the I-th level and
          singular values on the (I -1)-th level, and DIFR(*, 2 * I)
          record the normalizing factors of the right singular vectors
          matrices of subproblems on I-th level. \n
 * @param[in] Z
          Z is REAL array, dimension (LDU, NLVL). \n
          On entry, Z(1, I) contains the components of the deflation-
          adjusted updating row vector for subproblems on the I-th
          level. \n
 * @param[in] POLES
          POLES is REAL array, dimension (LDU, 2 * NLVL). \n
          On entry, POLES(*, 2 * I -1: 2 * I) contains the new and old
          singular values involved in the secular equations on the I-th
          level. \n
 * @param[in] GIVPTR
          GIVPTR is INTEGER array, dimension (N). \n
          On entry, GIVPTR(I) records the number of Givens
          rotations performed on the I-th problem on the computation
          tree. \n
 * @param[in] GIVCOL
          GIVCOL is INTEGER array, dimension (LDGCOL, 2 * NLVL). \n
          On entry, for each I, GIVCOL(*, 2 * I - 1: 2 * I) records the
          locations of Givens rotations performed on the I-th level on
          the computation tree. \n
 * @param[in] LDGCOL
          LDGCOL is INTEGER, LDGCOL = > N. \n
          The leading dimension of arrays GIVCOL and PERM. \n
 * @param[in] PERM
          PERM is INTEGER array, dimension (LDGCOL, NLVL). \n
          On entry, PERM(*, I) records permutations done on the I-th
          level of the computation tree. \n
 * @param[in] GIVNUM
          GIVNUM is REAL array, dimension (LDU, 2 * NLVL). \n
          On entry, GIVNUM(*, 2 *I -1 : 2 * I) records the C- and S-
          values of Givens rotations performed on the I-th level on the
          computation tree. \n
 * @param[in] C
          C is REAL array, dimension (N). \n
          On entry, if the I-th subproblem is not square,
          C(I) contains the C-value of a Givens rotation related to
          the right null space of the I-th subproblem. \n
 * @param[in] S
          S is REAL array, dimension (N). \n
          On entry, if the I-th subproblem is not square,
          S(I) contains the S-value of a Givens rotation related to
          the right null space of the I-th subproblem. \n
 * @param[out] WORK
          WORK is REAL array, dimension (N) \n
 * @param[out] IWORK
          IWORK is INTEGER array, dimension (3*N) \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lalsa(integer *icompq, integer *smlsiz, integer *n, integer *nrhs, T *b, integer *ldb, T *bx, integer *ldbx, T * u, integer *ldu, T *vt, integer *k, T *difl, T *difr, T * z, T *poles, integer *givptr, integer *givcol, integer *ldgcol, integer *perm, T *givnum, T *c, T *s, T *work, integer * iwork, integer *info)
{
  return lalsa(icompq, smlsiz, n, nrhs, b, ldb, bx, ldbx, u, ldu, vt, k, difl, difr, z, poles, givptr, givcol, ldgcol, perm, givnum, c, s, work, iwork, info);
}
template< typename T, typename Ta >
integer lalsa(integer *icompq, integer *smlsiz, integer *n, integer *nrhs, T *b, integer *ldb, T *bx, integer *ldbx, Ta * u, integer *ldu, Ta *vt, integer *k, Ta *difl, Ta *difr, Ta * z, Ta *poles, integer *givptr, integer *givcol, integer *ldgcol, integer *perm, Ta *givnum, Ta *c, Ta *s, Ta *work, integer * iwork, integer *info)
{
  return lalsa(icompq, smlsiz, n, nrhs, b, ldb, bx, ldbx, u, ldu, vt, k, difl, difr, z, poles, givptr, givcol, ldgcol, perm, givnum, c, s, work, iwork, info);
}

/*! @brief LALSD uses the singular value decomposition of A to solve the least squares problem

 * @details
 * \b Purpose:
    \verbatim 
    LALSD uses the singular value decomposition of A to solve the least
    squares problem of finding X to minimize the Euclidean norm of each
    column of A*X-B, where A is N-by-N upper bidiagonal, and X and B
    are N-by-NRHS. The solution X overwrites B.

    The singular values of A smaller than RCOND times the largest
    singular value are treated as zero in solving the least squares
    problem; in this case a minimum norm solution is   returned.
    The actual singular values are   returned in D in ascending order.

    This code makes very mild assumptions about floating point
    arithmetic. It will work on machines with a guard digit in
    add/subtract, or on those binary machines without guard digits
    which subtract like the Cray XMP, Cray YMP, Cray C 90, or Cray 2.
    It could conceivably fail on hexadecimal or decimal machines
    without guard digits, but we know of none.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U': D and E define an upper bidiagonal matrix. \n
          = 'L': D and E define a  lower bidiagonal matrix. \n
 * @param[in] SMLSIZ
          SMLSIZ is INTEGER \n
          The maximum size of the subproblems at the bottom of the
          computation tree. \n
 * @param[in] N
          N is INTEGER \n
          The dimension of the  bidiagonal matrix.  N >= 0. \n
 * @param[in] NRHS
          NRHS is INTEGER \n
          The number of columns of B. NRHS must be at least 1. \n
 * @param[in,out] D
          D is REAL array, dimension (N) \n
          On entry D contains the main diagonal of the bidiagonal
          matrix. On exit, if INFO = 0, D contains its singular values. \n
 * @param[in,out] E
          E is REAL array, dimension (N-1) \n
          Contains the super-diagonal entries of the bidiagonal matrix.
          On exit, E has been destroyed. \n
 * @param[in,out] B
          B is REAL array, dimension (LDB,NRHS) \n
          On input, B contains the right hand sides of the least
          squares problem. On output, B contains the solution X. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of B in the calling subprogram.
          LDB must be at least max(1,N). \n
 * @param[in] RCOND
          RCOND is REAL \n
          The singular values of A less than or equal to RCOND times
          the largest singular value are treated as zero in solving
          the least squares problem. If RCOND is negative,
          machine precision is used instead. \n
          For example, if diag(S)*X=B were the least squares problem,
          where diag(S) is a diagonal matrix of singular values, the
          solution would be X(i) = B(i) / S(i) if S(i) is greater than
          RCOND*max(S), and X(i) = 0 if S(i) is less than or equal to
          RCOND*max(S). \n
 * @param[out] RANK
          RANK is INTEGER \n
          The number of singular values of A greater than RCOND times
          the largest singular value. \n
 * @param[out] WORK
          WORK is REAL array, dimension at least \n
          (9*N + 2*N*SMLSIZ + 8*N*NLVL + N*NRHS + (SMLSIZ+1)**2), \n
          where NLVL = max(0, INT(log_2 (N/(SMLSIZ+1))) + 1). \n
 * @param[out] IWORK
          IWORK is INTEGER array, dimension at least
          (3*N*NLVL + 11*N) \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n
          > 0:  The algorithm failed to compute a singular value while
                working on the submatrix lying in rows and columns
                INFO/(N+1) through MOD(INFO,N+1). \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lalsd(char *uplo, integer *smlsiz, integer *n, integer *nrhs, T *d, T *e, T *b, integer *ldb, T *rcond, integer *rank, T *work, integer *iwork, integer *info)
{
  return lalsd(uplo, smlsiz, n, nrhs, d, e, b, ldb, rcond, rank, work, iwork, info);
}
template< typename T, typename Ta >
integer lalsd(char *uplo, integer *smlsiz, integer *n, integer *nrhs, Ta *d, Ta *e, T *b, integer *ldb, Ta *rcond, integer *rank, T *work, Ta* rwork, integer *iwork, integer *info)
{
  return lalsd(uplo, smlsiz, n, nrhs, d, e, b, ldb, rcond, rank, work, rwork, iwork, info);
}

/*! @brief LAMRG creates a permutation list to merge the entries of two independently sorted sets into a single set sorted in ascending order

 * @details
 * \b Purpose:
    \verbatim 
    LAMRG will create a permutation list which will merge the elements
    of A (which is composed of two independently sorted sets) into a
    single set which is sorted in ascending order.
    \endverbatim  

 * @param[in] N1
          N1 is INTEGER \n
 * @param[in] N2
          N2 is INTEGER \n
          These arguments contain the respective lengths of the two
          sorted lists to be merged. \n
 * @param[in] A
          A is REAL array, dimension (N1+N2) \n
          The first N1 elements of A contain a list of numbers which
          are sorted in either ascending or descending order.  Likewise
          for the final N2 elements. \n
 * @param[in] STRD1
          STRD1 is INTEGER \n
 * @param[in] STRD2
          STRD2 is INTEGER \n
          These are the strides to be taken through the array A.
          Allowable strides are 1 and -1.  They indicate whether a
          subset of A is sorted in ascending (STRDx = 1) or descending
          (STRDx = -1) order. \n
 * @param[out] INDEX
          INDEX is INTEGER array, dimension (N1+N2) \n
          On exit this array will contain a permutation such that
          if B(I) = A(INDEX(I)) for I=1,N1+N2, then B will be
          sorted in ascending order. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lamrg(integer *n1, integer *n2, T *a, integer * strd1, integer *strd2, integer *index)
{
  return lamrg(n1, n2, a, strd1, strd2, index);
}

/*! @brief LAMSWLQ overwrites the general real M-by-N matrix C

 * @details
 * \b Purpose:
    \verbatim 
    LAMSWLQ overwrites the general real M-by-N matrix C with

                    SIDE = 'L'     SIDE = 'R'
    TRANS = 'N':      Q * C          C * Q
    TRANS = 'T':      Q**T * C       C * Q**T
    where Q is a real orthogonal matrix defined as the product of blocked
    elementary reflectors computed by short wide LQ
    factorization (LASWLQ)
    \endverbatim  

  * @param[in] SIDE
           SIDE is CHARACTER*1 \n
           = 'L': apply Q or Q**T from the Left; \n
           = 'R': apply Q or Q**T from the Right. \n
  * @param[in] TRANS
           TRANS is CHARACTER*1 \n
           = 'N':  No transpose, apply Q; \n
           = 'T':  Transpose, apply Q**T. \n
  * @param[in] M
           M is INTEGER \n
           The number of rows of the matrix C.  M >=0. \n
  * @param[in] N
           N is INTEGER \n
           The number of columns of the matrix C. N >= M. \n
  * @param[in] K
           K is INTEGER \n
           The number of elementary reflectors whose product defines
           the matrix Q.
           M >= K >= 0; \n
  * @param[in] MB
           MB is INTEGER \n
           The row block size to be used in the blocked QR.
           M >= MB >= 1 \n
  * @param[in] NB
           NB is INTEGER \n
           The column block size to be used in the blocked QR.
           NB > M. \n
  * @param[in] NB
           NB is INTEGER \n
           The block size to be used in the blocked QR.
                 MB > M. \n
  * @param[in] A
           A is REAL array, dimension \n
                                (LDA,M) if SIDE = 'L', \n
                                (LDA,N) if SIDE = 'R' \n
           The i-th row must contain the vector which defines the blocked
           elementary reflector H(i), for i = 1,2,...,k, as   returned by
           SLASWLQ in the first k rows of its array argument A. \n
  * @param[in] LDA
           LDA is INTEGER \n
           The leading dimension of the array A. \n
           If SIDE = 'L', LDA >= max(1,M); \n
           if SIDE = 'R', LDA >= max(1,N). \n
  * @param[in] T
           T is REAL array, dimension \n
           (M * Number of blocks(CEIL(N-K/NB-K)), \n
           The blocked upper triangular block reflectors stored in compact form
           as a sequence of upper triangular blocks.  See below
           for further details. \n
  * @param[in] LDT
           LDT is INTEGER \n
           The leading dimension of the array T.  LDT >= MB. \n
  * @param[in,out] C
           C is REAL array, dimension (LDC,N) \n
           On entry, the M-by-N matrix C.
           On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q. \n
  * @param[in] LDC
           LDC is INTEGER \n
           The leading dimension of the array C. LDC >= max(1,M). \n
  * @param[out] WORK
          (workspace) REAL array, dimension (MAX(1,LWORK)) \n
  * @param[in] LWORK
           LWORK is INTEGER \n
           The dimension of the array WORK. \n
           If SIDE = 'L', LWORK >= max(1,NB) * MB; \n
           if SIDE = 'R', LWORK >= max(1,M) * MB. \n
           If LWORK = -1, then a workspace query is assumed; the routine
           only calculates the optimal size of the WORK array,   returns
           this value as the first entry of the WORK array, and no error
           message related to LWORK is issued by XERBLA. \n
  * @param[out] INFO
           INFO is INTEGER \n
           = 0:  successful exit \n
           < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lamswlq(char *side, char *trans, integer *m, integer * n, integer *k, integer *mb, integer *nb, T *a, integer *lda, T * t, integer *ldt, T *c, integer *ldc, T *work, integer *lwork, integer *info)
{
  return lamswlq(side, trans, m, n, k, mb, nb, a, lda, t, ldt, c, ldc, work, lwork, info);
}

/*! @brief LAMTSQR overwrites the general real M-by-N matrix C

 * @details
 * \b Purpose:
    \verbatim 
     LAMTSQR overwrites the general real M-by-N matrix C with

                    SIDE = 'L'     SIDE = 'R'
    TRANS = 'N':      Q * C          C * Q
    TRANS = 'T':      Q**T * C       C * Q**T
    where Q is a real orthogonal matrix defined as the product
    of blocked elementary reflectors computed by tall skinny
    QR factorization (DLATSQR)
    \endverbatim  

  * @param[in] SIDE
           SIDE is CHARACTER*1 \n
           = 'L': apply Q or Q**T from the Left; \n
           = 'R': apply Q or Q**T from the Right. \n
  * @param[in] TRANS
           TRANS is CHARACTER*1 \n
           = 'N':  No transpose, apply Q; \n
           = 'T':  Transpose, apply Q**T. \n
  * @param[in] M
           M is INTEGER \n
           The number of rows of the matrix A.  M >=0. \n
  * @param[in] N
           N is INTEGER \n
           The number of columns of the matrix C. M >= N >= 0. \n
  * @param[in] K
           K is INTEGER \n
           The number of elementary reflectors whose product defines
           the matrix Q.
           N >= K >= 0; \n
  * @param[in] MB
           MB is INTEGER \n
           The block size to be used in the blocked QR.
           MB > N. (must be the same as DLATSQR) \n
  * @param[in] NB
           NB is INTEGER \n
           The column block size to be used in the blocked QR.
           N >= NB >= 1. \n
  * @param[in] A
           A is REAL array, dimension (LDA,K) \n
           The i-th column must contain the vector which defines the
           blockedelementary reflector H(i), for i = 1,2,...,k, as
           returned by DLATSQR in the first k columns of
           its array argument A. \n
  * @param[in] LDA
           LDA is INTEGER \n
           The leading dimension of the array A. \n
           If SIDE = 'L', LDA >= max(1,M); \n
           if SIDE = 'R', LDA >= max(1,N). \n
  * @param[in] T
           T is REAL array, dimension \n
           (N * Number of blocks(CEIL(M-K/MB-K)), \n
           The blocked upper triangular block reflectors stored in compact form
           as a sequence of upper triangular blocks.  See below
           for further details. \n
  * @param[in] LDT
           LDT is INTEGER \n
           The leading dimension of the array T.  LDT >= NB. \n
  * @param[in,out] C
           C is REAL array, dimension (LDC,N) \n
           On entry, the M-by-N matrix C.
           On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q. \n
  * @param[in] LDC
           LDC is INTEGER \n
           The leading dimension of the array C. LDC >= max(1,M). \n
  * @param[out] WORK
          (workspace) REAL array, dimension (MAX(1,LWORK)) \n
  * @param[in] LWORK
           LWORK is INTEGER \n
           The dimension of the array WORK. \n
  \n
           If SIDE = 'L', LWORK >= max(1,N)*NB; \n
           if SIDE = 'R', LWORK >= max(1,MB)*NB. \n
           If LWORK = -1, then a workspace query is assumed; the routine
           only calculates the optimal size of the WORK array,   returns
           this value as the first entry of the WORK array, and no error
           message related to LWORK is issued by XERBLA. \n
  * @param[out] INFO
           INFO is INTEGER \n
           = 0:  successful exit \n
           < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lamtsqr(char *side, char *trans, integer *m, integer * n, integer *k, integer *mb, integer *nb, T *a, integer *lda, T * t, integer *ldt, T *c, integer *ldc, T *work, integer *lwork, integer *info)
{
  return lamtsqr(side, trans, m, n, k, mb, nb, a, lda, t, ldt, c, ldc, work, lwork, info);
}

/*! @brief LANEG computes the Sturm count

 * @details
 * \b Purpose:
    \verbatim 
    LANEG computes the Sturm count, the number of negative pivots
    encountered while factoring tridiagonal T - sigma I = L D L^T.
    This implementation works directly on the factors without forming
    the tridiagonal matrix T.  The Sturm count is also the number of
    eigenvalues of T less than sigma.

    This routine is called from SLARRB.

    The current routine does not use the PIVMIN parameter but rather
    requires IEEE-754 propagation of Infinities and NaNs.  This
    routine also has no input range restrictions but does require
    default exception handling such that x/0 produces Inf when x is
    non-zero, and Inf/Inf produces NaN.  For more information, see:

      Marques, Riedy, and Voemel, "Benefits of IEEE-754 Features in
      Modern Symmetric Tridiagonal Eigensolvers," SIAM Journal on
      Scientific Computing, v28, n5, 2006.  DOI 10.1137/050641624
      (Tech report version in LAWN 172 with the same title.)
    \endverbatim 

 * @param[in] N
          N is INTEGER \n
          The order of the matrix. \n
 * @param[in] D
          D is REAL array, dimension (N) \n
          The N diagonal elements of the diagonal matrix D. \n
 * @param[in] LLD
          LLD is REAL array, dimension (N-1) \n
          The (N-1) elements L(i)*L(i)*D(i). \n
 * @param[in] SIGMA
          SIGMA is REAL \n
          Shift amount in T - sigma I = L D L^T. \n
 * @param[in] PIVMIN
          PIVMIN is REAL \n
          The minimum pivot in the Sturm sequence.  May be used
          when zero pivots are encountered on non-IEEE-754
          architectures. \n
 * @param[in] R
          R is INTEGER \n
          The twist index for the twisted factorization that is used
          for the negcount. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer laneg(integer *n, T *d, T *lld, T *sigma, T *pivmin, integer *r__)
{
  return laneg(n, d, lld, sigma, pivmin, r__);
}

/*! @brief LANGB   returns the value of the 1-norm, Frobenius norm, infinity-norm, \n
     or the largest absolute value of any element of general band matrix
 * @details
 * \b Purpose:
    \verbatim 
    LANGB    returns the value of the one norm, or the Frobenius norm, or
    the  infinity norm, or the element of  largest absolute value  of an
    n by n band matrix  A, with kl sub-diagonals and ku super-diagonals.
    

       SLANGB = (max(abs(A(i,j))), NORM = 'M' or 'm'
                (
                (norm1(A),        NORM = '1', 'O' or 'o'
                (
                (normI(A),        NORM = 'I' or 'i'
                (
                (normF(A),        NORM = 'F', 'f', 'E' or 'e'

    where  norm1  denotes the  one norm of a matrix (maximum column sum),
    normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
    normF  denotes the  Frobenius norm of a matrix (square root of sum of
    squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
    \endverbatim  

 * @param[in] NORM
          NORM is CHARACTER*1 \n
          Specifies the value to be   returned in SLANGB as described
          above. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0.  When N = 0, SLANGB is
          set to zero. \n
 * @param[in] KL
          KL is INTEGER \n
          The number of sub-diagonals of the matrix A.  KL >= 0. \n
 * @param[in] KU
          KU is INTEGER \n
          The number of super-diagonals of the matrix A.  KU >= 0. \n
 * @param[in] AB
          AB is REAL array, dimension (LDAB,N) \n
          The band matrix A, stored in rows 1 to KL+KU+1.  The j-th
          column of A is stored in the j-th column of the array AB as
          follows: \n
          AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(n,j+kl). \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          The leading dimension of the array AB.  LDAB >= KL+KU+1. \n
 * @param[out] WORK
          WORK is REAL array, dimension (MAX(1,LWORK)), \n
          where LWORK >= N when NORM = 'I'; otherwise, WORK is not
          referenced.   \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
T langb(char *norm, integer *n, integer *kl, integer *ku, T *ab, integer *ldab, T *work)
{
  return langb(norm, n, kl, ku, ab, ldab, work);
}
template< typename T, typename Ta >
Ta langb(char *norm, integer *n, integer *kl, integer *ku, T *ab, integer *ldab, Ta *work)
{
  return langb(norm, n, kl, ku, ab, ldab, work);
}

/*! @brief LANGT   returns the value of the 1-norm, Frobenius norm, infinity-norm, \n
     or the largest absolute value of any element of a general tridiagonal matrix
 * @details
 * \b Purpose:
    \verbatim 
    LANGT    returns the value of the one norm, or the Frobenius norm, or
    the  infinity norm, or the  element of  largest absolute value  of a
    real tridiagonal matrix A.

       SLANGT = (max(abs(A(i,j))), NORM = 'M' or 'm'
                (
                (norm1(A),        NORM = '1', 'O' or 'o'
                (
                (normI(A),        NORM = 'I' or 'i'
                (
                (normF(A),        NORM = 'F', 'f', 'E' or 'e'

    where  norm1  denotes the  one norm of a matrix (maximum column sum),
    normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
    normF  denotes the  Frobenius norm of a matrix (square root of sum of
    squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
    \endverbatim 

 * @param[in] NORM
          NORM is CHARACTER*1 \n
          Specifies the value to be   returned in SLANGT as described
          above. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0.  When N = 0, SLANGT is
          set to zero. \n
 * @param[in] DL
          DL is REAL array, dimension (N-1) \n
          The (n-1) sub-diagonal elements of A. \n
 * @param[in] D
          D is REAL array, dimension (N) \n
          The diagonal elements of A. \n
 * @param[in] DU
          DU is REAL array, dimension (N-1) \n
          The (n-1) super-diagonal elements of A. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
T langt(char *norm, integer *n, T *dl, T *d, T *du)
{
  return langt(norm, n, dl, d, du);
}
template< typename T, typename Ta >
Ta langt(char *norm, integer *n, T *dl, T *d, T *du)
{
  return langt(norm, n, dl, d, du);
}

/*! @brief LANHB returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, \n
     or the element of largest absolute value of a Hermitian band matrix
 * @details
 * \b Purpose:
    \verbatim 
    LANHB returns the value of the one norm, or the Frobenius norm, or
    the  infinity norm, or the element of  largest absolute value  of an
    n by n hermitian band matrix A, with k super-diagonals.

       LANHB = (max(abs(A(i,j))), NORM = 'M' or 'm'
                (
                (norm1(A),        NORM = '1', 'O' or 'o'
                (
                (normI(A),        NORM = 'I' or 'i'
                (
                (normF(A),        NORM = 'F', 'f', 'E' or 'e'

    where  norm1  denotes the  one norm of a matrix (maximum column sum),
    normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
    normF  denotes the  Frobenius norm of a matrix (square root of sum of
    squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
    \endverbatim 

 * @param[in] NORM
          NORM is CHARACTER*1 \n
          Specifies the value to be   returned in CLANHB as described
          above. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the upper or lower triangular part of the
          band matrix A is supplied. \n
          = 'U':  Upper triangular \n
          = 'L':  Lower triangular \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0.  When N = 0, CLANHB is
          set to zero. \n
 * @param[in] K
          K is INTEGER \n
          The number of super-diagonals or sub-diagonals of the
          band matrix A.  K >= 0. \n
 * @param[in] AB
          AB is COMPLEX array, dimension (LDAB,N) \n
          The upper or lower triangle of the hermitian band matrix A,
          stored in the first K+1 rows of AB.  The j-th column of A is
          stored in the j-th column of the array AB as follows: \n
          if UPLO = 'U', AB(k+1+i-j,j) = A(i,j) for max(1,j-k)<=i<=j; \n
          if UPLO = 'L', AB(1+i-j,j)   = A(i,j) for j<=i<=min(n,j+k). \n
          Note that the imaginary parts of the diagonal elements need
          not be set and are assumed to be zero. \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          The leading dimension of the array AB.  LDAB >= K+1. \n
 * @param[out] WORK
          WORK is REAL array, dimension (MAX(1,LWORK)), \n
          where LWORK >= N when NORM = 'I' or '1' or 'O'; otherwise,
          WORK is not referenced. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T, typename Ta >
Ta lanhb(char *norm, char *uplo, integer *n, integer *k, T *ab, integer *ldab, Ta *work)
{
  return lanhb(norm, uplo, n, k, ab, ldab, work); 
}

/*! @brief LANHF   returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, \n
     or the element of largest absolute value of a Hermitian matrix in RFP format
 * @details
 * \b Purpose:
    \verbatim 
    LANHF    returns the value of the one norm, or the Frobenius norm, or
    the  infinity norm, or the  element of  largest absolute value  of a
    complex Hermitian matrix A in RFP format.

       CLANHF = (max(abs(A(i,j))), NORM = 'M' or 'm'
                (
                (norm1(A),        NORM = '1', 'O' or 'o'
                (
                (normI(A),        NORM = 'I' or 'i'
                (
                (normF(A),        NORM = 'F', 'f', 'E' or 'e'

    where  norm1  denotes the  one norm of a matrix (maximum column sum),
    normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
    normF  denotes the  Frobenius norm of a matrix (square root of sum of
    squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
    \endverbatim 

 * @param[in] NORM
          NORM is CHARACTER \n
          Specifies the value to be   returned in CLANHF as described
          above. \n
 * @param[in] TRANSR
          TRANSR is CHARACTER \n
          Specifies whether the RFP format of A is normal or
          conjugate-transposed format. \n
          = 'N':  RFP format is Normal \n
          = 'C':  RFP format is Conjugate-transposed \n
 * @param[in] UPLO
          UPLO is CHARACTER \n
          On entry, UPLO specifies whether the RFP matrix A came from
          an upper or lower triangular matrix as follows: \n
 \n
          UPLO = 'U' or 'u' RFP A came from an upper triangular
          matrix
 \n
          UPLO = 'L' or 'l' RFP A came from a  lower triangular
          matrix \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0.  When N = 0, CLANHF is
          set to zero. \n
 * @param[in] A
          A is COMPLEX array, dimension (N*(N+1)/2); \n
          On entry, the matrix A in RFP Format.
          RFP Format is described by TRANSR, UPLO and N as follows:
          If TRANSR='N' then RFP A is (0:N,0:K-1) when N is even;
          K=N/2. RFP A is (0:N-1,0:K) when N is odd; K=N/2. If
          TRANSR = 'C' then RFP is the Conjugate-transpose of RFP A
          as defined when TRANSR = 'N'. The contents of RFP A are
          defined by UPLO as follows: If UPLO = 'U' the RFP A
          contains the (N*(N+1)/2) elements of upper packed A
          either in normal or conjugate-transpose Format. If
          UPLO = 'L' the RFP A contains the (N*(N+1) /2) elements
          of lower packed A either in normal or conjugate-transpose
          Format. The LDA of RFP A is (N+1)/2 when TRANSR = 'C'. When
          TRANSR is 'N' the LDA is N+1 when N is even and is N when
          is odd. See the Note below for more details. \n
          Unchanged on exit. \n
 * @param[out] WORK
          WORK is REAL array, dimension (LWORK), \n
          where LWORK >= N when NORM = 'I' or '1' or 'O'; otherwise,
          WORK is not referenced. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T, typename Ta >
Ta lanhf(char *norm, char *transr, char *uplo, integer *n, T *a, Ta *work)
{
  return lanhf(norm, transr, uplo, n, a, work); 
}

/*! @brief LANHP returns the value of the 1-norm, or the Frobenius norm, or the infinity norm,   \n
     or the element of largest absolute value of a complex Hermitian matrix supplied in packed form
 * @details
 * \b Purpose:
    \verbatim 
    LANHP returns the value of the one norm, or the Frobenius norm, or
    the  infinity norm, or the  element of  largest absolute value  of a
    complex hermitian matrix A, supplied in packed form.

       CLANHP = (max(abs(A(i,j))), NORM = 'M' or 'm'
                (
                (norm1(A),        NORM = '1', 'O' or 'o'
                (
                (normI(A),        NORM = 'I' or 'i'
                (
                (normF(A),        NORM = 'F', 'f', 'E' or 'e'

    where  norm1  denotes the  one norm of a matrix (maximum column sum),
    normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
    normF  denotes the  Frobenius norm of a matrix (square root of sum of
    squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
    \endverbatim  

 * @param[in] NORM
          NORM is CHARACTER*1 \n
          Specifies the value to be   returned in CLANHP as described
          above. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the upper or lower triangular part of the
          hermitian matrix A is supplied. \n
          = 'U':  Upper triangular part of A is supplied \n
          = 'L':  Lower triangular part of A is supplied \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0.  When N = 0, CLANHP is
          set to zero. \n
 * @param[in] AP
          AP is COMPLEX array, dimension (N*(N+1)/2) \n
          The upper or lower triangle of the hermitian matrix A, packed
          columnwise in a linear array.  The j-th column of A is stored
          in the array AP as follows: \n
          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j; \n
          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n. \n
          Note that the  imaginary parts of the diagonal elements need
          not be set and are assumed to be zero. \n
 * @param[out] WORK
          WORK is REAL array, dimension (MAX(1,LWORK)), \n
          where LWORK >= N when NORM = 'I' or '1' or 'O'; otherwise,
          WORK is not referenced. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T, typename Ta >
Ta lanhp(char *norm, char *uplo, integer *n, T *ap, Ta *work)
{
  return lanhp(norm, uplo, n, ap, work); 
}

/*! @brief LANHS returns the value of the 1-norm, Frobenius norm, infinity-norm, or the \n
     largest absolute value of any element of an upper Hessenberg matrix
 * @details
 * \b Purpose:
    \verbatim 
    LANHS returns the value of the one norm, or the Frobenius norm, or
    the infinity norm, or the  element of  largest absolute value  of a
    Hessenberg matrix A.

       SLANHS = (max(abs(A(i,j))), NORM = 'M' or 'm'
                (
                (norm1(A),        NORM = '1', 'O' or 'o'
                (
                (normI(A),        NORM = 'I' or 'i'
                (
                (normF(A),        NORM = 'F', 'f', 'E' or 'e'

    where  norm1  denotes the  one norm of a matrix (maximum column sum),
    normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
    normF  denotes the  Frobenius norm of a matrix (square root of sum of
    squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
    \endverbatim

 * @param[in] NORM
          NORM is CHARACTER*1 \n
          Specifies the value to be   returned in SLANHS as described
          above. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0.  When N = 0, SLANHS is
          set to zero. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          The n by n upper Hessenberg matrix A; the part of A below the
          first sub-diagonal is not referenced. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(N,1). \n
 * @param[out] WORK
          WORK is REAL array, dimension (MAX(1,LWORK)), \n
          where LWORK >= N when NORM = 'I'; otherwise, WORK is not
          referenced. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
T lanhs(char *norm, integer *n, T *a, integer *lda, T *work)
{
  return lanhs(norm, n, a, lda, work);
}
template< typename T, typename Ta >
Ta lanhs(char *norm, integer *n, T *a, integer *lda, Ta *work)
{
  return lanhs(norm, n, a, lda, work);
}

/*! @brief LANHT returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, \n
     or the element of largest absolute value of a complex Hermitian tridiagonal matrix
 * @details
 * \b Purpose:
    \verbatim 
    LANHT returns the value of the one norm, or the Frobenius norm, or
    the infinity norm, or the element of largest absolute value of a
    complex Hermitian tridiagonal matrix A.

    \  return CLANHT
    

       CLANHT = (max(abs(A(i,j))), NORM = 'M' or 'm'
                (
                (norm1(A),        NORM = '1', 'O' or 'o'
                (
                (normI(A),        NORM = 'I' or 'i'
                (
                (normF(A),        NORM = 'F', 'f', 'E' or 'e'

    where  norm1  denotes the  one norm of a matrix (maximum column sum),
    normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
    normF  denotes the  Frobenius norm of a matrix (square root of sum of
    squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
    \endverbatim

 * @param[in] NORM
          NORM is CHARACTER*1 \n
          Specifies the value to be   returned in CLANHT as described
          above. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0.  When N = 0, CLANHT is
          set to zero. \n
 * @param[in] D
          D is REAL array, dimension (N) \n
          The diagonal elements of A. \n
 * @param[in] E
          E is COMPLEX array, dimension (N-1) \n
          The (n-1) sub-diagonal or super-diagonal elements of A.  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T, typename Ta >
Ta lanht(char *norm, integer *n, Ta *d, T *e)
{
  return lanht(norm, n, d, e);
}

/*! @brief LANSB returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, \n
     or the element of largest absolute value of a symmetric band matrix 
 * @details
 * \b Purpose:
    \verbatim 
    LANSB returns the value of the one norm, or the Frobenius norm, or
    the infinity norm, or the element of largest absolute value of an
    n by n symmetric band matrix A, with k super-diagonals.

    \  return SLANSB

       SLANSB = (max(abs(A(i,j))), NORM = 'M' or 'm'
                (
                (norm1(A),        NORM = '1', 'O' or 'o'
                (
                (normI(A),        NORM = 'I' or 'i'
                (
                (normF(A),        NORM = 'F', 'f', 'E' or 'e'

    where  norm1  denotes the  one norm of a matrix (maximum column sum),
    normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
    normF  denotes the  Frobenius norm of a matrix (square root of sum of
    squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
    \endverbatim

 * @param[in] NORM
          NORM is CHARACTER*1 \n
          Specifies the value to be   returned in SLANSB as described
          above. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the upper or lower triangular part of the
          band matrix A is supplied. \n
          = 'U':  Upper triangular part is supplied \n
          = 'L':  Lower triangular part is supplied \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0.  When N = 0, SLANSB is
          set to zero. \n
 * @param[in] K
          K is INTEGER \n
          The number of super-diagonals or sub-diagonals of the
          band matrix A.  K >= 0. \n
 * @param[in] AB
          AB is REAL array, dimension (LDAB,N) \n
          The upper or lower triangle of the symmetric band matrix A,
          stored in the first K+1 rows of AB.  The j-th column of A is
          stored in the j-th column of the array AB as follows: \n
          if UPLO = 'U', AB(k+1+i-j,j) = A(i,j) for max(1,j-k)<=i<=j; \n
          if UPLO = 'L', AB(1+i-j,j)   = A(i,j) for j<=i<=min(n,j+k). \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          The leading dimension of the array AB.  LDAB >= K+1. \n
 * @param[out] WORK
          WORK is REAL array, dimension (MAX(1,LWORK)), \n
          where LWORK >= N when NORM = 'I' or '1' or 'O'; otherwise,
          WORK is not referenced.  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T, typename Ta >
Ta lansb(char *norm, char *uplo, integer *n, integer *k, T *ab, integer *ldab, Ta *work)
{
  return lansb(norm, uplo, n, k, ab, ldab, work);
}

/*! @brief LANSF returns the value of the one norm, or the Frobenius norm, or the infinity norm, \n
     or the element of largest absolute value of a real symmetric matrix A in RFP format
 * @details
 * \b Purpose:
    \verbatim 
    LANSF returns the value of the one norm, or the Frobenius norm, or
    the infinity norm, or the element of largest absolute value of a
    real symmetric matrix A in RFP format.

    \  return SLANSF

       SLANSF = (max(abs(A(i,j))), NORM = 'M' or 'm'
                (
                (norm1(A),        NORM = '1', 'O' or 'o'
                (
                (normI(A),        NORM = 'I' or 'i'
                (
                (normF(A),        NORM = 'F', 'f', 'E' or 'e'

    where  norm1  denotes the  one norm of a matrix (maximum column sum),
    normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
    normF  denotes the  Frobenius norm of a matrix (square root of sum of
    squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
    \endverbatim

 * @param[in] NORM
          NORM is CHARACTER*1 \n
          Specifies the value to be   returned in SLANSF as described
          above. \n
 * @param[in] TRANSR
          TRANSR is CHARACTER*1 \n
          Specifies whether the RFP format of A is normal or
          transposed format. \n
          = 'N':  RFP format is Normal; \n
          = 'T':  RFP format is Transpose. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          On entry, UPLO specifies whether the RFP matrix A came from
          an upper or lower triangular matrix as follows: \n
          = 'U': RFP A came from an upper triangular matrix; \n
          = 'L': RFP A came from a lower triangular matrix. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A. N >= 0. When N = 0, SLANSF is
          set to zero. \n
 * @param[in] A
          A is REAL array, dimension (N*(N+1)/2); \n
          On entry, the upper (if UPLO = 'U') or lower (if UPLO = 'L')
          part of the symmetric matrix A stored in RFP format. See the
          "Notes" below for more details. \n
          Unchanged on exit. \n
 * @param[out] WORK
          WORK is REAL array, dimension (MAX(1,LWORK)), \n
          where LWORK >= N when NORM = 'I' or '1' or 'O'; otherwise,
          WORK is not referenced.  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
T lansf(char *norm, char *transr, char *uplo, integer *n, T *a, T * work)
{
  return lansf(norm, transr, uplo, n,  a, work); 
}

/*! @brief LANSP returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, \n
     or the element of largest absolute value of a symmetric matrix supplied in packed form
 * @details
 * \b Purpose:
    \verbatim 
    LANSP returns the value of the one norm, or the Frobenius norm, or
    the infinity norm, or the element of largest absolute value of a
    real symmetric matrix A, supplied in packed form.
    
    \  return SLANSP

       SLANSP = (max(abs(A(i,j))), NORM = 'M' or 'm'
                (
                (norm1(A),        NORM = '1', 'O' or 'o'
                (
                (normI(A),        NORM = 'I' or 'i'
                (
                (normF(A),        NORM = 'F', 'f', 'E' or 'e'

    where  norm1  denotes the  one norm of a matrix (maximum column sum),
    normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
    normF  denotes the  Frobenius norm of a matrix (square root of sum of
    squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
    \endverbatim 

 * @param[in] NORM
          NORM is CHARACTER*1 \n
          Specifies the value to be   returned in SLANSP as described
          above. \n
 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the upper or lower triangular part of the
          symmetric matrix A is supplied. \n
          = 'U':  Upper triangular part of A is supplied \n
          = 'L':  Lower triangular part of A is supplied \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0.  When N = 0, SLANSP is
          set to zero. \n
 * @param[in] AP
          AP is REAL array, dimension (N*(N+1)/2) \n
          The upper or lower triangle of the symmetric matrix A, packed
          columnwise in a linear array.  The j-th column of A is stored
          in the array AP as follows: \n
          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j; \n
          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n. \n
 * @param[out] WORK
          WORK is REAL array, dimension (MAX(1,LWORK)), \n
          where LWORK >= N when NORM = 'I' or '1' or 'O'; otherwise,
          WORK is not referenced. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
T lansp(char *norm, char *uplo, integer *n, T *ap, T *work)
{
  return lansp(norm, uplo, n, ap, work);
}
template< typename T, typename Ta >
Ta lansp(char *norm, char *uplo, integer *n, T *ap, Ta *work)
{
  return lansp(norm, uplo, n, ap, work);
}

/*! @brief LANST returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, 
     or the element of largest absolute value of a real symmetric tridiagonal matrix
 * @details
 * \b Purpose:
    \verbatim 
    LANST returns the value of the one norm, or the Frobenius norm, or
    the infinity norm, or the element of largest absolute value  of a
    real symmetric tridiagonal matrix A.
    
    \  return SLANST

       SLANST = (max(abs(A(i,j))), NORM = 'M' or 'm'
                (
                (norm1(A),        NORM = '1', 'O' or 'o'
                (
                (normI(A),        NORM = 'I' or 'i'
                (
                (normF(A),        NORM = 'F', 'f', 'E' or 'e'

    where  norm1  denotes the  one norm of a matrix (maximum column sum),
    normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
    normF  denotes the  Frobenius norm of a matrix (square root of sum of
    squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
    \endverbatim 

 * @param[in] NORM
          NORM is CHARACTER*1 \n
          Specifies the value to be   returned in SLANST as described
          above. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0.  When N = 0, SLANST is
          set to zero. \n
 * @param[in] D
          D is REAL array, dimension (N) \n
          The diagonal elements of A. \n
 * @param[in] E
          E is REAL array, dimension (N-1) \n
          The (n-1) sub-diagonal or super-diagonal elements of A. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
T lanst(char *norm, integer *n, T *d, T *e)
{
  return lanst(norm, n, d, e);
}

/*! @brief LANV2 computes the Schur factorization of a real 2-by-2 nonsymmetric matrix in standard form 

 * @details
 * \b Purpose:
    \verbatim 
    LANV2 computes the Schur factorization of a real 2-by-2 nonsymmetric
    matrix in standard form:

         [ A  B ] = [ CS -SN ] [ AA  BB ] [ CS  SN ]
         [ C  D ]   [ SN  CS ] [ CC  DD ] [-SN  CS ]

    where either
    1) CC = 0 so that AA and DD are real eigenvalues of the matrix, or
    2) AA = DD and BB*CC < 0, so that AA + or - sqrt(BB*CC) are complex
    conjugate eigenvalues.
    \endverbatim  

 * @param[in,out] A
          A is REAL \n
 * @param[in,out] B
          B is REAL \n
 * @param[in,out] C
          C is REAL \n
 * @param[in,out] D
          D is REAL \n
          On entry, the elements of the input matrix.
          On exit, they are overwritten by the elements of the
          standardised Schur form. \n
 * @param[out] RT1R
          RT1R is REAL \n
 * @param[out] RT1I
          RT1I is REAL \n
 * @param[out] RT2R
          RT2R is REAL \n
 * @param[out] RT2I
          RT2I is REAL \n
          The real and imaginary parts of the eigenvalues. If the
          eigenvalues are a complex conjugate pair, RT1I > 0. \n
 * @param[out] CS
          CS is REAL \n
 * @param[out] SN
          SN is REAL \n
          Parameters of the rotation matrix. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lanv2(T *a, T *b, T *c, T *d, T * rt1r, T *rt1i, T *rt2r, T *rt2i, T *cs, T *sn)
{
  return lanv2(a, b, c, d,  rt1r, rt1i, rt2r, rt2i, cs, sn);
}

/*! @brief LAORHR_COL_GETRFNP computes the modified LU factorization without pivoting of a real general M-by-N matrix A 

 * @details
 * \b Purpose:
    \verbatim 
    LAORHR_COL_GETRFNP computes the modified LU factorization without
    pivoting of a real general M-by-N matrix A. The factorization has
    the form:

        A - S = L * U,

    where:
       S is a m-by-n diagonal sign matrix with the diagonal D, so that
       D(i) = S(i,i), 1 <= i <= min(M,N). The diagonal D is constructed
       as D(i)=-SIGN(A(i,i)), where A(i,i) is the value after performing
       i-1 steps of Gaussian elimination. This means that the diagonal
       element at each step of "modified" Gaussian elimination is
       at least one in absolute value (so that division-by-zero not
       not possible during the division by the diagonal element);

       L is a M-by-N lower triangular matrix with unit diagonal elements
       (lower trapezoidal if M > N);

       and U is a M-by-N upper triangular matrix
       (upper trapezoidal if M < N).

    This routine is an auxiliary routine used in the Householder
    reconstruction routine SORHR_COL. In SORHR_COL, this routine is
    applied to an M-by-N matrix A with orthonormal columns, where each
    element is bounded by one in absolute value. With the choice of
    the matrix S above, one can show that the diagonal element at each
    step of Gaussian elimination is the largest (in absolute value) in
    the column on or below the diagonal, so that no pivoting is required
    for numerical stability [1].

    For more details on the Householder reconstruction algorithm,
    including the modified LU factorization, see [1].

    This is the blocked right-looking version of the algorithm,
    calling Level 3 BLAS to update the submatrix. To factorize a block,
    this routine calls the recursive routine SLAORHR_COL_GETRFNP2.

    [1] "Reconstructing Householder vectors from tall-skinny QR",
        G. Ballard, J. Demmel, L. Grigori, M. Jacquelin, H.D. Nguyen,
        E. Solomonik, J. Parallel Distrib. Comput.,
        vol. 85, pp. 3-31, 2015.
    \endverbatim 

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the M-by-N matrix to be factored.
          On exit, the factors L and U from the factorization
          A-S=L*U; the unit diagonal elements of L are not stored. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,M). \n
 * @param[out] D
          D is REAL array, dimension min(M,N) \n
          The diagonal elements of the diagonal M-by-N sign matrix S,
          D(i) = S(i,i), where 1 <= i <= min(M,N). The elements can
          be only plus or minus one. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer laorhr_col_getrfnp(integer *m, integer *n, T *a, integer *lda, T *d, integer *info)
{
  return laorhr_col_getrfnp(m, n, a, lda, d, info);
}

/*! @brief LAUNHR_COL_GETRFNP computes the modified LU factorization without pivoting of a complex general M-by-N matrix A

 * @details
 * \b Purpose:
    \verbatim  
    LAUNHR_COL_GETRFNP computes the modified LU factorization without
    pivoting of a complex general M-by-N matrix A. The factorization has
    the form:

        A - S = L * U,

    where:
       S is a m-by-n diagonal sign matrix with the diagonal D, so that
       D(i) = S(i,i), 1 <= i <= min(M,N). The diagonal D is constructed
       as D(i)=-SIGN(A(i,i)), where A(i,i) is the value after performing
       i-1 steps of Gaussian elimination. This means that the diagonal
       element at each step of "modified" Gaussian elimination is
       at least one in absolute value (so that division-by-zero not
       not possible during the division by the diagonal element);

       L is a M-by-N lower triangular matrix with unit diagonal elements
       (lower trapezoidal if M > N);

       and U is a M-by-N upper triangular matrix
       (upper trapezoidal if M < N).

    This routine is an auxiliary routine used in the Householder
    reconstruction routine CUNHR_COL. In CUNHR_COL, this routine is
    applied to an M-by-N matrix A with orthonormal columns, where each
    element is bounded by one in absolute value. With the choice of
    the matrix S above, one can show that the diagonal element at each
    step of Gaussian elimination is the largest (in absolute value) in
    the column on or below the diagonal, so that no pivoting is required
    for numerical stability [1].

    For more details on the Householder reconstruction algorithm,
    including the modified LU factorization, see [1].

    This is the blocked right-looking version of the algorithm,
    calling Level 3 BLAS to update the submatrix. To factorize a block,
    this routine calls the recursive routine CLAUNHR_COL_GETRFNP2.

    [1] "Reconstructing Householder vectors from tall-skinny QR",
        G. Ballard, J. Demmel, L. Grigori, M. Jacquelin, H.D. Nguyen,
        E. Solomonik, J. Parallel Distrib. Comput.,
        vol. 85, pp. 3-31, 2015.
    \endverbatim 

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is COMPLEX array, dimension (LDA,N) \n
          On entry, the M-by-N matrix to be factored.
          On exit, the factors L and U from the factorization
          A-S=L*U; the unit diagonal elements of L are not stored. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,M). \n
 * @param[out] D
          D is COMPLEX array, dimension min(M,N) \n
          The diagonal elements of the diagonal M-by-N sign matrix S,
          D(i) = S(i,i), where 1 <= i <= min(M,N). The elements can be
          only (+1.0, 0.0) or (-1.0, 0.0). \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer launhr_col_getrfnp(integer *m, integer *n, T *a, integer *lda, T *d, integer *info)
{
  return launhr_col_getrfnp(m, n, a, lda, d, info);
}

/*! @brief LAORHR_COL_GETRFNP2 computes the modified LU factorization without pivoting of a real general M-by-N matrix A

 * @details
 * \b Purpose:
    \verbatim 
    LAORHR_COL_GETRFNP2 computes the modified LU factorization without
    pivoting of a real general M-by-N matrix A. The factorization has
    the form:

        A - S = L * U,

    where:
       S is a m-by-n diagonal sign matrix with the diagonal D, so that
       D(i) = S(i,i), 1 <= i <= min(M,N). The diagonal D is constructed
       as D(i)=-SIGN(A(i,i)), where A(i,i) is the value after performing
       i-1 steps of Gaussian elimination. This means that the diagonal
       element at each step of "modified" Gaussian elimination is at
       least one in absolute value (so that division-by-zero not
       possible during the division by the diagonal element);

       L is a M-by-N lower triangular matrix with unit diagonal elements
       (lower trapezoidal if M > N);

       and U is a M-by-N upper triangular matrix
       (upper trapezoidal if M < N).

    This routine is an auxiliary routine used in the Householder
    reconstruction routine SORHR_COL. In SORHR_COL, this routine is
    applied to an M-by-N matrix A with orthonormal columns, where each
    element is bounded by one in absolute value. With the choice of
    the matrix S above, one can show that the diagonal element at each
    step of Gaussian elimination is the largest (in absolute value) in
    the column on or below the diagonal, so that no pivoting is required
    for numerical stability [1].

    For more details on the Householder reconstruction algorithm,
    including the modified LU factorization, see [1].

    This is the recursive version of the LU factorization algorithm.
    Denote A - S by B. The algorithm divides the matrix B into four
    submatrices:

           [  B11 | B12  ]  where B11 is n1 by n1,
       B = [ -----|----- ]        B21 is (m-n1) by n1,
           [  B21 | B22  ]        B12 is n1 by n2,
                                  B22 is (m-n1) by n2,
                                  with n1 = min(m,n)/2, n2 = n-n1.


    The subroutine calls itself to factor B11, solves for B21,
    solves for B12, updates B22, then calls itself to factor B22.

    For more details on the recursive LU algorithm, see [2].

    SLAORHR_COL_GETRFNP2 is called to factorize a block by the blocked
    routine SLAORHR_COL_GETRFNP, which uses blocked code calling
   *. Level 3 BLAS to update the submatrix. However, SLAORHR_COL_GETRFNP2
    is self-sufficient and can be used without SLAORHR_COL_GETRFNP.

    [1] "Reconstructing Householder vectors from tall-skinny QR",
        G. Ballard, J. Demmel, L. Grigori, M. Jacquelin, H.D. Nguyen,
        E. Solomonik, J. Parallel Distrib. Comput.,
        vol. 85, pp. 3-31, 2015.

    [2] "Recursion leads to automatic variable blocking for dense linear
        algebra algorithms", F. Gustavson, IBM J. of Res. and Dev.,
        vol. 41, no. 6, pp. 737-755, 1997.
    \endverbatim

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the M-by-N matrix to be factored.
          On exit, the factors L and U from the factorization
          A-S=L*U; the unit diagonal elements of L are not stored. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,M). \n
 * @param[out] D
          D is REAL array, dimension min(M,N) \n
          The diagonal elements of the diagonal M-by-N sign matrix S,
          D(i) = S(i,i), where 1 <= i <= min(M,N). The elements can
          be only plus or minus one. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer laorhr_col_getrfnp2(integer *m, integer *n, T *a, integer *lda, T *d, integer *info)
{
  return laorhr_col_getrfnp2(m, n, a, lda, d, info);
}

/*! @brief LAUNHR_COL_GETRFNP2 computes the modified LU factorization without pivoting of a real general M-by-N matrix A

 * @details
 * \b Purpose:
    \verbatim       
    LAUNHR_COL_GETRFNP2 computes the modified LU factorization without
    pivoting of a complex general M-by-N matrix A. The factorization has
    the form:

        A - S = L * U,

    where:
       S is a m-by-n diagonal sign matrix with the diagonal D, so that
       D(i) = S(i,i), 1 <= i <= min(M,N). The diagonal D is constructed
       as D(i)=-SIGN(A(i,i)), where A(i,i) is the value after performing
       i-1 steps of Gaussian elimination. This means that the diagonal
       element at each step of "modified" Gaussian elimination is at
       least one in absolute value (so that division-by-zero not
       possible during the division by the diagonal element);

       L is a M-by-N lower triangular matrix with unit diagonal elements
       (lower trapezoidal if M > N);

       and U is a M-by-N upper triangular matrix
       (upper trapezoidal if M < N).

    This routine is an auxiliary routine used in the Householder
    reconstruction routine CUNHR_COL. In CUNHR_COL, this routine is
    applied to an M-by-N matrix A with orthonormal columns, where each
    element is bounded by one in absolute value. With the choice of
    the matrix S above, one can show that the diagonal element at each
    step of Gaussian elimination is the largest (in absolute value) in
    the column on or below the diagonal, so that no pivoting is required
    for numerical stability [1].

    For more details on the Householder reconstruction algorithm,
    including the modified LU factorization, see [1].

    This is the recursive version of the LU factorization algorithm.
    Denote A - S by B. The algorithm divides the matrix B into four
    submatrices:

           [  B11 | B12  ]  where B11 is n1 by n1,
       B = [ -----|----- ]        B21 is (m-n1) by n1,
           [  B21 | B22  ]        B12 is n1 by n2,
                                  B22 is (m-n1) by n2,
                                  with n1 = min(m,n)/2, n2 = n-n1.


    The subroutine calls itself to factor B11, solves for B21,
    solves for B12, updates B22, then calls itself to factor B22.

    For more details on the recursive LU algorithm, see [2].

    CLAUNHR_COL_GETRFNP2 is called to factorize a block by the blocked
    routine CLAUNHR_COL_GETRFNP, which uses blocked code calling
   *. Level 3 BLAS to update the submatrix. However, CLAUNHR_COL_GETRFNP2
    is self-sufficient and can be used without CLAUNHR_COL_GETRFNP.

    [1] "Reconstructing Householder vectors from tall-skinny QR",
        G. Ballard, J. Demmel, L. Grigori, M. Jacquelin, H.D. Nguyen,
        E. Solomonik, J. Parallel Distrib. Comput.,
        vol. 85, pp. 3-31, 2015.

    [2] "Recursion leads to automatic variable blocking for dense linear
        algebra algorithms", F. Gustavson, IBM J. of Res. and Dev.,
        vol. 41, no. 6, pp. 737-755, 1997.
    \endverbatim 

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is COMPLEX array, dimension (LDA,N) \n
          On entry, the M-by-N matrix to be factored.
          On exit, the factors L and U from the factorization
          A-S=L*U; the unit diagonal elements of L are not stored. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,M). \n
 * @param[out] D
          D is COMPLEX array, dimension min(M,N) \n
          The diagonal elements of the diagonal M-by-N sign matrix S,
          D(i) = S(i,i), where 1 <= i <= min(M,N). The elements can be
          only (+1.0, 0.0) or (-1.0, 0.0). \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer launhr_col_getrfnp2(integer *m, integer *n, T *a, integer *lda, T *d, integer *info)
{
  return launhr_col_getrfnp2(m, n, a, lda, d, info);
}

/*! @brief LAPLL measures the linear dependence of two vectors

 * @details
 * \b Purpose:
    \verbatim 
    Given two column vectors X and Y, let
                         A = (X Y).
    The subroutine first computes the QR factorization of A = Q*R,
    and then computes the SVD of the 2-by-2 upper triangular matrix R.
    The smaller singular value of R is   returned in SSMIN, which is used
    as the measurement of the linear dependency of the vectors X and Y.
    \endverbatim
    
 * @param[in] N
          N is INTEGER \n
          The length of the vectors X and Y. \n
 * @param[in,out] X
          X is REAL array,
                         dimension (1+(N-1)*INCX) \n
          On entry, X contains the N-vector X.
          On exit, X is overwritten. \n
 * @param[in] INCX
          INCX is INTEGER \n
          The increment between successive elements of X. INCX > 0. \n
 * @param[in,out] Y
          Y is REAL array,
                         dimension (1+(N-1)*INCY) \n
          On entry, Y contains the N-vector Y.
          On exit, Y is overwritten. \n
 * @param[in] INCY
          INCY is INTEGER \n
          The increment between successive elements of Y. INCY > 0. \n
 * @param[out] SSMIN
          SSMIN is REAL \n
          The smallest singular value of the N-by-2 matrix A = (X Y).  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lapll(integer *n, T *x, integer *incx, T *y, integer *incy, T *ssmin)
{
  return lapll(n, x, incx, y, incy, ssmin);
}
template< typename T, typename Ta >
integer lapll(integer *n, T *x, integer *incx, T *y, integer *incy, Ta *ssmin)
{
  return lapll(n, x, incx, y, incy, ssmin);
}

/*! @brief LAQGB scales a general band matrix, using row and column scaling factors computed by gbequ

 * @details
 * \b Purpose:
    \verbatim 
    LAQGB equilibrates a general M by N band matrix A with KL
    subdiagonals and KU superdiagonals using the row and scaling factors
    in the vectors R and C.
    \endverbatim 

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A.  N >= 0. \n
 * @param[in] KL
          KL is INTEGER \n
          The number of subdiagonals within the band of A.  KL >= 0. \n
 * @param[in] KU
          KU is INTEGER \n
          The number of superdiagonals within the band of A.  KU >= 0. \n
 * @param[in,out] AB
          AB is REAL array, dimension (LDAB,N) \n
          On entry, the matrix A in band storage, in rows 1 to KL+KU+1.
          The j-th column of A is stored in the j-th column of the
          array AB as follows:
          AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl)
 \n
          On exit, the equilibrated matrix, in the same storage format
          as A.  See EQUED for the form of the equilibrated matrix. \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          The leading dimension of the array AB.  LDA >= KL+KU+1. \n
 * @param[in] R
          R is REAL array, dimension (M) \n
          The row scale factors for A. \n
 * @param[in] C
          C is REAL array, dimension (N) \n
          The column scale factors for A. \n
 * @param[in] ROWCND
          ROWCND is REAL \n
          Ratio of the smallest R(i) to the largest R(i). \n
 * @param[in] COLCND
          COLCND is REAL \n
          Ratio of the smallest C(i) to the largest C(i). \n
 * @param[in] AMAX
          AMAX is REAL \n
          Absolute value of largest matrix entry. \n
 * @param[out] EQUED
          EQUED is CHARACTER*1 \n
          Specifies the form of equilibration that was done. \n
          = 'N':  No equilibration \n
          = 'R':  Row equilibration, i.e., A has been premultiplied by
                  diag(R). \n
          = 'C':  Column equilibration, i.e., A has been postmultiplied
                  by diag(C). \n
          = 'B':  Both row and column equilibration, i.e., A has been
                  replaced by diag(R) * A * diag(C).  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer laqgb(integer *m, integer *n, integer *kl, integer *ku, T *ab, integer *ldab, T *r, T *c, T *rowcnd, T *colcnd, T *amax, char *equed)
{
  return laqgb(m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax, equed);
}
template< typename T, typename Ta >
integer laqgb(integer *m, integer *n, integer *kl, integer *ku, T *ab, integer *ldab, Ta *r, Ta *c, Ta *rowcnd, Ta *colcnd, Ta *amax, char *equed)
{
  return laqgb(m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax, equed);
}

/*! @brief LAQGE scales a general rectangular matrix, using row and column scaling factors computed by geequ

 * @details
 * \b Purpose:
    \verbatim 

    LAQGE equilibrates a general M by N matrix A using the row and
    column scaling factors in the vectors R and C.

    \endverbatim 

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the M by N matrix A.
          On exit, the equilibrated matrix.  See EQUED for the form of
          the equilibrated matrix. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(M,1). \n
 * @param[in] R
          R is REAL array, dimension (M) \n
          The row scale factors for A. \n
 * @param[in] C
          C is REAL array, dimension (N) \n
          The column scale factors for A. \n
 * @param[in] ROWCND
          ROWCND is REAL \n
          Ratio of the smallest R(i) to the largest R(i). \n
 * @param[in] COLCND
          COLCND is REAL \n
          Ratio of the smallest C(i) to the largest C(i). \n
 * @param[in] AMAX
          AMAX is REAL \n
          Absolute value of largest matrix entry. \n
 * @param[out] EQUED
          EQUED is CHARACTER*1 \n
          Specifies the form of equilibration that was done. \n
          = 'N':  No equilibration \n
          = 'R':  Row equilibration, i.e., A has been premultiplied by
                  diag(R). \n
          = 'C':  Column equilibration, i.e., A has been postmultiplied
                  by diag(C). \n
          = 'B':  Both row and column equilibration, i.e., A has been
                  replaced by diag(R) * A * diag(C).  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer laqge(integer *m, integer *n, T *a, integer *lda, T *r, T *c, T *rowcnd, T *colcnd, T *amax, char *equed)
{
  return laqge(m, n, a, lda, r, c, rowcnd, colcnd, amax, equed);
}
template< typename T, typename Ta >
integer laqge(integer *m, integer *n, T *a, integer *lda, Ta *r, Ta *c, Ta *rowcnd, Ta *colcnd, Ta *amax, char *equed)
{
  return laqge(m, n, a, lda, r, c, rowcnd, colcnd, amax, equed);
}

/*! @brief LAQHB scales a Hermitian band matrix, using scaling factors computed by cpbequ

 * @details
 * \b Purpose:
    \verbatim 
    LAQHB equilibrates an Hermitian band matrix A using the scaling
    factors in the vector S.
    \endverbatim

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the upper or lower triangular part of the
          symmetric matrix A is stored. \n
          = 'U':  Upper triangular \n
          = 'L':  Lower triangular \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] KD
          KD is INTEGER \n
          The number of super-diagonals of the matrix A if UPLO = 'U',
          or the number of sub-diagonals if UPLO = 'L'.  KD >= 0. \n
 * @param[in,out] AB
          AB is COMPLEX array, dimension (LDAB,N) \n
          On entry, the upper or lower triangle of the symmetric band
          matrix A, stored in the first KD+1 rows of the array.  The
          j-th column of A is stored in the j-th column of the array AB
          as follows: \n
          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j; \n
          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd). \n
 \n
          On exit, if INFO = 0, the triangular factor U or L from the
          Cholesky factorization A = U**H *U or A = L*L**H of the band
          matrix A, in the same storage format as A. \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          The leading dimension of the array AB.  LDAB >= KD+1. \n
 * @param[out] S
          S is REAL array, dimension (N) \n
          The scale factors for A. \n
 * @param[in] SCOND
          SCOND is REAL \n
          Ratio of the smallest S(i) to the largest S(i). \n
 * @param[in] AMAX
          AMAX is REAL \n
          Absolute value of largest matrix entry. \n
 * @param[out] EQUED
          EQUED is CHARACTER*1 \n
          Specifies whether or not equilibration was done. \n
          = 'N':  No equilibration. \n
          = 'Y':  Equilibration was done, i.e., A has been replaced by
                  diag(S) * A * diag(S).  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T, typename Ta >
integer laqhb(char *uplo, integer *n, integer *kd, T *ab, integer *ldab, Ta *s, Ta *scond, Ta *amax, char *equed)
{
  return laqhb(uplo, n, kd, ab, ldab, s, scond, amax, equed); 
}

/*! @brief LAQHE scales a Hermitian matrix

 * @details
 * \b Purpose:
    \verbatim
    LAQHE equilibrates a Hermitian matrix A using the scaling factors
    in the vector S.
    \endverbatim

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the upper or lower triangular part of the
          Hermitian matrix A is stored. \n
          = 'U':  Upper triangular \n
          = 'L':  Lower triangular \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is COMPLEX array, dimension (LDA,N) \n
          On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
          n by n upper triangular part of A contains the upper
          triangular part of the matrix A, and the strictly lower
          triangular part of A is not referenced.  If UPLO = 'L', the
          leading n by n lower triangular part of A contains the lower
          triangular part of the matrix A, and the strictly upper
          triangular part of A is not referenced. \n
 \n
          On exit, if EQUED = 'Y', the equilibrated matrix:
          diag(S) * A * diag(S). \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(N,1). \n
 * @param[in] S
          S is REAL array, dimension (N) \n
          The scale factors for A. \n
 * @param[in] SCOND
          SCOND is REAL \n
          Ratio of the smallest S(i) to the largest S(i). \n
 * @param[in] AMAX
          AMAX is REAL \n
          Absolute value of largest matrix entry. \n
 * @param[out] EQUED
          EQUED is CHARACTER*1 \n
          Specifies whether or not equilibration was done. \n
          = 'N':  No equilibration. \n
          = 'Y':  Equilibration was done, i.e., A has been replaced by
                  diag(S) * A * diag(S).   \n

 * @return INTEGER Return value of the function.
 * */
template< typename T, typename Ta >
integer laqhe(char *uplo, integer *n, T *a, integer *lda, Ta *s, Ta *scond, Ta *amax, char *equed)
{
  return laqhe(uplo, n, a, lda, s, scond, amax, equed); 
}

/*! @brief LAQHP scales a Hermitian matrix stored in packed form

 * @details
 * \b Purpose:
    \verbatim 
    LAQHP equilibrates a Hermitian matrix A using the scaling factors
    in the vector S.
    \endverbatim  

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the upper or lower triangular part of the
          Hermitian matrix A is stored. \n
          = 'U':  Upper triangular \n
          = 'L':  Lower triangular \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] AP
          AP is COMPLEX array, dimension (N*(N+1)/2) \n
          On entry, the upper or lower triangle of the Hermitian matrix
          A, packed columnwise in a linear array.  The j-th column of A
          is stored in the array AP as follows: \n
          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j; \n
          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n. \n
 \n
          On exit, the equilibrated matrix:  diag(S) * A * diag(S), in
          the same storage format as A. \n
 * @param[in] S
          S is REAL array, dimension (N) \n
          The scale factors for A. \n
 * @param[in] SCOND
          SCOND is REAL \n
          Ratio of the smallest S(i) to the largest S(i). \n
 * @param[in] AMAX
          AMAX is REAL \n
          Absolute value of largest matrix entry. \n
 * @param[out] EQUED
          EQUED is CHARACTER*1 \n
          Specifies whether or not equilibration was done. \n
          = 'N':  No equilibration. \n
          = 'Y':  Equilibration was done, i.e., A has been replaced by
                  diag(S) * A * diag(S).  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T, typename Ta >
integer laqhp(char *uplo, integer *n, T *ap, Ta *s, Ta *scond, Ta *amax, char *equed)
{
  return laqhp(uplo, n, ap, s, scond, amax, equed); 
}

/*! @brief LAQP2 computes a QR factorization with column pivoting of the matrix block

 * @details
 * \b Purpose:
    \verbatim
    LAQP2 computes a QR factorization with column pivoting of
    the block A(OFFSET+1:M,1:N).
    The block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized.
    \endverbatim

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A. M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A. N >= 0. \n
 * @param[in] OFFSET
          OFFSET is INTEGER \n
          The number of rows of the matrix A that must be pivoted
          but no factorized. OFFSET >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the M-by-N matrix A. \n
          On exit, the upper triangle of block A(OFFSET+1:M,1:N) is
          the triangular factor obtained; the elements in block
          A(OFFSET+1:M,1:N) below the diagonal, together with the
          array TAU, represent the orthogonal matrix Q as a product of
          elementary reflectors. Block A(1:OFFSET,1:N) has been
          accordingly pivoted, but no factorized. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A. LDA >= max(1,M). \n
 * @param[in,out] JPVT
          JPVT is INTEGER array, dimension (N) \n
          On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted
          to the front of A*P (a leading column); if JPVT(i) = 0,
          the i-th column of A is a free column. \n
          On exit, if JPVT(i) = k, then the i-th column of A*P
          was the k-th column of A. \n
 * @param[out] TAU
          TAU is REAL array, dimension (min(M,N)) \n
          The scalar factors of the elementary reflectors. \n
 * @param[in,out] VN1
          VN1 is REAL array, dimension (N) \n
          The vector with the partial column norms. \n
 * @param[in,out] VN2
          VN2 is REAL array, dimension (N) \n
          The vector with the exact column norms. \n
 * @param[out] WORK
          WORK is REAL array, dimension (N)  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer laqp2(integer *m, integer *n, integer *offset, T *a, integer *lda, integer *jpvt, T *tau, T *vn1, T *vn2, T *work)
{
  return laqp2(m, n, offset, a, lda, jpvt, tau, vn1, vn2, work);
}
template< typename T, typename Ta >
integer laqp2(integer *m, integer *n, integer *offset, T *a, integer *lda, integer *jpvt, T *tau, Ta *vn1, Ta *vn2, T *work)
{
  return laqp2(m, n, offset, a, lda, jpvt, tau, vn1, vn2, work);
}

/*! @brief LAQPS computes a step of QR factorization with column pivoting of a real m-by-n matrix A by using BLAS level 3

 * @details
 * \b Purpose:
    \verbatim 
    LAQPS computes a step of QR factorization with column pivoting
    of a real M-by-N matrix A by using Blas-3.  It tries to factorize
    NB columns from A starting from the row OFFSET+1, and updates all
    of the matrix with Blas-3 xGEMM.

    In some cases, due to catastrophic cancellations, it cannot
    factorize NB columns.  Hence, the actual number of factorized
    columns is   returned in KB.

    Block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized.
    \endverbatim 

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A. M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A. N >= 0 \n
 * @param[in] OFFSET
          OFFSET is INTEGER \n
          The number of rows of A that have been factorized in
          previous steps. \n
 * @param[in] NB
          NB is INTEGER \n
          The number of columns to factorize. \n
 * @param[out] KB
          KB is INTEGER \n
          The number of columns actually factorized. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the M-by-N matrix A. \n
          On exit, block A(OFFSET+1:M,1:KB) is the triangular
          factor obtained and block A(1:OFFSET,1:N) has been
          accordingly pivoted, but no factorized.
          The rest of the matrix, block A(OFFSET+1:M,KB+1:N) has
          been updated. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A. LDA >= max(1,M). \n
 * @param[in,out] JPVT
          JPVT is INTEGER array, dimension (N) \n
          JPVT(I) = K <==> Column K of the full matrix A has been
          permuted into position I in AP. \n
 * @param[out] TAU
          TAU is REAL array, dimension (KB) \n
          The scalar factors of the elementary reflectors. \n
 * @param[in,out] VN1
          VN1 is REAL array, dimension (N) \n
          The vector with the partial column norms. \n
 * @param[in,out] VN2
          VN2 is REAL array, dimension (N) \n
          The vector with the exact column norms. \n
 * @param[in,out] AUXV
          AUXV is REAL array, dimension (NB) \n
          Auxiliary vector. \n
 * @param[in,out] F
          F is REAL array, dimension (LDF,NB) \n
          Matrix F**T = L*Y**T*A. \n
 * @param[in] LDF
          LDF is INTEGER \n
          The leading dimension of the array F. LDF >= max(1,N).  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer laqps(integer *m, integer *n, integer *offset, integer *nb, integer *kb, T *a, integer *lda, integer *jpvt, T *tau, T *vn1, T *vn2, T *auxv, T *f, integer *ldf)
{
  return laqps(m, n, offset, nb, kb, a, lda, jpvt, tau, vn1, vn2, auxv, f, ldf);
}
template< typename T, typename Ta >
integer laqps(integer *m, integer *n, integer *offset, integer *nb, integer *kb, T *a, integer *lda, integer *jpvt, T *tau, Ta *vn1, Ta *vn2, T *auxv, T *f, integer *ldf)
{
  return laqps(m, n, offset, nb, kb, a, lda, jpvt, tau, vn1, vn2, auxv, f, ldf);
}

/*! @brief LAQR0 computes the eigenvalues of a Hessenberg matrix, and optionally the matrices from the Schur decomposition

 * @details
 * \b Purpose:
    \verbatim
    LAQR0 computes the eigenvalues of a Hessenberg matrix H
    and, optionally, the matrices T and Z from the Schur decomposition
    H = Z T Z**T, where T is an upper quasi-triangular matrix (the
    Schur form), and Z is the orthogonal matrix of Schur vectors.

    Optionally Z may be postmultiplied into an input orthogonal
    matrix Q so that this routine can give the Schur factorization
    of a matrix A which has been reduced to the Hessenberg form H
    by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.
    \endverbatim

 * @param[in] WANTT
          WANTT is LOGICAL \n
          = .TRUE. : the full Schur form T is required; \n
          = .FALSE.: only eigenvalues are required. \n
 * @param[in] WANTZ
          WANTZ is LOGICAL \n
          = .TRUE. : the matrix of Schur vectors Z is required; \n
          = .FALSE.: Schur vectors are not required. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix H.  N >= 0. \n
 * @param[in] ILO
          ILO is INTEGER \n
 * @param[in] IHI
          IHI is INTEGER \n
          It is assumed that H is already upper triangular in rows
          and columns 1:ILO-1 and IHI+1:N and, if ILO > 1,
          H(ILO,ILO-1) is zero. ILO and IHI are normally set by a
          previous call to SGEBAL, and then passed to SGEHRD when the
          matrix output by SGEBAL is reduced to Hessenberg form.
          Otherwise, ILO and IHI should be set to 1 and N,
          respectively.  If N > 0, then 1 <= ILO <= IHI <= N.
          If N = 0, then ILO = 1 and IHI = 0. \n
 * @param[in,out] H
          H is REAL array, dimension (LDH,N) \n
          On entry, the upper Hessenberg matrix H. \n
          On exit, if INFO = 0 and WANTT is .TRUE., then H contains
          the upper quasi-triangular matrix T from the Schur
          decomposition (the Schur form); 2-by-2 diagonal blocks
          (corresponding to complex conjugate pairs of eigenvalues)
          are   returned in standard form, with H(i,i) = H(i+1,i+1)
          and H(i+1,i)*H(i,i+1) < 0. If INFO = 0 and WANTT is
          .FALSE., then the contents of H are unspecified on exit.
          (The output value of H when INFO > 0 is given under the
          description of INFO below.) \n
 \n
          This subroutine may explicitly set H(i,j) = 0 for i > j and
          j = 1, 2, ... ILO-1 or j = IHI+1, IHI+2, ... N. \n
 * @param[in] LDH
          LDH is INTEGER \n
          The leading dimension of the array H. LDH >= max(1,N). \n
 * @param[out] WR
          WR is REAL array, dimension (IHI) \n
 * @param[out] WI
          WI is REAL array, dimension (IHI) \n
          The real and imaginary parts, respectively, of the computed
          eigenvalues of H(ILO:IHI,ILO:IHI) are stored in WR(ILO:IHI)
          and WI(ILO:IHI). If two eigenvalues are computed as a
          complex conjugate pair, they are stored in consecutive
          elements of WR and WI, say the i-th and (i+1)th, with
          WI(i) > 0 and WI(i+1) < 0. If WANTT is .TRUE., then
          the eigenvalues are stored in the same order as on the
          diagonal of the Schur form   returned in H, with
          WR(i) = H(i,i) and, if H(i:i+1,i:i+1) is a 2-by-2 diagonal
          block, WI(i) = sqrt(-H(i+1,i)*H(i,i+1)) and
          WI(i+1) = -WI(i). \n
 * @param[in] ILOZ
          ILOZ is INTEGER \n
 * @param[in] IHIZ
          IHIZ is INTEGER \n
          Specify the rows of Z to which transformations must be
          applied if WANTZ is .TRUE.. \n
          1 <= ILOZ <= ILO; IHI <= IHIZ <= N. \n
 * @param[in,out] Z
          Z is REAL array, dimension (LDZ,IHI) \n
          If WANTZ is .FALSE., then Z is not referenced. \n
          If WANTZ is .TRUE., then Z(ILO:IHI,ILOZ:IHIZ) is
          replaced by Z(ILO:IHI,ILOZ:IHIZ)*U where U is the
          orthogonal Schur factor of H(ILO:IHI,ILO:IHI).
          (The output value of Z when INFO > 0 is given under
          the description of INFO below.) \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of the array Z.  if WANTZ is .TRUE.
          then LDZ >= MAX(1,IHIZ).  Otherwise, LDZ >= 1. \n
 * @param[out] WORK
          WORK is REAL array, dimension LWORK \n
          On exit, if LWORK = -1, WORK(1)   returns an estimate of
          the optimal value for LWORK. \n
 * @param[in] LWORK
          LWORK is INTEGER \n
          The dimension of the array WORK.  LWORK >= max(1,N)
          is sufficient, but LWORK typically as large as 6*N may
          be required for optimal performance.  A workspace query
          to determine the optimal workspace size is recommended.
 \n
          If LWORK = -1, then SLAQR0 does a workspace query.
          In this case, SLAQR0 checks the input parameters and
          estimates the optimal workspace size for the given
          values of N, ILO and IHI.  The estimate is   returned
          in WORK(1).  No error message related to LWORK is
          issued by XERBLA.  Neither H nor Z are accessed. \n
 * @param[out] INFO
          INFO is INTEGER
             = 0:  successful exit \n
             > 0:  if INFO = i, SLAQR0 failed to compute all of
                the eigenvalues.  Elements 1:ilo-1 and i+1:n of WR
                and WI contain those eigenvalues which have been
                successfully computed.  (Failures are rare.)
 \n
                If INFO > 0 and WANT is .FALSE., then on exit,
                the remaining unconverged eigenvalues are the eigen-
                values of the upper Hessenberg matrix rows and
                columns ILO through INFO of the final, output
                value of H.
 \n
                If INFO > 0 and WANTT is .TRUE., then on exit
 \n
           (*)  (initial value of H)*U  = U*(final value of H)
 \n
                where U is an orthogonal matrix.  The final
                value of H is upper Hessenberg and quasi-triangular
                in rows and columns INFO+1 through IHI.
 \n
                If INFO > 0 and WANTZ is .TRUE., then on exit
 \n
                  (final value of Z(ILO:IHI,ILOZ:IHIZ)
                   =  (initial value of Z(ILO:IHI,ILOZ:IHIZ)*U
 \n
                where U is the orthogonal matrix in (*) (regard-
                less of the value of WANTT.)
 \n
                If INFO > 0 and WANTZ is .FALSE., then Z is not
                accessed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer laqr0(logical *wantt, logical *wantz, integer *n, integer *ilo, integer *ihi, T *h, integer *ldh, T *wr, T *wi, integer *iloz, integer *ihiz, T *z, integer *ldz, T *work, integer *lwork, integer *info)
{
  return laqr0(wantt, wantz, n, ilo, ihi, h, ldh, wr, wi, iloz, ihiz, z, ldz, work, lwork, info);
}
template< typename T >
integer laqr0(logical *wantt, logical *wantz, integer *n, integer *ilo, integer *ihi, T *h, integer *ldh, T *w, integer *iloz, integer *ihiz, T *z, integer *ldz, T *work, integer *lwork, integer *info)
{
  return laqr0(wantt, wantz, n, ilo, ihi, h, ldh, w, iloz, ihiz, z, ldz, work, lwork, info);
}

/*! @brief LAQR1 sets a scalar multiple of the first column of the product of 2-by-2 or 3-by-3 matrix H and specified shifts

 * @details
 * \b Purpose:
    \verbatim 
     Given a 2-by-2 or 3-by-3 matrix H, SLAQR1 sets v to a
     scalar multiple of the first column of the product

     (*)  K = (H - (sr1 + i*si1)*I)*(H - (sr2 + i*si2)*I)

     scaling to avoid overflows and most underflows. It
     is assumed that either

             1) sr1 = sr2 and si1 = -si2
         or
             2) si1 = si2 = 0.

     This is useful for starting double implicit shift bulges
     in the QR algorithm.
    \endverbatim  

 * @param[in] N
          N is INTEGER \n
          Order of the matrix H. N must be either 2 or 3. \n
 * @param[in] H
          H is REAL array, dimension (LDH,N) \n
          The 2-by-2 or 3-by-3 matrix H in (*). \n
 * @param[in] LDH
          LDH is INTEGER \n
          The leading dimension of H as declared in
          the calling procedure.  LDH >= N \n
 * @param[in] SR1
          SR1 is REAL \n
 * @param[in] SI1
          SI1 is REAL \n
 * @param[in] SR2
          SR2 is REAL \n
 * @param[in] SI2
          SI2 is REAL \n
          The shifts in (*). \n
 * @param[out] V
          V is REAL array, dimension (N) \n
          A scalar multiple of the first column of the
          matrix K in (*).  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer laqr1(integer *n, T *h, integer *ldh, T *sr1, T *si1, T *sr2, T *si2, T *v)
{
  return laqr1(n, h, ldh, sr1, si1, sr2, si2, v);
}
template< typename T >
integer laqr1(integer *n, T *h, integer *ldh, T *s1, T *s2, T *v)
{
  return laqr1(n, h, ldh, s1, s2, v);
}

/*! @brief LAQR2 performs the orthogonal similarity transformation of a Hessenberg  \n
     matrix  to detect and deflate fully converged eigenvalues from a trailing      \n
     principal submatrix (aggressive early deflation)
 * @details
 * \b Purpose:
    \verbatim 
    LAQR2 is identical to SLAQR3 except that it avoids
    recursion by calling SLAHQR instead of SLAQR4.

    Aggressive early deflation:

    This subroutine accepts as input an upper Hessenberg matrix
    H and performs an orthogonal similarity transformation
    designed to detect and deflate fully converged eigenvalues from
    a trailing principal submatrix.  On output H has been over-
    written by a new Hessenberg matrix that is a perturbation of
    an orthogonal similarity transformation of H.  It is to be
    hoped that the final version of H has many zero subdiagonal
    entries.
    \endverbatim 

 * @param[in] WANTT
          WANTT is LOGICAL \n
          If .TRUE., then the Hessenberg matrix H is fully updated
          so that the quasi-triangular Schur factor may be
          computed (in cooperation with the calling subroutine).
          If .FALSE., then only enough of H is updated to preserve
          the eigenvalues. \n
 * @param[in] WANTZ
          WANTZ is LOGICAL \n
          If .TRUE., then the orthogonal matrix Z is updated so
          so that the orthogonal Schur factor may be computed
          (in cooperation with the calling subroutine).
          If .FALSE., then Z is not referenced. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix H and (if WANTZ is .TRUE.) the
          order of the orthogonal matrix Z. \n
 * @param[in] KTOP
          KTOP is INTEGER \n
          It is assumed that either KTOP = 1 or H(KTOP,KTOP-1)=0.
          KBOT and KTOP together determine an isolated block
          along the diagonal of the Hessenberg matrix. \n
 * @param[in] KBOT
          KBOT is INTEGER \n
          It is assumed without a check that either
          KBOT = N or H(KBOT+1,KBOT)=0.  KBOT and KTOP together
          determine an isolated block along the diagonal of the
          Hessenberg matrix. \n
 * @param[in] NW
          NW is INTEGER \n
          Deflation window size.  1 <= NW <= (KBOT-KTOP+1). \n
 * @param[in,out] H
          H is REAL array, dimension (LDH,N) \n
          On input the initial N-by-N section of H stores the
          Hessenberg matrix undergoing aggressive early deflation. \n
          On output H has been transformed by an orthogonal
          similarity transformation, perturbed, and the   returned
          to Hessenberg form that (it is to be hoped) has some
          zero subdiagonal entries. \n
 * @param[in] LDH
          LDH is INTEGER \n
          Leading dimension of H just as declared in the calling
          subroutine.  N <= LDH \n
 * @param[in] ILOZ
          ILOZ is INTEGER \n
 * @param[in] IHIZ
          IHIZ is INTEGER \n
          Specify the rows of Z to which transformations must be
          applied if WANTZ is .TRUE.. 1 <= ILOZ <= IHIZ <= N. \n
 * @param[in,out] Z
          Z is REAL array, dimension (LDZ,N) \n
          IF WANTZ is .TRUE., then on output, the orthogonal
          similarity transformation mentioned above has been
          accumulated into Z(ILOZ:IHIZ,ILOZ:IHIZ) from the right.
          If WANTZ is .FALSE., then Z is unreferenced. \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of Z just as declared in the
          calling subroutine.  1 <= LDZ. \n
 * @param[out] NS
          NS is INTEGER \n
          The number of unconverged (ie approximate) eigenvalues
          returned in SR and SI that may be used as shifts by the
          calling subroutine. \n
 * @param[out] ND
          ND is INTEGER \n
          The number of converged eigenvalues uncovered by this
          subroutine. \n
 * @param[out] SR
          SR is REAL array, dimension (KBOT) \n
 * @param[out] SI
          SI is REAL array, dimension (KBOT) \n
          On output, the real and imaginary parts of approximate
          eigenvalues that may be used for shifts are stored in
          SR(KBOT-ND-NS+1) through SR(KBOT-ND) and
          SI(KBOT-ND-NS+1) through SI(KBOT-ND), respectively.
          The real and imaginary parts of converged eigenvalues
          are stored in SR(KBOT-ND+1) through SR(KBOT) and
          SI(KBOT-ND+1) through SI(KBOT), respectively. \n
 * @param[out] V
          V is REAL array, dimension (LDV,NW) \n
          An NW-by-NW work array. \n
 * @param[in] LDV
          LDV is INTEGER \n
          The leading dimension of V just as declared in the
          calling subroutine.  NW <= LDV \n
 * @param[in] NH
          NH is INTEGER \n
          The number of columns of T.  NH >= NW. \n
 * @param[out] T
          T is REAL array, dimension (LDT,NW) \n
 * @param[in] LDT
          LDT is INTEGER \n
          The leading dimension of T just as declared in the
          calling subroutine.  NW <= LDT \n
 * @param[in] NV
          NV is INTEGER \n
          The number of rows of work array WV available for
          workspace.  NV >= NW. \n
 * @param[out] WV
          WV is REAL array, dimension (LDWV,NW) \n
 * @param[in] LDWV
          LDWV is INTEGER \n
          The leading dimension of W just as declared in the
          calling subroutine.  NW <= LDV \n
 * @param[out] WORK
          WORK is REAL array, dimension (LWORK) \n
          On exit, WORK(1) is set to an estimate of the optimal value
          of LWORK for the given values of N, NW, KTOP and KBOT. \n
 * @param[in] LWORK
          LWORK is INTEGER \n
          The dimension of the work array WORK.  LWORK = 2*NW
          suffices, but greater efficiency may result from larger
          values of LWORK. \n
 \n
          If LWORK = -1, then a workspace query is assumed; SLAQR2
          only estimates the optimal workspace size for the given
          values of N, NW, KTOP and KBOT.  The estimate is   returned
          in WORK(1).  No error message related to LWORK is issued
          by XERBLA.  Neither H nor Z are accessed. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer laqr2(logical *wantt, logical *wantz, integer *n, integer *ktop, integer *kbot, integer *nw, T *h, integer *ldh, integer *iloz, integer *ihiz, T *z, integer *ldz, integer *ns, integer *nd, T *sr, T *si, T *v, integer *ldv, integer *nh, T *t, integer *ldt, integer *nv, T *wv, integer *ldwv, T *work, integer *lwork)
{
  return laqr2(wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz, ihiz, z, ldz, ns, nd, sr, si, v, ldv, nh, t, ldt, nv, wv, ldwv, work, lwork);
}
template< typename T >
integer laqr2(logical *wantt, logical *wantz, integer *n, integer *ktop, integer *kbot, integer *nw, T *h, integer *ldh, integer *iloz, integer *ihiz, T *z, integer *ldz, integer *ns, integer *nd, T *sh, T *v, integer *ldv, integer *nh, T *t, integer *ldt, integer *nv, T *wv, integer *ldwv, T *work, integer *lwork)
{
  return laqr2(wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz, ihiz, z, ldz, ns, nd, sh, v, ldv, nh, t, ldt, nv, wv, ldwv, work, lwork);
}

/*! @brief LAQR3 performs the orthogonal similarity transformation of a Hessenberg \n
     matrix to detect and deflate fully converged eigenvalues from a trailing      \n
     principal submatrix (aggressive early deflation).
 * @details
 * \b Purpose:
    \verbatim 
    LAQR3 accepts as input an upper Hessenberg matrix
    H and performs an orthogonal similarity transformation
    designed to detect and deflate fully converged eigenvalues from
    a trailing principal submatrix.  On output H has been over-
    written by a new Hessenberg matrix that is a perturbation of
    an orthogonal similarity transformation of H.  It is to be
    hoped that the final version of H has many zero subdiagonal
    entries.
    \endverbatim 

 * @param[in] WANTT
          WANTT is LOGICAL \n
          If .TRUE., then the Hessenberg matrix H is fully updated
          so that the quasi-triangular Schur factor may be
          computed (in cooperation with the calling subroutine). \n
          If .FALSE., then only enough of H is updated to preserve
          the eigenvalues. \n
 * @param[in] WANTZ
          WANTZ is LOGICAL \n
          If .TRUE., then the orthogonal matrix Z is updated so
          so that the orthogonal Schur factor may be computed
          (in cooperation with the calling subroutine). \n
          If .FALSE., then Z is not referenced. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix H and (if WANTZ is .TRUE.) the
          order of the orthogonal matrix Z. \n
 * @param[in] KTOP
          KTOP is INTEGER \n
          It is assumed that either KTOP = 1 or H(KTOP,KTOP-1)=0.
          KBOT and KTOP together determine an isolated block
          along the diagonal of the Hessenberg matrix. \n
 * @param[in] KBOT
          KBOT is INTEGER \n
          It is assumed without a check that either
          KBOT = N or H(KBOT+1,KBOT)=0.  KBOT and KTOP together
          determine an isolated block along the diagonal of the
          Hessenberg matrix. \n
 * @param[in] NW
          NW is INTEGER \n
          Deflation window size.  1 <= NW <= (KBOT-KTOP+1). \n
 * @param[in,out] H
          H is REAL array, dimension (LDH,N) \n
          On input the initial N-by-N section of H stores the
          Hessenberg matrix undergoing aggressive early deflation.
          On output H has been transformed by an orthogonal
          similarity transformation, perturbed, and the   returned
          to Hessenberg form that (it is to be hoped) has some
          zero subdiagonal entries. \n
 * @param[in] LDH
          LDH is INTEGER \n
          Leading dimension of H just as declared in the calling
          subroutine.  N <= LDH \n
 * @param[in] ILOZ
          ILOZ is INTEGER \n
 * @param[in] IHIZ
          IHIZ is INTEGER \n
          Specify the rows of Z to which transformations must be
          applied if WANTZ is .TRUE.. 1 <= ILOZ <= IHIZ <= N. \n
 * @param[in,out] Z
          Z is REAL array, dimension (LDZ,N) \n
          IF WANTZ is .TRUE., then on output, the orthogonal
          similarity transformation mentioned above has been
          accumulated into Z(ILOZ:IHIZ,ILOZ:IHIZ) from the right. \n
          If WANTZ is .FALSE., then Z is unreferenced. \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of Z just as declared in the
          calling subroutine.  1 <= LDZ. \n
 * @param[out] NS
          NS is INTEGER \n
          The number of unconverged (ie approximate) eigenvalues
          returned in SR and SI that may be used as shifts by the
          calling subroutine. \n
 * @param[out] ND
          ND is INTEGER \n
          The number of converged eigenvalues uncovered by this
          subroutine. \n
 * @param[out] SR
          SR is REAL array, dimension (KBOT) \n
 * @param[out] SI
          SI is REAL array, dimension (KBOT) \n
          On output, the real and imaginary parts of approximate
          eigenvalues that may be used for shifts are stored in
          SR(KBOT-ND-NS+1) through SR(KBOT-ND) and
          SI(KBOT-ND-NS+1) through SI(KBOT-ND), respectively.
          The real and imaginary parts of converged eigenvalues
          are stored in SR(KBOT-ND+1) through SR(KBOT) and
          SI(KBOT-ND+1) through SI(KBOT), respectively. \n
 * @param[out] V
          V is REAL array, dimension (LDV,NW) \n
          An NW-by-NW work array. \n
 * @param[in] LDV
          LDV is INTEGER \n
          The leading dimension of V just as declared in the
          calling subroutine.  NW <= LDV \n
 * @param[in] NH
          NH is INTEGER \n
          The number of columns of T.  NH >= NW. \n
 * @param[out] T
          T is REAL array, dimension (LDT,NW) \n
 * @param[in] LDT
          LDT is INTEGER \n
          The leading dimension of T just as declared in the
          calling subroutine.  NW <= LDT \n
 * @param[in] NV
          NV is INTEGER \n
          The number of rows of work array WV available for
          workspace.  NV >= NW. \n
 * @param[out] WV
          WV is REAL array, dimension (LDWV,NW) \n
 * @param[in] LDWV
          LDWV is INTEGER \n
          The leading dimension of W just as declared in the
          calling subroutine.  NW <= LDV \n
 * @param[out] WORK
          WORK is REAL array, dimension (LWORK) \n
          On exit, WORK(1) is set to an estimate of the optimal value
          of LWORK for the given values of N, NW, KTOP and KBOT. \n
 * @param[in] LWORK
          LWORK is INTEGER \n
          The dimension of the work array WORK.  LWORK = 2*NW
          suffices, but greater efficiency may result from larger
          values of LWORK. \n
 \n
          If LWORK = -1, then a workspace query is assumed; SLAQR3
          only estimates the optimal workspace size for the given
          values of N, NW, KTOP and KBOT.  The estimate is   returned
          in WORK(1).  No error message related to LWORK is issued
          by XERBLA.  Neither H nor Z are accessed.  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer laqr3(logical *wantt, logical *wantz, integer *n, integer *ktop, integer *kbot, integer *nw, T *h, integer *ldh, integer *iloz, integer *ihiz, T *z, integer *ldz, integer *ns, integer *nd, T *sr, T *si, T *v, integer *ldv, integer *nh, T *t, integer *ldt, integer *nv, T *wv, integer *ldwv, T *work, integer *lwork)
{
  return laqr3(wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz, ihiz, z, ldz, ns, nd, sr, si, v, ldv, nh, t, ldt, nv, wv, ldwv, work, lwork);
}
template< typename T >
integer laqr3(logical *wantt, logical *wantz, integer *n, integer *ktop, integer *kbot, integer *nw, T *h, integer *ldh, integer *iloz, integer *ihiz, T *z, integer *ldz, integer *ns, integer *nd, T *sh, T *v, integer *ldv, integer *nh, T *t, integer *ldt, integer *nv, T *wv, integer *ldwv, T *work, integer *lwork)
{
  return laqr3(wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz, ihiz, z, ldz, ns, nd, sh, v, ldv, nh, t, ldt, nv, wv, ldwv, work, lwork);
}

/*! @brief LAQR4 computes the eigenvalues of a Hessenberg matrix, and optionally the matrices from the Schur decomposition 

 * @details
 * \b Purpose:
    \verbatim 
    LAQR4 implements one level of recursion for SLAQR0.
    It is a complete implementation of the small bulge multi-shift
    QR algorithm.  It may be called by SLAQR0 and, for large enough
    deflation window size, it may be called by SLAQR3.  This
    subroutine is identical to SLAQR0 except that it calls SLAQR2
    instead of SLAQR3.

    SLAQR4 computes the eigenvalues of a Hessenberg matrix H
    and, optionally, the matrices T and Z from the Schur decomposition
    H = Z T Z**T, where T is an upper quasi-triangular matrix (the
    Schur form), and Z is the orthogonal matrix of Schur vectors.

    Optionally Z may be postmultiplied into an input orthogonal
    matrix Q so that this routine can give the Schur factorization
    of a matrix A which has been reduced to the Hessenberg form H
    by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.
    \endverbatim 

 * @param[in] WANTT
          WANTT is LOGICAL \n
          = .TRUE. : the full Schur form T is required; \n
          = .FALSE.: only eigenvalues are required. \n
 * @param[in] WANTZ
          WANTZ is LOGICAL \n
          = .TRUE. : the matrix of Schur vectors Z is required; \n
          = .FALSE.: Schur vectors are not required. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix H.  N >= 0. \n
 * @param[in] ILO
          ILO is INTEGER \n
 * @param[in] IHI
          IHI is INTEGER \n
          It is assumed that H is already upper triangular in rows
          and columns 1:ILO-1 and IHI+1:N and, if ILO > 1,
          H(ILO,ILO-1) is zero. ILO and IHI are normally set by a
          previous call to SGEBAL, and then passed to SGEHRD when the
          matrix output by SGEBAL is reduced to Hessenberg form.
          Otherwise, ILO and IHI should be set to 1 and N,
          respectively.  If N > 0, then 1 <= ILO <= IHI <= N. \n
          If N = 0, then ILO = 1 and IHI = 0. \n
 * @param[in,out] H
          H is REAL array, dimension (LDH,N) \n
          On entry, the upper Hessenberg matrix H. \n
          On exit, if INFO = 0 and WANTT is .TRUE., then H contains
          the upper quasi-triangular matrix T from the Schur
          decomposition (the Schur form); 2-by-2 diagonal blocks
          (corresponding to complex conjugate pairs of eigenvalues)
          are   returned in standard form, with H(i,i) = H(i+1,i+1)
          and H(i+1,i)*H(i,i+1) < 0. If INFO = 0 and WANTT is
          .FALSE., then the contents of H are unspecified on exit.
          (The output value of H when INFO > 0 is given under the
          description of INFO below.) \n
 \n
          This subroutine may explicitly set H(i,j) = 0 for i > j and
          j = 1, 2, ... ILO-1 or j = IHI+1, IHI+2, ... N. \n
 * @param[in] LDH
          LDH is INTEGER \n
          The leading dimension of the array H. LDH >= max(1,N). \n
 * @param[out] WR
          WR is REAL array, dimension (IHI) \n
 * @param[out] WI
          WI is REAL array, dimension (IHI) \n
          The real and imaginary parts, respectively, of the computed
          eigenvalues of H(ILO:IHI,ILO:IHI) are stored in WR(ILO:IHI)
          and WI(ILO:IHI). If two eigenvalues are computed as a
          complex conjugate pair, they are stored in consecutive
          elements of WR and WI, say the i-th and (i+1)th, with
          WI(i) > 0 and WI(i+1) < 0. If WANTT is .TRUE., then
          the eigenvalues are stored in the same order as on the
          diagonal of the Schur form   returned in H, with
          WR(i) = H(i,i) and, if H(i:i+1,i:i+1) is a 2-by-2 diagonal
          block, WI(i) = sqrt(-H(i+1,i)*H(i,i+1)) and
          WI(i+1) = -WI(i). \n
 * @param[in] ILOZ
          ILOZ is INTEGER \n
 * @param[in] IHIZ
          IHIZ is INTEGER \n
          Specify the rows of Z to which transformations must be
          applied if WANTZ is .TRUE.. \n
          1 <= ILOZ <= ILO; IHI <= IHIZ <= N. \n
 * @param[in,out] Z
          Z is REAL array, dimension (LDZ,IHI) \n
          If WANTZ is .FALSE., then Z is not referenced. \n
          If WANTZ is .TRUE., then Z(ILO:IHI,ILOZ:IHIZ) is
          replaced by Z(ILO:IHI,ILOZ:IHIZ)*U where U is the
          orthogonal Schur factor of H(ILO:IHI,ILO:IHI).
          (The output value of Z when INFO > 0 is given under
          the description of INFO below.) \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of the array Z.  if WANTZ is .TRUE.
          then LDZ >= MAX(1,IHIZ).  Otherwise, LDZ >= 1. \n
 * @param[out] WORK
          WORK is REAL array, dimension LWORK \n
          On exit, if LWORK = -1, WORK(1)   returns an estimate of
          the optimal value for LWORK. \n
 * @param[in] LWORK
          LWORK is INTEGER \n
          The dimension of the array WORK.  LWORK >= max(1,N)
          is sufficient, but LWORK typically as large as 6*N may
          be required for optimal performance.  A workspace query
          to determine the optimal workspace size is recommended.
 \n
          If LWORK = -1, then SLAQR4 does a workspace query.
          In this case, SLAQR4 checks the input parameters and
          estimates the optimal workspace size for the given
          values of N, ILO and IHI.  The estimate is   returned
          in WORK(1).  No error message related to LWORK is
          issued by XERBLA.  Neither H nor Z are accessed. \n
 * @param[out] INFO
          INFO is INTEGER \n
             = 0:  successful exit \n
             > 0:  if INFO = i, SLAQR4 failed to compute all of
                the eigenvalues.  Elements 1:ilo-1 and i+1:n of WR
                and WI contain those eigenvalues which have been
                successfully computed.  (Failures are rare.)
 \n
                If INFO > 0 and WANT is .FALSE., then on exit,
                the remaining unconverged eigenvalues are the eigen-
                values of the upper Hessenberg matrix rows and
                columns ILO through INFO of the final, output
                value of H.
 \n
                If INFO > 0 and WANTT is .TRUE., then on exit
 \n
           (*)  (initial value of H)*U  = U*(final value of H)
 \n
                where U is a orthogonal matrix.  The final
                value of  H is upper Hessenberg and triangular in
                rows and columns INFO+1 through IHI.
 \n
                If INFO > 0 and WANTZ is .TRUE., then on exit
 \n
                  (final value of Z(ILO:IHI,ILOZ:IHIZ)
                   =  (initial value of Z(ILO:IHI,ILOZ:IHIZ)*U
 \n
                where U is the orthogonal matrix in (*) (regard-
                less of the value of WANTT.)
 \n
                If INFO > 0 and WANTZ is .FALSE., then Z is not
                accessed.  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer laqr4(logical *wantt, logical *wantz, integer *n, integer *ilo, integer *ihi, T *h, integer *ldh, T *wr, T * wi, integer *iloz, integer *ihiz, T *z, integer *ldz, T *work, integer *lwork, integer *info)
{
  return laqr4(wantt, wantz, n, ilo, ihi, h, ldh, wr, wi, iloz, ihiz, z, ldz, work, lwork, info);
}
template< typename T >
integer laqr4(logical *wantt, logical *wantz, integer *n, integer *ilo, integer *ihi, T *h, integer *ldh, T *w, integer *iloz, integer *ihiz, T *z, integer *ldz, T *work, integer *lwork, integer *info)
{
  return laqr4(wantt, wantz, n, ilo, ihi, h, ldh, w, iloz, ihiz, z, ldz, work, lwork, info);
}

/*! @brief LAQR5 performs a single small-bulge multi-shift QR sweep

 * @details
 * \b Purpose:
    \verbatim
    LAQR5, called by SLAQR0, performs a
    single small-bulge multi-shift QR sweep.
    \endverbatim

 * @param[in] WANTT
          WANTT is LOGICAL \n
          WANTT = .true. if the quasi-triangular Schur factor
          is being computed.  WANTT is set to .false. otherwise. \n
 * @param[in] WANTZ
          WANTZ is LOGICAL \n
          WANTZ = .true. if the orthogonal Schur factor is being
          computed.  WANTZ is set to .false. otherwise. \n
 * @param[in] KACC22
          KACC22 is INTEGER with value 0, 1, or 2. \n
          Specifies the computation mode of far-from-diagonal
          orthogonal updates. \n
          = 0: SLAQR5 does not accumulate reflections and does not
               use matrix-matrix multiply to update far-from-diagonal
               matrix entries. \n
          = 1: SLAQR5 accumulates reflections and uses matrix-matrix
               multiply to update the far-from-diagonal matrix entries. \n
          = 2: SLAQR5 accumulates reflections, uses matrix-matrix
               multiply to update the far-from-diagonal matrix entries,
               and takes advantage of 2-by-2 block structure during
               matrix multiplies. \n
 * @param[in] N
          N is INTEGER \n
          N is the order of the Hessenberg matrix H upon which this
          subroutine operates. \n
 * @param[in] KTOP
          KTOP is INTEGER \n
 * @param[in] KBOT
          KBOT is INTEGER \n
          These are the first and last rows and columns of an
          isolated diagonal block upon which the QR sweep is to be
          applied. It is assumed without a check that \n
                   either KTOP = 1  or   H(KTOP,KTOP-1) = 0 \n
          and \n
                   either KBOT = N  or   H(KBOT+1,KBOT) = 0. \n
 * @param[in] NSHFTS
          NSHFTS is INTEGER \n
          NSHFTS gives the number of simultaneous shifts.  NSHFTS
          must be positive and even. \n
 * @param[in,out] SR
          SR is REAL array, dimension (NSHFTS) \n
 * @param[in,out] SI
          SI is REAL array, dimension (NSHFTS) \n
          SR contains the real parts and SI contains the imaginary
          parts of the NSHFTS shifts of origin that define the
          multi-shift QR sweep.  On output SR and SI may be
          reordered. \n
 * @param[in,out] H
          H is REAL array, dimension (LDH,N) \n
          On input H contains a Hessenberg matrix.  On output a
          multi-shift QR sweep with shifts SR(J)+i*SI(J) is applied
          to the isolated diagonal block in rows and columns KTOP
          through KBOT. \n
 * @param[in] LDH
          LDH is INTEGER \n
          LDH is the leading dimension of H just as declared in the
          calling procedure.  LDH >= MAX(1,N). \n
 * @param[in] ILOZ
          ILOZ is INTEGER \n
 * @param[in] IHIZ
          IHIZ is INTEGER \n
          Specify the rows of Z to which transformations must be
          applied if WANTZ is .TRUE.. 1 <= ILOZ <= IHIZ <= N \n
 * @param[in,out] Z
          Z is REAL array, dimension (LDZ,IHIZ) \n
          If WANTZ = .TRUE., then the QR Sweep orthogonal
          similarity transformation is accumulated into
          Z(ILOZ:IHIZ,ILOZ:IHIZ) from the right. \n
          If WANTZ = .FALSE., then Z is unreferenced. \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          LDZ is the leading dimension of Z just as declared in
          the calling procedure. LDZ >= N. \n
 * @param[out] V
          V is REAL array, dimension (LDV,NSHFTS/2) \n
 * @param[in] LDV
          LDV is INTEGER \n
          LDV is the leading dimension of V as declared in the
          calling procedure.  LDV >= 3. \n
 * @param[out] U
          U is REAL array, dimension (LDU,3*NSHFTS-3) \n
 * @param[in] LDU
          LDU is INTEGER \n
          LDU is the leading dimension of U just as declared in the
          in the calling subroutine.  LDU >= 3*NSHFTS-3. \n
 * @param[in] NV
          NV is INTEGER \n
          NV is the number of rows in WV agailable for workspace.
          NV >= 1. \n
 * @param[out] WV
          WV is REAL array, dimension (LDWV,3*NSHFTS-3)
 * @param[in] LDWV
          LDWV is INTEGER
          LDWV is the leading dimension of WV as declared in the
          in the calling subroutine.  LDWV >= NV.
 * @param[in] NH
          NH is INTEGER
          NH is the number of columns in array WH available for
          workspace. NH >= 1.
 * @param[out] WH
          WH is REAL array, dimension (LDWH,NH) \n
 * @param[in] LDWH
          LDWH is INTEGER \n
          Leading dimension of WH just as declared in the
          calling procedure.  LDWH >= 3*NSHFTS-3.  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer laqr5(logical *wantt, logical *wantz, integer *kacc22, integer *n, integer *ktop, integer *kbot, integer *nshfts, T *sr, T *si, T *h, integer *ldh, integer *iloz, integer *ihiz, T *z, integer *ldz, T *v, integer *ldv, T *u, integer *ldu, integer *nv, T *wv, integer *ldwv, integer *nh, T *wh, integer * ldwh)
{
  return laqr5(wantt, wantz, kacc22, n, ktop, kbot, nshfts, sr, si, h, ldh, iloz, ihiz, z, ldz, v, ldv, u, ldu, nv, wv, ldwv, nh, wh, ldwh);
}
template< typename T >
integer laqr5(logical *wantt, logical *wantz, integer *kacc22, integer *n, integer *ktop, integer *kbot, integer *nshfts, T *s, T *h, integer *ldh, integer *iloz, integer *ihiz, T *z, integer *ldz, T *v, integer *ldv, T *u, integer *ldu, integer *nv, T *wv, integer *ldwv, integer *nh, T *wh, integer * ldwh)
{
  return laqr5(wantt, wantz, kacc22, n, ktop, kbot, nshfts, s, h, ldh, iloz, ihiz, z, ldz, v, ldv, u, ldu, nv, wv, ldwv, nh, wh, ldwh);
}

/*! @brief LAQSB scales a symmetric/Hermitian band matrix, using scaling factors computed by spbequ.

 * @details
 * \b Purpose:
    \verbatim
    LAQSB equilibrates a symmetric band matrix A using the scaling
    factors in the vector S.
    \endverbatim

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the upper or lower triangular part of the
          symmetric matrix A is stored. \n
          = 'U':  Upper triangular \n
          = 'L':  Lower triangular \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] KD
          KD is INTEGER \n
          The number of super-diagonals of the matrix A if UPLO = 'U',
          or the number of sub-diagonals if UPLO = 'L'.  KD >= 0. \n
 * @param[in,out] AB
          AB is REAL array, dimension (LDAB,N) \n
          On entry, the upper or lower triangle of the symmetric band
          matrix A, stored in the first KD+1 rows of the array.  The
          j-th column of A is stored in the j-th column of the array AB
          as follows: \n
          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j; \n
          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd). \n
 \n
          On exit, if INFO = 0, the triangular factor U or L from the
          Cholesky factorization A = U**T*U or A = L*L**T of the band
          matrix A, in the same storage format as A. \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          The leading dimension of the array AB.  LDAB >= KD+1. \n
 * @param[in] S
          S is REAL array, dimension (N) \n
          The scale factors for A. \n
 * @param[in] SCOND
          SCOND is REAL \n
          Ratio of the smallest S(i) to the largest S(i). \n
 * @param[in] AMAX
          AMAX is REAL \n
          Absolute value of largest matrix entry. \n
 * @param[out] EQUED
          EQUED is CHARACTER*1 \n
          Specifies whether or not equilibration was done. \n
          = 'N':  No equilibration. \n
          = 'Y':  Equilibration was done, i.e., A has been replaced by
                  diag(S) * A * diag(S).  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer laqsb(char *uplo, integer *n, integer *kd, T *ab, integer *ldab, T *s, T *scond, T *amax, char *equed)
{
  return laqsb(uplo, n, kd, ab, ldab, s, scond, amax, equed);
}
template< typename T, typename Ta >
integer laqsb(char *uplo, integer *n, integer *kd, T *ab, integer *ldab, Ta *s, Ta *scond, Ta *amax, char *equed)
{
  return laqsb(uplo, n, kd, ab, ldab, s, scond, amax, equed);
}

/*! @brief LAQSP scales a symmetric/Hermitian matrix in packed storage, using scaling factors computed by sppequ

 * @details
 * \b Purpose:
    \verbatim
    LAQSP equilibrates a symmetric matrix A using the scaling factors
    in the vector S.
    \endverbatim

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the upper or lower triangular part of the
          symmetric matrix A is stored. \n
          = 'U':  Upper triangular \n
          = 'L':  Lower triangular \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] AP
          AP is REAL array, dimension (N*(N+1)/2) \n
          On entry, the upper or lower triangle of the symmetric matrix
          A, packed columnwise in a linear array.  The j-th column of A
          is stored in the array AP as follows: \n
          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j; \n
          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n. \n
 \n
          On exit, the equilibrated matrix:  diag(S) * A * diag(S), in
          the same storage format as A. \n
 * @param[in] S
          S is REAL array, dimension (N) \n
          The scale factors for A. \n
 * @param[in] SCOND
          SCOND is REAL \n
          Ratio of the smallest S(i) to the largest S(i). \n
 * @param[in] AMAX
          AMAX is REAL \n
          Absolute value of largest matrix entry. \n
 * @param[out] EQUED
          EQUED is CHARACTER*1 \n
          Specifies whether or not equilibration was done. \n
          = 'N':  No equilibration. \n
          = 'Y':  Equilibration was done, i.e., A has been replaced by
                  diag(S) * A * diag(S).  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer laqsp(char *uplo, integer *n, T *ap, T *s, T * scond, T *amax, char *equed)
{
  return laqsp(uplo, n, ap, s, scond, amax, equed);
}
template< typename T, typename Ta >
integer laqsp(char *uplo, integer *n, T *ap, Ta *s, Ta * scond, Ta *amax, char *equed)
{
  return laqsp(uplo, n, ap, s, scond, amax, equed);
}

/*! @brief LAQSY scales a symmetric/Hermitian matrix, using scaling factors computed by spoequ

 * @details
 * \b Purpose:
    \verbatim
    LAQSY equilibrates a symmetric matrix A using the scaling factors
    in the vector S.
    \endverbatim

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the upper or lower triangular part of the
          symmetric matrix A is stored. \n
          = 'U':  Upper triangular \n
          = 'L':  Lower triangular \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
          n by n upper triangular part of A contains the upper
          triangular part of the matrix A, and the strictly lower
          triangular part of A is not referenced.  If UPLO = 'L', the
          leading n by n lower triangular part of A contains the lower
          triangular part of the matrix A, and the strictly upper
          triangular part of A is not referenced. \n
 \n
          On exit, if EQUED = 'Y', the equilibrated matrix:
          diag(S) * A * diag(S). \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(N,1). \n
 * @param[in] S
          S is REAL array, dimension (N) \n
          The scale factors for A. \n
 * @param[in] SCOND
          SCOND is REAL \n
          Ratio of the smallest S(i) to the largest S(i). \n
 * @param[in] AMAX
          AMAX is REAL \n
          Absolute value of largest matrix entry. \n
 * @param[out] EQUED
          EQUED is CHARACTER*1 \n
          Specifies whether or not equilibration was done. \n
          = 'N':  No equilibration. \n
          = 'Y':  Equilibration was done, i.e., A has been replaced by
                  diag(S) * A * diag(S). \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer laqsy(char *uplo, integer *n, T *a, integer *lda, T *s, T *scond, T *amax, char *equed)
{
  return laqsy(uplo, n, a, lda, s, scond, amax, equed);
}
template< typename T, typename Ta >
integer laqsy(char *uplo, integer *n, T *a, integer *lda, Ta *s, Ta *scond, Ta *amax, char *equed)
{
  return laqsy(uplo, n, a, lda, s, scond, amax, equed);
}

/*! @brief LAQTR solves a real quasi-triangular system of equations, or a complex \n
     quasi-triangular system of special form, in real arithmetic
 * @details
 * \b Purpose:
    \verbatim 
    LAQTR solves the real quasi-triangular system

                 op(T)*p = scale*c,              if LREAL = .TRUE.

    or the complex quasi-triangular systems

               op(T + iB)*(p+iq) = scale*(c+id), if LREAL = .FALSE.

    in real arithmetic, where T is upper quasi-triangular.
    If LREAL = .FALSE., then the first diagonal block of T must be
    1 by 1, B is the specially structured matrix

                   B = [ b(1) b(2) ... b(n) ]
                       [       w            ]
                       [           w        ]
                       [              .     ]
                       [                 w  ]

    op(A) = A or A**T, A**T denotes the transpose of
    matrix A.

    On input, X = [ c ].  On output, X = [ p ].
                  [ d ]                  [ q ]

    This subroutine is designed for the condition number estimation
    in routine STRSNA.
    \endverbatim 

 * @param[in] LTRAN
          LTRAN is LOGICAL \n
          On entry, LTRAN specifies the option of conjugate transpose: \n
             = .FALSE.,   op(T+i*B) = T+i*B, \n
             = .TRUE.,    op(T+i*B) = (T+i*B)**T. \n
 * @param[in] LREAL
          LREAL is LOGICAL \n
          On entry, LREAL specifies the input matrix structure: \n
             = .FALSE.,   the input is complex \n
             = .TRUE.,    the input is real \n
 * @param[in] N
          N is INTEGER \n
          On entry, N specifies the order of T+i*B. N >= 0. \n
 * @param[in] T
          T is REAL array, dimension (LDT,N) \n
          On entry, T contains a matrix in Schur canonical form. \n
          If LREAL = .FALSE., then the first diagonal block of T must
          be 1 by 1. \n
 * @param[in] LDT
          LDT is INTEGER \n
          The leading dimension of the matrix T. LDT >= max(1,N). \n
 * @param[in] B
          B is REAL array, dimension (N) \n
          On entry, B contains the elements to form the matrix
          B as described above. \n
          If LREAL = .TRUE., B is not referenced. \n
 * @param[in] W
          W is REAL \n
          On entry, W is the diagonal element of the matrix B.
          If LREAL = .TRUE., W is not referenced. \n
 * @param[out] SCALE
          SCALE is REAL \n
          On exit, SCALE is the scale factor. \n
 * @param[in,out] X
          X is REAL array, dimension (2*N) \n
          On entry, X contains the right hand side of the system.
          On exit, X is overwritten by the solution. \n
 * @param[out] WORK
          WORK is REAL array, dimension (N) \n
 * @param[out] INFO
          INFO is INTEGER \n
          On exit, INFO is set to \n
             0: successful exit. \n
               1: the some diagonal 1 by 1 block has been perturbed by
                  a small number SMIN to keep nonsingularity. \n
               2: the some diagonal 2 by 2 block has been perturbed by
                  a small number in SLALN2 to keep nonsingularity. \n
          NOTE: In the interests of speed, this routine does not
                check the inputs for errors.  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer laqtr(logical *ltran, logical *lreal, integer *n, T *t, integer *ldt, T *b, T *w, T *scale, T *x, T *work, integer *info)
{
  return laqtr(ltran, lreal, n, t, ldt, b, w, scale, x, work, info);
}

/*! @brief LAR1V computes the (scaled) r-th column of the inverse of the \n
     submatrix in rows b1 through bn of the tridiagonal matrix LDLT - I
 * @details
 * \b Purpose:
    \verbatim 
    LAR1V computes the (scaled) r-th column of the inverse of
    the sumbmatrix in rows B1 through BN of the tridiagonal matrix
    L D L**T - sigma I. When sigma is close to an eigenvalue, the
    computed vector is an accurate eigenvector. Usually, r corresponds
    to the index where the eigenvector is largest in magnitude.
    The following steps accomplish this computation :
    (a) Stationary qd transform, L D L**T - sigma I = L(+) D(+) L(+)**T,
    (b) Progressive qd transform, L D L**T - sigma I = U(-) D(-) U(-)**T,
    (c) Computation of the diagonal elements of the inverse of
        L D L**T - sigma I by combining the above transforms, and choosing
        r as the index where the diagonal of the inverse is (one of the)
        largest in magnitude.
    (d) Computation of the (scaled) r-th column of the inverse using the
        twisted factorization obtained by combining the top part of the
        the stationary and the bottom part of the progressive transform.
    \endverbatim 

 * @param[in] N
          N is INTEGER \n
          The order of the matrix L D L**T. \n
 * @param[in] B1
          B1 is INTEGER \n
          First index of the submatrix of L D L**T. \n
 * @param[in] BN
          BN is INTEGER \n
          Last index of the submatrix of L D L**T. \n
 * @param[in] LAMBDA
          LAMBDA is REAL \n
          The shift. In order to compute an accurate eigenvector,
          LAMBDA should be a good approximation to an eigenvalue
          of L D L**T. \n
 * @param[in] L
          L is REAL array, dimension (N-1) \n
          The (n-1) subdiagonal elements of the unit bidiagonal matrix
          L, in elements 1 to N-1. \n
 * @param[in] D
          D is REAL array, dimension (N) \n
          The n diagonal elements of the diagonal matrix D. \n
 * @param[in] LD
          LD is REAL array, dimension (N-1) \n
          The n-1 elements L(i)*D(i). \n
 * @param[in] LLD
          LLD is REAL array, dimension (N-1) \n
          The n-1 elements L(i)*L(i)*D(i). \n
 * @param[in] PIVMIN
          PIVMIN is REAL \n
          The minimum pivot in the Sturm sequence. \n
 * @param[in] GAPTOL
          GAPTOL is REAL \n
          Tolerance that indicates when eigenvector entries are negligible
          w.r.t. their contribution to the residual. \n
 * @param[in,out] Z
          Z is REAL array, dimension (N) \n
          On input, all entries of Z must be set to 0.
          On output, Z contains the (scaled) r-th column of the
          inverse. The scaling is such that Z(R) equals 1. \n
 * @param[in] WANTNC
          WANTNC is LOGICAL \n
          Specifies whether NEGCNT has to be computed. \n
 * @param[out] NEGCNT
          NEGCNT is INTEGER \n
          If WANTNC is .TRUE. then NEGCNT = the number of pivots < pivmin
          in the  matrix factorization L D L**T, and NEGCNT = -1 otherwise. \n
 * @param[out] ZTZ
          ZTZ is REAL \n
          The square of the 2-norm of Z. \n
 * @param[out] MINGMA
          MINGMA is REAL \n
          The reciprocal of the largest (in magnitude) diagonal
          element of the inverse of L D L**T - sigma I. \n
 * @param[in,out] R
          R is INTEGER \n
          The twist index for the twisted factorization used to
          compute Z. \n
          On input, 0 <= R <= N. If R is input as 0, R is set to
          the index where (L D L**T - sigma I)^{-1} is largest
          in magnitude. If 1 <= R <= N, R is unchanged.
          On output, R contains the twist index used to compute Z.
          Ideally, R designates the position of the maximum entry in the
          eigenvector. \n
 * @param[out] ISUPPZ
          ISUPPZ is INTEGER array, dimension (2) \n
          The support of the vector in Z, i.e., the vector Z is
          nonzero only in elements ISUPPZ(1) through ISUPPZ(2). \n
 * @param[out] NRMINV
          NRMINV is REAL \n
          NRMINV = 1/SQRT(ZTZ) \n
 * @param[out] RESID
          RESID is REAL \n
          The residual of the FP vector.
          RESID = ABS(MINGMA)/SQRT(ZTZ) \n
 * @param[out] RQCORR
          RQCORR is REAL \n
          The Rayleigh Quotient correction to LAMBDA.
          RQCORR = MINGMA*TMP \n
 * @param[out] WORK
          WORK is REAL array, dimension (4*N)  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lar1v(integer *n, integer *b1, integer *bn, T * lambda, T *d, T *l, T *ld, T *lld, T *pivmin, T * gaptol, T *z, logical *wantnc, integer *negcnt, T *ztz, T * mingma, integer *r, integer *isuppz, T *nrminv, T *resid, T *rqcorr, T *work)
{
  return lar1v(n, b1, bn, lambda, d, l, d, lld, pivmin, gaptol, z, wantnc, negcnt, ztz, mingma, r, isuppz, nrminv, resid, rqcorr, work);
}
template< typename T, typename Ta >
integer lar1v(integer *n, integer *b1, integer *bn, Ta *lambda, Ta *d, Ta *l, Ta *ld, Ta *lld, Ta *pivmin, Ta * gaptol, T *z, logical *wantnc, integer *negcnt, Ta *ztz, Ta * mingma, integer *r, integer *isuppz, Ta *nrminv, Ta *resid, Ta *rqcorr, Ta *work)
{
  return lar1v(n, b1, bn, lambda, d, l, d, lld, pivmin, gaptol, z, wantnc, negcnt, ztz, mingma, r, isuppz, nrminv, resid, rqcorr, work);
}

/*! @brief LAR2V applies a vector of plane rotations with real cosines and real \n
     sines from both sides to a sequence of 2-by-2 symmetric/Hermitian matrices 
 * @details
 * \b Purpose:
    \verbatim 
    LAR2V applies a vector of real plane rotations from both sides to
    a sequence of 2-by-2 real symmetric matrices, defined by the elements
    of the vectors x, y and z. For i = 1,2,...,n

    (x(i)  z(i)) := ( c(i)  s(i)) (x(i)  z(i)) (c(i) -s(i))
    (z(i)  y(i))    (-s(i)  c(i)) (z(i)  y(i)) (s(i)  c(i))
    \endverbatim 

 * @param[in] N
          N is INTEGER \n
          The number of plane rotations to be applied. \n
 * @param[in,out] X
          X is REAL array,
                         dimension (1+(N-1)*INCX) \n
          The vector x. \n
 * @param[in,out] Y
          Y is REAL array,
                         dimension (1+(N-1)*INCX) \n
          The vector y. \n
 * @param[in,out] Z
          Z is REAL array,
                         dimension (1+(N-1)*INCX) \n
          The vector z. \n
 * @param[in] INCX
          INCX is INTEGER \n
          The increment between elements of X, Y and Z. INCX > 0. \n
 * @param[in] C
          C is REAL array, dimension (1+(N-1)*INCC) \n
          The cosines of the plane rotations. \n
 * @param[in] S
          S is REAL array, dimension (1+(N-1)*INCC) \n
          The sines of the plane rotations. \n
 * @param[in] INCC
          INCC is INTEGER \n
          The increment between elements of C and S. INCC > 0.  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lar2v(integer *n, T *x, T *y, T *z, integer *incx, T *c, T *s, integer *incc)
{
  return lar2v(n, x, y, z, incx, c, s, incc);
}
template< typename T, typename Ta >
integer lar2v(integer *n, T *x, T *y, T *z, integer *incx, Ta *c, T *s, integer *incc)
{
  return lar2v(n, x, y, z, incx, c, s, incc);
}

/*! @brief LARF applies an elementary reflector to a general rectangular matrix

 * @details
 * \b Purpose:
    \verbatim 
    LARF applies a real elementary reflector H to a real m by n matrix
    C, from either the left or the right. H is represented in the form

          H = I - tau * v * v**T

    where tau is a real scalar and v is a real vector.

    If tau = 0, then H is taken to be the unit matrix.
    \endverbatim  

 * @param[in] SIDE
          SIDE is CHARACTER*1 \n
          = 'L': form  H * C \n
          = 'R': form  C * H \n
 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix C. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix C. \n
 * @param[in] V
          V is REAL array, dimension \n
                     (1 + (M-1)*abs(INCV)) if SIDE = 'L' \n
                  or (1 + (N-1)*abs(INCV)) if SIDE = 'R' \n
          The vector v in the representation of H. V is not used if
          TAU = 0. \n
 * @param[in] INCV
          INCV is INTEGER \n
          The increment between elements of v. INCV <> 0. \n
 * @param[in] TAU
          TAU is REAL \n
          The value tau in the representation of H. \n
 * @param[in,out] C
          C is REAL array, dimension (LDC,N) \n
          On entry, the m by n matrix C. \n
          On exit, C is overwritten by the matrix H * C if SIDE = 'L',
          or C * H if SIDE = 'R'. \n
 * @param[in] LDC
          LDC is INTEGER \n
          The leading dimension of the array C. LDC >= max(1,M). \n
 * @param[out] WORK
          WORK is REAL array, dimension \n
                         (N) if SIDE = 'L' \n
                      or (M) if SIDE = 'R'  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer larf(char *side, integer *m, integer *n, T *v, integer *incv, T *tau, T *c, integer *ldc, T *work)
{
  return larf(side, m, n, v, incv, tau, c, ldc, work);
}

/*! @brief LARFY applies an elementary reflector, or Householder matrix, H, \n
     to an n x n symmetric matrix C, from both the left and the right
 * @details
 * \b Purpose:
    \verbatim 
    LARFY applies an elementary reflector, or Householder matrix, H,
    to an n x n symmetric matrix C, from both the left and the right.
   
    H is represented in the form
   
       H = I - tau * v * v'
   
    where  tau  is a scalar and  v  is a vector.
   
    If  tau  is  zero, then  H  is taken to be the unit matrix.
    \endverbatim

  * @param[in] UPLO
           UPLO is CHARACTER*1 \n
           Specifies whether the upper or lower triangular part of the
           symmetric matrix C is stored. \n
           = 'U':  Upper triangle \n
           = 'L':  Lower triangle \n
  * @param[in] N
           N is INTEGER \n
           The number of rows and columns of the matrix C.  N >= 0. \n
  * @param[in] V
           V is REAL array, dimension
                   (1 + (N-1)*abs(INCV)) \n
           The vector v as described above. \n
  * @param[in] INCV
           INCV is INTEGER \n
           The increment between successive elements of v.  INCV must
           not be zero. \n
  * @param[in] TAU
           TAU is REAL \n
           The value tau as described above. \n
  * @param[in,out] C
           C is REAL array, dimension (LDC, N) \n
           On entry, the matrix C.
           On exit, C is overwritten by H * C * H'. \n
  * @param[in] LDC
           LDC is INTEGER \n
           The leading dimension of the array C.  LDC >= max(1, N). \n
  * @param[out] WORK
           WORK is REAL array, dimension (N)   \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer larfy(char *uplo, integer *n, T *v, integer *incv, T *tau, T *c, integer *ldc, T *work)
{
  return larfy(uplo, n, v, incv, tau, c, ldc, work);
}

/*! @brief LARGV generates a vector of plane rotations with real cosines and real sines

 * @details
 * \b Purpose:
    \verbatim 
    LARGV generates a vector of real plane rotations, determined by
    elements of the real vectors x and y. For i = 1,2,...,n

       ( c(i)  s(i)) (x(i)) = (a(i))
       (-s(i)  c(i)) (y(i)) = (  0 )
    \endverbatim 

 * @param[in] N
          N is INTEGER \n
          The number of plane rotations to be generated. \n
 * @param[in,out] X
          X is REAL array,
                         dimension (1+(N-1)*INCX) \n
          On entry, the vector x.
          On exit, x(i) is overwritten by a(i), for i = 1,...,n. \n
 * @param[in] INCX
          INCX is INTEGER \n
          The increment between elements of X. INCX > 0. \n
 * @param[in,out] Y
          Y is REAL array,
                         dimension (1+(N-1)*INCY) \n
          On entry, the vector y.
          On exit, the sines of the plane rotations. \n
 * @param[in] INCY
          INCY is INTEGER \n
          The increment between elements of Y. INCY > 0. \n
 * @param[out] C
          C is REAL array, dimension (1+(N-1)*INCC) \n
          The cosines of the plane rotations. \n
 * @param[in] INCC
          INCC is INTEGER \n
          The increment between elements of C. INCC > 0. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer largv(integer *n, T *x, integer *incx, T *y, integer *incy, T *c, integer *incc)
{
  return largv(n, x, incx, y, incy, c, incc);
}
template< typename T, typename Ta >
integer largv(integer *n, T *x, integer *incx, T *y, integer *incy, Ta *c, integer *incc)
{
  return largv(n, x, incx, y, incy, c, incc);
}

/*! @brief LARRA computes the splitting points with the specified threshold

 * @details
 * \b Purpose:
    \verbatim
    Compute the splitting points with threshold SPLTOL.
    LARRA sets any "small" off-diagonal elements to zero.
    \endverbatim

 * @param[in] N
          N is INTEGER \n
          The order of the matrix. N > 0. \n
 * @param[in] D
          D is REAL array, dimension (N) \n
          On entry, the N diagonal elements of the tridiagonal
          matrix T. \n
 * @param[in,out] E
          E is REAL array, dimension (N) \n
          On entry, the first (N-1) entries contain the subdiagonal
          elements of the tridiagonal matrix T; E(N) need not be set.
          On exit, the entries E(ISPLIT(I)), 1 <= I <= NSPLIT,
          are set to zero, the other entries of E are untouched. \n
 * @param[in,out] E2
          E2 is REAL array, dimension (N) \n
          On entry, the first (N-1) entries contain the SQUARES of the
          subdiagonal elements of the tridiagonal matrix T;
          E2(N) need not be set. \n
          On exit, the entries E2(ISPLIT(I)),
          1 <= I <= NSPLIT, have been set to zero \n
 * @param[in] SPLTOL
          SPLTOL is REAL \n
          The threshold for splitting. Two criteria can be used:
          SPLTOL<0 : criterion based on absolute off-diagonal value
          SPLTOL>0 : criterion that preserves relative accuracy \n
 * @param[in] TNRM
          TNRM is REAL \n
          The norm of the matrix. \n
 * @param[out] NSPLIT
          NSPLIT is INTEGER \n
          The number of blocks T splits into. 1 <= NSPLIT <= N. \n
 * @param[out] ISPLIT
          ISPLIT is INTEGER array, dimension (N) \n
          The splitting points, at which T breaks up into blocks.
          The first block consists of rows/columns 1 to ISPLIT(1),
          the second of rows/columns ISPLIT(1)+1 through ISPLIT(2),
          etc., and the NSPLIT-th consists of rows/columns
          ISPLIT(NSPLIT-1)+1 through ISPLIT(NSPLIT)=N. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer larra(integer *n, T *d, T *e, T *e2, T * spltol, T *tnrm, integer *nsplit, integer *isplit, integer *info)
{
  return larra(n, d, e, e2, spltol, tnrm, nsplit, isplit, info); 
}

/*! @brief LARRB provides limited bisection to locate eigenvalues for more accuracy

 * @details
 * \b Purpose:
    \verbatim
    Given the relatively robust representation(RRR) L D L^T, SLARRB
    does "limited" bisection to refine the eigenvalues of L D L^T,
    W(IFIRST-OFFSET) through W(ILAST-OFFSET), to more accuracy. Initial
    guesses for these eigenvalues are input in W, the corresponding estimate
    of the error in these guesses and their gaps are input in WERR
    and WGAP, respectively. During bisection, intervals
    [left, right] are maintained by storing their mid-points and
    semi-widths in the arrays W and WERR respectively.
    \endverbatim

 * @param[in] N
          N is INTEGER \n
          The order of the matrix. \n
 * @param[in] D
          D is REAL array, dimension (N) \n
          The N diagonal elements of the diagonal matrix D. \n
 * @param[in] LLD
          LLD is REAL array, dimension (N-1) \n
          The (N-1) elements L(i)*L(i)*D(i). \n
 * @param[in] IFIRST
          IFIRST is INTEGER \n
          The index of the first eigenvalue to be computed. \n
 * @param[in] ILAST
          ILAST is INTEGER \n
          The index of the last eigenvalue to be computed. \n
 * @param[in] RTOL1
          RTOL1 is REAL \n
 * @param[in] RTOL2
          RTOL2 is REAL \n
          Tolerance for the convergence of the bisection intervals.
          An interval [LEFT,RIGHT] has converged if
          RIGHT-LEFT < MAX(RTOL1*GAP, RTOL2*MAX(|LEFT|,|RIGHT|))
          where GAP is the (estimated) distance to the nearest
          eigenvalue. \n
 * @param[in] OFFSET
          OFFSET is INTEGER \n
          Offset for the arrays W, WGAP and WERR, i.e., the IFIRST-OFFSET
          through ILAST-OFFSET elements of these arrays are to be used. \n
 * @param[in,out] W
          W is REAL array, dimension (N) \n
          On input, W(IFIRST-OFFSET) through W(ILAST-OFFSET) are
          estimates of the eigenvalues of L D L^T indexed IFIRST through
          ILAST. \n
          On output, these estimates are refined. \n
 * @param[in,out] WGAP
          WGAP is REAL array, dimension (N-1) \n
          On input, the (estimated) gaps between consecutive
          eigenvalues of L D L^T, i.e., WGAP(I-OFFSET) is the gap between
          eigenvalues I and I+1. Note that if IFIRST = ILAST
          then WGAP(IFIRST-OFFSET) must be set to ZERO. \n
          On output, these gaps are refined. \n
 * @param[in,out] WERR
          WERR is REAL array, dimension (N) \n
          On input, WERR(IFIRST-OFFSET) through WERR(ILAST-OFFSET) are
          the errors in the estimates of the corresponding elements in W.
          On output, these errors are refined. \n
 * @param[out] WORK
          WORK is REAL array, dimension (2*N) \n
          Workspace. \n
 * @param[out] IWORK
          IWORK is INTEGER array, dimension (2*N) \n
          Workspace. \n
 * @param[in] PIVMIN
          PIVMIN is REAL \n
          The minimum pivot in the Sturm sequence. \n
 * @param[in] SPDIAM
          SPDIAM is REAL \n
          The spectral diameter of the matrix. \n
 * @param[in] TWIST
          TWIST is INTEGER \n
          The twist index for the twisted factorization that is used
          for the negcount. \n
          TWIST = N: Compute negcount from L D L^T - LAMBDA I = L+ D+ L+^T \n
          TWIST = 1: Compute negcount from L D L^T - LAMBDA I = U- D- U-^T \n
          TWIST = R: Compute negcount from L D L^T - LAMBDA I = N(r) D(r) N(r) \n
 * @param[out] INFO
          INFO is INTEGER \n
          Error flag.  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer larrb(integer *n, T *d, T *lld, integer *ifirst, integer *ilast, T *rtol1, T *rtol2, integer *offset, T *w, T *wgap, T *werr, T *work, integer *iwork, T * pivmin, T *spdiam, integer *twist, integer *info)
{
  return larrb(n, d, lld, ifirst, ilast, rtol1, rtol2, offset, w, wgap, werr, work, iwork, pivmin, spdiam, twist, info); 
}

/*! @brief LARRC computes the number of eigenvalues of the symmetric tridiagonal matrix

 * @details
 * \b Purpose:
    \verbatim 
    Find the number of eigenvalues of the symmetric tridiagonal matrix T
    that are in the interval (VL,VU] if JOBT = 'T', and of L D L^T
    if JOBT = 'L'.
    \endverbatim  

 * @param[in] JOBT
          JOBT is CHARACTER*1 \n
          = 'T':  Compute Sturm count for matrix T. \n
          = 'L':  Compute Sturm count for matrix L D L^T. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix. N > 0. \n
 * @param[in] VL
          VL is REAL \n
          The lower bound for the eigenvalues. \n
 * @param[in] VU
          VU is REAL \n
          The upper bound for the eigenvalues. \n
 * @param[in] D
          D is REAL array, dimension (N) \n
          JOBT = 'T': The N diagonal elements of the tridiagonal matrix T. \n
          JOBT = 'L': The N diagonal elements of the diagonal matrix D. \n
 * @param[in] E
          E is REAL array, dimension (N) \n
          JOBT = 'T': The N-1 offdiagonal elements of the matrix T. \n
          JOBT = 'L': The N-1 offdiagonal elements of the matrix L. \n
 * @param[in] PIVMIN
          PIVMIN is REAL \n
          The minimum pivot in the Sturm sequence for T. \n
 * @param[out] EIGCNT
          EIGCNT is INTEGER \n
          The number of eigenvalues of the symmetric tridiagonal matrix T
          that are in the interval (VL,VU] \n
 * @param[out] LCNT
          LCNT is INTEGER \n
 * @param[out] RCNT
          RCNT is INTEGER \n
          The left and right negcounts of the interval. \n
 * @param[out] INFO
          INFO is INTEGER  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer larrc(char *jobt, integer *n, T *vl, T *vu, T *d, T *e, T *pivmin, integer *eigcnt, integer *lcnt, integer * rcnt, integer *info)
{
  return larrc(jobt, n, vl, vu, d, e, pivmin, eigcnt, lcnt, rcnt, info); 
}

/*! @brief LARRD computes the eigenvalues of a symmetric tridiagonal matrix to suitable accuracy

 * @details
 * \b Purpose:
    \verbatim
    LARRD computes the eigenvalues of a symmetric tridiagonal
    matrix T to suitable accuracy. This is an auxiliary code to be
    called from SSTEMR.
    The user may ask for all eigenvalues, all eigenvalues
    in the half-open interval (VL, VU], or the IL-th through IU-th
    eigenvalues.

    To avoid overflow, the matrix must be scaled so that its
    largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest
    accuracy, it should not be much smaller than that.

    See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
    Matrix", Report CS41, Computer Science Dept., Stanford
    University, July 21, 1966.
    \endverbatim

 * @param[in] RANGE
          RANGE is CHARACTER*1 \n
          = 'A': ("All")   all eigenvalues will be found. \n
          = 'V': ("Value") all eigenvalues in the half-open interval
                           (VL, VU] will be found. \n
          = 'I': ("Index") the IL-th through IU-th eigenvalues (of the
                           entire matrix) will be found. \n
 * @param[in] ORDER
          ORDER is CHARACTER*1 \n
          = 'B': ("By Block") the eigenvalues will be grouped by
                              split-off block (see IBLOCK, ISPLIT) and
                              ordered from smallest to largest within
                              the block. \n
          = 'E': ("Entire matrix") \n
                              the eigenvalues for the entire matrix
                              will be ordered from smallest to
                              largest. \n
 * @param[in] N
          N is INTEGER \n
          The order of the tridiagonal matrix T.  N >= 0. \n
 * @param[in] VL
          VL is REAL \n
          If RANGE='V', the lower bound of the interval to
          be searched for eigenvalues.  Eigenvalues less than or equal
          to VL, or greater than VU, will not be   returned.  VL < VU. \n
          Not referenced if RANGE = 'A' or 'I'. \n
 * @param[in] VU
          VU is REAL \n
          If RANGE='V', the upper bound of the interval to
          be searched for eigenvalues.  Eigenvalues less than or equal
          to VL, or greater than VU, will not be   returned.  VL < VU. \n
          Not referenced if RANGE = 'A' or 'I'. \n
 * @param[in] IL
          IL is INTEGER \n
          If RANGE='I', the index of the
          smallest eigenvalue to be   returned. \n
          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0. \n
          Not referenced if RANGE = 'A' or 'V'. \n
 * @param[in] IU
          IU is INTEGER \n
          If RANGE='I', the index of the
          largest eigenvalue to be   returned. \n
          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0. \n
          Not referenced if RANGE = 'A' or 'V'. \n
 * @param[in] GERS
          GERS is REAL array, dimension (2*N) \n
          The N Gerschgorin intervals (the i-th Gerschgorin interval
          is (GERS(2*i-1), GERS(2*i)). \n
 * @param[in] RELTOL
          RELTOL is REAL \n
          The minimum relative width of an interval.  When an interval
          is narrower than RELTOL times the larger (in
          magnitude) endpoint, then it is considered to be
          sufficiently small, i.e., converged.  Note: this should
          always be at least radix*machine epsilon. \n
 * @param[in] D
          D is REAL array, dimension (N) \n
          The n diagonal elements of the tridiagonal matrix T. \n
 * @param[in] E
          E is REAL array, dimension (N-1) \n
          The (n-1) off-diagonal elements of the tridiagonal matrix T. \n
 * @param[in] E2
          E2 is REAL array, dimension (N-1) \n
          The (n-1) squared off-diagonal elements of the tridiagonal matrix T. \n
 * @param[in] PIVMIN
          PIVMIN is REAL \n
          The minimum pivot allowed in the Sturm sequence for T. \n
 * @param[in] NSPLIT
          NSPLIT is INTEGER \n
          The number of diagonal blocks in the matrix T.
          1 <= NSPLIT <= N. \n
 * @param[in] ISPLIT
          ISPLIT is INTEGER array, dimension (N) \n
          The splitting points, at which T breaks up into submatrices.
          The first submatrix consists of rows/columns 1 to ISPLIT(1),
          the second of rows/columns ISPLIT(1)+1 through ISPLIT(2),
          etc., and the NSPLIT-th consists of rows/columns
          ISPLIT(NSPLIT-1)+1 through ISPLIT(NSPLIT)=N. \n
          (Only the first NSPLIT elements will actually be used, but
          since the user cannot know a priori what value NSPLIT will
          have, N words must be reserved for ISPLIT.) \n
 * @param[out] M
          M is INTEGER \n
          The actual number of eigenvalues found. 0 <= M <= N.
          (See also the description of INFO=2,3.) \n
 * @param[out] W
          W is REAL array, dimension (N) \n
          On exit, the first M elements of W will contain the
          eigenvalue approximations. SLARRD computes an interval
          I_j = (a_j, b_j] that includes eigenvalue j. The eigenvalue
          approximation is given as the interval midpoint
          W(j)= (a_j + b_j)/2. The corresponding error is bounded by
          WERR(j) = abs(a_j - b_j)/2 \n
 * @param[out] WERR
          WERR is REAL array, dimension (N) \n
          The error bound on the corresponding eigenvalue approximation
          in W. \n
 * @param[out] WL
          WL is REAL \n
 * @param[out] WU
          WU is REAL \n
          The interval (WL, WU] contains all the wanted eigenvalues. \n
          If RANGE='V', then WL=VL and WU=VU. \n
          If RANGE='A', then WL and WU are the global Gerschgorin bounds
                        on the spectrum. \n
          If RANGE='I', then WL and WU are computed by SLAEBZ from the
                        index range specified. \n
 * @param[out] IBLOCK
          IBLOCK is INTEGER array, dimension (N) \n
          At each row/column j where E(j) is zero or small, the
          matrix T is considered to split into a block diagonal
          matrix.  On exit, if INFO = 0, IBLOCK(i) specifies to which
          block (from 1 to the number of blocks) the eigenvalue W(i)
          belongs.  (SLARRD may use the remaining N-M elements as
          workspace.) \n
 * @param[out] INDEXW
          INDEXW is INTEGER array, dimension (N) \n
          The indices of the eigenvalues within each block (submatrix);
          for example, INDEXW(i)= j and IBLOCK(i)=k imply that the
          i-th eigenvalue W(i) is the j-th eigenvalue in block k. \n
 * @param[out] WORK
          WORK is REAL array, dimension (4*N) \n
 * @param[out] IWORK
          IWORK is INTEGER array, dimension (3*N) \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  some or all of the eigenvalues failed to converge or
                were not computed: \n
                =1 or 3: Bisection failed to converge for some
                        eigenvalues; these eigenvalues are flagged by a
                        negative block number.  The effect is that the
                        eigenvalues may not be as accurate as the
                        absolute and relative tolerances.  This is
                        generally caused by unexpectedly inaccurate
                        arithmetic. \n
                =2 or 3: RANGE='I' only: Not all of the eigenvalues
                        IL:IU were found. \n
                        Effect: M < IU+1-IL \n
                        Cause:  non-monotonic arithmetic, causing the
                                Sturm sequence to be non-monotonic. \n
                        Cure:   recalculate, using RANGE='A', and pick
                                out eigenvalues IL:IU.  In some cases,
                                increasing the PARAMETER "FUDGE" may
                                make things work. \n
                = 4:    RANGE='I', and the Gershgorin interval
                        initially used was too small.  No eigenvalues
                        were computed. \n
                        Probable cause: your machine has sloppy
                                        floating-point arithmetic. \n
                        Cure: Increase the PARAMETER "FUDGE",
                              recompile, and try again.  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer larrd(char *range, char *order, integer *n, T *vl, T *vu, integer *il, integer *iu, T *gers, T *reltol, T * d, T *e, T *e2, T *pivmin, integer *nsplit, integer * isplit, integer *m, T *w, T *werr, T *wl, T *wu, integer * iblock, integer *indexw, T *work, integer *iwork, integer *info)
{
  return larrd(range, order, n, vl, vu, il, iu, gers, reltol, d, e, e2, pivmin, nsplit, isplit, m, w, werr, wl, wu, iblock, indexw, work, iwork, info); 
}

/*! @brief LARRE given the tridiagonal matrix T, sets small off-diagonal elements to \n
     zero and for each unreduced block Ti, finds base representations and eigenvalues
 * @details
 * \b Purpose:
    \verbatim 
    To find the desired eigenvalues of a given real symmetric
    tridiagonal matrix T, SLARRE sets any "small" off-diagonal
    elements to zero, and for each unreduced block T_i, it finds
    (a) a suitable shift at one end of the block's spectrum,
    (b) the base representation, T_i - sigma_i I = L_i D_i L_i^T, and
    (c) eigenvalues of each L_i D_i L_i^T.
    The representations and eigenvalues found are then used by
    SSTEMR to compute the eigenvectors of T.
    The accuracy varies depending on whether bisection is used to
    find a few eigenvalues or the dqds algorithm (subroutine SLASQ2) to
    conpute all and then discard any unwanted one.
    As an added benefit, SLARRE also outputs the n
    Gerschgorin intervals for the matrices L_i D_i L_i^T.
    \endverbatim 

 * @param[in] RANGE
          RANGE is CHARACTER*1 \n
          = 'A': ("All")   all eigenvalues will be found. \n
          = 'V': ("Value") all eigenvalues in the half-open interval
                           (VL, VU] will be found. \n
          = 'I': ("Index") the IL-th through IU-th eigenvalues (of the
                           entire matrix) will be found. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix. N > 0. \n
 * @param[in,out] VL
          VL is REAL \n
          If RANGE='V', the lower bound for the eigenvalues.
          Eigenvalues less than or equal to VL, or greater than VU,
          will not be   returned.  VL < VU. \n
          If RANGE='I' or ='A', SLARRE computes bounds on the desired
          part of the spectrum. \n
 * @param[in,out] VU
          VU is REAL \n
          If RANGE='V', the upper bound for the eigenvalues.
          Eigenvalues less than or equal to VL, or greater than VU,
          will not be   returned.  VL < VU. \n
          If RANGE='I' or ='A', SLARRE computes bounds on the desired
          part of the spectrum. \n
 * @param[in] IL
          IL is INTEGER \n
          If RANGE='I', the index of the
          smallest eigenvalue to be   returned. \n
          1 <= IL <= IU <= N. \n
 * @param[in] IU
          IU is INTEGER \n
          If RANGE='I', the index of the
          largest eigenvalue to be   returned. \n
          1 <= IL <= IU <= N. \n
 * @param[in,out] D
          D is REAL array, dimension (N) \n
          On entry, the N diagonal elements of the tridiagonal
          matrix T. \n
          On exit, the N diagonal elements of the diagonal
          matrices D_i. \n
 * @param[in,out] E
          E is REAL array, dimension (N) \n
          On entry, the first (N-1) entries contain the subdiagonal
          elements of the tridiagonal matrix T; E(N) need not be set. \n
          On exit, E contains the subdiagonal elements of the unit
          bidiagonal matrices L_i. The entries E(ISPLIT(I)), \n
          1 <= I <= NSPLIT, contain the base points sigma_i on output. \n
 * @param[in,out] E2
          E2 is REAL array, dimension (N) \n
          On entry, the first (N-1) entries contain the SQUARES of the
          subdiagonal elements of the tridiagonal matrix T;
          E2(N) need not be set. \n
          On exit, the entries E2(ISPLIT(I)),
          1 <= I <= NSPLIT, have been set to zero \n
 * @param[in] RTOL1
          RTOL1 is REAL \n
 * @param[in] RTOL2
          RTOL2 is REAL \n
          Parameters for bisection. \n
          An interval [LEFT,RIGHT] has converged if
          RIGHT-LEFT < MAX(RTOL1*GAP, RTOL2*MAX(|LEFT|,|RIGHT|)) \n
 * @param[in] SPLTOL
          SPLTOL is REAL \n
          The threshold for splitting. \n
 * @param[out] NSPLIT
          NSPLIT is INTEGER \n
          The number of blocks T splits into. 1 <= NSPLIT <= N. \n
 * @param[out] ISPLIT
          ISPLIT is INTEGER array, dimension (N) \n
          The splitting points, at which T breaks up into blocks.
          The first block consists of rows/columns 1 to ISPLIT(1),
          the second of rows/columns ISPLIT(1)+1 through ISPLIT(2),
          etc., and the NSPLIT-th consists of rows/columns
          ISPLIT(NSPLIT-1)+1 through ISPLIT(NSPLIT)=N. \n
 * @param[out] M
          M is INTEGER \n
          The total number of eigenvalues (of all L_i D_i L_i^T) \n
          found.
 * @param[out] W
          W is REAL array, dimension (N) \n
          The first M elements contain the eigenvalues. The
          eigenvalues of each of the blocks, L_i D_i L_i^T, are
          sorted in ascending order (SLARRE may use the
          remaining N-M elements as workspace). \n
 * @param[out] WERR
          WERR is REAL array, dimension (N) \n
          The error bound on the corresponding eigenvalue in W. \n
 * @param[out] WGAP
          WGAP is REAL array, dimension (N) \n
          The separation from the right neighbor eigenvalue in W.
          The gap is only with respect to the eigenvalues of the same block
          as each block has its own representation tree.
          Exception: at the right end of a block we store the left gap \n
 * @param[out] IBLOCK
          IBLOCK is INTEGER array, dimension (N) \n
          The indices of the blocks (submatrices) associated with the
          corresponding eigenvalues in W; IBLOCK(i)=1 if eigenvalue
          W(i) belongs to the first block from the top, =2 if W(i)
          belongs to the second block, etc. \n
 * @param[out] INDEXW
          INDEXW is INTEGER array, dimension (N) \n
          The indices of the eigenvalues within each block (submatrix);
          for example, INDEXW(i)= 10 and IBLOCK(i)=2 imply that the
          i-th eigenvalue W(i) is the 10-th eigenvalue in block 2 \n
 * @param[out] GERS
          GERS is REAL array, dimension (2*N) \n
          The N Gerschgorin intervals (the i-th Gerschgorin interval
          is (GERS(2*i-1), GERS(2*i)). \n
 * @param[out] PIVMIN
          PIVMIN is REAL \n
          The minimum pivot in the Sturm sequence for T. \n
 * @param[out] WORK
          WORK is REAL array, dimension (6*N) \n
          Workspace. \n
 * @param[out] IWORK
          IWORK is INTEGER array, dimension (5*N) \n
          Workspace. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit \n
          > 0:  A problem occurred in SLARRE. \n
          < 0:  One of the called subroutines signaled an internal problem.
                Needs inspection of the corresponding parameter IINFO
                for further information. \n
          =-1:  Problem in SLARRD. \n
          = 2:  No base representation could be found in MAXTRY iterations.
                Increasing MAXTRY and recompilation might be a remedy. \n
          =-3:  Problem in SLARRB when computing the refined root
                representation for SLASQ2. \n
          =-4:  Problem in SLARRB when preforming bisection on the
                desired part of the spectrum. \n
          =-5:  Problem in SLASQ2. \n
          =-6:  Problem in SLASQ2.  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer larre(char *range, integer *n, T *vl, T *vu, integer *il, integer *iu, T *d, T *e, T *e2, T *rtol1, T *rtol2, T *spltol, integer *nsplit, integer *isplit, integer * m, T *w, T *werr, T *wgap, integer *iblock, integer *indexw, T *gers, T *pivmin, T *work, integer *iwork, integer *info)
{
  return larre(range, n, vl, vu, il, iu, d, e, e2, rtol1, rtol2, spltol, nsplit, isplit, m, w, werr, wgap, iblock, indexw, gers, pivmin, work, iwork, info); 
}

/*! @brief LARRF finds a new relatively robust representation such that at least \n
     one of the eigenvalues is relatively isolated
 * @details
 * \b Purpose:
    \verbatim 
    Given the initial representation L D L^T and its cluster of close
    eigenvalues (in a relative measure), W(CLSTRT), W(CLSTRT+1), ...
    W(CLEND), SLARRF finds a new relatively robust representation
    L D L^T - SIGMA I = L(+) D(+) L(+)^T such that at least one of the
    eigenvalues of L(+) D(+) L(+)^T is relatively isolated.
    \endverbatim 

 * @param[in] N
          N is INTEGER \n
          The order of the matrix (subblock, if the matrix split). \n
 * @param[in] D
          D is REAL array, dimension (N) \n
          The N diagonal elements of the diagonal matrix D. \n
 * @param[in] L
          L is REAL array, dimension (N-1) \n
          The (N-1) subdiagonal elements of the unit bidiagonal
          matrix L. \n
 * @param[in] LD
          LD is REAL array, dimension (N-1) \n
          The (N-1) elements L(i)*D(i). \n
 * @param[in] CLSTRT
          CLSTRT is INTEGER \n
          The index of the first eigenvalue in the cluster. \n
 * @param[in] CLEND
          CLEND is INTEGER \n
          The index of the last eigenvalue in the cluster. \n
 * @param[in] W
          W is REAL array, dimension \n
          dimension is >=  (CLEND-CLSTRT+1) \n
          The eigenvalue APPROXIMATIONS of L D L^T in ascending order.
          W(CLSTRT) through W(CLEND) form the cluster of relatively
          close eigenalues. \n
 * @param[in,out] WGAP
          WGAP is REAL array, dimension \n
          dimension is >=  (CLEND-CLSTRT+1) \n
          The separation from the right neighbor eigenvalue in W. \n
 * @param[in] WERR
          WERR is REAL array, dimension \n
          dimension is >=  (CLEND-CLSTRT+1) \n
          WERR contain the semiwidth of the uncertainty
          interval of the corresponding eigenvalue APPROXIMATION in W \n
 * @param[in] SPDIAM
          SPDIAM is REAL \n
          estimate of the spectral diameter obtained from the
          Gerschgorin intervals \n
 * @param[in] CLGAPL
          CLGAPL is REAL \n
 * @param[in] CLGAPR
          CLGAPR is REAL \n
          absolute gap on each end of the cluster.
          Set by the calling routine to protect against shifts too close
          to eigenvalues outside the cluster. \n
 * @param[in] PIVMIN
          PIVMIN is REAL \n
          The minimum pivot allowed in the Sturm sequence. \n
 * @param[out] SIGMA
          SIGMA is REAL \n
          The shift used to form L(+) D(+) L(+)^T. \n
 * @param[out] DPLUS
          DPLUS is REAL array, dimension (N) \n
          The N diagonal elements of the diagonal matrix D(+). \n
 * @param[out] LPLUS
          LPLUS is REAL array, dimension (N-1) \n
          The first (N-1) elements of LPLUS contain the subdiagonal
          elements of the unit bidiagonal matrix L(+). \n
 * @param[out] WORK
          WORK is REAL array, dimension (2*N) \n
          Workspace. \n
 * @param[out] INFO
          INFO is INTEGER \n
          Signals processing OK (=0) or failure (=1) \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer larrf(integer *n, T *d, T *l, T *ld, integer *clstrt, integer *clend, T *w, T *wgap, T *werr, T *spdiam, T *clgapl, T *clgapr, T *pivmin, T *sigma, T *dplus, T *lplus, T *work, integer *info)
{
  return larrf(n, d, l, ld, clstrt, clend, w, wgap, werr, spdiam, clgapl, clgapr, pivmin, sigma, dplus, lplus, work, info); 
}

/*! @brief LARRJ performs refinement of the initial estimates of the eigenvalues of the matrix T

 * @details
 * \b Purpose:
    \verbatim 
    Given the initial eigenvalue approximations of T, SLARRJ
    does  bisection to refine the eigenvalues of T,
    W(IFIRST-OFFSET) through W(ILAST-OFFSET), to more accuracy. Initial
    guesses for these eigenvalues are input in W, the corresponding estimate
    of the error in these guesses in WERR. During bisection, intervals
    [left, right] are maintained by storing their mid-points and
    semi-widths in the arrays W and WERR respectively.
    \endverbatim 

 * @param[in] N
          N is INTEGER \n
          The order of the matrix. \n
 * @param[in] D
          D is REAL array, dimension (N) \n
          The N diagonal elements of T. \n
 * @param[in] E2
          E2 is REAL array, dimension (N-1) \n
          The Squares of the (N-1) subdiagonal elements of T. \n
 * @param[in] IFIRST
          IFIRST is INTEGER \n
          The index of the first eigenvalue to be computed. \n
 * @param[in] ILAST
          ILAST is INTEGER \n
          The index of the last eigenvalue to be computed. \n
 * @param[in] RTOL
          RTOL is REAL \n
          Tolerance for the convergence of the bisection intervals.
          An interval [LEFT,RIGHT] has converged if
          RIGHT-LEFT < RTOL*MAX(|LEFT|,|RIGHT|). \n
 * @param[in] OFFSET
          OFFSET is INTEGER \n
          Offset for the arrays W and WERR, i.e., the IFIRST-OFFSET
          through ILAST-OFFSET elements of these arrays are to be used. \n
 * @param[in,out] W
          W is REAL array, dimension (N) \n
          On input, W(IFIRST-OFFSET) through W(ILAST-OFFSET) are
          estimates of the eigenvalues of L D L^T indexed IFIRST through
          ILAST. \n
          On output, these estimates are refined. \n
 * @param[in,out] WERR
          WERR is REAL array, dimension (N) \n
          On input, WERR(IFIRST-OFFSET) through WERR(ILAST-OFFSET) are
          the errors in the estimates of the corresponding elements in W.
          On output, these errors are refined. \n
 * @param[out] WORK
          WORK is REAL array, dimension (2*N) \n
          Workspace. \n
 * @param[out] IWORK
          IWORK is INTEGER array, dimension (2*N) \n
          Workspace. \n
 * @param[in] PIVMIN
          PIVMIN is REAL \n
          The minimum pivot in the Sturm sequence for T. \n
 * @param[in] SPDIAM
          SPDIAM is REAL \n
          The spectral diameter of T. \n
 * @param[out] INFO
          INFO is INTEGER \n
          Error flag. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer larrj(integer *n, T *d, T *e2, integer *ifirst, integer *ilast, T *rtol, integer *offset, T *w, T *werr, T *work, integer *iwork, T *pivmin, T *spdiam, integer *info)
{
  return larrj(n, d, e2, ifirst, ilast, rtol, offset, w, werr, work, iwork, pivmin, spdiam, info); 
}

/*! @brief LARRK computes one eigenvalue of a symmetric tridiagonal matrix T to suitable accuracy

 * @details
 * \b Purpose:
    \verbatim 
    LARRK computes one eigenvalue of a symmetric tridiagonal
    matrix T to suitable accuracy. This is an auxiliary code to be
    called from SSTEMR.

    To avoid overflow, the matrix must be scaled so that its
    largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest
    accuracy, it should not be much smaller than that.

    See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
    Matrix", Report CS41, Computer Science Dept., Stanford
    University, July 21, 1966.
    \endverbatim 

 * @param[in] N
          N is INTEGER \n
          The order of the tridiagonal matrix T.  N >= 0. \n
 * @param[in] IW
          IW is INTEGER \n
          The index of the eigenvalues to be returned. \n
 * @param[in] GL
          GL is REAL \n
 * @param[in] GU
          GU is REAL \n
          An upper and a lower bound on the eigenvalue. \n
 * @param[in] D
          D is REAL array, dimension (N) \n
          The n diagonal elements of the tridiagonal matrix T. \n
 * @param[in] E2
          E2 is REAL array, dimension (N-1) \n
          The (n-1) squared off-diagonal elements of the tridiagonal matrix T. \n
 * @param[in] PIVMIN
          PIVMIN is REAL \n
          The minimum pivot allowed in the Sturm sequence for T. \n
 * @param[in] RELTOL
          RELTOL is REAL \n
          The minimum relative width of an interval.  When an interval
          is narrower than RELTOL times the larger (in
          magnitude) endpoint, then it is considered to be
          sufficiently small, i.e., converged.  Note: this should
          always be at least radix*machine epsilon. \n
 * @param[out] W
          W is REAL \n
 * @param[out] WERR
          WERR is REAL \n
          The error bound on the corresponding eigenvalue approximation
          in W. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:       Eigenvalue converged \n
          = -1:      Eigenvalue did NOT converge  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer larrk(integer *n, integer *iw, T *gl, T *gu, T *d, T *e2, T *pivmin, T *reltol, T *w, T *werr, integer *info)
{
  return larrk(n, iw, gl, gu, d, e2, pivmin, reltol, w, werr, info); 
}

/*! @brief LARRR performs tests to decide whether the symmetric tridiagonal matrix T \n
     warrants expensive computations which guarantee high relative accuracy in the   \n
     eigenvalues
 * @details
 * \b Purpose:
    \verbatim 
    Perform tests to decide whether the symmetric tridiagonal matrix T
    warrants expensive computations which guarantee high relative accuracy
    in the eigenvalues.
    \endverbatim 

 * @param[in] N
          N is INTEGER \n
          The order of the matrix. N > 0. \n
 * @param[in] D
          D is REAL array, dimension (N) \n
          The N diagonal elements of the tridiagonal matrix T. \n
 * @param[in,out] E
          E is REAL array, dimension (N) \n
          On entry, the first (N-1) entries contain the subdiagonal
          elements of the tridiagonal matrix T; E(N) is set to ZERO. \n
 * @param[out] INFO
          INFO is INTEGER \n
          INFO = 0(default) : the matrix warrants computations preserving
                              relative accuracy. \n
          INFO = 1          : the matrix warrants computations guaranteeing
                              only absolute accuracy.  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer larrr(integer *n, T *d, T *e, integer *info)
{
  return larrr(n, d, e, info);   
}

/*! @brief LARRV computes the eigenvectors of the tridiagonal matrix T = L D LT    \n
     given L, D and the eigenvalues of L D LT
 * @details
 * \b Purpose:
    \verbatim 
    LARRV computes the eigenvectors of the tridiagonal matrix
    T = L D L**T given L, D and APPROXIMATIONS to the eigenvalues of L D L**T.
    The input eigenvalues should have been computed by LARRE.
    \endverbatim 

 * @param[in] N
          N is INTEGER \n
          The order of the matrix.  N >= 0. \n
 * @param[in] VL
          VL is REAL \n
          Lower bound of the interval that contains the desired
          eigenvalues. VL < VU. Needed to compute gaps on the left or right
          end of the extremal eigenvalues in the desired RANGE. \n
 * @param[in] VU
          VU is REAL \n
          Upper bound of the interval that contains the desired
          eigenvalues. VL < VU.  \n
          Note: VU is currently not used by this implementation of SLARRV, VU is
          passed to SLARRV because it could be used compute gaps on the right end
          of the extremal eigenvalues. However, with not much initial accuracy in
          LAMBDA and VU, the formula can lead to an overestimation of the right gap
          and thus to inadequately early RQI 'convergence'. This is currently
          prevented this by forcing a small right gap. And so it turns out that VU
          is currently not used by this implementation of SLARRV. \n
 * @param[in,out] D
          D is REAL array, dimension (N) \n
          On entry, the N diagonal elements of the diagonal matrix D.
          On exit, D may be overwritten. \n
 * @param[in,out] L
          L is REAL array, dimension (N) \n
          On entry, the (N-1) subdiagonal elements of the unit
          bidiagonal matrix L are in elements 1 to N-1 of L
          (if the matrix is not split.) At the end of each block
          is stored the corresponding shift as given by SLARRE. \n
          On exit, L is overwritten. \n
 * @param[in] PIVMIN
          PIVMIN is REAL \n
          The minimum pivot allowed in the Sturm sequence. \n
 * @param[in] ISPLIT
          ISPLIT is INTEGER array, dimension (N) \n
          The splitting points, at which T breaks up into blocks.
          The first block consists of rows/columns 1 to
          ISPLIT(1), the second of rows/columns ISPLIT(1)+1
          through ISPLIT(2), etc. \n
 * @param[in] M
          M is INTEGER \n
          The total number of input eigenvalues.  0 <= M <= N. \n
 * @param[in] DOL
          DOL is INTEGER \n
 * @param[in] DOU
          DOU is INTEGER \n
          If the user wants to compute only selected eigenvectors from all
          the eigenvalues supplied, he can specify an index range DOL:DOU.
          Or else the setting DOL=1, DOU=M should be applied.
          Note that DOL and DOU refer to the order in which the eigenvalues
          are stored in W. \n
          If the user wants to compute only selected eigenpairs, then
          the columns DOL-1 to DOU+1 of the eigenvector space Z contain the
          computed eigenvectors. All other columns of Z are set to zero. \n
 * @param[in] MINRGP
          MINRGP is REAL \n
 * @param[in] RTOL1
          RTOL1 is REAL \n
 * @param[in] RTOL2
          RTOL2 is REAL \n
          Parameters for bisection. \n
          An interval [LEFT,RIGHT] has converged if
          RIGHT-LEFT < MAX(RTOL1*GAP, RTOL2*MAX(|LEFT|,|RIGHT|)) \n
 * @param[in,out] W
          W is REAL array, dimension (N) \n
          The first M elements of W contain the APPROXIMATE eigenvalues for
          which eigenvectors are to be computed.  The eigenvalues
          should be grouped by split-off block and ordered from
          smallest to largest within the block (The output array
          W from SLARRE is expected here). Furthermore, they are with
          respect to the shift of the corresponding root representation
          for their block. On exit, W holds the eigenvalues of the
          UNshifted matrix. \n
 * @param[in,out] WERR
          WERR is REAL array, dimension (N) \n
          The first M elements contain the semiwidth of the uncertainty
          interval of the corresponding eigenvalue in W \n
 * @param[in,out] WGAP
          WGAP is REAL array, dimension (N) \n
          The separation from the right neighbor eigenvalue in W. \n
 * @param[in] IBLOCK
          IBLOCK is INTEGER array, dimension (N) \n
          The indices of the blocks (submatrices) associated with the
          corresponding eigenvalues in W; IBLOCK(i)=1 if eigenvalue
          W(i) belongs to the first block from the top, =2 if W(i)
          belongs to the second block, etc. \n
 * @param[in] INDEXW
          INDEXW is INTEGER array, dimension (N) \n
          The indices of the eigenvalues within each block (submatrix);
          for example, INDEXW(i)= 10 and IBLOCK(i)=2 imply that the
          i-th eigenvalue W(i) is the 10-th eigenvalue in the second block. \n
 * @param[in] GERS
          GERS is REAL array, dimension (2*N) \n
          The N Gerschgorin intervals (the i-th Gerschgorin interval
          is (GERS(2*i-1), GERS(2*i)). The Gerschgorin intervals should
          be computed from the original UNshifted matrix. \n
 * @param[out] Z
          Z is REAL array, dimension (LDZ, max(1,M)) \n
          If INFO = 0, the first M columns of Z contain the
          orthonormal eigenvectors of the matrix T
          corresponding to the input eigenvalues, with the i-th
          column of Z holding the eigenvector associated with W(i).
          Note: the user must ensure that at least max(1,M) columns are
          supplied in the array Z. \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of the array Z.  LDZ >= 1, and if
          JOBZ = 'V', LDZ >= max(1,N). \n
 * @param[out] ISUPPZ
          ISUPPZ is INTEGER array, dimension (2*max(1,M)) \n
          The support of the eigenvectors in Z, i.e., the indices
          indicating the nonzero elements in Z. The I-th eigenvector
          is nonzero only in elements ISUPPZ(2*I-1) through
          ISUPPZ(2*I). \n
 * @param[out] WORK
          WORK is REAL array, dimension (12*N) \n
 * @param[out] IWORK
          IWORK is INTEGER array, dimension (7*N) \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit \n
          > 0:  A problem occurred in SLARRV. \n
          < 0:  One of the called subroutines signaled an internal problem.
                Needs inspection of the corresponding parameter IINFO
                for further information. \n
          =-1:  Problem in SLARRB when refining a child's eigenvalues. \n
          =-2:  Problem in SLARRF when computing the RRR of a child.
                When a child is inside a tight cluster, it can be difficult
                to find an RRR. A partial remedy from the user's point of
                view is to make the parameter MINRGP smaller and recompile.
                However, as the orthogonality of the computed vectors is
                proportional to 1/MINRGP, the user should be aware that
                he might be trading in precision when he decreases MINRGP. \n
          =-3:  Problem in SLARRB when refining a single eigenvalue
                after the Rayleigh correction was rejected. \n
          = 5:  The Rayleigh Quotient Iteration failed to converge to
                full accuracy in MAXITR steps.  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer larrv(integer *n, T *vl, T *vu, T *d, T *l, T *pivmin, integer *isplit, integer *m, integer *dol, integer *dou, T *minrgp, T *rtol1, T *rtol2, T *w, T *werr, T *wgap, integer *iblock, integer *indexw, T *gers, T *z, integer *ldz, integer *isuppz, T *work, integer *iwork, integer * info)
{
  return larrv(n, vl, vu, d, l, pivmin, isplit, m, dol, dou, minrgp, rtol1, rtol2, w, werr, wgap, iblock, indexw, gers, z, ldz, isuppz, work, iwork, info);
}
template< typename T, typename Ta >
integer larrv(integer *n, Ta *vl, Ta *vu, Ta *d, Ta *l, Ta *pivmin, integer *isplit, integer *m, integer *dol, integer *dou, Ta *minrgp, Ta *rtol1, Ta *rtol2, Ta *w, Ta *werr, Ta *wgap, integer *iblock, integer *indexw, Ta *gers, T *z, integer *ldz, integer *isuppz, Ta *work, integer *iwork, integer * info)
{
  return larrv(n, vl, vu, d, l, pivmin, isplit, m, dol, dou, minrgp, rtol1, rtol2, w, werr, wgap, iblock, indexw, gers, z, ldz, isuppz, work, iwork, info);
}

/*! @brief LARSCL2 performs reciprocal diagonal scaling on a vector

 * @details
 * \b Purpose:
    \verbatim 
    LARSCL2 performs a reciprocal diagonal scaling on an vector:
      x <-- inv(D) * x
    where the diagonal matrix D is stored as a vector.

    Eventually to be replaced by BLAS_sge_diag_scale in the new BLAS
    standard.
    \endverbatim 

 * @param[in] M
          M is INTEGER \n
          The number of rows of D and X. M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of X. N >= 0. \n
 * @param[in] D
          D is REAL array, length M \n
          Diagonal matrix D, stored as a vector of length M. \n
 * @param[in,out] X
          X is REAL array, dimension (LDX,N) \n
          On entry, the vector X to be scaled by D.
          On exit, the scaled vector. \n
 * @param[in] LDX
          LDX is INTEGER \n
          The leading dimension of the vector X. LDX >= M.  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer larscl2(integer *m, integer *n, T *d, T *x, integer *ldx)
{
  return larscl2(m, n, d, x, ldx);
}
template< typename T, typename Ta >
integer larscl2(integer *m, integer *n, Ta *d, T *x, integer *ldx)
{
  return larscl2(m, n, d, x, ldx);
}

/*! @brief LARTG generates a plane rotation with real cosine and real sine

 * @details
 * \b Purpose:
    \verbatim 
    LARTG generate a plane rotation so that

       [  CS  SN  ]  .  [ F ]  =  [ R ]   where CS**2 + SN**2 = 1.
       [ -SN  CS  ]     [ G ]     [ 0 ]

    This is a slower, more accurate version of the BLAS1 routine SROTG,
    with the following other differences:
       F and G are unchanged on   return.
       If G=0, then CS=1 and SN=0.
       If F=0 and (G .ne. 0), then CS=0 and SN=1 without doing any
          floating point operations (saves work in SBDSQR when
          there are zeros on the diagonal).

    If F exceeds G in magnitude, CS will be positive.
    \endverbatim  

 * @param[in] F
          F is REAL \n
          The first component of vector to be rotated. \n
 * @param[in] G
          G is REAL \n
          The second component of vector to be rotated. \n
 * @param[out] CS
          CS is REAL \n
          The cosine of the rotation. \n
 * @param[out] SN
          SN is REAL \n
          The sine of the rotation. \n
 * @param[out] R
          R is REAL \n
          The nonzero component of the rotated vector. \n
 \n
  This version has a few statements commented out for thread safety
  (machine parameters are computed on each entry). 10 feb 03, SJH.
 
 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lartg(T f, T g, T *cs, T *sn, T *r__)
{
  return lartg(f, g, cs, sn, r__);
}
template< typename T, typename Ta >
integer lartg(T f, T g, Ta *cs, T *sn, T *r__)
{
  return lartg(f, g, cs, sn, r__);
}

/*! @brief LARTV applies a vector of plane rotations with real cosines and \n
     real sines to the elements of a pair of vectors
 * @details
 * \b Purpose:
    \verbatim 
    LARTV applies a vector of real plane rotations to elements of the
    real vectors x and y. For i = 1,2,...,n

       (x(i)) := ( c(i)  s(i)) (x(i))
       (y(i))    (-s(i)  c(i)) (y(i))
    \endverbatim 

 * @param[in] N
          N is INTEGER \n
          The number of plane rotations to be applied. \n
 * @param[in,out] X
          X is REAL array,
                         dimension (1+(N-1)*INCX) \n
          The vector x. \n
 * @param[in] INCX
          INCX is INTEGER \n
          The increment between elements of X. INCX > 0. \n
 * @param[in,out] Y
          Y is REAL array,
                         dimension (1+(N-1)*INCY) \n
          The vector y. \n
 * @param[in] INCY
          INCY is INTEGER \n
          The increment between elements of Y. INCY > 0. \n
 * @param[in] C
          C is REAL array, dimension (1+(N-1)*INCC) \n
          The cosines of the plane rotations. \n
 * @param[in] S
          S is REAL array, dimension (1+(N-1)*INCC) \n
          The sines of the plane rotations. \n
 * @param[in] INCC
          INCC is INTEGER \n
          The increment between elements of C and S. INCC > 0. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lartv(integer *n, T *x, integer *incx, T *y, integer *incy, T *c, T *s, integer *incc)
{
  return lartv(n, x, incx, y, incy, c, s, incc);
}
template< typename T, typename Ta >
integer lartv(integer *n, T *x, integer *incx, T *y, integer *incy, Ta *c, T *s, integer *incc)
{
  return lartv(n, x, incx, y, incy, c, s, incc);
}

/*! @brief LARUV returns a vector of n random real numbers from a uniform distribution

 * @details
 * \b Purpose:
    \verbatim 
    LARUV returns a vector of n random real numbers from a uniform (0,1)
    distribution (n <= 128).

    This is an auxiliary routine called by SLARNV and CLARNV.
    \endverbatim 

 * @param[in,out] ISEED
          ISEED is INTEGER array, dimension (4) \n
          On entry, the seed of the random number generator; the array
          elements must be between 0 and 4095, and ISEED(4) must be
          odd. \n
          On exit, the seed is updated. \n
 * @param[in] N
          N is INTEGER \n
          The number of random numbers to be generated. N <= 128. \n
 * @param[out] X
          X is REAL array, dimension (N) \n
          The generated random numbers. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer laruv(integer *iseed, integer *n, T *x)
{
  return laruv(iseed, n, x);  
}

/*! @brief LARZ applies an elementary reflector (as   returned by stzrzf) to a general matrix

 * @details
 * \b Purpose:
    \verbatim 
    LARZ applies a real elementary reflector H to a real M-by-N
    matrix C, from either the left or the right. H is represented in the
    form

          H = I - tau * v * v**T

    where tau is a real scalar and v is a real vector.

    If tau = 0, then H is taken to be the unit matrix.


    H is a product of k elementary reflectors as   returned by STZRZF.
    \endverbatim 

 * @param[in] SIDE
          SIDE is CHARACTER*1 \n
          = 'L': form  H * C \n
          = 'R': form  C * H \n
 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix C. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix C. \n
 * @param[in] L
          L is INTEGER \n
          The number of entries of the vector V containing
          the meaningful part of the Householder vectors. \n
          If SIDE = 'L', M >= L >= 0, if SIDE = 'R', N >= L >= 0. \n
 * @param[in] V
          V is REAL array, dimension (1+(L-1)*abs(INCV)) \n
          The vector v in the representation of H as   returned by
          STZRZF. V is not used if TAU = 0. \n
 * @param[in] INCV
          INCV is INTEGER \n
          The increment between elements of v. INCV <> 0. \n
 * @param[in] TAU
          TAU is REAL \n
          The value tau in the representation of H. \n
 * @param[in,out] C
          C is REAL array, dimension (LDC,N) \n
          On entry, the M-by-N matrix C.
          On exit, C is overwritten by the matrix H * C if SIDE = 'L',
          or C * H if SIDE = 'R'. \n
 * @param[in] LDC
          LDC is INTEGER \n
          The leading dimension of the array C. LDC >= max(1,M). \n
 * @param[out] WORK
          WORK is REAL array, dimension \n
                         (N) if SIDE = 'L' \n
                      or (M) if SIDE = 'R'   \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer larz(char *side, integer *m, integer *n, integer *l, T *v, integer *incv, T *tau, T *c, integer *ldc, T * work)
{
  return larz(side, m, n, l, v, incv, tau, c, ldc, work);
}

/*! @brief LARZB applies a block reflector or its transpose to a general matrix

 * @details
 * \b Purpose:
    \verbatim 
    LARZB applies a real block reflector H or its transpose H**T to
    a real distributed M-by-N  C from the left or the right.

    Currently, only STOREV = 'R' and DIRECT = 'B' are supported.
    \endverbatim 

 * @param[in] SIDE
          SIDE is CHARACTER*1 \n
          = 'L': apply H or H**T from the Left \n
          = 'R': apply H or H**T from the Right \n
 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          = 'N': apply H (No transpose) \n
          = 'C': apply H**T (Transpose) \n
 * @param[in] DIRECT
          DIRECT is CHARACTER*1 \n
          Indicates how H is formed from a product of elementary
          reflectors \n
          = 'F': H = H(1) H(2) . . . H(k) (Forward, not supported yet) \n
          = 'B': H = H(k) . . . H(2) H(1) (Backward) \n
 * @param[in] STOREV
          STOREV is CHARACTER*1 \n
          Indicates how the vectors which define the elementary
          reflectors are stored: \n
          = 'C': Columnwise (not supported yet) \n
          = 'R': Rowwise \n
 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix C. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix C. \n
 * @param[in] K
          K is INTEGER \n
          The order of the matrix T (= the number of elementary
          reflectors whose product defines the block reflector). \n
 * @param[in] L
          L is INTEGER \n
          The number of columns of the matrix V containing the
          meaningful part of the Householder reflectors. \n
          If SIDE = 'L', M >= L >= 0, if SIDE = 'R', N >= L >= 0. \n
 * @param[in] V
          V is REAL array, dimension (LDV,NV). \n
          If STOREV = 'C', NV = K; if STOREV = 'R', NV = L. \n
 * @param[in] LDV
          LDV is INTEGER \n
          The leading dimension of the array V. \n
          If STOREV = 'C', LDV >= L; if STOREV = 'R', LDV >= K. \n
 * @param[in] T
          T is REAL array, dimension (LDT,K) \n
          The triangular K-by-K matrix T in the representation of the
          block reflector. \n
 * @param[in] LDT
          LDT is INTEGER \n
          The leading dimension of the array T. LDT >= K. \n
 * @param[in,out] C
          C is REAL array, dimension (LDC,N) \n
          On entry, the M-by-N matrix C.
          On exit, C is overwritten by H*C or H**T*C or C*H or C*H**T. \n
 * @param[in] LDC
          LDC is INTEGER \n
          The leading dimension of the array C. LDC >= max(1,M). \n
 * @param[out] WORK
          WORK is REAL array, dimension (LDWORK,K) \n
 * @param[in] LDWORK
          LDWORK is INTEGER \n
          The leading dimension of the array WORK. \n
          If SIDE = 'L', LDWORK >= max(1,N); \n
          if SIDE = 'R', LDWORK >= max(1,M). \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer larzb(char *side, char *trans, char *direct, char * storev, integer *m, integer *n, integer *k, integer *l, T *v, integer *ldv, T *t, integer *ldt, T *c, integer *ldc, T * work, integer *ldwork)
{
  return larzb(side, trans, direct, storev, m, n, k, l, v, ldv, t, ldt, c, ldc, work, ldwork);
}

/*! @brief LARZT forms the triangular factor T of a block reflector H = I - vtvH.

 * @details
 * \b Purpose:
    \verbatim 
    LARZT forms the triangular factor T of a real block reflector
    H of order > n, which is defined as a product of k elementary
    reflectors.

    If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;

    If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.

    If STOREV = 'C', the vector which defines the elementary reflector
    H(i) is stored in the i-th column of the array V, and

       H  =  I - V * T * V**T

    If STOREV = 'R', the vector which defines the elementary reflector
    H(i) is stored in the i-th row of the array V, and

       H  =  I - V**T * T * V

    Currently, only STOREV = 'R' and DIRECT = 'B' are supported.
    \endverbatim 

 * @param[in] DIRECT
          DIRECT is CHARACTER*1 \n
          Specifies the order in which the elementary reflectors are
          multiplied to form the block reflector: \n
          = 'F': H = H(1) H(2) . . . H(k) (Forward, not supported yet) \n
          = 'B': H = H(k) . . . H(2) H(1) (Backward) \n
 * @param[in] STOREV
          STOREV is CHARACTER*1 \n
          Specifies how the vectors which define the elementary
          reflectors are stored (see also Further Details): \n
          = 'C': columnwise (not supported yet) \n
          = 'R': rowwise \n
 * @param[in] N
          N is INTEGER \n
          The order of the block reflector H. N >= 0. \n
 * @param[in] K
          K is INTEGER \n
          The order of the triangular factor T (= the number of
          elementary reflectors). K >= 1. \n
 * @param[in,out] V
          V is REAL array, dimension \n
                               (LDV,K) if STOREV = 'C' \n
                               (LDV,N) if STOREV = 'R' \n
          The matrix V. See further details. \n
 * @param[in] LDV
          LDV is INTEGER \n
          The leading dimension of the array V.
          If STOREV = 'C', LDV >= max(1,N); if STOREV = 'R', LDV >= K. \n
 * @param[in] TAU
          TAU is REAL array, dimension (K) \n
          TAU(i) must contain the scalar factor of the elementary
          reflector H(i). \n
 * @param[out] T
          T is REAL array, dimension (LDT,K) \n
          The k by k triangular factor T of the block reflector.
          If DIRECT = 'F', T is upper triangular; if DIRECT = 'B', T is
          lower triangular. The rest of the array is not used. \n
 * @param[in] LDT
          LDT is INTEGER \n
          The leading dimension of the array T. LDT >= K. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer larzt(char *direct, char *storev, integer *n, integer * k, T *v, integer *ldv, T *tau, T *t, integer *ldt)
{
  return larzt(direct, storev, n, k, v, ldv, tau, t, ldt);
}

/*! @brief LAS2 computes singular values of a 2-by-2 triangular matrix

 * @details
 * \b Purpose:
    \verbatim 
    LAS2  computes the singular values of the 2-by-2 matrix
       [  F   G  ]
       [  0   H  ].
    On   return, SSMIN is the smaller singular value and SSMAX is the
    larger singular value.
    \endverbatim 

 * @param[in] F
          F is REAL \n
          The (1,1) element of the 2-by-2 matrix. \n
 * @param[in] G
          G is REAL \n
          The (1,2) element of the 2-by-2 matrix. \n
 * @param[in] H
          H is REAL \n
          The (2,2) element of the 2-by-2 matrix. \n
 * @param[out] SSMIN
          SSMIN is REAL \n
          The smaller singular value. \n
 * @param[out] SSMAX
          SSMAX is REAL \n
          The larger singular value.  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer las2(T *f, T *g, T *h, T *ssmin, T * ssmax)
{
  return las2(f, g, h, ssmin, ssmax); 
}

/*! @brief LASCL2 performs diagonal scaling on a vector

 * @details
 * \b Purpose:
    \verbatim 
    LASCL2 performs a diagonal scaling on a vector:
      x <-- D * x
    where the diagonal matrix D is stored as a vector.

    Eventually to be replaced by BLAS_sge_diag_scale in the new BLAS
    standard.
    \endverbatim 

 * @param[in] M
          M is INTEGER \n
          The number of rows of D and X. M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of X. N >= 0. \n
 * @param[in] D
          D is REAL array, length M \n
          Diagonal matrix D, stored as a vector of length M. \n
 * @param[in,out] X
          X is REAL array, dimension (LDX,N) \n
          On entry, the vector X to be scaled by D.
          On exit, the scaled vector. \n
 * @param[in] LDX
          LDX is INTEGER \n
          The leading dimension of the vector X. LDX >= M.  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lascl2(integer *m, integer *n, T *d, T *x, integer *ldx)
{
  return lascl2(m, n, d, x, ldx);
}
template< typename T, typename Ta >
integer lascl2(integer *m, integer *n, Ta *d, T *x, integer *ldx)
{
  return lascl2(m, n, d, x, ldx);
}

/*! @brief LASD0 computes the singular values of a real upper bidiagonal n-by-m  \n
     matrix B with diagonal d and off-diagonal e. Used by sbdsdc
 * @details
 * \b Purpose:
    \verbatim 
    Using a divide and conquer approach, SLASD0 computes the singular
    value decomposition (SVD) of a real upper bidiagonal N-by-M
    matrix B with diagonal D and offdiagonal E, where M = N + SQRE.
    The algorithm computes orthogonal matrices U and VT such that
    B = U * S * VT. The singular values S are overwritten on D.

    A related subroutine, SLASDA, computes only the singular values,
    and optionally, the singular vectors in compact form.
    \endverbatim 

 * @param[in] N
          N is INTEGER \n
          On entry, the row dimension of the upper bidiagonal matrix.
          This is also the dimension of the main diagonal array D. \n
 * @param[in] SQRE
          SQRE is INTEGER \n
          Specifies the column dimension of the bidiagonal matrix. \n
          = 0: The bidiagonal matrix has column dimension M = N; \n
          = 1: The bidiagonal matrix has column dimension M = N+1; \n
 * @param[in,out] D
          D is REAL array, dimension (N) \n
          On entry D contains the main diagonal of the bidiagonal
          matrix. \n
          On exit D, if INFO = 0, contains its singular values. \n
 * @param[in,out] E
          E is REAL array, dimension (M-1) \n
          Contains the subdiagonal entries of the bidiagonal matrix.
          On exit, E has been destroyed. \n
 * @param[out] U
          U is REAL array, dimension (LDU, N) \n
          On exit, U contains the left singular vectors. \n
 * @param[in] LDU
          LDU is INTEGER \n
          On entry, leading dimension of U. \n
 * @param[out] VT
          VT is REAL array, dimension (LDVT, M) \n
          On exit, VT**T contains the right singular vectors. \n
 * @param[in] LDVT
          LDVT is INTEGER \n
          On entry, leading dimension of VT. \n
 * @param[in] SMLSIZ
          SMLSIZ is INTEGER \n
          On entry, maximum size of the subproblems at the
          bottom of the computation tree. \n
 * @param[out] IWORK
          IWORK is INTEGER array, dimension (8*N) \n
 * @param[out] WORK
          WORK is REAL array, dimension (3*M**2+2*M) \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n
          > 0:  if INFO = 1, a singular value did not converge  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lasd0(integer *n, integer *sqre, T *d, T *e, T *u, integer *ldu, T *vt, integer *ldvt, integer *smlsiz, integer *iwork, T *work, integer *info)
{
  return lasd0(n, sqre, d, e, u, ldu, vt, ldvt, smlsiz, iwork, work, info); 
}

/*! @brief LASD1 computes the SVD of an upper bidiagonal matrix B of the specified size. Used by sbdsdc

 * @details
 * \b Purpose:
    \verbatim 
    LASD1 computes the SVD of an upper bidiagonal N-by-M matrix B,
    where N = NL + NR + 1 and M = N + SQRE. SLASD1 is called from SLASD0.

    A related subroutine SLASD7 handles the case in which the singular
    values (and the singular vectors in factored form) are desired.

    SLASD1 computes the SVD as follows:

                  (D1(in)    0    0       0)
      B = U(in) * (  Z1**T   a   Z2**T    b) * VT(in)
                  (  0       0   D2(in)   0)

        = U(out) * (D(out) 0) * VT(out)

    where Z**T = (Z1**T a Z2**T b) = u**T VT**T, and u is a vector of dimension M
    with ALPHA and BETA in the NL+1 and NL+2 th entries and zeros
    elsewhere; and the entry b is empty if SQRE = 0.

    The left singular vectors of the original matrix are stored in U, and
    the transpose of the right singular vectors are stored in VT, and the
    singular values are in D.  The algorithm consists of three stages:

       The first stage consists of deflating the size of the problem
       when there are multiple singular values or when there are zeros in
       the Z vector.  For each such occurrence the dimension of the
       secular equation problem is reduced by one.  This stage is
       performed by the routine SLASD2.

       The second stage consists of calculating the updated
       singular values. This is done by finding the square roots of the
       roots of the secular equation via the routine SLASD4 (as called
       by SLASD3). This routine also calculates the singular vectors of
       the current problem.

       The final stage consists of computing the updated singular vectors
       directly using the updated singular values.  The singular vectors
       for the current problem are multiplied with the singular vectors
       from the overall problem.
    \endverbatim 

 * @param[in] NL
          NL is INTEGER \n
          The row dimension of the upper block.  NL >= 1. \n
 * @param[in] NR
          NR is INTEGER \n
          The row dimension of the lower block.  NR >= 1. \n
 * @param[in] SQRE
          SQRE is INTEGER \n
          = 0: the lower block is an NR-by-NR square matrix. \n
          = 1: the lower block is an NR-by-(NR+1) rectangular matrix. \n
 \n
          The bidiagonal matrix has row dimension N = NL + NR + 1,
          and column dimension M = N + SQRE. \n
 * @param[in,out] D
          D is REAL array, dimension (NL+NR+1). \n
          N = NL+NR+1 \n
          On entry D(1:NL,1:NL) contains the singular values of the
          upper block; and D(NL+2:N) contains the singular values of
          the lower block. On exit D(1:N) contains the singular values
          of the modified matrix. \n
 * @param[in,out] ALPHA
          ALPHA is REAL \n
          Contains the diagonal element associated with the added row. \n
 * @param[in,out] BETA
          BETA is REAL \n
          Contains the off-diagonal element associated with the added
          row. \n
 * @param[in,out] U
          U is REAL array, dimension (LDU,N) \n
          On entry U(1:NL, 1:NL) contains the left singular vectors of
          the upper block; U(NL+2:N, NL+2:N) contains the left singular
          vectors of the lower block. On exit U contains the left
          singular vectors of the bidiagonal matrix. \n
 * @param[in] LDU
          LDU is INTEGER \n
          The leading dimension of the array U.  LDU >= max(1, N). \n
 * @param[in,out] VT
          VT is REAL array, dimension (LDVT,M) \n
          where M = N + SQRE. \n
          On entry VT(1:NL+1, 1:NL+1)**T contains the right singular
          vectors of the upper block; VT(NL+2:M, NL+2:M)**T contains
          the right singular vectors of the lower block. On exit
          VT**T contains the right singular vectors of the
          bidiagonal matrix. \n
 * @param[in] LDVT
          LDVT is INTEGER \n
          The leading dimension of the array VT.  LDVT >= max(1, M). \n
 * @param[in,out] IDXQ
          IDXQ is INTEGER array, dimension (N) \n
          This contains the permutation which will reintegrate the
          subproblem just solved back into sorted order, i.e.
          D(IDXQ(I = 1, N)) will be in ascending order. \n
 * @param[out] IWORK
          IWORK is INTEGER array, dimension (4*N) \n
 * @param[out] WORK
          WORK is REAL array, dimension (3*M**2+2*M) \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n
          > 0:  if INFO = 1, a singular value did not converge \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lasd1(integer *nl, integer *nr, integer *sqre, T * d, T *alpha, T *beta, T *u, integer *ldu, T *vt, integer *ldvt, integer *idxq, integer *iwork, T *work, integer * info)
{
  return lasd1(nl, nr, sqre, d, alpha, beta, u, ldu, vt, ldvt, idxq, iwork, work, info); 
}

/*! @brief LASD2 merges the two sets of singular values together into a single sorted set. Used by sbdsdc

 * @details
 * \b Purpose:
    \verbatim 
    LASD2 merges the two sets of singular values together into a single
    sorted set.  Then it tries to deflate the size of the problem.
    There are two ways in which deflation can occur:  when two or more
    singular values are close together or if there is a tiny entry in the
    Z vector.  For each such occurrence the order of the related secular
    equation problem is reduced by one.

    SLASD2 is called from SLASD1.
    \endverbatim 

 * @param[in] NL
          NL is INTEGER \n
          The row dimension of the upper block.  NL >= 1. \n
 * @param[in] NR
          NR is INTEGER \n
          The row dimension of the lower block.  NR >= 1. \n
 * @param[in] SQRE
          SQRE is INTEGER \n
          = 0: the lower block is an NR-by-NR square matrix. \n
          = 1: the lower block is an NR-by-(NR+1) rectangular matrix. \n
 \n
          The bidiagonal matrix has N = NL + NR + 1 rows and
          M = N + SQRE >= N columns. \n
 * @param[out] K
          K is INTEGER \n
          Contains the dimension of the non-deflated matrix,
          This is the order of the related secular equation. 1 <= K <=N. \n
 * @param[in,out] D
          D is REAL array, dimension (N) \n
          On entry D contains the singular values of the two submatrices
          to be combined.  On exit D contains the trailing (N-K) updated
          singular values (those which were deflated) sorted into
          increasing order. \n
 * @param[out] Z
          Z is REAL array, dimension (N) \n
          On exit Z contains the updating row vector in the secular
          equation. \n
 * @param[in] ALPHA
          ALPHA is REAL \n
          Contains the diagonal element associated with the added row. \n
 * @param[in] BETA
          BETA is REAL \n
          Contains the off-diagonal element associated with the added
          row. \n
 * @param[in,out] U
          U is REAL array, dimension (LDU,N) \n
          On entry U contains the left singular vectors of two
          submatrices in the two square blocks with corners at (1,1),
          (NL, NL), and (NL+2, NL+2), (N,N). \n
          On exit U contains the trailing (N-K) updated left singular
          vectors (those which were deflated) in its last N-K columns. \n
 * @param[in] LDU
          LDU is INTEGER \n
          The leading dimension of the array U.  LDU >= N. \n
 * @param[in,out] VT
          VT is REAL array, dimension (LDVT,M) \n
          On entry VT**T contains the right singular vectors of two
          submatrices in the two square blocks with corners at (1,1),
          (NL+1, NL+1), and (NL+2, NL+2), (M,M). \n
          On exit VT**T contains the trailing (N-K) updated right singular
          vectors (those which were deflated) in its last N-K columns.
          In case SQRE =1, the last row of VT spans the right null
          space. \n
 * @param[in] LDVT
          LDVT is INTEGER \n
          The leading dimension of the array VT.  LDVT >= M. \n
 * @param[out] DSIGMA
          DSIGMA is REAL array, dimension (N) \n
          Contains a copy of the diagonal elements (K-1 singular values
          and one zero) in the secular equation. \n
 * @param[out] U2
          U2 is REAL array, dimension (LDU2,N) \n
          Contains a copy of the first K-1 left singular vectors which
          will be used by SLASD3 in a matrix multiply (SGEMM) to solve
          for the new left singular vectors. U2 is arranged into four
          blocks. The first block contains a column with 1 at NL+1 and
          zero everywhere else; the second block contains non-zero
          entries only at and above NL; the third contains non-zero
          entries only below NL+1; and the fourth is dense. \n
 * @param[in] LDU2
          LDU2 is INTEGER \n
          The leading dimension of the array U2.  LDU2 >= N. \n
 * @param[out] VT2
          VT2 is REAL array, dimension (LDVT2,N) \n
          VT2**T contains a copy of the first K right singular vectors
          which will be used by SLASD3 in a matrix multiply (SGEMM) to
          solve for the new right singular vectors. VT2 is arranged into
          three blocks. The first block contains a row that corresponds
          to the special 0 diagonal element in SIGMA; the second block
          contains non-zeros only at and before NL +1; the third block
          contains non-zeros only at and after  NL +2. \n
 * @param[in] LDVT2
          LDVT2 is INTEGER \n
          The leading dimension of the array VT2.  LDVT2 >= M. \n
 * @param[out] IDXP
          IDXP is INTEGER array, dimension (N) \n
          This will contain the permutation used to place deflated
          values of D at the end of the array. On output IDXP(2:K)
          points to the nondeflated D-values and IDXP(K+1:N)
          points to the deflated singular values. \n
 * @param[out] IDX
          IDX is INTEGER array, dimension (N) \n
          This will contain the permutation used to sort the contents of
          D into ascending order. \n
 * @param[out] IDXC
          IDXC is INTEGER array, dimension (N) \n
          This will contain the permutation used to arrange the columns
          of the deflated U matrix into three groups:  the first group
          contains non-zero entries only at and above NL, the second
          contains non-zero entries only below NL+2, and the third is
          dense. \n
 * @param[in,out] IDXQ
          IDXQ is INTEGER array, dimension (N) \n
          This contains the permutation which separately sorts the two
          sub-problems in D into ascending order.  Note that entries in
          the first hlaf of this permutation must first be moved one
          position backward; and entries in the second half
          must first have NL+1 added to their values. \n
 * @param[out] COLTYP
          COLTYP is INTEGER array, dimension (N) \n
          As workspace, this will contain a label which will indicate
          which of the following types a column in the U2 matrix or a
          row in the VT2 matrix is: \n
          1 : non-zero in the upper half only \n
          2 : non-zero in the lower half only \n
          3 : dense \n
          4 : deflated \n
 \n
          On exit, it is an array of dimension 4, with COLTYP(I) being
          the dimension of the I-th type columns. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, the i-th argument had an illegal value.  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lasd2(integer *nl, integer *nr, integer *sqre, integer *k, T *d, T *z, T *alpha, T *beta, T *u, integer * ldu, T *vt, integer *ldvt, T *dsigma, T *u2, integer *ldu2, T *vt2, integer *ldvt2, integer *idxp, integer *idx, integer *idxc, integer *idxq, integer *coltyp, integer *info)
{
  return lasd2(nl, nr, sqre, k, d, z, alpha, beta, u, ldu, vt, ldvt, dsigma, u2, ldu2, vt2, ldvt2, idxp, idx, idxc, idxq, coltyp, info); 
}

/*! @brief LASD3 finds all square roots of the roots of the secular equation, \n
     as defined by the values in D and Z, and then updates the singular       \n
     vectors by matrix multiplication. Used by sbdsdc
 * @details
 * \b Purpose:
    \verbatim 
    LASD3 finds all the square roots of the roots of the secular
    equation, as defined by the values in D and Z.  It makes the
    appropriate calls to SLASD4 and then updates the singular
    vectors by matrix multiplication.

    This code makes very mild assumptions about floating point
    arithmetic. It will work on machines with a guard digit in
    add/subtract, or on those binary machines without guard digits
    which subtract like the Cray XMP, Cray YMP, Cray C 90, or Cray 2.
    It could conceivably fail on hexadecimal or decimal machines
    without guard digits, but we know of none.

    SLASD3 is called from SLASD1.
    \endverbatim

 * @param[in] NL
          NL is INTEGER \n
          The row dimension of the upper block.  NL >= 1. \n
 * @param[in] NR
          NR is INTEGER \n
          The row dimension of the lower block.  NR >= 1. \n
 * @param[in] SQRE
          SQRE is INTEGER \n
          = 0: the lower block is an NR-by-NR square matrix. \n
          = 1: the lower block is an NR-by-(NR+1) rectangular matrix. \n
 \n
          The bidiagonal matrix has N = NL + NR + 1 rows and
          M = N + SQRE >= N columns. \n
 * @param[in] K
          K is INTEGER \n
          The size of the secular equation, 1 =< K = < N. \n
 * @param[out] D
          D is REAL array, dimension(K) \n
          On exit the square roots of the roots of the secular equation,
          in ascending order. \n
 * @param[out] Q
          Q is REAL array, dimension (LDQ,K) \n
 * @param[in] LDQ
          LDQ is INTEGER \n
          The leading dimension of the array Q.  LDQ >= K. \n
 * @param[in,out] DSIGMA
          DSIGMA is REAL array, dimension(K) \n
          The first K elements of this array contain the old roots
          of the deflated updating problem.  These are the poles
          of the secular equation. \n
 * @param[out] U
          U is REAL array, dimension (LDU, N) \n
          The last N - K columns of this matrix contain the deflated
          left singular vectors. \n
 * @param[in] LDU
          LDU is INTEGER \n
          The leading dimension of the array U.  LDU >= N. \n
 * @param[in] U2
          U2 is REAL array, dimension (LDU2, N) \n
          The first K columns of this matrix contain the non-deflated
          left singular vectors for the split problem. \n
 * @param[in] LDU2
          LDU2 is INTEGER \n
          The leading dimension of the array U2.  LDU2 >= N. \n
 * @param[out] VT
          VT is REAL array, dimension (LDVT, M) \n
          The last M - K columns of VT**T contain the deflated
          right singular vectors. \n
 * @param[in] LDVT
          LDVT is INTEGER \n
          The leading dimension of the array VT.  LDVT >= N. \n
 * @param[in,out] VT2
          VT2 is REAL array, dimension (LDVT2, N) \n
          The first K columns of VT2**T contain the non-deflated
          right singular vectors for the split problem. \n
 * @param[in] LDVT2
          LDVT2 is INTEGER \n
          The leading dimension of the array VT2.  LDVT2 >= N. \n
 * @param[in] IDXC
          IDXC is INTEGER array, dimension (N) \n
          The permutation used to arrange the columns of U (and rows of
          VT) into three groups:  the first group contains non-zero
          entries only at and above (or before) NL +1; the second
          contains non-zero entries only at and below (or after) NL+2;
          and the third is dense. The first column of U and the row of
          VT are treated separately, however. \n
 \n
          The rows of the singular vectors found by SLASD4
          must be likewise permuted before the matrix multiplies can
          take place. \n
 * @param[in] CTOT
          CTOT is INTEGER array, dimension (4) \n
          A count of the total number of the various types of columns
          in U (or rows in VT), as described in IDXC. The fourth column
          type is any column which has been deflated. \n
 * @param[in,out] Z
          Z is REAL array, dimension (K) \n
          The first K elements of this array contain the components
          of the deflation-adjusted updating row vector. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n
          > 0:  if INFO = 1, a singular value did not converge  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lasd3(integer *nl, integer *nr, integer *sqre, integer *k, T *d, T *q, integer *ldq, T *dsigma, T *u, integer * ldu, T *u2, integer *ldu2, T *vt, integer *ldvt, T *vt2, integer *ldvt2, integer *idxc, integer *ctot, T *z, integer * info)
{
  return lasd3(nl, nr, sqre, k, d, q, ldq, dsigma, u, ldu, u2, ldu2, vt, ldvt, vt2, ldvt2, idxc, ctot, z, info); 
}

/*! @brief LASD4 computes the square root of the i-th updated eigenvalue  \n
     of a positive symmetric rank-one modification to a positive diagonal \n
     matrix. Used by sbdsdc
 * @details
 * \b Purpose:
    \verbatim 
    This subroutine computes the square root of the I-th updated
    eigenvalue of a positive symmetric rank-one modification to
    a positive diagonal matrix whose entries are given as the squares
    of the corresponding entries in the array d, and that

           0 <= D(i) < D(j)  for  i < j

    and that RHO > 0. This is arranged by the calling routine, and is
    no loss in generality.  The rank-one modified system is thus

           diag(D) * diag(D) +  RHO * Z * Z_transpose.

    where we assume the Euclidean norm of Z is 1.

    The method consists of approximating the rational functions in the
    secular equation by simpler interpolating rational functions.
    \endverbatim 

 * @param[in] N
          N is INTEGER \n
          The length of all arrays. \n
 * @param[in] I
          I is INTEGER \n
          The index of the eigenvalue to be computed.  1 <= I <= N. \n
 * @param[in] D
          D is REAL array, dimension (N) \n
          The original eigenvalues.  It is assumed that they are in
          order, 0 <= D(I) < D(J)  for I < J. \n
 * @param[in] Z
          Z is REAL array, dimension (N) \n
          The components of the updating vector. \n
 * @param[out] DELTA
          DELTA is REAL array, dimension (N) \n
          If N .ne. 1, DELTA contains (D(j) - sigma_I) in its  j-th
          component.  If N = 1, then DELTA(1) = 1.  The vector DELTA
          contains the information necessary to construct the
          (singular) eigenvectors. \n
 * @param[in] RHO
          RHO is REAL \n
          The scalar in the symmetric updating formula. \n
 * @param[out] SIGMA
          SIGMA is REAL \n
          The computed sigma_I, the I-th updated eigenvalue. \n
 * @param[out] WORK
          WORK is REAL array, dimension (N) \n
          If N .ne. 1, WORK contains (D(j) + sigma_I) in its  j-th
          component.  If N = 1, then WORK(1) = 1. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit \n
          > 0:  if INFO = 1, the updating process failed.  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lasd4(integer *n, integer *i, T *d, T *z, T *delta, T *rho, T *sigma, T *work, integer *info)
{
  return lasd4(n, i, d, z, delta, rho, sigma, work, info); 
}

/*! @brief LASD5 computes the square root of the i-th eigenvalue of a      \n
     positive symmetric rank-one modification of a 2-by-2 diagonal matrix. \n 
     Used by sbdsdc
 * @details
 * \b Purpose:
    \verbatim 
    This subroutine computes the square root of the I-th eigenvalue
    of a positive symmetric rank-one modification of a 2-by-2 diagonal
    matrix

               diag(D) * diag(D) +  RHO * Z * transpose(Z) .

    The diagonal entries in the array D are assumed to satisfy

               0 <= D(i) < D(j)  for  i < j .

    We also assume RHO > 0 and that the Euclidean norm of the vector
    Z is one.
    \endverbatim 

 * @param[in] I
          I is INTEGER \n
          The index of the eigenvalue to be computed.  I = 1 or I = 2. \n
 * @param[in] D
          D is REAL array, dimension (2) \n
          The original eigenvalues.  We assume 0 <= D(1) < D(2). \n
 * @param[in] Z
          Z is REAL array, dimension (2) \n
          The components of the updating vector. \n
 * @param[out] DELTA
          DELTA is REAL array, dimension (2) \n
          Contains (D(j) - sigma_I) in its  j-th component.
          The vector DELTA contains the information necessary
          to construct the eigenvectors. \n
 * @param[in] RHO
          RHO is REAL \n
          The scalar in the symmetric updating formula. \n
 * @param[out] DSIGMA
          DSIGMA is REAL \n
          The computed sigma_I, the I-th updated eigenvalue. \n
 * @param[out] WORK
          WORK is REAL array, dimension (2) \n
          WORK contains (D(j) + sigma_I) in its  j-th component.  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lasd5(integer *i, T *d, T *z, T *delta, T *rho, T *dsigma, T *work)
{
  return lasd5(i, d, z, delta, rho, dsigma, work); 
}

/*! @brief LASD6 computes the SVD of an updated upper bidiagonal matrix \n
     obtained by merging two smaller ones by appending a row.           \n
     Used by sbdsdc
 * @details
 * \b Purpose:
    \verbatim 
    LASD6 computes the SVD of an updated upper bidiagonal matrix B
    obtained by merging two smaller ones by appending a row. This
    routine is used only for the problem which requires all singular
    values and optionally singular vector matrices in factored form.
    B is an N-by-M matrix with N = NL + NR + 1 and M = N + SQRE.
    A related subroutine, SLASD1, handles the case in which all singular
    values and singular vectors of the bidiagonal matrix are desired.

    SLASD6 computes the SVD as follows:

                  (D1(in)    0    0       0)
      B = U(in) * (  Z1**T   a   Z2**T    b) * VT(in)
                  (  0       0   D2(in)   0)

        = U(out) * (D(out) 0) * VT(out)

    where Z**T = (Z1**T a Z2**T b) = u**T VT**T, and u is a vector of dimension M
    with ALPHA and BETA in the NL+1 and NL+2 th entries and zeros
    elsewhere; and the entry b is empty if SQRE = 0.

    The singular values of B can be computed using D1, D2, the first
    components of all the right singular vectors of the lower block, and
    the last components of all the right singular vectors of the upper
    block. These components are stored and updated in VF and VL,
    respectively, in SLASD6. Hence U and VT are not explicitly
    referenced.

    The singular values are stored in D. The algorithm consists of two
    stages:

          The first stage consists of deflating the size of the problem
          when there are multiple singular values or if there is a zero
          in the Z vector. For each such occurrence the dimension of the
          secular equation problem is reduced by one. This stage is
          performed by the routine SLASD7.

          The second stage consists of calculating the updated
          singular values. This is done by finding the roots of the
          secular equation via the routine SLASD4 (as called by SLASD8).
          This routine also updates VF and VL and computes the distances
          between the updated singular values and the old singular
          values.

    SLASD6 is called from SLASDA.
    \endverbatim 

 * @param[in] ICOMPQ
          ICOMPQ is INTEGER \n
          Specifies whether singular vectors are to be computed in
          factored form: \n
          = 0: Compute singular values only. \n
          = 1: Compute singular vectors in factored form as well. \n
 * @param[in] NL
          NL is INTEGER \n
          The row dimension of the upper block.  NL >= 1. \n
 * @param[in] NR
          NR is INTEGER \n
          The row dimension of the lower block.  NR >= 1. \n
 * @param[in] SQRE
          SQRE is INTEGER \n
          = 0: the lower block is an NR-by-NR square matrix. \n
          = 1: the lower block is an NR-by-(NR+1) rectangular matrix. \n
 \n
          The bidiagonal matrix has row dimension N = NL + NR + 1,
          and column dimension M = N + SQRE. \n
 * @param[in,out] D
          D is REAL array, dimension (NL+NR+1). \n
          On entry D(1:NL,1:NL) contains the singular values of the
          upper block, and D(NL+2:N) contains the singular values
          of the lower block. On exit D(1:N) contains the singular
          values of the modified matrix. \n
 * @param[in,out] VF
          VF is REAL array, dimension (M) \n
          On entry, VF(1:NL+1) contains the first components of all
          right singular vectors of the upper block; and VF(NL+2:M)
          contains the first components of all right singular vectors
          of the lower block. On exit, VF contains the first components
          of all right singular vectors of the bidiagonal matrix. \n
 * @param[in,out] VL
          VL is REAL array, dimension (M) \n
          On entry, VL(1:NL+1) contains the  last components of all
          right singular vectors of the upper block; and VL(NL+2:M)
          contains the last components of all right singular vectors of
          the lower block. On exit, VL contains the last components of
          all right singular vectors of the bidiagonal matrix. \n
 * @param[in,out] ALPHA
          ALPHA is REAL \n
          Contains the diagonal element associated with the added row. \n
 * @param[in,out] BETA
          BETA is REAL \n
          Contains the off-diagonal element associated with the added
          row. \n
 * @param[in,out] IDXQ
          IDXQ is INTEGER array, dimension (N) \n
          This contains the permutation which will reintegrate the
          subproblem just solved back into sorted order, i.e.
          D(IDXQ(I = 1, N)) will be in ascending order. \n
 * @param[out] PERM
          PERM is INTEGER array, dimension (N) \n
          The permutations (from deflation and sorting) to be applied
          to each block. Not referenced if ICOMPQ = 0. \n
 * @param[out] GIVPTR
          GIVPTR is INTEGER \n
          The number of Givens rotations which took place in this
          subproblem. Not referenced if ICOMPQ = 0. \n
 * @param[out] GIVCOL
          GIVCOL is INTEGER array, dimension (LDGCOL, 2) \n
          Each pair of numbers indicates a pair of columns to take place
          in a Givens rotation. Not referenced if ICOMPQ = 0. \n
 * @param[in] LDGCOL
          LDGCOL is INTEGER \n
          leading dimension of GIVCOL, must be at least N. \n
 * @param[out] GIVNUM
          GIVNUM is REAL array, dimension (LDGNUM, 2) \n
          Each number indicates the C or S value to be used in the
          corresponding Givens rotation. Not referenced if ICOMPQ = 0. \n
 * @param[in] LDGNUM
          LDGNUM is INTEGER \n
          The leading dimension of GIVNUM and POLES, must be at least N. \n
 * @param[out] POLES
          POLES is REAL array, dimension (LDGNUM, 2) \n
          On exit, POLES(1,*) is an array containing the new singular
          values obtained from solving the secular equation, and
          POLES(2,*) is an array containing the poles in the secular
          equation. Not referenced if ICOMPQ = 0. \n
 * @param[out] DIFL
          DIFL is REAL array, dimension (N) \n
          On exit, DIFL(I) is the distance between I-th updated
          (undeflated) singular value and the I-th (undeflated) old
          singular value. \n
 * @param[out] DIFR
          DIFR is REAL array, \n
                   dimension (LDDIFR, 2) if ICOMPQ = 1 and
                   dimension (K) if ICOMPQ = 0. \n
          On exit, DIFR(I,1) = D(I) - DSIGMA(I+1), DIFR(K,1) is not
          defined and will not be referenced. \n
 \n
          If ICOMPQ = 1, DIFR(1:K,2) is an array containing the
          normalizing factors for the right singular vector matrix.
 \n
          See SLASD8 for details on DIFL and DIFR. \n
 * @param[out] Z
          Z is REAL array, dimension (M) \n
          The first elements of this array contain the components
          of the deflation-adjusted updating row vector. \n
 * @param[out] K
          K is INTEGER \n
          Contains the dimension of the non-deflated matrix,
          This is the order of the related secular equation. 1 <= K <=N. \n
 * @param[out] C
          C is REAL \n
          C contains garbage if SQRE =0 and the C-value of a Givens
          rotation related to the right null space if SQRE = 1. \n
 * @param[out] S
          S is REAL \n
          S contains garbage if SQRE =0 and the S-value of a Givens
          rotation related to the right null space if SQRE = 1. \n
 * @param[out] WORK
          WORK is REAL array, dimension (4 * M) \n
 * @param[out] IWORK
          IWORK is INTEGER array, dimension (3 * N) \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n
          > 0:  if INFO = 1, a singular value did not converge  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lasd6(integer *icompq, integer *nl, integer *nr, integer *sqre, T *d, T *vf, T *vl, T *alpha, T *beta, integer *idxq, integer *perm, integer *givptr, integer *givcol, integer *ldgcol, T *givnum, integer *ldgnum, T *poles, T * difl, T *difr, T *z, integer *k, T *c, T *s, T * work, integer *iwork, integer *info)
{
  return lasd6(icompq, nl, nr, sqre, d, vf, vl, alpha, beta, idxq, perm, givptr, givcol, ldgcol, givnum, ldgnum, poles, difl, difr, z, k, c, s, work, iwork, info); 
}

/*! @brief LASD7 merges the two sets of singular values together into a   \n
     single sorted set. Then it tries to deflate the size of the problem. \n
     Used by sbdsdc
 * @details
 * \b Purpose:
    \verbatim 
    LASD7 merges the two sets of singular values together into a single
    sorted set. Then it tries to deflate the size of the problem. There
    are two ways in which deflation can occur:  when two or more singular
    values are close together or if there is a tiny entry in the Z
    vector. For each such occurrence the order of the related
    secular equation problem is reduced by one.

    SLASD7 is called from SLASD6.
    \endverbatim  

 * @param[in] ICOMPQ
          ICOMPQ is INTEGER \n
          Specifies whether singular vectors are to be computed
          in compact form, as follows: \n
          = 0: Compute singular values only. \n
          = 1: Compute singular vectors of upper
               bidiagonal matrix in compact form. \n
 * @param[in] NL
          NL is INTEGER \n
          The row dimension of the upper block. NL >= 1. \n
 * @param[in] NR
          NR is INTEGER \n
          The row dimension of the lower block. NR >= 1. \n
 * @param[in] SQRE
          SQRE is INTEGER \n
          = 0: the lower block is an NR-by-NR square matrix. \n
          = 1: the lower block is an NR-by-(NR+1) rectangular matrix. \n
 \n
          The bidiagonal matrix has \n
          N = NL + NR + 1 rows and \n
          M = N + SQRE >= N columns. \n
 * @param[out] K
          K is INTEGER \n
          Contains the dimension of the non-deflated matrix, this is
          the order of the related secular equation. 1 <= K <=N. \n
 * @param[in,out] D
          D is REAL array, dimension (N) \n
          On entry D contains the singular values of the two submatrices
          to be combined. On exit D contains the trailing (N-K) updated
          singular values (those which were deflated) sorted into
          increasing order. \n
 * @param[out] Z
          Z is REAL array, dimension (M) \n
          On exit Z contains the updating row vector in the secular
          equation. \n
 * @param[out] ZW
          ZW is REAL array, dimension (M) \n
          Workspace for Z. \n
 * @param[in,out] VF
          VF is REAL array, dimension (M) \n
          On entry, VF(1:NL+1) contains the first components of all
          right singular vectors of the upper block; and VF(NL+2:M)
          contains the first components of all right singular vectors
          of the lower block. On exit, VF contains the first components
          of all right singular vectors of the bidiagonal matrix. \n
 * @param[out] VFW
          VFW is REAL array, dimension (M) \n
          Workspace for VF. \n
 * @param[in,out] VL
          VL is REAL array, dimension (M) \n
          On entry, VL(1:NL+1) contains the  last components of all
          right singular vectors of the upper block; and VL(NL+2:M)
          contains the last components of all right singular vectors
          of the lower block. On exit, VL contains the last components
          of all right singular vectors of the bidiagonal matrix. \n
 * @param[out] VLW
          VLW is REAL array, dimension (M) \n
          Workspace for VL. \n
 * @param[in] ALPHA
          ALPHA is REAL \n
          Contains the diagonal element associated with the added row. \n
 * @param[in] BETA
          BETA is REAL \n
          Contains the off-diagonal element associated with the added
          row. \n
 * @param[out] DSIGMA
          DSIGMA is REAL array, dimension (N) \n
          Contains a copy of the diagonal elements (K-1 singular values
          and one zero) in the secular equation. \n
 * @param[out] IDX
          IDX is INTEGER array, dimension (N) \n
          This will contain the permutation used to sort the contents of
          D into ascending order. \n
 * @param[out] IDXP
          IDXP is INTEGER array, dimension (N) \n
          This will contain the permutation used to place deflated
          values of D at the end of the array. On output IDXP(2:K)
          points to the nondeflated D-values and IDXP(K+1:N)
          points to the deflated singular values. \n
 * @param[in] IDXQ
          IDXQ is INTEGER array, dimension (N) \n
          This contains the permutation which separately sorts the two
          sub-problems in D into ascending order.  Note that entries in
          the first half of this permutation must first be moved one
          position backward; and entries in the second half
          must first have NL+1 added to their values. \n
 * @param[out] PERM
          PERM is INTEGER array, dimension (N) \n
          The permutations (from deflation and sorting) to be applied
          to each singular block. Not referenced if ICOMPQ = 0. \n
 * @param[out] GIVPTR
          GIVPTR is INTEGER \n
          The number of Givens rotations which took place in this
          subproblem. Not referenced if ICOMPQ = 0. \n
 * @param[out] GIVCOL
          GIVCOL is INTEGER array, dimension (LDGCOL, 2) \n
          Each pair of numbers indicates a pair of columns to take place
          in a Givens rotation. Not referenced if ICOMPQ = 0. \n
 * @param[in] LDGCOL
          LDGCOL is INTEGER \n
          The leading dimension of GIVCOL, must be at least N. \n
 * @param[out] GIVNUM
          GIVNUM is REAL array, dimension (LDGNUM, 2) \n
          Each number indicates the C or S value to be used in the
          corresponding Givens rotation. Not referenced if ICOMPQ = 0. \n
 * @param[in] LDGNUM
          LDGNUM is INTEGER \n
          The leading dimension of GIVNUM, must be at least N. \n
 * @param[out] C
          C is REAL \n
          C contains garbage if SQRE =0 and the C-value of a Givens
          rotation related to the right null space if SQRE = 1. \n
 * @param[out] S
          S is REAL \n
          S contains garbage if SQRE =0 and the S-value of a Givens
          rotation related to the right null space if SQRE = 1. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, the i-th argument had an illegal value.  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lasd7(integer *icompq, integer *nl, integer *nr, integer *sqre, integer *k, T *d, T *z, T *zw, T *vf, T *vfw, T *vl, T *vlw, T *alpha, T *beta, T *dsigma, integer *idx, integer *idxp, integer *idxq, integer *perm, integer * givptr, integer *givcol, integer *ldgcol, T *givnum, integer * ldgnum, T *c, T *s, integer *info)
{
  return lasd7(icompq, nl, nr, sqre, k, d, z, zw, vf, vfw, vl, vlw, alpha, beta, dsigma, idx, idxp, idxq, perm, givptr, givcol, ldgcol, givnum, ldgnum, c, s, info); 
}

/*! @brief LASD8 finds the square roots of the roots of the secular equation, \n
     and stores, for each element in D, the distance to its two nearest poles. \n
     Used by sbdsdc
 * @details
 * \b Purpose:
    \verbatim 
    LASD8 finds the square roots of the roots of the secular equation,
    as defined by the values in DSIGMA and Z. It makes the appropriate
    calls to SLASD4, and stores, for each  element in D, the distance
    to its two nearest poles (elements in DSIGMA). It also updates
    the arrays VF and VL, the first and last components of all the
    right singular vectors of the original bidiagonal matrix.

    LASD8 is called from LASD6.
    \endverbatim 

 * @param[in] ICOMPQ
          ICOMPQ is INTEGER \n
          Specifies whether singular vectors are to be computed in
          factored form in the calling routine: \n
          = 0: Compute singular values only. \n
          = 1: Compute singular vectors in factored form as well. \n
 * @param[in] K
          K is INTEGER \n
          The number of terms in the rational function to be solved
          by SLASD4.  K >= 1. \n
 * @param[out] D
          D is REAL array, dimension (K) \n
          On output, D contains the updated singular values. \n
 * @param[in,out] Z
          Z is REAL array, dimension (K) \n
          On entry, the first K elements of this array contain the
          components of the deflation-adjusted updating row vector. \n
          On exit, Z is updated. \n
 * @param[in,out] VF
          VF is REAL array, dimension (K) \n
          On entry, VF contains  information passed through DBEDE8. \n
          On exit, VF contains the first K components of the first
          components of all right singular vectors of the bidiagonal
          matrix. \n
 * @param[in,out] VL
          VL is REAL array, dimension (K) \n
          On entry, VL contains  information passed through DBEDE8. \n
          On exit, VL contains the first K components of the last
          components of all right singular vectors of the bidiagonal
          matrix. \n
 * @param[out] DIFL
          DIFL is REAL array, dimension (K) \n
          On exit, DIFL(I) = D(I) - DSIGMA(I). \n
 * @param[out] DIFR
          DIFR is REAL array, \n
                   dimension (LDDIFR, 2) if ICOMPQ = 1 and
                   dimension (K) if ICOMPQ = 0. \n
          On exit, DIFR(I,1) = D(I) - DSIGMA(I+1), DIFR(K,1) is not
          defined and will not be referenced. \n
 \n
          If ICOMPQ = 1, DIFR(1:K,2) is an array containing the
          normalizing factors for the right singular vector matrix. \n
 * @param[in] LDDIFR
          LDDIFR is INTEGER \n
          The leading dimension of DIFR, must be at least K. \n
 * @param[in,out] DSIGMA
          DSIGMA is REAL array, dimension (K) \n
          On entry, the first K elements of this array contain the old
          roots of the deflated updating problem.  These are the poles
          of the secular equation. \n
          On exit, the elements of DSIGMA may be very slightly altered
          in value. \n
 * @param[out] WORK
          WORK is REAL array, dimension (3*K) \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n
          > 0:  if INFO = 1, a singular value did not converge  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lasd8(integer *icompq, integer *k, T *d, T * z, T *vf, T *vl, T *difl, T *difr, integer *lddifr, T *dsigma, T *work, integer *info)
{
  return lasd8(icompq, k, d, z, vf, vl, difl, difr, lddifr, dsigma, work, info); 
}

/*! @brief LASDA computes the singular value decomposition (SVD) of a \n
     real upper bidiagonal matrix with diagonal d and off-diagonal e. \n
     Used by sbdsdc
 * @details
 * \b Purpose:
    \verbatim 
    Using a divide and conquer approach, LASDA computes the singular
    value decomposition (SVD) of a real upper bidiagonal N-by-M matrix
    B with diagonal D and offdiagonal E, where M = N + SQRE. The
    algorithm computes the singular values in the SVD B = U * S * VT.
    The orthogonal matrices U and VT are optionally computed in
    compact form.

    A related subroutine, SLASD0, computes the singular values and
    the singular vectors in explicit form.
    \endverbatim 

 * @param[in] ICOMPQ
          ICOMPQ is INTEGER \n
          Specifies whether singular vectors are to be computed
          in compact form, as follows \n
          = 0: Compute singular values only. \n
          = 1: Compute singular vectors of upper bidiagonal
               matrix in compact form. \n
 * @param[in] SMLSIZ
          SMLSIZ is INTEGER \n
          The maximum size of the subproblems at the bottom of the
          computation tree. \n
 * @param[in] N
          N is INTEGER \n
          The row dimension of the upper bidiagonal matrix. This is
          also the dimension of the main diagonal array D. \n
 * @param[in] SQRE
          SQRE is INTEGER \n
          Specifies the column dimension of the bidiagonal matrix. \n
          = 0: The bidiagonal matrix has column dimension M = N; \n
          = 1: The bidiagonal matrix has column dimension M = N + 1. \n
 * @param[in,out] D
          D is REAL array, dimension (N) \n
          On entry D contains the main diagonal of the bidiagonal
          matrix. On exit D, if INFO = 0, contains its singular values. \n
 * @param[in] E
          E is REAL array, dimension (M-1) \n
          Contains the subdiagonal entries of the bidiagonal matrix.
          On exit, E has been destroyed. \n
 * @param[out] U
          U is REAL array, \n
          dimension (LDU, SMLSIZ) if ICOMPQ = 1, and not referenced
          if ICOMPQ = 0. If ICOMPQ = 1, on exit, U contains the left
          singular vector matrices of all subproblems at the bottom
          level. \n
 * @param[in] LDU
          LDU is INTEGER, LDU = > N. \n
          The leading dimension of arrays U, VT, DIFL, DIFR, POLES,
          GIVNUM, and Z. \n
 * @param[out] VT
          VT is REAL array, \n
          dimension (LDU, SMLSIZ+1) if ICOMPQ = 1, and not referenced
          if ICOMPQ = 0. If ICOMPQ = 1, on exit, VT**T contains the right
          singular vector matrices of all subproblems at the bottom
          level. \n
 * @param[out] K
          K is INTEGER array, dimension (N) \n
          if ICOMPQ = 1 and dimension 1 if ICOMPQ = 0. \n
          If ICOMPQ = 1, on exit, K(I) is the dimension of the I-th
          secular equation on the computation tree. \n
 * @param[out] DIFL
          DIFL is REAL array, dimension (LDU, NLVL), \n
          where NLVL = floor(log_2 (N/SMLSIZ))). \n
 * @param[out] DIFR
          DIFR is REAL array, \n
                  dimension (LDU, 2 * NLVL) if ICOMPQ = 1 and \n
                  dimension (N) if ICOMPQ = 0. \n
          If ICOMPQ = 1, on exit, DIFL(1:N, I) and DIFR(1:N, 2 * I - 1)
          record distances between singular values on the I-th
          level and singular values on the (I -1)-th level, and
          DIFR(1:N, 2 * I) contains the normalizing factors for
          the right singular vector matrix. See SLASD8 for details. \n
 * @param[out] Z
          Z is REAL array, \n
                  dimension (LDU, NLVL) if ICOMPQ = 1 and \n
                  dimension (N) if ICOMPQ = 0. \n
          The first K elements of Z(1, I) contain the components of
          the deflation-adjusted updating row vector for subproblems
          on the I-th level. \n
 * @param[out] POLES
          POLES is REAL array, \n
          dimension (LDU, 2 * NLVL) if ICOMPQ = 1, and not referenced
          if ICOMPQ = 0. If ICOMPQ = 1, on exit, POLES(1, 2*I - 1) and
          POLES(1, 2*I) contain  the new and old singular values
          involved in the secular equations on the I-th level. \n
 * @param[out] GIVPTR
          GIVPTR is INTEGER array, \n
          dimension (N) if ICOMPQ = 1, and not referenced if
          ICOMPQ = 0. If ICOMPQ = 1, on exit, GIVPTR(I) records
          the number of Givens rotations performed on the I-th
          problem on the computation tree. \n
 * @param[out] GIVCOL
          GIVCOL is INTEGER array, \n
          dimension (LDGCOL, 2 * NLVL) if ICOMPQ = 1, and not
          referenced if ICOMPQ = 0. If ICOMPQ = 1, on exit, for each I,
          GIVCOL(1, 2 *I - 1) and GIVCOL(1, 2 *I) record the locations
          of Givens rotations performed on the I-th level on the
          computation tree. \n
 * @param[in] LDGCOL
          LDGCOL is INTEGER, LDGCOL = > N. \n
          The leading dimension of arrays GIVCOL and PERM. \n
 * @param[out] PERM
          PERM is INTEGER array, dimension (LDGCOL, NLVL) \n
          if ICOMPQ = 1, and not referenced \n
          if ICOMPQ = 0. If ICOMPQ = 1, on exit, PERM(1, I) records
          permutations done on the I-th level of the computation tree. \n
 * @param[out] GIVNUM
          GIVNUM is REAL array, \n
          dimension (LDU, 2 * NLVL) if ICOMPQ = 1, and not \n
          referenced if ICOMPQ = 0. If ICOMPQ = 1, on exit, for each I,
          GIVNUM(1, 2 *I - 1) and GIVNUM(1, 2 *I) record the C- and S-
          values of Givens rotations performed on the I-th level on
          the computation tree. \n
 * @param[out] C
          C is REAL array, \n
          dimension (N) if ICOMPQ = 1, and dimension 1 if ICOMPQ = 0.
          If ICOMPQ = 1 and the I-th subproblem is not square, on exit,
          C(I) contains the C-value of a Givens rotation related to
          the right null space of the I-th subproblem. \n
 * @param[out] S
          S is REAL array, dimension (N) if \n
          ICOMPQ = 1, and dimension 1 if ICOMPQ = 0. If ICOMPQ = 1
          and the I-th subproblem is not square, on exit, S(I)
          contains the S-value of a Givens rotation related to
          the right null space of the I-th subproblem. \n
 * @param[out] WORK
          WORK is REAL array, dimension
          (6 * N + (SMLSIZ + 1)*(SMLSIZ + 1)). \n
 * @param[out] IWORK
          IWORK is INTEGER array, dimension (7*N). \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit. \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n
          > 0:  if INFO = 1, a singular value did not converge  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lasda(integer *icompq, integer *smlsiz, integer *n, integer *sqre, T *d, T *e, T *u, integer *ldu, T *vt, integer *k, T *difl, T *difr, T *z, T *poles, integer * givptr, integer *givcol, integer *ldgcol, integer *perm, T *givnum, T *c, T *s, T *work, integer *iwork, integer *info)
{
  return lasda(icompq, smlsiz, n, sqre, d, e, u, ldu, vt, k, difl, difr, z, poles, givptr, givcol, ldgcol, perm, givnum, c, s, work, iwork, info); 
}

/*! @brief LASDQ computes the SVD of a real bidiagonal matrix with diagonal \n
     d and off-diagonal e. Used by sbdsdc
 * @details
 * \b Purpose:
    \verbatim 
    LASDQ computes the singular value decomposition (SVD) of a real
    (upper or lower) bidiagonal matrix with diagonal D and offdiagonal
    E, accumulating the transformations if desired. Letting B denote
    the input bidiagonal matrix, the algorithm computes orthogonal
    matrices Q and P such that B = Q * S * P**T (P**T denotes the transpose
    of P). The singular values S are overwritten on D.

    The input matrix U  is changed to U  * Q  if desired.
    The input matrix VT is changed to P**T * VT if desired.
    The input matrix C  is changed to Q**T * C  if desired.

    See "Computing  Small Singular Values of Bidiagonal Matrices With
    Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
    LAPACK Working Note #3, for a detailed description of the algorithm.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          On entry, UPLO specifies whether the input bidiagonal matrix
          is upper or lower bidiagonal, and whether it is square are
          not. \n
             UPLO = 'U' or 'u'   B is upper bidiagonal. \n
             UPLO = 'L' or 'l'   B is lower bidiagonal. \n
 * @param[in] SQRE
          SQRE is INTEGER \n
          = 0: then the input matrix is N-by-N. \n
          = 1: then the input matrix is N-by-(N+1) if UPLU = 'U' and
               (N+1)-by-N if UPLU = 'L'. \n
 \n
          The bidiagonal matrix has \n
          N = NL + NR + 1 rows and \n
          M = N + SQRE >= N columns. \n
 * @param[in] N
          N is INTEGER \n
          On entry, N specifies the number of rows and columns
          in the matrix. N must be at least 0. \n
 * @param[in] NCVT
          NCVT is INTEGER \n
          On entry, NCVT specifies the number of columns of
          the matrix VT. NCVT must be at least 0. \n
 * @param[in] NRU
          NRU is INTEGER \n
          On entry, NRU specifies the number of rows of
          the matrix U. NRU must be at least 0. \n
 * @param[in] NCC
          NCC is INTEGER \n
          On entry, NCC specifies the number of columns of
          the matrix C. NCC must be at least 0. \n
 * @param[in,out] D
          D is REAL array, dimension (N) \n
          On entry, D contains the diagonal entries of the
          bidiagonal matrix whose SVD is desired. On normal exit,
          D contains the singular values in ascending order. \n
 * @param[in,out] E
          E is REAL array. \n
          dimension is (N-1) if SQRE = 0 and N if SQRE = 1. \n
          On entry, the entries of E contain the offdiagonal entries
          of the bidiagonal matrix whose SVD is desired. On normal
          exit, E will contain 0. If the algorithm does not converge,
          D and E will contain the diagonal and superdiagonal entries
          of a bidiagonal matrix orthogonally equivalent to the one
          given as input. \n
 * @param[in,out] VT
          VT is REAL array, dimension (LDVT, NCVT) \n
          On entry, contains a matrix which on exit has been
          premultiplied by P**T, dimension N-by-NCVT if SQRE = 0
          and (N+1)-by-NCVT if SQRE = 1 (not referenced if NCVT=0). \n
 * @param[in] LDVT
          LDVT is INTEGER \n
          On entry, LDVT specifies the leading dimension of VT as
          declared in the calling (sub) program. LDVT must be at
          least 1. If NCVT is nonzero LDVT must also be at least N. \n
 * @param[in,out] U
          U is REAL array, dimension (LDU, N) \n
          On entry, contains a  matrix which on exit has been
          postmultiplied by Q, dimension NRU-by-N if SQRE = 0
          and NRU-by-(N+1) if SQRE = 1 (not referenced if NRU=0). \n
 * @param[in] LDU
          LDU is INTEGER \n
          On entry, LDU  specifies the leading dimension of U as
          declared in the calling (sub) program. LDU must be at
          least max(1, NRU). \n
 * @param[in,out] C
          C is REAL array, dimension (LDC, NCC) \n
          On entry, contains an N-by-NCC matrix which on exit
          has been premultiplied by Q**T  dimension N-by-NCC if SQRE = 0
          and (N+1)-by-NCC if SQRE = 1 (not referenced if NCC=0). \n
 * @param[in] LDC
          LDC is INTEGER \n
          On entry, LDC  specifies the leading dimension of C as
          declared in the calling (sub) program. LDC must be at
          least 1. If NCC is nonzero, LDC must also be at least N. \n
 * @param[out] WORK
          WORK is REAL array, dimension (4*N) \n
          Workspace. Only referenced if one of NCVT, NRU, or NCC is
          nonzero, and if N is at least 2. \n
 * @param[out] INFO
          INFO is INTEGER \n
          On exit, a value of 0 indicates a successful exit. \n
          If INFO < 0, argument number -INFO is illegal. \n
          If INFO > 0, the algorithm did not converge, and INFO
          specifies how many superdiagonals did not converge.  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lasdq(char *uplo, integer *sqre, integer *n, integer * ncvt, integer *nru, integer *ncc, T *d, T *e, T *vt, integer *ldvt, T *u, integer *ldu, T *c, integer *ldc, T * work, integer *info)
{
  return lasdq(uplo, sqre, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc, work, info); 
}

/*! @brief LASDT creates a tree of subproblems for bidiagonal divide and conquer. \n
     Used by sbdsdc
 * @details
 * \b Purpose:
    \verbatim 
    LASDT creates a tree of subproblems for bidiagonal divide and
    conquer.
    \endverbatim  

 * @param[in] N
          N is INTEGER \n
          On entry, the number of diagonal elements of the
          bidiagonal matrix. \n
 * @param[out] LVL
          LVL is INTEGER \n
          On exit, the number of levels on the computation tree. \n
 * @param[out] ND
          ND is INTEGER \n
          On exit, the number of nodes on the tree. \n
 * @param[out] INODE
          INODE is INTEGER array, dimension (N) \n
          On exit, centers of subproblems. \n
 * @param[out] NDIML
          NDIML is INTEGER array, dimension (N) \n
          On exit, row dimensions of left children. \n
 * @param[out] NDIMR
          NDIMR is INTEGER array, dimension (N) \n
          On exit, row dimensions of right children. \n
 * @param[in] MSUB
          MSUB is INTEGER \n
          On entry, the maximum row dimension each subproblem at the
          bottom of the tree can be of.  \n

 * @return INTEGER Return value of the function.
 * */
integer slasdt(integer *n, integer *lvl, integer *nd, integer * inode, integer *ndiml, integer *ndimr, integer *msub)
{
  return slasdt_(n, lvl, nd, inode, ndiml, ndimr, msub); 
}
integer dlasdt(integer *n, integer *lvl, integer *nd, integer * inode, integer *ndiml, integer *ndimr, integer *msub)
{
  return dlasdt_(n, lvl, nd, inode, ndiml, ndimr, msub); 
}

/*! @brief LASQ1 computes the singular values of a real square bidiagonal matrix. \n
     Used by sbdsqr
 * @details
 * \b Purpose:
    \verbatim 
    LASQ1 computes the singular values of a real N-by-N bidiagonal
    matrix with diagonal D and off-diagonal E. The singular values
    are computed to high relative accuracy, in the absence of
    denormalization, underflow and overflow. The algorithm was first
    presented in

    "Accurate singular values and differential qd algorithms" by K. V.
    Fernando and B. N. Parlett, Numer. Math., Vol-67, No. 2, pp. 191-230,
    1994,

    and the present implementation is described in "An implementation of
    the dqds Algorithm (Positive Case)", LAPACK Working Note.
    \endverbatim 

 * @param[in] N
          N is INTEGER \n
          The number of rows and columns in the matrix. N >= 0. \n
 * @param[in,out] D
          D is REAL array, dimension (N) \n
          On entry, D contains the diagonal elements of the
          bidiagonal matrix whose SVD is desired. On normal exit,
          D contains the singular values in decreasing order. \n
 * @param[in,out] E
          E is REAL array, dimension (N) \n
          On entry, elements E(1:N-1) contain the off-diagonal elements
          of the bidiagonal matrix whose SVD is desired. \n
          On exit, E is overwritten. \n
 * @param[out] WORK
          WORK is REAL array, dimension (4*N) \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n
          > 0: the algorithm failed \n
               = 1, a split was marked by a positive value in E \n
               = 2, current block of Z not diagonalized after 100*N
                    iterations (in inner while loop)  On exit D and E
                    represent a matrix with the same singular values
                    which the calling subroutine could use to finish the
                    computation, or even feed back into SLASQ1 \n
               = 3, termination criterion of outer while loop not met
                    (program created more than N unreduced blocks) \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lasq1(integer *n, T *d, T *e, T *work, integer *info)
{
  return lasq1(n, d, e, work, info);
}

/*! @brief LASQ2 computes all the eigenvalues of the symmetric positive definite   \n
     tridiagonal matrix associated with the qd Array Z to high relative accuracy.  \n
     Used by sbdsqr and sstegr.
 * @details
 * \b Purpose:
    \verbatim 
    LASQ2 computes all the eigenvalues of the symmetric positive
    definite tridiagonal matrix associated with the qd array Z to high
    relative accuracy are computed to high relative accuracy, in the
    absence of denormalization, underflow and overflow.

    To see the relation of Z to the tridiagonal matrix, let L be a
    unit lower bidiagonal matrix with subdiagonals Z(2,4,6,,..) and
    let U be an upper bidiagonal matrix with 1's above and diagonal
    Z(1,3,5,,..). The tridiagonal is L*U or, if you prefer, the
    symmetric tridiagonal to which it is similar.

    Note : SLASQ2 defines a logical variable, IEEE, which is true
    on machines which follow ieee-754 floating-point standard in their
    handling of infinities and NaNs, and false otherwise. This variable
    is passed to SLASQ3.
    \endverbatim

 * @param[in] N
          N is INTEGER \n
          The number of rows and columns in the matrix. N >= 0. \n
 * @param[in,out] Z
          Z is REAL array, dimension (4*N) \n
          On entry Z holds the qd array. On exit, entries 1 to N hold
          the eigenvalues in decreasing order, Z(2*N+1) holds the
          trace, and Z(2*N+2) holds the sum of the eigenvalues. If
          N > 2, then Z(2*N+3) holds the iteration count, Z(2*N+4)
          holds NDIVS/NIN^2, and Z(2*N+5) holds the percentage of
          shifts that failed. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if the i-th argument is a scalar and had an illegal
               value, then INFO = -i, if the i-th argument is an
               array and the j-entry had an illegal value, then
               INFO = -(i*100+j) \n
          > 0: the algorithm failed \n
                = 1, a split was marked by a positive value in E \n
                = 2, current block of Z not diagonalized after 100*N \n
                     iterations (in inner while loop).  On exit Z holds
                     a qd array with the same eigenvalues as the given Z. \n
                = 3, termination criterion of outer while loop not met
                     (program created more than N unreduced blocks)  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lasq2(integer *n, T *z, integer *info)
{
  return lasq2(n, z, info);
}

/*! @brief LASQ3 checks for deflation, computes a shift and calls dqds. Used by sbdsqr.

 * @details
 * \b Purpose:
    \verbatim 
    LASQ3 checks for deflation, computes a shift (TAU) and calls dqds.
    In case of failure it changes shifts, and tries again until output
    is positive.
    \endverbatim 

 * @param[in] I0
          I0 is INTEGER \n
          First index. \n
 * @param[in,out] N0
          N0 is INTEGER \n
          Last index. \n
 * @param[in,out] Z
          Z is REAL array, dimension (4*N0) \n
          Z holds the qd array. \n
 * @param[in,out] PP
          PP is INTEGER \n
          PP=0 for ping, PP=1 for pong. \n
          PP=2 indicates that flipping was applied to the Z array
          and that the initial tests for deflation should not be
          performed. \n
 * @param[out] DMIN
          DMIN is REAL \n
          Minimum value of d. \n
 * @param[out] SIGMA
          SIGMA is REAL \n
          Sum of shifts used in current segment. \n
 * @param[in,out] DESIG
          DESIG is REAL \n
          Lower order part of SIGMA \n
 * @param[in] QMAX
          QMAX is REAL \n
          Maximum value of q. \n
 * @param[in,out] NFAIL
          NFAIL is INTEGER \n
          Increment NFAIL by 1 each time the shift was too big. \n
 * @param[in,out] ITER
          ITER is INTEGER \n
          Increment ITER by 1 for each iteration. \n
 * @param[in,out] NDIV
          NDIV is INTEGER \n
          Increment NDIV by 1 for each division. \n
 * @param[in] IEEE
          IEEE is LOGICAL \n
          Flag for IEEE or non IEEE arithmetic (passed to SLASQ5). \n
 * @param[in,out] TTYPE
          TTYPE is INTEGER \n
          Shift type. \n
 * @param[in,out] DMIN1
          DMIN1 is REAL \n
 * @param[in,out] DMIN2
          DMIN2 is REAL \n
 * @param[in,out] DN
          DN is REAL \n
 * @param[in,out] DN1
          DN1 is REAL \n
 * @param[in,out] DN2
          DN2 is REAL \n
 * @param[in,out] G
          G is REAL \n
 * @param[in,out] TAU
          TAU is REAL \n
          These are passed as arguments in order to save their values
          between calls to LASQ3. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lasq3(integer *i0, integer *n0, T *z, integer *pp, T *dmin, T *sigma, T *desig, T *qmax, integer *nfail, integer *iter, integer *ndiv, logical *ieee, integer *ttype, T * dmin1, T *dmin2, T *dn, T *dn1, T *dn2, T *g, T * tau)
{
  return lasq3(i0, n0, z, pp, dmin, sigma, desig, qmax, nfail, iter, ndiv, ieee, ttype, dmin1, dmin2, dn, dn1, dn2, g, tau);
}

/*! @brief LASQ4 computes an approximation to the smallest eigenvalue using   \n
     values of d from the previous transform. Used by sbdsqr
 * @details
 * \b Purpose:
    \verbatim 
    LASQ4 computes an approximation TAU to the smallest eigenvalue
    using values of d from the previous transform.
    \endverbatim 

 * @param[in] I0
          I0 is INTEGER \n
          First index. \n
 * @param[in] N0
          N0 is INTEGER \n
          Last index. \n
 * @param[in] Z
          Z is REAL array, dimension (4*N0) \n
          Z holds the qd array. \n
 * @param[in] PP
          PP is INTEGER \n
          PP=0 for ping, PP=1 for pong. \n
 * @param[in] N0IN
          N0IN is INTEGER \n
          The value of N0 at start of EIGTEST. \n
 * @param[in] DMIN
          DMIN is REAL \n
          Minimum value of d. \n
 * @param[in] DMIN1
          DMIN1 is REAL \n
          Minimum value of d, excluding D(N0). \n
 * @param[in] DMIN2
          DMIN2 is REAL \n
          Minimum value of d, excluding D(N0) and D(N0-1). \n
 * @param[in] DN
          DN is REAL \n
          d(N) \n
 * @param[in] DN1
          DN1 is REAL \n
          d(N-1) \n
 * @param[in] DN2
          DN2 is REAL \n
          d(N-2) \n
 * @param[out] TAU
          TAU is REAL \n
          This is the shift. \n
 * @param[out] TTYPE
          TTYPE is INTEGER \n
          Shift type. \n
 * @param[in,out] G
          G is REAL \n
          G is passed as an argument in order to save its value between
          calls to SLASQ4.  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lasq4(integer *i0, integer *n0, T *z, integer *pp, integer *n0in, T *dmin, T *dmin1, T *dmin2, T *dn, T *dn1, T *dn2, T *tau, integer *ttype, T *g)
{
  return lasq4(i0, n0, z, pp, n0in, dmin, dmin1, dmin2, dn, dn1, dn2, tau, ttype, g);
}

/*! @brief LASQ5 computes one dqds transform in ping-pong form. Used by sbdsqr and sstegr

 * @details
 * \b Purpose:
    \verbatim 
    LASQ5 computes one dqds transform in ping-pong form, one
    version for IEEE machines another for non IEEE machines.
    \endverbatim 

 * @param[in] I0
          I0 is INTEGER \n
          First index. \n
 * @param[in] N0
          N0 is INTEGER \n
          Last index. \n
 * @param[in] Z
          Z is REAL array, dimension (4*N) \n
          Z holds the qd array. EMIN is stored in Z(4*N0) to avoid
          an extra argument. \n
 * @param[in] PP
          PP is INTEGER \n
          PP=0 for ping, PP=1 for pong. \n
 * @param[in] TAU
          TAU is REAL \n
          This is the shift. \n
 * @param[in] SIGMA
          SIGMA is REAL \n
          This is the accumulated shift up to this step. \n
 * @param[out] DMIN
          DMIN is REAL \n
          Minimum value of d. \n
 * @param[out] DMIN1
          DMIN1 is REAL \n
          Minimum value of d, excluding D(N0). \n
 * @param[out] DMIN2
          DMIN2 is REAL \n
          Minimum value of d, excluding D(N0) and D(N0-1). \n
 * @param[out] DN
          DN is REAL \n
          d(N0), the last value of d. \n
 * @param[out] DNM1
          DNM1 is REAL \n
          d(N0-1). \n
 * @param[out] DNM2
          DNM2 is REAL \n
          d(N0-2). \n
 * @param[in] IEEE
          IEEE is LOGICAL \n
          Flag for IEEE or non IEEE arithmetic. \n
 * @param[in] EPS
          EPS is REAL \n
          This is the value of epsilon used. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lasq5(integer *i0, integer *n0, T *z, integer *pp, T *tau, T *sigma, T *dmin, T *dmin1, T *dmin2, T *dn, T *dnm1, T *dnm2, logical *ieee, T *eps)
{
  return lasq5(i0, n0, z, pp, tau, sigma, dmin, dmin1, dmin2, dn, dnm1, dnm2, ieee, eps);
}

/*! @brief LASQ6 computes one dqd transform in ping-pong form. Used by sbdsqr and sstegr.

 * @details
 * \b Purpose:
    \verbatim 
    LASQ6 computes one dqd (shift equal to zero) transform in
    ping-pong form, with protection against underflow and overflow.
    \endverbatim 

 * @param[in] I0
          I0 is INTEGER \n
          First index. \n
 * @param[in] N0
          N0 is INTEGER \n
          Last index. \n
 * @param[in] Z
          Z is REAL array, dimension (4*N) \n
          Z holds the qd array. EMIN is stored in Z(4*N0) to avoid
          an extra argument. \n
 * @param[in] PP 
          PP is INTEGER \n
          PP=0 for ping, PP=1 for pong.  \n
 * @param[out] DMIN
          DMIN is REAL \n
          Minimum value of d. \n
 * @param[out] DMIN1
          DMIN1 is REAL \n
          Minimum value of d, excluding D(N0). \n
 * @param[out] DMIN2
          DMIN2 is REAL \n
          Minimum value of d, excluding D(N0) and D(N0-1). \n
 * @param[out] DN
          DN is REAL \n
          d(N0), the last value of d. \n
 * @param[out] DNM1
          DNM1 is REAL \n
          d(N0-1). \n
 * @param[out] DNM2
          DNM2 is REAL \n
          d(N0-2).  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lasq6(integer *i0, integer *n0, T *z, integer *pp, T *dmin, T *dmin1, T *dmin2, T *dn, T *dnm1, T * dnm2) 
{
  return lasq6(i0, n0, z, pp, dmin, dmin1, dmin2, dn, dnm1, dnm2);
}

/*! @brief LASR applies a sequence of plane rotations to a general rectangular matrix

 * @details
 * \b Purpose:
    \verbatim 
    LASR applies a sequence of plane rotations to a real matrix A,
    from either the left or the right.

    When SIDE = 'L', the transformation takes the form

       A := P*A

    and when SIDE = 'R', the transformation takes the form

       A := A*P**T

    where P is an orthogonal matrix consisting of a sequence of z plane
    rotations, with z = M when SIDE = 'L' and z = N when SIDE = 'R',
    and P**T is the transpose of P.

    When DIRECT = 'F' (Forward sequence), then

       P = P(z-1) * ... * P(2) * P(1)

    and when DIRECT = 'B' (Backward sequence), then

       P = P(1) * P(2) * ... * P(z-1)

    where P(k) is a plane rotation matrix defined by the 2-by-2 rotation

       R(k) = ( c(k)  s(k))
            = (-s(k)  c(k)).

    When PIVOT = 'V' (Variable pivot), the rotation is performed
    for the plane (k,k+1), i.e., P(k) has the form

       P(k) = ( 1                                           )
              (      ...                                    )
              (             1                               )
              (                  c(k)  s(k)                 )
              (                 -s(k)  c(k)                 )
              (                               1             )
              (                                    ...      )
              (                                           1 )

    where R(k) appears as a rank-2 modification to the identity matrix in
    rows and columns k and k+1.

    When PIVOT = 'T' (Top pivot), the rotation is performed for the
    plane (1,k+1), so P(k) has the form

       P(k) = ( c(k)                    s(k)                )
              (        1                                    )
              (             ...                             )
              (                    1                        )
              (-s(k)                    c(k)                )
              (                                1            )
              (                                     ...     )
              (                                            1)

    where R(k) appears in rows and columns 1 and k+1.

    Similarly, when PIVOT = 'B' (Bottom pivot), the rotation is
    performed for the plane (k,z), giving P(k) the form

       P(k) = (1                                            )
              (     ...                                     )
              (            1                                )
              (                 c(k)                    s(k))
              (                        1                    )
              (                             ...             )
              (                                    1        )
              (                -s(k)                    c(k))

    where R(k) appears in rows and columns k and z.  The rotations are
    performed without ever forming P(k) explicitly.
    \endverbatim  

 * @param[in] SIDE
          SIDE is CHARACTER*1 \n
          Specifies whether the plane rotation matrix P is applied to
          A on the left or the right. \n
          = 'L':  Left, compute A := P*A \n
          = 'R':  Right, compute A:= A*P**T \n
 * @param[in] PIVOT
          PIVOT is CHARACTER*1 \n
          Specifies the plane for which P(k) is a plane rotation
          matrix. \n
          = 'V':  Variable pivot, the plane (k,k+1) \n
          = 'T':  Top pivot, the plane (1,k+1) \n
          = 'B':  Bottom pivot, the plane (k,z) \n
 * @param[in] DIRECT
          DIRECT is CHARACTER*1 \n
          Specifies whether P is a forward or backward sequence of
          plane rotations. \n
          = 'F':  Forward, P = P(z-1)*...*P(2)*P(1) \n
          = 'B':  Backward, P = P(1)*P(2)*...*P(z-1) \n
 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  If m <= 1, an immediate
          return is effected. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A.  If n <= 1, an
          immediate   return is effected. \n
 * @param[in] C
          C is REAL array, dimension \n
                  (M-1) if SIDE = 'L' \n
                  (N-1) if SIDE = 'R' \n
          The cosines c(k) of the plane rotations. \n
 * @param[in] S
          S is REAL array, dimension \n
                  (M-1) if SIDE = 'L' \n
                  (N-1) if SIDE = 'R' \n
          The sines s(k) of the plane rotations.  The 2-by-2 plane
          rotation part of the matrix P(k), R(k), has the form \n
          R(k) = ( c(k)  s(k)) \n
                 (-s(k)  c(k)). \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          The M-by-N matrix A.  On exit, A is overwritten by P*A if
          SIDE = 'R' or by A*P**T if SIDE = 'L'. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,M).  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lasr(char *side, char *pivot, char *direct, integer *m, integer *n, T *c, T *s, T *a, integer *lda)
{
  return lasr(side, pivot, direct, m, n, c, s, a, lda);
}
template< typename T, typename Ta >
integer lasr(char *side, char *pivot, char *direct, integer *m, integer *n, Ta *c, Ta *s, T *a, integer *lda)
{
  return lasr(side, pivot, direct, m, n, c, s, a, lda);
}

/*! @brief LASV2 computes the singular value decomposition of a 2-by-2 triangular matrix

 * @details
 * \b Purpose:
    \verbatim 
    LASV2 computes the singular value decomposition of a 2-by-2
    triangular matrix
       [  F   G  ]
       [  0   H  ].
    On   return, abs(SSMAX) is the larger singular value, abs(SSMIN) is the
    smaller singular value, and (CSL,SNL) and (CSR,SNR) are the left and
    right singular vectors for abs(SSMAX), giving the decomposition

       [ CSL  SNL ] [  F   G  ] [ CSR -SNR ]  =  [ SSMAX   0   ]
       [-SNL  CSL ] [  0   H  ] [ SNR  CSR ]     [  0    SSMIN ].
    \endverbatim 

 * @param[in] F
          F is REAL \n
          The (1,1) element of the 2-by-2 matrix. \n
 * @param[in] G
          G is REAL \n
          The (1,2) element of the 2-by-2 matrix. \n
 * @param[in] H
          H is REAL \n
          The (2,2) element of the 2-by-2 matrix. \n
 * @param[out] SSMIN
          SSMIN is REAL \n
          abs(SSMIN) is the smaller singular value. \n
 * @param[out] SSMAX
          SSMAX is REAL \n
          abs(SSMAX) is the larger singular value. \n
 * @param[out] SNL
          SNL is REAL \n
 * @param[out] CSL
          CSL is REAL \n
          The vector (CSL, SNL) is a unit left singular vector for the
          singular value abs(SSMAX). \n
 * @param[out] SNR
          SNR is REAL \n
 * @param[out] CSR
          CSR is REAL \n
          The vector (CSR, SNR) is a unit right singular vector for the
          singular value abs(SSMAX).  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lasv2(T *f, T *g, T *h, T *ssmin, T * ssmax, T *snr, T *csr, T *snl, T *csl)
{
  return lasv2(f, g, h, ssmin, ssmax, snr, csr, snl, csl);
}

/*! @brief LASWLQ computes a blocked Tall-Skinny LQ factorization of a real M-by-N matrix A for M <= N

 * @details
 * \b Purpose:
    \verbatim 
     LASWLQ computes a blocked Tall-Skinny LQ factorization of
     a real M-by-N matrix A for M <= N:
    
        A = (L 0) *  Q,
    
     where:
    
        Q is a n-by-N orthogonal matrix, stored on exit in an implicit
        form in the elements above the digonal of the array A and in
        the elemenst of the array T;
        L is an lower-triangular M-by-M matrix stored on exit in
        the elements on and below the diagonal of the array A.
        0 is a M-by-(N-M) zero matrix, if M < N, and is not stored.
    \endverbatim 

  * @param[in] M
           M is INTEGER \n
           The number of rows of the matrix A.  M >= 0. \n
  * @param[in] N
           N is INTEGER \n
           The number of columns of the matrix A.  N >= M >= 0. \n
  * @param[in] MB
           MB is INTEGER \n
           The row block size to be used in the blocked QR.
           M >= MB >= 1 \n
  * @param[in] NB
           NB is INTEGER \n
           The column block size to be used in the blocked QR.
           NB > M. \n
  * @param[in,out] A
           A is REAL array, dimension (LDA,N) \n
           On entry, the M-by-N matrix A. \n
           On exit, the elements on and below the diagonal
           of the array contain the N-by-N lower triangular matrix L;
           the elements above the diagonal represent Q by the rows
           of blocked V (see Further Details). \n
  * @param[in] LDA
           LDA is INTEGER \n
           The leading dimension of the array A.  LDA >= max(1,M). \n
  * @param[out] T
           T is REAL array,
           dimension (LDT, N * Number_of_row_blocks) \n
           where Number_of_row_blocks = CEIL((N-M)/(NB-M)) \n
           The blocked upper triangular block reflectors stored in compact form
           as a sequence of upper triangular blocks.
           See Further Details below. \n
  * @param[in] LDT
           LDT is INTEGER \n
           The leading dimension of the array T.  LDT >= MB. \n
  * @param[out] WORK
          (workspace) REAL array, dimension (MAX(1,LWORK)) \n
  * @param[in] LWORK
           The dimension of the array WORK.  LWORK >= MB * M. \n
           If LWORK = -1, then a workspace query is assumed; the routine
           only calculates the optimal size of the WORK array,   returns
           this value as the first entry of the WORK array, and no error
           message related to LWORK is issued by XERBLA. \n
  * @param[out] INFO
           INFO is INTEGER \n
           = 0:  successful exit \n
           < 0:  if INFO = -i, the i-th argument had an illegal value   \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer laswlq(integer *m, integer *n, integer *mb, integer * nb, T *a, integer *lda, T *t, integer *ldt, T *work, integer *lwork, integer *info)
{
  return laswlq(m, n, mb, nb, a, lda, t, ldt, work, lwork, info);
}

/*! @brief LASY2 solves the Sylvester matrix equation where the matrices are of order 1 or 2

 * @details
 * \b Purpose:
    \verbatim 
    LASY2 solves for the N1 by N2 matrix X, 1 <= N1,N2 <= 2, in

           op(TL)*X + ISGN*X*op(TR) = SCALE*B,

    where TL is N1 by N1, TR is N2 by N2, B is N1 by N2, and ISGN = 1 or
    -1.  op(T) = T or T**T, where T**T denotes the transpose of T.
    \endverbatim 

 * @param[in] LTRANL
          LTRANL is LOGICAL \n
          On entry, LTRANL specifies the op(TL): \n
             = .FALSE., op(TL) = TL, \n
             = .TRUE., op(TL) = TL**T. \n
 * @param[in] LTRANR
          LTRANR is LOGICAL \n
          On entry, LTRANR specifies the op(TR): \n
            = .FALSE., op(TR) = TR, \n
            = .TRUE., op(TR) = TR**T. \n
 * @param[in] ISGN
          ISGN is INTEGER \n
          On entry, ISGN specifies the sign of the equation
          as described before. ISGN may only be 1 or -1. \n
 * @param[in] N1
          N1 is INTEGER \n
          On entry, N1 specifies the order of matrix TL.
          N1 may only be 0, 1 or 2. \n
 * @param[in] N2
          N2 is INTEGER \n
          On entry, N2 specifies the order of matrix TR.
          N2 may only be 0, 1 or 2. \n
 * @param[in] TL
          TL is REAL array, dimension (LDTL,2) \n
          On entry, TL contains an N1 by N1 matrix. \n
 * @param[in] LDTL
          LDTL is INTEGER \n
          The leading dimension of the matrix TL. LDTL >= max(1,N1). \n
 * @param[in] TR
          TR is REAL array, dimension (LDTR,2) \n
          On entry, TR contains an N2 by N2 matrix. \n
 * @param[in] LDTR
          LDTR is INTEGER \n
          The leading dimension of the matrix TR. LDTR >= max(1,N2). \n
 * @param[in] B
          B is REAL array, dimension (LDB,2) \n
          On entry, the N1 by N2 matrix B contains the right-hand
          side of the equation. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the matrix B. LDB >= max(1,N1). \n
 * @param[out] SCALE
          SCALE is REAL \n
          On exit, SCALE contains the scale factor. SCALE is chosen
          less than or equal to 1 to prevent the solution overflowing. \n
 * @param[out] X
          X is REAL array, dimension (LDX,2) \n
          On exit, X contains the N1 by N2 solution. \n
 * @param[in] LDX
          LDX is INTEGER \n
          The leading dimension of the matrix X. LDX >= max(1,N1). \n
 * @param[out] XNORM
          XNORM is REAL \n
          On exit, XNORM is the infinity-norm of the solution. \n
 * @param[out] INFO
          INFO is INTEGER \n
          On exit, INFO is set to \n
             0: successful exit. \n
             1: TL and TR have too close eigenvalues, so TL or
                TR is perturbed to get a nonsingular equation. \n
          NOTE: In the interests of speed, this routine does not
                check the inputs for errors.   \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lasy2(logical *ltranl, logical *ltranr, integer *isgn, integer *n1, integer *n2, T *tl, integer *ldtl, T *tr, integer * ldtr, T *b, integer *ldb, T *scale, T *x, integer *ldx, T *xnorm, integer *info)
{
  return lasy2(ltranl, ltranr, isgn, n1, n2, tl, ldtl, tr,  ldtr, b, ldb, scale, x, ldx, xnorm, info);
}

/*! @brief LASYF computes a partial factorization of a real symmetric matrix using the Bunch-Kaufman diagonal pivoting method

 * @details
 * \b Purpose:
    \verbatim 
    LASYF computes a partial factorization of a real symmetric matrix A
    using the Bunch-Kaufman diagonal pivoting method. The partial
    factorization has the form:

    A  =  (I  U12) (A11  0 ) ( I       0   )  if UPLO = 'U', or:
          (0  U22) ( 0   D ) (U12**T U22**T)

    A  =  (L11  0) ( D   0 ) (L11**T L21**T)  if UPLO = 'L'
          (L21  I) ( 0  A22) ( 0       I   )

    where the order of D is at most NB. The actual order is   returned in
    the argument KB, and is either NB or NB-1, or N if N <= NB.

    SLASYF is an auxiliary routine called by SSYTRF. It uses blocked code
    (calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or
    A22 (if UPLO = 'L').
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the upper or lower triangular part of the
          symmetric matrix A is stored: \n
          = 'U':  Upper triangular \n
          = 'L':  Lower triangular \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NB
          NB is INTEGER \n
          The maximum number of columns of the matrix A that should be
          factored.  NB should be at least 2 to allow for 2-by-2 pivot
          blocks. \n
 * @param[out] KB
          KB is INTEGER \n
          The number of columns of A that were actually factored.
          KB is either NB-1 or NB, or N if N <= NB. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
          n-by-n upper triangular part of A contains the upper
          triangular part of the matrix A, and the strictly lower
          triangular part of A is not referenced.  If UPLO = 'L', the
          leading n-by-n lower triangular part of A contains the lower
          triangular part of the matrix A, and the strictly upper
          triangular part of A is not referenced. \n
          On exit, A contains details of the partial factorization. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D.
 \n
          If UPLO = 'U': \n
             Only the last KB elements of IPIV are set.
 \n
             If IPIV(k) > 0, then rows and columns k and IPIV(k) were
             interchanged and D(k,k) is a 1-by-1 diagonal block.
 \n
             If IPIV(k) = IPIV(k-1) < 0, then rows and columns
             k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
             is a 2-by-2 diagonal block.
 \n
          If UPLO = 'L': \n
             Only the first KB elements of IPIV are set.
 \n
             If IPIV(k) > 0, then rows and columns k and IPIV(k) were
             interchanged and D(k,k) is a 1-by-1 diagonal block.
 \n
             If IPIV(k) = IPIV(k+1) < 0, then rows and columns
             k+1 and -IPIV(k) were interchanged and D(k:k+1,k:k+1)
             is a 2-by-2 diagonal block. \n
 * @param[out] W
          W is REAL array, dimension (LDW,NB) \n
 * @param[in] LDW
          LDW is INTEGER \n
          The leading dimension of the array W.  LDW >= max(1,N). \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0: successful exit \n
          > 0: if INFO = k, D(k,k) is exactly zero. The factorization
               has been completed, but the block diagonal matrix D is
               exactly singular.  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lasyf(char *uplo, integer *n, integer *nb, integer *kb, T *a, integer *lda, integer *ipiv, T *w, integer *ldw, integer *info)
{
  return lasyf(uplo, n, nb, kb, a, lda, ipiv, w, ldw, info);
}

/*! @brief LASYF_AA factorizes a panel of a real symmetric matrix A using the Aasen's algorithm

 * @details
 * \b Purpose:
    \verbatim 
    LASYF_AA factorizes a panel of a real symmetric matrix A using
    the Aasen's algorithm. The panel consists of a set of NB rows of A
    when UPLO is U, or a set of NB columns when UPLO is L.
   
    In order to factorize the panel, the Aasen's algorithm requires the
    last row, or column, of the previous panel. The first row, or column,
    of A is set to be the first row, or column, of an identity matrix,
    which is used to factorize the first panel.
   
    The resulting J-th row of U, or J-th column of L, is stored in the
    (J-1)-th row, or column, of A (without the unit diagonals), while
    the diagonal and subdiagonal of A are overwritten by those of T.
    \endverbatim 
  
  * @param[in] UPLO
           UPLO is CHARACTER*1 \n
           = 'U':  Upper triangle of A is stored; \n
           = 'L':  Lower triangle of A is stored. \n
  * @param[in] J1
           J1 is INTEGER \n
           The location of the first row, or column, of the panel
           within the submatrix of A, passed to this routine, e.g.,
           when called by SSYTRF_AA, for the first panel, J1 is 1,
           while for the remaining panels, J1 is 2. \n
  * @param[in] M
           M is INTEGER \n
           The dimension of the submatrix. M >= 0. \n
  * @param[in] NB
           NB is INTEGER \n
           The dimension of the panel to be facotorized. \n
  * @param[in,out] A
           A is REAL array, dimension (LDA,M) for \n
           the first panel, while dimension (LDA,M+1) for the
           remaining panels. \n
  \n
           On entry, A contains the last row, or column, of
           the previous panel, and the trailing submatrix of A
           to be factorized, except for the first panel, only
           the panel is passed.
  \n
           On exit, the leading panel is factorized. \n
  * @param[in] LDA
           LDA is INTEGER \n
           The leading dimension of the array A.  LDA >= max(1,M). \n
  * @param[out] IPIV
           IPIV is INTEGER array, dimension (M) \n
           Details of the row and column interchanges,
           the row and column k were interchanged with the row and
           column IPIV(k). \n
  * @param[in,out] H
           H is REAL workspace, dimension (LDH,NB). \n
  * @param[in] LDH
           LDH is INTEGER \n
           The leading dimension of the workspace H. LDH >= max(1,M). \n
  * @param[out] WORK
           WORK is REAL workspace, dimension (M).  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lasyf_aa(char *uplo, integer *j1, integer *m, integer *nb, T *a, integer *lda, integer *ipiv, T *h, integer *ldh, T *work)
{
  return lasyf_aa(uplo, j1, m, nb, a, lda, ipiv, h, ldh, work);
}

/*! @brief LASYF_RK computes a partial factorization of a real symmetric indefinite \n
     matrix using bounded Bunch-Kaufman (rook) diagonal pivoting method
 * @details
 * \b Purpose:
    \verbatim 
    LASYF_RK computes a partial factorization of a real symmetric
    matrix A using the bounded Bunch-Kaufman (rook) diagonal
    pivoting method. The partial factorization has the form:

    A  =  (I  U12) (A11  0 ) ( I       0   )  if UPLO = 'U', or:
          (0  U22) ( 0   D ) (U12**T U22**T)

    A  =  (L11  0) ( D   0 ) (L11**T L21**T)  if UPLO = 'L',
          (L21  I) ( 0  A22) ( 0       I   )

    where the order of D is at most NB. The actual order is   returned in
    the argument KB, and is either NB or NB-1, or N if N <= NB.

    LASYF_RK is an auxiliary routine called by SSYTRF_RK. It uses
    blocked code (calling Level 3 BLAS) to update the submatrix
    A11 (if UPLO = 'U') or A22 (if UPLO = 'L').
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the upper or lower triangular part of the
          symmetric matrix A is stored: \n
          = 'U':  Upper triangular \n
          = 'L':  Lower triangular \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NB
          NB is INTEGER \n
          The maximum number of columns of the matrix A that should be
          factored.  NB should be at least 2 to allow for 2-by-2 pivot
          blocks. \n
 * @param[out] KB
          KB is INTEGER \n
          The number of columns of A that were actually factored.
          KB is either NB-1 or NB, or N if N <= NB. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the symmetric matrix A. \n
            If UPLO = 'U': the leading N-by-N upper triangular part
            of A contains the upper triangular part of the matrix A,
            and the strictly lower triangular part of A is not
            referenced.
 \n
            If UPLO = 'L': the leading N-by-N lower triangular part
            of A contains the lower triangular part of the matrix A,
            and the strictly upper triangular part of A is not
            referenced.
 \n
          On exit, contains: \n
            a) ONLY diagonal elements of the symmetric block diagonal
               matrix D on the diagonal of A, i.e. D(k,k) = A(k,k);
               (superdiagonal (or subdiagonal) elements of D
                are stored on exit in array E), and \n
            b) If UPLO = 'U': factor U in the superdiagonal part of A.
               If UPLO = 'L': factor L in the subdiagonal part of A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] E
          E is REAL array, dimension (N) \n
          On exit, contains the superdiagonal (or subdiagonal)
          elements of the symmetric block diagonal matrix D
          with 1-by-1 or 2-by-2 diagonal blocks, where \n
          If UPLO = 'U': E(i) = D(i-1,i), i=2:N, E(1) is set to 0; \n
          If UPLO = 'L': E(i) = D(i+1,i), i=1:N-1, E(N) is set to 0. \n
 \n
          NOTE: For 1-by-1 diagonal block D(k), where
          1 <= k <= N, the element E(k) is set to 0 in both
          UPLO = 'U' or UPLO = 'L' cases. \n
 * @param[out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          IPIV describes the permutation matrix P in the factorization
          of matrix A as follows. The absolute value of IPIV(k)
          represents the index of row and column that were
          interchanged with the k-th row and column. The value of UPLO
          describes the order in which the interchanges were applied.
          Also, the sign of IPIV represents the block structure of
          the symmetric block diagonal matrix D with 1-by-1 or 2-by-2
          diagonal blocks which correspond to 1 or 2 interchanges
          at each factorization step. \n
 \n
          If UPLO = 'U',
          (in factorization order, k decreases from N to 1): \n
            a) A single positive entry IPIV(k) > 0 means:
               D(k,k) is a 1-by-1 diagonal block.
               If IPIV(k) != k, rows and columns k and IPIV(k) were
               interchanged in the submatrix A(1:N,N-KB+1:N);
               If IPIV(k) = k, no interchange occurred. \n
 \n
            b) A pair of consecutive negative entries
               IPIV(k) < 0 and IPIV(k-1) < 0 means:
               D(k-1:k,k-1:k) is a 2-by-2 diagonal block.
               (NOTE: negative entries in IPIV appear ONLY in pairs). \n
               1) If -IPIV(k) != k, rows and columns
                  k and -IPIV(k) were interchanged
                  in the matrix A(1:N,N-KB+1:N).
                  If -IPIV(k) = k, no interchange occurred. \n
               2) If -IPIV(k-1) != k-1, rows and columns
                  k-1 and -IPIV(k-1) were interchanged
                  in the submatrix A(1:N,N-KB+1:N).
                  If -IPIV(k-1) = k-1, no interchange occurred. \n
 \n
            c) In both cases a) and b) is always ABS(IPIV(k)) <= k. \n
 \n
            d) NOTE: Any entry IPIV(k) is always NONZERO on output. \n
 \n
          If UPLO = 'L',
          (in factorization order, k increases from 1 to N): \n
            a) A single positive entry IPIV(k) > 0 means:
               D(k,k) is a 1-by-1 diagonal block.
               If IPIV(k) != k, rows and columns k and IPIV(k) were
               interchanged in the submatrix A(1:N,1:KB).
               If IPIV(k) = k, no interchange occurred. \n
 \n
            b) A pair of consecutive negative entries
               IPIV(k) < 0 and IPIV(k+1) < 0 means:
               D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
               (NOTE: negative entries in IPIV appear ONLY in pairs). \n
               1) If -IPIV(k) != k, rows and columns
                  k and -IPIV(k) were interchanged
                  in the submatrix A(1:N,1:KB).
                  If -IPIV(k) = k, no interchange occurred. \n
               2) If -IPIV(k+1) != k+1, rows and columns
                  k-1 and -IPIV(k-1) were interchanged
                  in the submatrix A(1:N,1:KB).
                  If -IPIV(k+1) = k+1, no interchange occurred. \n
 \n
            c) In both cases a) and b) is always ABS(IPIV(k)) >= k. \n
 \n
            d) NOTE: Any entry IPIV(k) is always NONZERO on output. \n
 * @param[out] W
          W is REAL array, dimension (LDW,NB) \n
 * @param[in] LDW
          LDW is INTEGER \n
          The leading dimension of the array W.  LDW >= max(1,N). \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: If INFO = -k, the k-th argument had an illegal value \n
          > 0: If INFO = k, the matrix A is singular, because: \n
                 If UPLO = 'U': column k in the upper
                 triangular part of A contains all zeros. \n
                 If UPLO = 'L': column k in the lower
                 triangular part of A contains all zeros. \n
 \n
               Therefore D(k,k) is exactly zero, and superdiagonal
               elements of column k of U (or subdiagonal elements of
               column k of L) are all zeros. The factorization has
               been completed, but the block diagonal matrix D is
               exactly singular, and division by zero will occur if
               it is used to solve a system of equations.
 \n
               NOTE: INFO only stores the first occurrence of
               a singularity, any subsequent occurrence of singularity
               is not stored in INFO even though the factorization
               always completes.  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lasyf_rk(char *uplo, integer *n, integer *nb, integer *kb, T *a, integer *lda, T *e, integer *ipiv, T *w, integer * ldw, integer *info)
{
  return lasyf_rk(uplo, n, nb, kb, a, lda, e, ipiv, w, ldw, info);
}

/*! @brief LASYF_ROOK computes a partial factorization of a real symmetric    \n
     matrix using the bounded Bunch-Kaufman ("rook") diagonal pivoting method
 * @details
 * \b Purpose:
    \verbatim 
    LASYF_ROOK computes a partial factorization of a real symmetric
    matrix A using the bounded Bunch-Kaufman ("rook") diagonal
    pivoting method. The partial factorization has the form:

    A  =  (I  U12) (A11  0 ) ( I       0   )  if UPLO = 'U', or:
          (0  U22) ( 0   D ) (U12**T U22**T)

    A  =  (L11  0) ( D   0 ) (L11**T L21**T)  if UPLO = 'L'
          (L21  I) ( 0  A22) ( 0       I   )

    where the order of D is at most NB. The actual order is   returned in
    the argument KB, and is either NB or NB-1, or N if N <= NB.

    SLASYF_ROOK is an auxiliary routine called by SSYTRF_ROOK. It uses
    blocked code (calling Level 3 BLAS) to update the submatrix
    A11 (if UPLO = 'U') or A22 (if UPLO = 'L').
    \endverbatim

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the upper or lower triangular part of the
          symmetric matrix A is stored: \n
          = 'U':  Upper triangular \n
          = 'L':  Lower triangular \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] NB
          NB is INTEGER \n
          The maximum number of columns of the matrix A that should be
          factored.  NB should be at least 2 to allow for 2-by-2 pivot
          blocks. \n
 * @param[out] KB
          KB is INTEGER \n
          The number of columns of A that were actually factored.
          KB is either NB-1 or NB, or N if N <= NB. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
          n-by-n upper triangular part of A contains the upper
          triangular part of the matrix A, and the strictly lower
          triangular part of A is not referenced.  If UPLO = 'L', the
          leading n-by-n lower triangular part of A contains the lower
          triangular part of the matrix A, and the strictly upper
          triangular part of A is not referenced. \n
          On exit, A contains details of the partial factorization. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] IPIV
          IPIV is INTEGER array, dimension (N) \n
          Details of the interchanges and the block structure of D.
 \n
          If UPLO = 'U': \n
             Only the last KB elements of IPIV are set.
 \n
             If IPIV(k) > 0, then rows and columns k and IPIV(k) were
             interchanged and D(k,k) is a 1-by-1 diagonal block.
 \n
             If IPIV(k) < 0 and IPIV(k-1) < 0, then rows and
             columns k and -IPIV(k) were interchanged and rows and
             columns k-1 and -IPIV(k-1) were inerchaged,
             D(k-1:k,k-1:k) is a 2-by-2 diagonal block.
 \n
          If UPLO = 'L': \n
             Only the first KB elements of IPIV are set.
 \n
             If IPIV(k) > 0, then rows and columns k and IPIV(k)
             were interchanged and D(k,k) is a 1-by-1 diagonal block.
 \n
             If IPIV(k) < 0 and IPIV(k+1) < 0, then rows and
             columns k and -IPIV(k) were interchanged and rows and
             columns k+1 and -IPIV(k+1) were inerchaged,
             D(k:k+1,k:k+1) is a 2-by-2 diagonal block. \n
 * @param[out] W
          W is REAL array, dimension (LDW,NB) \n
 * @param[in] LDW
          LDW is INTEGER \n
          The leading dimension of the array W.  LDW >= max(1,N). \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0: successful exit \n
          > 0: if INFO = k, D(k,k) is exactly zero.  The factorization
               has been completed, but the block diagonal matrix D is
               exactly singular.  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer lasyf_rook(char *uplo, integer *n, integer *nb, integer *kb, T *a, integer *lda, integer *ipiv, T *w, integer * ldw, integer *info)
{
  return lasyf_rook(uplo, n, nb, kb, a, lda, ipiv, w, ldw, info);
}

/*! @brief LAT2S converts a double-precision triangular matrix to a single-precision triangular matrix

 * @details
 * \b Purpose:
    \verbatim 
    DLAT2S converts a DOUBLE PRECISION triangular matrix, SA, to a SINGLE
    PRECISION triangular matrix, A.

    RMAX is the overflow for the SINGLE PRECISION arithmetic
    DLAS2S checks that all the entries of A are between -RMAX and
    RMAX. If not the conversion is aborted and a flag is raised.

    This is an auxiliary routine so there is no argument checking.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  A is upper triangular; \n
          = 'L':  A is lower triangular. \n
 * @param[in] N
          N is INTEGER \n
          The number of rows and columns of the matrix A.  N >= 0. \n
 * @param[in] A
          A is DOUBLE PRECISION array, dimension (LDA,N) \n
          On entry, the N-by-N triangular coefficient matrix A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] SA
          SA is REAL array, dimension (LDSA,N) \n
          Only the UPLO part of SA is referenced.  On exit, if INFO=0,
          the N-by-N coefficient matrix SA; if INFO>0, the content of
          the UPLO part of SA is unspecified. \n
 * @param[in] LDSA
          LDSA is INTEGER \n
          The leading dimension of the array SA.  LDSA >= max(1,M). \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit. \n
          = 1:  an entry of the matrix A is greater than the SINGLE
                PRECISION overflow threshold, in this case, the content
                of the UPLO part of SA in exit is unspecified.  \n

 * @return INTEGER Return value of the function.
 * */
integer dlat2s(char *uplo, integer *n, double *a, integer * lda, float *sa, integer *ldsa, integer *info)
{
  return dlat2s_(uplo, n, a, lda, sa, ldsa, info); 
}

/*! @brief LAT2C converts a double complex triangular matrix to a complex triangular matrix

 * @details
 * \b Purpose:
    \verbatim 
    ZLAT2C converts a COMPLEX*16 triangular matrix, SA, to a COMPLEX
    triangular matrix, A.

    RMAX is the overflow for the SINGLE PRECISION arithmetic
    ZLAT2C checks that all the entries of A are between -RMAX and
    RMAX. If not the conversion is aborted and a flag is raised.

    This is an auxiliary routine so there is no argument checking.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          = 'U':  A is upper triangular; \n
          = 'L':  A is lower triangular. \n
 * @param[in] N
          N is INTEGER \n
          The number of rows and columns of the matrix A.  N >= 0. \n
 * @param[in] A
          A is COMPLEX*16 array, dimension (LDA,N) \n
          On entry, the N-by-N triangular coefficient matrix A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[out] SA
          SA is COMPLEX array, dimension (LDSA,N) \n
          Only the UPLO part of SA is referenced.  On exit, if INFO=0,
          the N-by-N coefficient matrix SA; if INFO>0, the content of
          the UPLO part of SA is unspecified. \n
 * @param[in] LDSA
          LDSA is INTEGER \n
          The leading dimension of the array SA.  LDSA >= max(1,M). \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit. \n
          = 1:  an entry of the matrix A is greater than the SINGLE
                PRECISION overflow threshold, in this case, the content
                of the UPLO part of SA in exit is unspecified.  \n

 * @return INTEGER Return value of the function.
 * */
integer zlat2c(char *uplo, integer *n, dcomplex *a, integer *lda, scomplex *sa, integer *ldsa, integer *info)
{
  return zlat2c_(uplo, n, a, lda, sa, ldsa, info);
}

/*! @brief LATBS solves a triangular banded system of equations

 * @details
 * \b Purpose:
    \verbatim 
    LATBS solves one of the triangular systems

       A *x = s*b  or  A**T*x = s*b

    with scaling to prevent overflow, where A is an upper or lower
    triangular band matrix.  Here A**T denotes the transpose of A, x and b
    are n-element vectors, and s is a scaling factor, usually less than
    or equal to 1, chosen so that the components of x will be less than
    the overflow threshold.  If the unscaled problem will not cause
    overflow, the Level 2 BLAS routine STBSV is called.  If the matrix A
    is singular (A(j,j) = 0 for some j), then s is set to 0 and a
    non-trivial solution to A*x = 0 is   returned.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the matrix A is upper or lower triangular. \n
          = 'U':  Upper triangular \n
          = 'L':  Lower triangular \n
 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          Specifies the operation applied to A. \n
          = 'N':  Solve A * x = s*b  (No transpose) \n
          = 'T':  Solve A**T* x = s*b  (Transpose) \n
          = 'C':  Solve A**T* x = s*b  (Conjugate transpose = Transpose) \n
 * @param[in] DIAG
          DIAG is CHARACTER*1 \n
          Specifies whether or not the matrix A is unit triangular. \n
          = 'N':  Non-unit triangular \n
          = 'U':  Unit triangular \n
 * @param[in] NORMIN
          NORMIN is CHARACTER*1 \n
          Specifies whether CNORM has been set or not. \n
          = 'Y':  CNORM contains the column norms on entry \n
          = 'N':  CNORM is not set on entry.  On exit, the norms will
                  be computed and stored in CNORM. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] KD
          KD is INTEGER \n
          The number of subdiagonals or superdiagonals in the
          triangular matrix A.  KD >= 0. \n
 * @param[in] AB
          AB is REAL array, dimension (LDAB,N) \n
          The upper or lower triangular band matrix A, stored in the
          first KD+1 rows of the array. The j-th column of A is stored
          in the j-th column of the array AB as follows: \n
          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j; \n
          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd). \n
 * @param[in] LDAB
          LDAB is INTEGER \n
          The leading dimension of the array AB.  LDAB >= KD+1. \n
 * @param[in,out] X
          X is REAL array, dimension (N) \n
          On entry, the right hand side b of the triangular system.
          On exit, X is overwritten by the solution vector x. \n
 * @param[out] SCALE
          SCALE is REAL \n
          The scaling factor s for the triangular system \n
             A * x = s*b  or  A**T* x = s*b. \n
          If SCALE = 0, the matrix A is singular or badly scaled, and
          the vector x is an exact or approximate solution to A*x = 0. \n
 * @param[in,out] CNORM
          CNORM is REAL array, dimension (N) \n
 \n
          If NORMIN = 'Y', CNORM is an input argument and CNORM(j)
          contains the norm of the off-diagonal part of the j-th column
          of A.  If TRANS = 'N', CNORM(j) must be greater than or equal
          to the infinity-norm, and if TRANS = 'T' or 'C', CNORM(j)
          must be greater than or equal to the 1-norm.
 \n
          If NORMIN = 'N', CNORM is an output argument and CNORM(j)
          returns the 1-norm of the offdiagonal part of the j-th column
          of A. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -k, the k-th argument had an illegal value  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer latbs(char *uplo, char *trans, char *diag, char *normin, integer *n, integer *kd, T *ab, integer *ldab, T *x, T *scale, T *cnorm, integer *info)
{
  return latbs(uplo, trans, diag, normin, n, kd, ab, ldab, x, scale, cnorm, info);
}
template< typename T, typename Ta >
integer latbs(char *uplo, char *trans, char *diag, char * normin, integer *n, integer *kd, T *ab, integer *ldab, T *x, Ta *scale, Ta *cnorm, integer *info)
{
  return latbs(uplo, trans, diag, normin, n, kd, ab, ldab, x, scale, cnorm, info);
}

/*! @brief LATDF uses the LU factorization of the n-by-n matrix computed by sgetc2 \n
     and computes a contribution to the reciprocal Dif-estimate
 * @details
 * \b Purpose:
    \verbatim 
    LATDF uses the LU factorization of the n-by-n matrix Z computed by
    SGETC2 and computes a contribution to the reciprocal Dif-estimate
    by solving Z * x = b for x, and choosing the r.h.s. b such that
    the norm of x is as large as possible. On entry RHS = b holds the
    contribution from earlier solved sub-systems, and on   return RHS = x.

    The factorization of Z   returned by SGETC2 has the form Z = P*L*U*Q,
    where P and Q are permutation matrices. L is lower triangular with
    unit diagonal elements and U is upper triangular.
    \endverbatim 

 * @param[in] IJOB
          IJOB is INTEGER \n
          IJOB = 2: First compute an approximative null-vector e
              of Z using SGECON, e is normalized and solve for
              Zx = +-e - f with the sign giving the greater value
              of 2-norm(x). About 5 times as expensive as Default. \n
          IJOB .ne. 2: Local look ahead strategy where all entries of
              the r.h.s. b is chosen as either +1 or -1 (Default). \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix Z. \n
 * @param[in] Z
          Z is REAL array, dimension (LDZ, N) \n
          On entry, the LU part of the factorization of the n-by-n
          matrix Z computed by SGETC2:  Z = P * L * U * Q \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of the array Z.  LDA >= max(1, N). \n
 * @param[in,out] RHS
          RHS is REAL array, dimension N. \n
          On entry, RHS contains contributions from other subsystems.
          On exit, RHS contains the solution of the subsystem with
          entries according to the value of IJOB (see above). \n
 * @param[in,out] RDSUM
          RDSUM is REAL \n
          On entry, the sum of squares of computed contributions to
          the Dif-estimate under computation by STGSYL, where the
          scaling factor RDSCAL (see below) has been factored out. \n
          On exit, the corresponding sum of squares updated with the
          contributions from the current sub-system.
          If TRANS = 'T' RDSUM is not touched.
          NOTE: RDSUM only makes sense when STGSY2 is called by STGSYL. \n
 * @param[in,out] RDSCAL
          RDSCAL is REAL \n
          On entry, scaling factor used to prevent overflow in RDSUM. \n
          On exit, RDSCAL is updated w.r.t. the current contributions
          in RDSUM. \n
          If TRANS = 'T', RDSCAL is not touched. \n
          NOTE: RDSCAL only makes sense when STGSY2 is called by
                STGSYL. \n
 * @param[in] IPIV
          IPIV is INTEGER array, dimension (N). \n
          The pivot indices; for 1 <= i <= N, row i of the
          matrix has been interchanged with row IPIV(i). \n
 * @param[in] JPIV
          JPIV is INTEGER array, dimension (N). \n
          The pivot indices; for 1 <= j <= N, column j of the
          matrix has been interchanged with column JPIV(j).  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer latdf(integer *ijob, integer *n, T *z, integer * ldz, T *rhs, T *rdsum, T *rdscal, integer *ipiv, integer * jpiv)
{
  return latdf(ijob, n, z, ldz, rhs, rdsum, rdscal, ipiv, jpiv);
}
template< typename T, typename Ta >
integer latdf(integer *ijob, integer *n, T *z, integer * ldz, T *rhs, Ta *rdsum, Ta *rdscal, integer *ipiv, integer * jpiv)
{
  return latdf(ijob, n, z, ldz, rhs, rdsum, rdscal, ipiv, jpiv);
}

/*! @brief LATPS solves a triangular system of equations with the matrix held in packed storage

 * @details
 * \b Purpose:
    \verbatim
    LATPS solves one of the triangular systems

       A *x = s*b  or  A**T*x = s*b

    with scaling to prevent overflow, where A is an upper or lower
    triangular matrix stored in packed form.  Here A**T denotes the
    transpose of A, x and b are n-element vectors, and s is a scaling
    factor, usually less than or equal to 1, chosen so that the
    components of x will be less than the overflow threshold.  If the
    unscaled problem will not cause overflow, the Level 2 BLAS routine
    STPSV is called. If the matrix A is singular (A(j,j) = 0 for some j),
    then s is set to 0 and a non-trivial solution to A*x = 0 is   returned.
    \endverbatim

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the matrix A is upper or lower triangular. \n
          = 'U':  Upper triangular \n
          = 'L':  Lower triangular \n
 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          Specifies the operation applied to A. \n
          = 'N':  Solve A * x = s*b  (No transpose) \n
          = 'T':  Solve A**T* x = s*b  (Transpose) \n
          = 'C':  Solve A**T* x = s*b  (Conjugate transpose = Transpose) \n
 * @param[in] DIAG
          DIAG is CHARACTER*1 \n
          Specifies whether or not the matrix A is unit triangular. \n
          = 'N':  Non-unit triangular \n
          = 'U':  Unit triangular \n
 * @param[in] NORMIN
          NORMIN is CHARACTER*1 \n
          Specifies whether CNORM has been set or not. \n
          = 'Y':  CNORM contains the column norms on entry \n
          = 'N':  CNORM is not set on entry.  On exit, the norms will
                  be computed and stored in CNORM. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] AP
          AP is REAL array, dimension (N*(N+1)/2) \n
          The upper or lower triangular matrix A, packed columnwise in
          a linear array.  The j-th column of A is stored in the array
          AP as follows: \n
          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j; \n
          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n. \n
 * @param[in,out] X
          X is REAL array, dimension (N) \n
          On entry, the right hand side b of the triangular system.
          On exit, X is overwritten by the solution vector x. \n
 * @param[out] SCALE
          SCALE is REAL \n
          The scaling factor s for the triangular system \n
             A * x = s*b  or  A**T* x = s*b. \n
          If SCALE = 0, the matrix A is singular or badly scaled, and
          the vector x is an exact or approximate solution to A*x = 0. \n
 * @param[in,out] CNORM
          CNORM is REAL array, dimension (N) \n
 \n
          If NORMIN = 'Y', CNORM is an input argument and CNORM(j)
          contains the norm of the off-diagonal part of the j-th column
          of A.  If TRANS = 'N', CNORM(j) must be greater than or equal
          to the infinity-norm, and if TRANS = 'T' or 'C', CNORM(j)
          must be greater than or equal to the 1-norm.
 \n
          If NORMIN = 'N', CNORM is an output argument and CNORM(j)
          returns the 1-norm of the offdiagonal part of the j-th column
          of A. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -k, the k-th argument had an illegal value  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer latps(char *uplo, char *trans, char *diag, char * normin, integer *n, T *ap, T *x, T *scale, T *cnorm, integer *info)
{
  return latps(uplo, trans, diag, normin, n, ap, x, scale, cnorm, info);
}
template< typename T, typename Ta >
integer latps(char *uplo, char *trans, char *diag, char * normin, integer *n, T *ap, T *x, Ta *scale, Ta *cnorm, integer *info)
{
  return latps(uplo, trans, diag, normin, n, ap, x, scale, cnorm, info);
}

/*! @brief LATRD reduces the first nb rows and columns of a symmetric/Hermitian   \n
     matrix A to real tridiagonal form by an orthogonal similarity transformation
 * @details
 * \b Purpose:
    \verbatim 
    LATRD reduces NB rows and columns of a real symmetric matrix A to
    symmetric tridiagonal form by an orthogonal similarity
    transformation Q**T * A * Q, and   returns the matrices V and W which are
    needed to apply the transformation to the unreduced part of A.

    If UPLO = 'U', SLATRD reduces the last NB rows and columns of a
    matrix, of which the upper triangle is supplied;
    if UPLO = 'L', SLATRD reduces the first NB rows and columns of a
    matrix, of which the lower triangle is supplied.

    This is an auxiliary routine called by SSYTRD.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the upper or lower triangular part of the
          symmetric matrix A is stored: \n
          = 'U': Upper triangular \n
          = 'L': Lower triangular \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A. \n
 * @param[in] NB
          NB is INTEGER \n
          The number of rows and columns to be reduced. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
          n-by-n upper triangular part of A contains the upper
          triangular part of the matrix A, and the strictly lower
          triangular part of A is not referenced.  If UPLO = 'L', the
          leading n-by-n lower triangular part of A contains the lower
          triangular part of the matrix A, and the strictly upper
          triangular part of A is not referenced. \n
          On exit: \n
          if UPLO = 'U', the last NB columns have been reduced to
            tridiagonal form, with the diagonal elements overwriting
            the diagonal elements of A; the elements above the diagonal
            with the array TAU, represent the orthogonal matrix Q as a
            product of elementary reflectors; \n
          if UPLO = 'L', the first NB columns have been reduced to
            tridiagonal form, with the diagonal elements overwriting
            the diagonal elements of A; the elements below the diagonal
            with the array TAU, represent the  orthogonal matrix Q as a
            product of elementary reflectors. \n
          See Further Details. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= (1,N). \n
 * @param[out] E
          E is REAL array, dimension (N-1) \n
          If UPLO = 'U', E(n-nb:n-1) contains the superdiagonal
          elements of the last NB columns of the reduced matrix; \n
          if UPLO = 'L', E(1:nb) contains the subdiagonal elements of
          the first NB columns of the reduced matrix. \n
 * @param[out] TAU
          TAU is REAL array, dimension (N-1) \n
          The scalar factors of the elementary reflectors, stored in
          TAU(n-nb:n-1) if UPLO = 'U', and in TAU(1:nb) if UPLO = 'L'.
          See Further Details. \n
 * @param[out] W
          W is REAL array, dimension (LDW,NB) \n
          The n-by-nb matrix W required to update the unreduced part
          of A. \n
 * @param[in] LDW
          LDW is INTEGER \n
          The leading dimension of the array W. LDW >= max(1,N).  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer latrd(char *uplo, integer *n, integer *nb, T *a, integer *lda, T *e, T *tau, T *w, integer *ldw)
{
  return latrd(uplo, n, nb, a, lda, e, tau, w, ldw);
}
template< typename T, typename Ta >
integer latrd(char *uplo, integer *n, integer *nb, T *a, integer *lda, Ta *e, T *tau, T *w, integer *ldw)
{
  return latrd(uplo, n, nb, a, lda, e, tau, w, ldw);
}

/*! @brief LATRS solves a triangular system of equations with the scale factor set to prevent overflow

 * @details
 * \b Purpose:
    \verbatim 
    LATRS solves one of the triangular systems

       A *x = s*b  or  A**T*x = s*b

    with scaling to prevent overflow.  Here A is an upper or lower
    triangular matrix, A**T denotes the transpose of A, x and b are
    n-element vectors, and s is a scaling factor, usually less than
    or equal to 1, chosen so that the components of x will be less than
    the overflow threshold.  If the unscaled problem will not cause
    overflow, the Level 2 BLAS routine STRSV is called.  If the matrix A
    is singular (A(j,j) = 0 for some j), then s is set to 0 and a
    non-trivial solution to A*x = 0 is   returned.
    \endverbatim 

 * @param[in] UPLO
          UPLO is CHARACTER*1 \n
          Specifies whether the matrix A is upper or lower triangular. \n
          = 'U':  Upper triangular \n
          = 'L':  Lower triangular \n
 * @param[in] TRANS
          TRANS is CHARACTER*1 \n
          Specifies the operation applied to A. \n
          = 'N':  Solve A * x = s*b  (No transpose) \n
          = 'T':  Solve A**T* x = s*b  (Transpose) \n
          = 'C':  Solve A**T* x = s*b  (Conjugate transpose = Transpose) \n
 * @param[in] DIAG
          DIAG is CHARACTER*1 \n
          Specifies whether or not the matrix A is unit triangular. \n
          = 'N':  Non-unit triangular \n
          = 'U':  Unit triangular \n
 * @param[in] NORMIN
          NORMIN is CHARACTER*1 \n
          Specifies whether CNORM has been set or not. \n
          = 'Y':  CNORM contains the column norms on entry \n
          = 'N':  CNORM is not set on entry.  On exit, the norms will
                  be computed and stored in CNORM. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrix A.  N >= 0. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          The triangular matrix A.  If UPLO = 'U', the leading n by n
          upper triangular part of the array A contains the upper
          triangular matrix, and the strictly lower triangular part of
          A is not referenced.  If UPLO = 'L', the leading n by n lower
          triangular part of the array A contains the lower triangular
          matrix, and the strictly upper triangular part of A is not
          referenced.  If DIAG = 'U', the diagonal elements of A are
          also not referenced and are assumed to be 1. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max (1,N). \n
 * @param[in,out] X
          X is REAL array, dimension (N) \n
          On entry, the right hand side b of the triangular system.
          On exit, X is overwritten by the solution vector x. \n
 * @param[out] SCALE
          SCALE is REAL \n
          The scaling factor s for the triangular system \n
             A * x = s*b  or  A**T* x = s*b. \n
          If SCALE = 0, the matrix A is singular or badly scaled, and
          the vector x is an exact or approximate solution to A*x = 0. \n
 * @param[in,out] CNORM
          CNORM is REAL array, dimension (N) \n
 \n
          If NORMIN = 'Y', CNORM is an input argument and CNORM(j)
          contains the norm of the off-diagonal part of the j-th column
          of A.  If TRANS = 'N', CNORM(j) must be greater than or equal
          to the infinity-norm, and if TRANS = 'T' or 'C', CNORM(j)
          must be greater than or equal to the 1-norm. \n
 \n
          If NORMIN = 'N', CNORM is an output argument and CNORM(j)
          returns the 1-norm of the offdiagonal part of the j-th column
          of A. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -k, the k-th argument had an illegal value  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer latrs(char *uplo, char *trans, char *diag, char * normin, integer *n, T *a, integer *lda, T *x, T *scale, T *cnorm, integer *info)
{
  return latrs(uplo, trans, diag, normin, n, a, lda, x, scale, cnorm, info);
}
template< typename T, typename Ta >
integer latrs(char *uplo, char *trans, char *diag, char * normin, integer *n, T *a, integer *lda, T *x, Ta *scale, Ta *cnorm, integer *info)
{
  return latrs(uplo, trans, diag, normin, n, a, lda, x, scale, cnorm, info);
}

/*! @brief LATRZ factors an upper trapezoidal matrix by means of orthogonal transformations

 * @details
 * \b Purpose:
    \verbatim
    LATRZ factors the M-by-(M+L) real upper trapezoidal matrix
    [ A1 A2 ] = [ A(1:M,1:M) A(1:M,N-L+1:N) ] as (R  0) * Z, by means
    of orthogonal transformations.  Z is an (M+L)-by-(M+L) orthogonal
    matrix and, R and A1 are M-by-M upper triangular matrices.
    \endverbatim

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A.  N >= 0. \n
 * @param[in] L
          L is INTEGER \n
          The number of columns of the matrix A containing the
          meaningful part of the Householder vectors. N-M >= L >= 0. \n
 * @param[in,out] A
          A is REAL array, dimension (LDA,N) \n
          On entry, the leading M-by-N upper trapezoidal part of the
          array A must contain the matrix to be factorized.
          On exit, the leading M-by-M upper triangular part of A
          contains the upper triangular matrix R, and elements N-L+1 to
          N of the first M rows of A, with the array TAU, represent the
          orthogonal matrix Z as a product of M elementary reflectors. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,M). \n
 * @param[out] TAU
          TAU is REAL array, dimension (M) \n
          The scalar factors of the elementary reflectors. \n
 * @param[out] WORK
          WORK is REAL array, dimension (M)  \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer latrz(integer *m, integer *n, integer *l, T *a, integer *lda, T *tau, T *work)
{
  return latrz(m, n, l, a, lda, tau, work);
}

/*! @brief LATSQR computes a blocked Tall-Skinny QR factorization of a real M-by-N matrix A for M >= N

 * @details
 * \b Purpose:
    \verbatim 
    LATSQR computes a blocked Tall-Skinny QR factorization of
    a real M-by-N matrix A for M >= N:
   
       A = Q * (R),
               (0)
   
    where:
   
       Q is a M-by-M orthogonal matrix, stored on exit in an implicit
       form in the elements below the digonal of the array A and in
       the elemenst of the array T;
   
       R is an upper-triangular N-by-N matrix, stored on exit in
       the elements on and above the diagonal of the array A.
   
       0 is a (M-N)-by-N zero matrix, and is not stored.
    \endverbatim  
  
  * @param[in] M
           M is INTEGER \n
           The number of rows of the matrix A.  M >= 0. \n
  * @param[in] N
           N is INTEGER \n
           The number of columns of the matrix A. M >= N >= 0. \n
  * @param[in] MB
           MB is INTEGER \n
           The row block size to be used in the blocked QR.
           MB > N. \n
  * @param[in] NB
           NB is INTEGER \n
           The column block size to be used in the blocked QR.
           N >= NB >= 1. \n
  * @param[in,out] A
           A is REAL array, dimension (LDA,N) \n
           On entry, the M-by-N matrix A. \n
           On exit, the elements on and above the diagonal
           of the array contain the N-by-N upper triangular matrix R;
           the elements below the diagonal represent Q by the columns
           of blocked V (see Further Details). \n
  * @param[in] LDA
           LDA is INTEGER \n
           The leading dimension of the array A.  LDA >= max(1,M). \n
  * @param[out] T
           T is REAL array,
           dimension (LDT, N * Number_of_row_blocks) \n
           where Number_of_row_blocks = CEIL((M-N)/(MB-N)) \n
           The blocked upper triangular block reflectors stored in compact form
           as a sequence of upper triangular blocks.
           See Further Details below. \n
  * @param[in] LDT
           LDT is INTEGER \n
           The leading dimension of the array T.  LDT >= NB. \n
  * @param[out] WORK
          (workspace) REAL array, dimension (MAX(1,LWORK)) \n
  * @param[in] LWORK
           The dimension of the array WORK.  LWORK >= NB*N. \n
           If LWORK = -1, then a workspace query is assumed; the routine
           only calculates the optimal size of the WORK array, returns
           this value as the first entry of the WORK array, and no error
           message related to LWORK is issued by XERBLA. \n
  * @param[out] INFO
           INFO is INTEGER \n
           = 0:  successful exit \n
           < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer latsqr(integer *m, integer *n, integer *mb, integer *nb, T *a, integer *lda, T *t, integer *ldt, T *work, integer *lwork, integer *info)
{
  return latsqr(m, n, mb, nb, a, lda, t, ldt, work, lwork, info);
}

/*! @brief ICMAX1 finds the index of the first vector element of maximum absolute value

 * @details
 * \b Purpose:
    \verbatim 
    ICMAX1 finds the index of the first vector element of maximum absolute value.

    Based on ICAMAX from Level 1 BLAS.
    The change is to use the 'genuine' absolute value.
    \endverbatim 

 * @param[in] N
          N is INTEGER \n
          The number of elements in the vector CX. \n
 * @param[in] CX
          CX is COMPLEX array, dimension (N) \n
          The vector CX. The ICMAX1 function   returns the index of its first
          element of maximum absolute value. \n
 * @param[in] INCX
          INCX is INTEGER \n
          The spacing between successive values of CX.  INCX >= 1.  \n

 * @return INTEGER Return value of the function.
 * */
integer icmax1(integer *n, scomplex *cx, integer *incx)
{
  return icmax1_(n, cx, incx);
}

/*! @brief ILACLC scans a matrix for its last non-zero column.

 * @details
 * \b Purpose:
    \verbatim 
    ILACLC scans A for its last non-zero column.
    \endverbatim

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A. \n
 * @param[in] A
          A is COMPLEX array, dimension (LDA,N) \n
          The m by n matrix A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A. LDA >= max(1,M). \n

 * @return INTEGER Return value of the function.
 * */
integer ilaclc(integer *m, integer *n, scomplex *a, integer *lda) 
{
  return ilaclc_(m, n, a, lda); 
}

/*! @brief ILACLR scans a matrix for its last non-zero row

 * @details
 * \b Purpose:
    \verbatim
    ILACLR scans A for its last non-zero row.
    \endverbatim

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A. \n
 * @param[in] A
          A is COMPLEX array, dimension (LDA,N) \n
          The m by n matrix A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A. LDA >= max(1,M). \n

 * @return INTEGER Return value of the function.
 * */
integer ilaclr(integer *m, integer *n, scomplex *a, integer *lda) 
{
  return ilaclr_(m, n, a, lda); 
}

/*! @brief ILADIAG translated from a character string specifying if a matrix   \n
     has unit diagonal or not to the relevant BLAST-specified integer constant
 * @details
 * \b Purpose:
    \verbatim 
    This subroutine translated from a character string specifying if a
    matrix has unit diagonal or not to the relevant BLAST-specified
    integer constant.

    ILADIAG   returns an INTEGER. If ILADIAG < 0, then the input is not a
    character indicating a unit or non-unit diagonal. Otherwise ILADIAG
    returns the constant value corresponding to DIAG.
    \endverbatim
 * @param[in] diag
          DIAG is character pointer. \n
          = N means non-unit diagonal. \n
          = U means unit diagonal. \n

 * @return INTEGER Return value of the function.
 * */  
integer iladiag(char *diag)
{
  return iladiag_(diag); 
}

/*! @brief ILADLC scans a matrix for its last non-zero column

 * @details
 * \b Purpose:
    \verbatim
    ILADLC scans A for its last non-zero column.
    \endverbatim 

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A. \n
 * @param[in] A
          A is DOUBLE PRECISION array, dimension (LDA,N) \n
          The m by n matrix A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A. LDA >= max(1,M).  \n

 * @return INTEGER Return value of the function.
 * */
integer iladlc(integer *m, integer *n, double *a, integer *lda) 
{
  return iladlc_(m, n, a, lda);
}

/*! @brief ILADLR scans a matrix for its last non-zero row

 * @details
 * \b Purpose:
    \verbatim
    ILADLR scans A for its last non-zero row.
    \endverbatim  

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A. \n
 * @param[in] A
          A is DOUBLE PRECISION array, dimension (LDA,N) \n
          The m by n matrix A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A. LDA >= max(1,M).  \n

 * @return INTEGER Return value of the function.
 * */
integer iladlr(integer *m, integer *n, double *a, integer *lda)
{
  return iladlr_(m, n, a, lda);
}

/*! @brief ILAENV2STAGE is called from the LAPACK routines to choose problem-dependent \n
     parameters for the local environment
 * @details
 * \b Purpose:
    \verbatim     
    ILAENV2STAGE is called from the LAPACK routines to choose problem-dependent
    parameters for the local environment.  See ISPEC for a description of
    the parameters.
    It sets problem and machine dependent parameters useful for *_2STAGE and
    related subroutines.

    ILAENV2STAGE   returns an INTEGER
    if ILAENV2STAGE >= 0: ILAENV2STAGE   returns the value of the parameter
                          specified by ISPEC
    if ILAENV2STAGE < 0:  if ILAENV2STAGE = -k, the k-th argument had an
                          illegal value.

    This version provides a set of parameters which should give good,
    but not optimal, performance on many of the currently available
    computers for the 2-stage solvers. Users are encouraged to modify this
    subroutine to set the tuning parameters for their particular machine using
    the option and problem size information in the arguments.

    This routine will not function correctly if it is converted to all
    lower case.  Converting it to all upper case is allowed.
    \endverbatim 

 * @param[in] ISPEC
          ISPEC is INTEGER \n
          Specifies the parameter to be   returned as the value of
          ILAENV2STAGE. \n
          = 1: the optimal blocksize nb for the reduction to BAND
 \n
          = 2: the optimal blocksize ib for the eigenvectors
               singular vectors update routine
 \n
          = 3: The length of the array that store the Housholder 
               representation for the second stage 
               Band to Tridiagonal or Bidiagonal
 \n
          = 4: The workspace needed for the routine in input.
 \n
          = 5: For future release. \n
 * @param[in] NAME
          NAME is CHARACTER*(*) \n
          The name of the calling subroutine, in either upper case or
          lower case. \n
 * @param[in] OPTS
          OPTS is CHARACTER*(*) \n
          The character options to the subroutine NAME, concatenated
          into a single character string.  For example, UPLO = 'U',
          TRANS = 'T', and DIAG = 'N' for a triangular routine would
          be specified as OPTS = 'UTN'. \n
 * @param[in] N1
          N1 is INTEGER \n
 * @param[in] N2
          N2 is INTEGER \n
 * @param[in] N3
          N3 is INTEGER \n
 * @param[in] N4
          N4 is INTEGER \n
          Problem dimensions for the subroutine NAME; these may not all
          be required.  \n

 * @return INTEGER Return value of the function.
 * */
integer ilaenv2stage(integer *ispec, char *name, char *opts, integer *n1, integer *n2, integer *n3, integer *n4) 
{
  return ilaenv2stage_(ispec, name, opts, n1, n2, n3, n4); 
}

/*! @brief ILAPREC translated from a character string specifying an intermediate \n
     precision to the relevant BLAST-specified integer constant.
 * @details
 * \b Purpose:
    \verbatim 
    This subroutine translated from a character string specifying an
    intermediate precision to the relevant BLAST-specified integer
    constant.

    ILAPREC   returns an INTEGER.  If ILAPREC < 0, then the input is not a
    character indicating a supported intermediate precision.  Otherwise
    ILAPREC   returns the constant value corresponding to PREC.
    \endverbatim
 * @param[in] prec
          PREC is character pointer. \n
          = S means single precision \n
          = D means double precision \n
          = I means indigenous precision \n
          = X or E means extra precision. \n
          Other values returns invalid result. \n

 * @return INTEGER Return value of the function.
 * */
integer ilaprec(char *prec)
{
  return ilaprec_(prec);
}

/*! @brief ILASLC scans a matrix for its last non-zero column

 * @details
 * \b Purpose:
    \verbatim
    ILASLC scans A for its last non-zero column.
    \endverbatim 

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          The m by n matrix A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A. LDA >= max(1,M). \n

 * @return INTEGER Return value of the function.
 * */
integer ilaslc(integer *m, integer *n, float *a, integer *lda)
{
  return ilaslc_(m, n, a, lda);
}

/*! @brief ILASLR scans a matrix for its last non-zero row

 * @details
 * \b Purpose:
    \verbatim
    ILASLR scans A for its last non-zero row.
    \endverbatim

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A. \n
 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          The m by n matrix A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A. LDA >= max(1,M). \n 

 * @return INTEGER Return value of the function.
 * */
integer ilaslr(integer *m, integer *n, float *a, integer *lda) 
{
  return ilaslr_(m, n, a, lda); 
}

/*! @brief ILATRANS translates from a character string specifying a transposition \n
     operation to the relevant BLAST-specified integer constant
 * @details
 * \b Purpose:
    \verbatim 
    This subroutine translates from a character string specifying a
    transposition operation to the relevant BLAST-specified integer
    constant.

    ILATRANS   returns an INTEGER.  If ILATRANS < 0, then the input is not
    a character indicating a transposition operator.  Otherwise ILATRANS
      returns the constant value corresponding to TRANS
    \endverbatim
 * @param[in] trans
          trans is charater pointer. \n
          = N means no transposition \n
          = T means transposition \n
          = C means conjugate transposition \n

 * @return INTEGER Return value of the function.
 * */
integer ilatrans(char *trans) 
{
  return ilatrans_(trans); 
}

/*! @brief ILAUPLO translated from a character string specifying a upper- or \n
     lower-triangular matrix to the relevant BLAST-specified integer constant
 * @details
 * \b Purpose:
    \verbatim 
    This subroutine translated from a character string specifying a
    upper- or lower-triangular matrix to the relevant BLAST-specified
    integer constant.

    ILAUPLO   returns an INTEGER.  If ILAUPLO < 0, then the input is not
    a character indicating an upper- or lower-triangular matrix.
    Otherwise ILAUPLO   returns the constant value corresponding to UPLO
    \endverbatim
 * @param[in] uplo
          uplo is charater pointer. \n
          = 'L' means lower triangular matrix \n
          = 'U' means upper triangular matrix \n
          Other values, returns invalid result. \n

 * @return INTEGER Return value of the function.
 * */
integer ilauplo(char *uplo) 
{
  return ilauplo_(uplo); 
}

/*! @brief ILAVER   returns the LAPACK version

 * @details
 * \b Purpose:
    \verbatim
    This subroutine   returns the LAPACK version.
    \endverbatim 

 * @param[out] VERS_MAJOR
          VERS_MAJOR is INTEGER \n
          return the lapack major version \n
 * @param[out] VERS_MINOR
          VERS_MINOR is INTEGER \n
          return the lapack minor version from the major version \n
 * @param[out] VERS_PATCH
          VERS_PATCH is INTEGER \n
          return the lapack patch version from the minor version \n

 * @return INTEGER Return value of the function.
 * */
integer ilaver(integer *vers_major, integer *vers_minor, integer *vers_patch__) 
{
  return ilaver_(vers_major, vers_minor, vers_patch__); 
}

/*! @brief ILAZLC scans a matrix for its last non-zero column

 * @details
 * \b Purpose:
    \verbatim     
    
    ILAZLC scans A for its last non-zero column.
    
    \endverbatim  

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A. \n
 * @param[in] A
          A is COMPLEX*16 array, dimension (LDA,N) \n
          The m by n matrix A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A. LDA >= max(1,M) \n

 * @return INTEGER Return value of the function.
 * */
integer ilazlc(integer *m, integer *n, dcomplex *a, integer *lda) 
{
  return ilazlc_(m, n, a, lda); 
}

/*! @brief ILAZLR scans a matrix for its last non-zero row

 * @details
 * \b Purpose:
    \verbatim     
    
    ILAZLR scans A for its last non-zero row.
 
    \endverbatim 

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A. \n
 * @param[in] A
          A is COMPLEX*16 array, dimension (LDA,N) \n
          The m by n matrix A. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A. LDA >= max(1,M).  \n

 * @return INTEGER Return value of the function.
 * */
integer ilazlr(integer *m, integer *n, dcomplex *a, integer *lda) 
{
  return ilazlr_(m, n, a, lda); 
}

/*! @brief IPARAM2STAGE program sets problem and machine dependent parameters

 * @details
 * \b Purpose:
    \verbatim        
     This program sets problem and machine dependent parameters
     useful for xHETRD_2STAGE, xHETRD_HE2HB, xHETRD_HB2ST,
     xGEBRD_2STAGE, xGEBRD_GE2GB, xGEBRD_GB2BD 
     and related subroutines for eigenvalue problems. 
     It is called whenever ILAENV is called with 17 <= ISPEC <= 21.
     It is called whenever ILAENV2STAGE is called with 1 <= ISPEC <= 5
     with a direct conversion ISPEC + 16.
    \endverbatim  
    
  * @param[in] ISPEC
           ISPEC is integer scalar \n
           ISPEC specifies which tunable parameter IPARAM2STAGE should
           return. \n
 \n
           ISPEC=17: the optimal blocksize nb for the reduction to
                     BAND
 \n
           ISPEC=18: the optimal blocksize ib for the eigenvectors
                     singular vectors update routine
 \n
           ISPEC=19: The length of the array that store the Housholder 
                     representation for the second stage 
                     Band to Tridiagonal or Bidiagonal
 \n
           ISPEC=20: The workspace needed for the routine in input.
 \n
           ISPEC=21: For future release. \n
  * @param[in] NAME
           NAME is character string \n
           Name of the calling subroutine \n
  * @param[in] OPTS
           OPTS is CHARACTER*(*) \n
           The character options to the subroutine NAME, concatenated
           into a single character string.  For example, UPLO = 'U',
           TRANS = 'T', and DIAG = 'N' for a triangular routine would
           be specified as OPTS = 'UTN'. \n
  * @param[in] NI
           NI is INTEGER which is the size of the matrix \n
  * @param[in] NBI
           NBI is INTEGER which is the used in the reduciton,  \n
           (e.g., the size of the band), needed to compute workspace
           and LHOUS2. \n
  * @param[in] IBI
           IBI is INTEGER which represent the IB of the reduciton,
           needed to compute workspace and LHOUS2. \n
  * @param[in] NXI
           NXI is INTEGER needed in the future release. \n

 * @return INTEGER Return value of the function.
 * */
integer iparam2stage(integer *ispec, char *name, char *opts, integer *ni, integer *nbi, integer *ibi, integer *nxi) 
{
  return iparam2stage_(ispec, name, opts, ni, nbi, ibi, nxi);
}

/*! @brief IZMAX1 finds the index of the first vector element of maximum absolute value

 * @details
 * \b Purpose:
    \verbatim        
    IZMAX1 finds the index of the first vector element of maximum absolute value.

    Based on IZAMAX from Level 1 BLAS.
    The change is to use the 'genuine' absolute value.
    \endverbatim 

 * @param[in] N
          N is INTEGER \n
          The number of elements in the vector ZX. \n
 * @param[in] ZX
          ZX is COMPLEX*16 array, dimension (N) \n
          The vector ZX. The IZMAX1 function   returns the index of its first
          element of maximum absolute value. \n
 * @param[in] INCX
          INCX is INTEGER \n
          The spacing between successive values of ZX.  INCX >= 1.  \n

 * @return INTEGER Return value of the function.
 * */
integer izmax1(integer *n, dcomplex *zx, integer *incx)
{
  return izmax1_(n, zx, incx);   
}

/*! @brief LANTP returns the value of the one norm, or the Frobenius norm, or
      the infinity norm, or the element of largest absolute value  of a
      triangular matrix A, supplied in packed form.

 * @details
 * \b Purpose:
    \verbatim        
    SLANTP = ( max(abs(A(i,j))), NORM = 'M' or 'm'
             (
             ( norm1(A),         NORM = '1', 'O' or 'o'
             (
             ( normI(A),         NORM = 'I' or 'i'
             (
             ( normF(A),         NORM = 'F', 'f', 'E' or 'e'

    where  norm1  denotes the  one norm of a matrix (maximum column sum),
    normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
    normF  denotes the  Frobenius norm of a matrix (square root of sum of
    squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
    \endverbatim 

 * @param[in]	NORM	
          NORM is CHARACTER*1 \n
          Specifies the value to be returned in SLANTP as described
          above. \n
 * @param[in]	UPLO	
          UPLO is CHARACTER*1 \n
          Specifies whether the matrix A is upper or lower triangular. \n
          = 'U':  Upper triangular \n
          = 'L':  Lower triangular \n
 * @param[in]	DIAG	
          DIAG is CHARACTER*1 \n
          Specifies whether or not the matrix A is unit triangular. \n
          = 'N':  Non-unit triangular \n
          = 'U':  Unit triangular \n
 * @param[in]	N	
          N is INTEGER \n
          The order of the matrix A.  N >= 0.  When N = 0, SLANTP is
          set to zero. \n
 * @param[in]	AP	
          AP is REAL array, dimension (N*(N+1)/2) \n
          The upper or lower triangular matrix A, packed columnwise in
          a linear array.  The j-th column of A is stored in the array
          AP as follows: \n
          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j; \n
          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n. \n
          Note that when DIAG = 'U', the elements of the array AP
          corresponding to the diagonal elements of the matrix A are
          not referenced, but are assumed to be one. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)), \n
          where LWORK >= N when NORM = 'I'; otherwise, WORK is not
          referenced. \n

 * @return INTEGER Return value of the function.
 * */
template <typename T>
T lantp(char* norm, char* uplo, char* diag, integer* n, T* ap, T* work)
{
  return lantp(norm, uplo, diag, n, ap, work);
}
template <typename T, typename Ta>
Ta lantp(char* norm, char* uplo, char* diag, integer* n, T* ap, Ta* work)
{
  return lantp(norm, uplo, diag, n, ap, work);
}

/*! @brief LANTB returns the value of the one norm, or the Frobenius norm, or
     the infinity norm, or the element of largest absolute value of an
     n by n triangular band matrix A,  with ( k + 1 ) diagonals.

 * @details
 * \b Purpose:
    \verbatim        
    SLANTB = ( max(abs(A(i,j))), NORM = 'M' or 'm'
             (
             ( norm1(A),         NORM = '1', 'O' or 'o'
             (
             ( normI(A),         NORM = 'I' or 'i'
             (
             ( normF(A),         NORM = 'F', 'f', 'E' or 'e'

    where  norm1  denotes the  one norm of a matrix (maximum column sum),
    normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
    normF  denotes the  Frobenius norm of a matrix (square root of sum of
    squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
    \endverbatim 

 * @param[in]	NORM	
          NORM is CHARACTER*1 \n
          Specifies the value to be returned in SLANTB as described
          above. \n
 * @param[in]	UPLO	
          UPLO is CHARACTER*1 \n
          Specifies whether the matrix A is upper or lower triangular. \n
          = 'U':  Upper triangular \n
          = 'L':  Lower triangular \n
 * @param[in]	DIAG	
          DIAG is CHARACTER*1 \n
          Specifies whether or not the matrix A is unit triangular. \n
          = 'N':  Non-unit triangular \n
          = 'U':  Unit triangular \n
 * @param[in]	N	
          N is INTEGER \n
          The order of the matrix A.  N >= 0.  When N = 0, SLANTB is
          set to zero. \n
 * @param[in]	K	
          K is INTEGER \n
          The number of super-diagonals of the matrix A if UPLO = 'U',
          or the number of sub-diagonals of the matrix A if UPLO = 'L'.
          K >= 0. \n
 * @param[in]	AB	
          AB is REAL array, dimension (LDAB,N) \n
          The upper or lower triangular band matrix A, stored in the
          first k+1 rows of AB.  The j-th column of A is stored
          in the j-th column of the array AB as follows: \n
          if UPLO = 'U', AB(k+1+i-j,j) = A(i,j) for max(1,j-k)<=i<=j; \n
          if UPLO = 'L', AB(1+i-j,j)   = A(i,j) for j<=i<=min(n,j+k). \n
          Note that when DIAG = 'U', the elements of the array AB
          corresponding to the diagonal elements of the matrix A are
          not referenced, but are assumed to be one. \n
 * @param[in]	LDAB	
          LDAB is INTEGER \n
          The leading dimension of the array AB.  LDAB >= K+1. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)), \n
          where LWORK >= N when NORM = 'I'; otherwise, WORK is not
          referenced. \n

 * @return INTEGER Return value of the function.
 * */
template <typename T>
T lantb(char* norm, char* uplo, char* diag, integer* n, integer* k, T* ab, integer* ldab, T* work)
{
  return lantb(norm, uplo, diag, n, k, ab, ldab, work);
}
template <typename T, typename Ta>
Ta lantb(char* norm, char* uplo, char* diag, integer* n, integer* k, T* ab, integer* ldab, Ta* work)
{
  return lantb(norm, uplo, diag, n, k, ab, ldab, work);
}


/*! @brief GELQT computes a blocked LQ factorization of a real M-by-N matrix A
    using the compact WY representation of Q.

 * @details
 * \b Purpose:
    \verbatim        
    GELQT computes a blocked LQ factorization of a real M-by-N matrix A
    using the compact WY representation of Q.
    \endverbatim 

 * @param[in]	M	
          M is INTEGER \n
          The number of rows of the matrix A.  M >= 0. \n
 * @param[in]	N	
          N is INTEGER \n
          The number of columns of the matrix A.  N >= 0. \n
 * @param[in]	MB	
          MB is INTEGER \n
          The block size to be used in the blocked QR.  MIN(M,N) >= MB >= 1. \n
 * @param[in,out]	A	
          A is REAL array, dimension (LDA,N) \n
          On entry, the M-by-N matrix A. \n
          On exit, the elements on and below the diagonal of the array
          contain the M-by-MIN(M,N) lower trapezoidal matrix L (L is
          lower triangular if M <= N); the elements above the diagonal
          are the rows of V. \n
 * @param[in]	LDA	
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,M). \n
 * @param[out]	T	
          T is REAL array, dimension (LDT,MIN(M,N)) \n
          The upper triangular block reflectors stored in compact form
          as a sequence of upper triangular blocks.  See below
          for further details. \n
 * @param[in]	LDT	
          LDT is INTEGER \n
          The leading dimension of the array T.  LDT >= MB. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MB*N) \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer gelqt(integer* m, integer* n, integer* mb, T* a, integer* lda, T* t, integer* ldt, T* work, integer* info)
{
  return gelqt(m, n, mb, a, lda, t, ldt, work, info);
}

/*! @brief GEMLQT overwrites the general real M-by-N matrix C

 * @details
 * \b Purpose:
    \verbatim        
    GEMLQT overwrites the general real M-by-N matrix C with

                   SIDE = 'L'     SIDE = 'R'
    TRANS = 'N':      Q C            C Q
    TRANS = 'T':   Q**T C            C Q**T

    where Q is a real orthogonal matrix defined as the product of K
    elementary reflectors:

         Q = H(1) H(2) . . . H(K) = I - V T V**T

    generated using the compact WY representation as returned by DGELQT.

    Q is of order M if SIDE = 'L' and of order N  if SIDE = 'R'.
    \endverbatim 

 * @param[in]	SIDE	
          SIDE is CHARACTER*1 \n
          = 'L': apply Q or Q**T from the Left; \n
          = 'R': apply Q or Q**T from the Right. \n
 * @param[in]	TRANS	
          TRANS is CHARACTER*1 \n
          = 'N':  No transpose, apply Q; \n
          = 'C':  Transpose, apply Q**T. \n
 * @param[in]	M	
          M is INTEGER \n
          The number of rows of the matrix C. M >= 0. \n
 * @param[in]	N	
          N is INTEGER \n
          The number of columns of the matrix C. N >= 0. \n
 * @param[in]	K	
          K is INTEGER \n
          The number of elementary reflectors whose product defines
          the matrix Q. \n
          If SIDE = 'L', M >= K >= 0; \n
          if SIDE = 'R', N >= K >= 0. \n
 * @param[in]	MB	
          MB is INTEGER \n
          The block size used for the storage of T.  K >= MB >= 1. \n
          This must be the same value of MB used to generate T
          in DGELQT. \n
 * @param[in]	V	
          V is REAL array, dimension \n
                               (LDV,M) if SIDE = 'L', \n
                               (LDV,N) if SIDE = 'R' \n
          The i-th row must contain the vector which defines the
          elementary reflector H(i), for i = 1,2,...,k, as returned by
          DGELQT in the first K rows of its array argument A. \n
 * @param[in]	LDV	
          LDV is INTEGER \n
          The leading dimension of the array V. LDV >= max(1,K). \n
 * @param[in]	T	
          T is REAL array, dimension (LDT,K) \n
          The upper triangular factors of the block reflectors
          as returned by DGELQT, stored as a MB-by-K matrix. \n
 * @param[in]	LDT	
          LDT is INTEGER \n
          The leading dimension of the array T.  LDT >= MB. \n
 * @param[in,out]	C	
          C is REAL array, dimension (LDC,N) \n
          On entry, the M-by-N matrix C. \n
          On exit, C is overwritten by Q C, Q**T C, C Q**T or C Q. \n
 * @param[in]	LDC	
          LDC is INTEGER \n
          The leading dimension of the array C. LDC >= max(1,M). \n
 * @param[out]	WORK	
          WORK is REAL array. The dimension of \n
          WORK is N*MB if SIDE = 'L', or  M*MB if SIDE = 'R'. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer gemlqt(char* side, char* trans, integer* m, integer* n, integer* k, integer* mb, T* v, integer* ldv, T* t, integer* ldt, T* c, integer* ldc, T* work, integer* info)
{
  return gemlqt(side, trans, m, n, k, mb, v, ldv, t, ldt, c, ldc, work, info);
}

/*! @brief GEGS computes the eigenvalues and, optionally, the left and/or right eigenvectors for GE matrices

 * @details
 * \b Purpose:
    \verbatim
    This routine is deprecated and has been replaced by routine SGGES.

    SGEGS computes the eigenvalues, real Schur form, and, optionally,
    left and or/right Schur vectors of a real matrix pair (A,B).
    Given two square matrices A and B, the generalized real Schur
    factorization has the form

     A = Q*S*Z**T,  B = Q*T*Z**T

    where Q and Z are orthogonal matrices, T is upper triangular, and S
    is an upper quasi-triangular matrix with 1-by-1 and 2-by-2 diagonal
    blocks, the 2-by-2 blocks corresponding to complex conjugate pairs
    of eigenvalues of (A,B).  The columns of Q are the left Schur vectors
    and the columns of Z are the right Schur vectors.

    If only the eigenvalues of (A,B) are needed, the driver routine
    SGEGV should be used instead.  See SGEGV for a description of the
    eigenvalues of the generalized nonsymmetric eigenvalue problem
    (GNEP).
    \endverbatim 

 * @param[in]	JOBVSL	
          JOBVSL is CHARACTER*1 \n
          = 'N':  do not compute the left Schur vectors; \n
          = 'V':  compute the left Schur vectors (returned in VSL). \n
 * @param[in]	JOBVSR	
          JOBVSR is CHARACTER*1 \n
          = 'N':  do not compute the right Schur vectors; \n
          = 'V':  compute the right Schur vectors (returned in VSR). \n
 * @param[in]	N	
          N is INTEGER \n
          The order of the matrices A, B, VSL, and VSR.  N >= 0. \n
 * @param[in,out]	A	
          A is REAL array, dimension (LDA, N) \n
          On entry, the matrix A. \n
          On exit, the upper quasi-triangular matrix S from the
          generalized real Schur factorization. \n
 * @param[in]	LDA	
          LDA is INTEGER \n
          The leading dimension of A.  LDA >= max(1,N). \n
 * @param[in,out]	B	
          B is REAL array, dimension (LDB, N) \n
          On entry, the matrix B. \n
          On exit, the upper triangular matrix T from the generalized
          real Schur factorization. \n
 * @param[in]	LDB	
          LDB is INTEGER \n
          The leading dimension of B.  LDB >= max(1,N). \n
 * @param[out]	ALPHAR	
          ALPHAR is REAL array, dimension (N) \n
          The real parts of each scalar alpha defining an eigenvalue
          of GNEP. \n
 * @param[out]	ALPHAI	
          ALPHAI is REAL array, dimension (N) \n
          The imaginary parts of each scalar alpha defining an
          eigenvalue of GNEP.  If ALPHAI(j) is zero, then the j-th
          eigenvalue is real; if positive, then the j-th and (j+1)-st
          eigenvalues are a complex conjugate pair, with
          ALPHAI(j+1) = -ALPHAI(j). \n
 * @param[out]	BETA	
          BETA is REAL array, dimension (N) \n
          The scalars beta that define the eigenvalues of GNEP.
          Together, the quantities alpha = (ALPHAR(j),ALPHAI(j)) and
          beta = BETA(j) represent the j-th eigenvalue of the matrix
          pair (A,B), in one of the forms lambda = alpha/beta or
          mu = beta/alpha.  Since either lambda or mu may overflow,
          they should not, in general, be computed. \n
 * @param[out]	VSL	
          VSL is REAL array, dimension (LDVSL,N) \n
          If JOBVSL = 'V', the matrix of left Schur vectors Q.
          Not referenced if JOBVSL = 'N'. \n
 * @param[in]	LDVSL	
          LDVSL is INTEGER \n
          The leading dimension of the matrix VSL. LDVSL >=1, and
          if JOBVSL = 'V', LDVSL >= N. \n
 * @param[out]	VSR	
          VSR is REAL array, dimension (LDVSR,N) \n
          If JOBVSR = 'V', the matrix of right Schur vectors Z.
          Not referenced if JOBVSR = 'N'. \n
 * @param[in]	LDVSR	
          LDVSR is INTEGER \n
          The leading dimension of the matrix VSR. LDVSR >= 1, and
          if JOBVSR = 'V', LDVSR >= N. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK.  LWORK >= max(1,4*N).
          For good performance, LWORK must generally be larger.
          To compute the optimal value of LWORK, call ILAENV to get
          blocksizes (for SGEQRF, SORMQR, and SORGQR.)  Then compute:
          NB  -- MAX of the blocksizes for SGEQRF, SORMQR, and SORGQR
          The optimal LWORK is  2*N + N*(NB+1). \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n
          = 1,...,N: \n
                The QZ iteration failed.  (A,B) are not in Schur
                form, but ALPHAR(j), ALPHAI(j), and BETA(j) should
                be correct for j=INFO+1,...,N. \n
          > N:  errors that usually indicate LAPACK problems: \n
                =N+1: error return from SGGBAL \n
                =N+2: error return from SGEQRF \n
                =N+3: error return from SORMQR \n
                =N+4: error return from SORGQR \n
                =N+5: error return from SGGHRD \n
                =N+6: error return from SHGEQZ (other than failed
                                                iteration) \n
                =N+7: error return from SGGBAK (computing VSL) \n
                =N+8: error return from SGGBAK (computing VSR) \n
                =N+9: error return from SLASCL (various places) \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer gegs(char* jobvsl, char* jobvsr, integer* n, T* a, integer* lda, T* b, integer* ldb, T* alphar, T* alphai, T* beta, T* vsl, integer* ldvsl, T* vsr, integer* ldvsr, T* work, integer* lwork, integer* info)
{
  return gegs(jobvsl, jobvsr, n, a, lda, b, ldb, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, info);
}
template <typename T, typename Ta>
integer gegs(char* jobvsl, char* jobvsr, integer* n, T* a, integer* lda, T* b, integer* ldb, T* alpha, T* beta, T* vsl, integer* ldvsl, T* vsr, integer* ldvsr, T* work, integer* lwork, Ta* rwork, integer* info)
{
  return gegs(jobvsl, jobvsr, n, a, lda, b, ldb, alpha, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, rwork, info);
}

/*! @brief GEGV computes the eigenvalues and, optionally, the left and/or right
    eigenvectors of a real matrix pair (A,B).

 * @details
 * \b Purpose:
    \verbatim        
    This routine is deprecated and has been replaced by routine SGGEV.
    \endverbatim 
    SGEGV computes the eigenvalues and, optionally, the left and/or right
    eigenvectors of a real matrix pair (A,B).
    Given two square matrices A and B,
    the generalized nonsymmetric eigenvalue problem (GNEP) is to find the
    eigenvalues lambda and corresponding (non-zero) eigenvectors x such
    that

      A*x = lambda*B*x.

    An alternate form is to find the eigenvalues mu and corresponding
    eigenvectors y such that

      mu*A*y = B*y.

    These two forms are equivalent with mu = 1/lambda and x = y if
    neither lambda nor mu is zero.  In order to deal with the case that
    lambda or mu is zero or small, two values alpha and beta are returned
    for each eigenvalue, such that lambda = alpha/beta and
    mu = beta/alpha.

    The vectors x and y in the above equations are right eigenvectors of
    the matrix pair (A,B).  Vectors u and v satisfying

      u**H*A = lambda*u**H*B  or  mu*v**H*A = v**H*B

    are left eigenvectors of (A,B).

    Note: this routine performs "full balancing" on A and B

 * @param[in]	JOBVL	
          JOBVL is CHARACTER*1 \n
          = 'N':  do not compute the left generalized eigenvectors; \n
          = 'V':  compute the left generalized eigenvectors (returned
                  in VL). \n
 * @param[in]	JOBVR	
          JOBVR is CHARACTER*1 \n
          = 'N':  do not compute the right generalized eigenvectors; \n
          = 'V':  compute the right generalized eigenvectors (returned
                  in VR). \n
 * @param[in]	N	
          N is INTEGER \n
          The order of the matrices A, B, VL, and VR.  N >= 0. \n
 * @param[in,out]	A	
          A is REAL array, dimension (LDA, N) \n
          On entry, the matrix A. \n
          If JOBVL = 'V' or JOBVR = 'V', then on exit A
          contains the real Schur form of A from the generalized Schur
          factorization of the pair (A,B) after balancing. \n
          If no eigenvectors were computed, then only the diagonal
          blocks from the Schur form will be correct.  See SGGHRD and
          SHGEQZ for details. \n
 * @param[in]	LDA	
          LDA is INTEGER \n
          The leading dimension of A.  LDA >= max(1,N). \n
 * @param[in,out]	B	
          B is REAL array, dimension (LDB, N) \n
          On entry, the matrix B. \n
          If JOBVL = 'V' or JOBVR = 'V', then on exit B contains the
          upper triangular matrix obtained from B in the generalized
          Schur factorization of the pair (A,B) after balancing.
          If no eigenvectors were computed, then only those elements of
          B corresponding to the diagonal blocks from the Schur form of
          A will be correct.  See SGGHRD and SHGEQZ for details. \n
 * @param[in]	LDB	
          LDB is INTEGER \n
          The leading dimension of B.  LDB >= max(1,N). \n
 * @param[out]	ALPHAR	
          ALPHAR is REAL array, dimension (N) \n
          The real parts of each scalar alpha defining an eigenvalue of
          GNEP. \n
 * @param[out]	ALPHAI	
          ALPHAI is REAL array, dimension (N) \n
          The imaginary parts of each scalar alpha defining an
          eigenvalue of GNEP.  If ALPHAI(j) is zero, then the j-th
          eigenvalue is real; if positive, then the j-th and
          (j+1)-st eigenvalues are a complex conjugate pair, with
          ALPHAI(j+1) = -ALPHAI(j). \n
 * @param[out]	BETA	
          BETA is REAL array, dimension (N) \n
          The scalars beta that define the eigenvalues of GNEP. \n
 \n
          Together, the quantities alpha = (ALPHAR(j),ALPHAI(j)) and
          beta = BETA(j) represent the j-th eigenvalue of the matrix
          pair (A,B), in one of the forms lambda = alpha/beta or
          mu = beta/alpha.  Since either lambda or mu may overflow,
          they should not, in general, be computed. \n
 * @param[out]	VL	
          VL is REAL array, dimension (LDVL,N) \n
          If JOBVL = 'V', the left eigenvectors u(j) are stored
          in the columns of VL, in the same order as their eigenvalues. \n
          If the j-th eigenvalue is real, then u(j) = VL(:,j). \n
          If the j-th and (j+1)-st eigenvalues form a complex conjugate
          pair, then \n
             u(j) = VL(:,j) + i*VL(:,j+1) \n
          and \n
            u(j+1) = VL(:,j) - i*VL(:,j+1). \n
 \n
          Each eigenvector is scaled so that its largest component has
          abs(real part) + abs(imag. part) = 1, except for eigenvectors
          corresponding to an eigenvalue with alpha = beta = 0, which
          are set to zero. \n
          Not referenced if JOBVL = 'N'. \n
 * @param[in]	LDVL	
          LDVL is INTEGER \n
          The leading dimension of the matrix VL. LDVL >= 1, and
          if JOBVL = 'V', LDVL >= N. \n
 * @param[out]	VR	
          VR is REAL array, dimension (LDVR,N) \n
          If JOBVR = 'V', the right eigenvectors x(j) are stored
          in the columns of VR, in the same order as their eigenvalues. \n
          If the j-th eigenvalue is real, then x(j) = VR(:,j). \n
          If the j-th and (j+1)-st eigenvalues form a complex conjugate
          pair, then \n
            x(j) = VR(:,j) + i*VR(:,j+1) \n
          and \n
            x(j+1) = VR(:,j) - i*VR(:,j+1). \n
 \n
          Each eigenvector is scaled so that its largest component has
          abs(real part) + abs(imag. part) = 1, except for eigenvalues
          corresponding to an eigenvalue with alpha = beta = 0, which
          are set to zero. \n
          Not referenced if JOBVR = 'N'. \n
 * @param[in]	LDVR	
          LDVR is INTEGER \n
          The leading dimension of the matrix VR. LDVR >= 1, and
          if JOBVR = 'V', LDVR >= N. \n
 * @param[out]	WORK	
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in]	LWORK	
          LWORK is INTEGER \n
          The dimension of the array WORK.  LWORK >= max(1,8*N).
          For good performance, LWORK must generally be larger.
          To compute the optimal value of LWORK, call ILAENV to get
          blocksizes (for SGEQRF, SORMQR, and SORGQR.)  Then compute:
          NB  -- MAX of the blocksizes for SGEQRF, SORMQR, and SORGQR;
          The optimal LWORK is: \n
              2*N + MAX( 6*N, N*(NB+1) ). \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value. \n
          = 1,...,N: \n
                The QZ iteration failed.  No eigenvectors have been
                calculated, but ALPHAR(j), ALPHAI(j), and BETA(j)
                should be correct for j=INFO+1,...,N. \n
          > N:  errors that usually indicate LAPACK problems: \n
                =N+1: error return from SGGBAL \n
                =N+2: error return from SGEQRF \n
                =N+3: error return from SORMQR \n
                =N+4: error return from SORGQR \n
                =N+5: error return from SGGHRD \n
                =N+6: error return from SHGEQZ (other than failed
                                                iteration) \n
                =N+7: error return from STGEVC \n
                =N+8: error return from SGGBAK (computing VL) \n
                =N+9: error return from SGGBAK (computing VR) \n
                =N+10: error return from SLASCL (various calls) \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer gegv(char* jobvl, char* jobvr, integer* n, T* a, integer* lda, T* b, integer* ldb, T* alphar, T* alphai, T* beta, T* vl, integer* ldvl, T* vr, integer* ldvr, T* work, integer* lwork, integer* info)
{
  return ggev(jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, work, lwork, info);
}
template <typename T, typename Ta>
integer gegv(char* jobvl, char* jobvr, integer* n, T* a, integer* lda, T* b, integer* ldb, T* alpha, T* beta, T* vl, integer* ldvl, T* vr, integer* ldvr, T* work, integer* lwork, Ta* rwork, integer* info)
{
  return gegv(jobvl, jobvr, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, work, lwork, rwork, info);
}

/*! @brief LATZM applies a Householder matrix generated by STZRQF to a matrix.

 * @details
 * \b Purpose:
    \verbatim
     This routine is deprecated and has been replaced by routine SORMRZ.

    SLATZM applies a Householder matrix generated by STZRQF to a matrix.

    Let P = I - tau*u*u**T,   u = ( 1 ),
                                 ( v )
    where v is an (m-1) vector if SIDE = 'L', or a (n-1) vector if
    SIDE = 'R'.

    If SIDE equals 'L', let
          C = [ C1 ] 1
              [ C2 ] m-1
                n
    Then C is overwritten by P*C.

    If SIDE equals 'R', let
          C = [ C1, C2 ] m
                 1  n-1
    Then C is overwritten by C*P.
    \endverbatim

 * @param[in]	SIDE	
          SIDE is CHARACTER*1 \n
          = 'L': form P * C \n
          = 'R': form C * P \n
 * @param[in]	M	
          M is INTEGER \n
          The number of rows of the matrix C. \n
 * @param[in]	N	
          N is INTEGER \n
          The number of columns of the matrix C. \n
 * @param[in]	V	
          V is REAL array, dimension \n
                  (1 + (M-1)*abs(INCV)) if SIDE = 'L' \n
                  (1 + (N-1)*abs(INCV)) if SIDE = 'R' \n
          The vector v in the representation of P. V is not used
          if TAU = 0. \n
 * @param[in]	INCV	
          INCV is INTEGER \n
          The increment between elements of v. INCV <> 0 \n
 * @param[in]	TAU	
          TAU is REAL \n
          The value tau in the representation of P. \n
 * @param[in,out]	C1	
          C1 is REAL array, dimension \n
                         (LDC,N) if SIDE = 'L' \n
                         (M,1)   if SIDE = 'R' \n
          On entry, the n-vector C1 if SIDE = 'L', or the m-vector C1
          if SIDE = 'R'. \n
 \n
          On exit, the first row of P*C if SIDE = 'L', or the first
          column of C*P if SIDE = 'R'. \n
 * @param[in,out]	C2	
          C2 is REAL array, dimension \n
                         (LDC, N)   if SIDE = 'L' \n
                         (LDC, N-1) if SIDE = 'R' \n
          On entry, the (m - 1) x n matrix C2 if SIDE = 'L', or the
          m x (n - 1) matrix C2 if SIDE = 'R'. \n
 \n
          On exit, rows 2:m of P*C if SIDE = 'L', or columns 2:m of C*P
          if SIDE = 'R'. \n
 * @param[in]	LDC	
          LDC is INTEGER \n
          The leading dimension of the arrays C1 and C2. LDC >= (1,M). \n
 * @param[out]	WORK	
          WORK is REAL array, dimension \n
                      (N) if SIDE = 'L' \n
                      (M) if SIDE = 'R' \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer latzm(char* side, integer* m, integer* n, T* v, integer* incv, T* tau, T* c1, T* c2, integer* ldc, T* work)
{
  return latzm(side, m, n, v, incv, tau, c1, c2, ldc, work);
}

/*! @brief DSPOSV computes the solution to system of linear equations A * X = B for PO matrices

 * @details
 * \b Purpose:
    \verbatim
    DSPOSV computes the solution to a real system of linear equations
      A * X = B,
    where A is an N-by-N symmetric positive definite matrix and X and B
    are N-by-NRHS matrices.

    DSPOSV first attempts to factorize the matrix in SINGLE PRECISION
    and use this factorization within an iterative refinement procedure
    to produce a solution with DOUBLE PRECISION normwise backward error
    quality (see below). If the approach fails the method switches to a
    DOUBLE PRECISION factorization and solve.

    The iterative refinement is not going to be a winning strategy if
    the ratio SINGLE PRECISION performance over DOUBLE PRECISION
    performance is too small. A reasonable strategy should take the
    number of right-hand sides and the size of the matrix into account.
    This might be done with a call to ILAENV in the future. Up to now, we
    always try iterative refinement.

    The iterative refinement process is stopped if
       ITER > ITERMAX
    or for all the RHS we have:
       RNRM < SQRT(N)*XNRM*ANRM*EPS*BWDMAX
    where
       o ITER is the number of the current iteration in the iterative
         refinement process
       o RNRM is the infinity-norm of the residual
       o XNRM is the infinity-norm of the solution
       o ANRM is the infinity-operator-norm of the matrix A
       o EPS is the machine epsilon returned by DLAMCH('Epsilon')
    The value ITERMAX and BWDMAX are fixed to 30 and 1.0D+00
    respectively.
    \endverbatim

 * @param[in]	UPLO	
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in]	N	
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in]	NRHS	
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in,out]	A	
          A is DOUBLE PRECISION array,
          dimension (LDA,N) \n
          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
          N-by-N upper triangular part of A contains the upper
          triangular part of the matrix A, and the strictly lower
          triangular part of A is not referenced.  If UPLO = 'L', the
          leading N-by-N lower triangular part of A contains the lower
          triangular part of the matrix A, and the strictly upper
          triangular part of A is not referenced. \n
          On exit, if iterative refinement has been successfully used
          (INFO = 0 and ITER >= 0, see description below), then A is
          unchanged, if double precision factorization has been used
          (INFO = 0 and ITER < 0, see description below), then the
          array A contains the factor U or L from the Cholesky
          factorization A = U**T*U or A = L*L**T. \n
 * @param[in]	LDA	
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in]	B	
          B is DOUBLE PRECISION array, dimension (LDB,NRHS) \n
          The N-by-NRHS right hand side matrix B. \n
 * @param[in]	LDB	
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out]	X	
          X is DOUBLE PRECISION array, dimension (LDX,NRHS) \n
          If INFO = 0, the N-by-NRHS solution matrix X. \n
 * @param[in]	LDX	
          LDX is INTEGER \n
          The leading dimension of the array X.  LDX >= max(1,N). \n
 * @param[out]	WORK	
          WORK is DOUBLE PRECISION array, dimension (N,NRHS) \n
          This array is used to hold the residual vectors. \n
 * @param[out]	SWORK	
          SWORK is REAL array, dimension (N*(N+NRHS)) \n
          This array is used to use the single precision matrix and the
          right-hand sides or solutions in single precision. \n
 * @param[out]	ITER	
          ITER is INTEGER \n
          < 0: iterative refinement has failed, double precision
               factorization has been performed \n
               -1 : the routine fell back to full precision for
                    implementation- or machine-specific reasons \n
               -2 : narrowing the precision induced an overflow,
                    the routine fell back to full precision \n
               -3 : failure of SPOTRF \n
               -31: stop the iterative refinement after the 30th
                    iterations \n
          > 0: iterative refinement has been successfully used.
               Returns the number of iterations \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, the leading minor of order i of (DOUBLE
                PRECISION) A is not positive definite, so the
                factorization could not be completed, and the solution
                has not been computed. \n

 * @return INTEGER Return value of the function.
 * */
integer dsposv(char* uplo, integer* n, integer* nrhs, double* a, integer* lda, double* b, integer* ldb, double* x, integer* ldx, double* work, float* swork, integer* iter, integer* info)
{
  return dsposv_(uplo, n, nrhs, a, lda, b, ldb, x, ldx, work, swork, iter, info);
}

/*! @brief ZCPOSV computes the solution to system of linear equations A * X = B for PO matrices

 * @details
 * \b Purpose:
    \verbatim
    ZCPOSV computes the solution to a complex system of linear equations
      A * X = B,
    where A is an N-by-N Hermitian positive definite matrix and X and B
    are N-by-NRHS matrices.

    ZCPOSV first attempts to factorize the matrix in COMPLEX and use this
    factorization within an iterative refinement procedure to produce a
    solution with COMPLEX*16 normwise backward error quality (see below).
    If the approach fails the method switches to a COMPLEX*16
    factorization and solve.

    The iterative refinement is not going to be a winning strategy if
    the ratio COMPLEX performance over COMPLEX*16 performance is too
    small. A reasonable strategy should take the number of right-hand
    sides and the size of the matrix into account. This might be done
    with a call to ILAENV in the future. Up to now, we always try
    iterative refinement.

    The iterative refinement process is stopped if
       ITER > ITERMAX
    or for all the RHS we have:
       RNRM < SQRT(N)*XNRM*ANRM*EPS*BWDMAX
    where
       o ITER is the number of the current iteration in the iterative
         refinement process
       o RNRM is the infinity-norm of the residual
       o XNRM is the infinity-norm of the solution
       o ANRM is the infinity-operator-norm of the matrix A
       o EPS is the machine epsilon returned by DLAMCH('Epsilon')
    The value ITERMAX and BWDMAX are fixed to 30 and 1.0D+00
    respectively.
    \endverbatim

 * @param[in]	UPLO	
          UPLO is CHARACTER*1 \n
          = 'U':  Upper triangle of A is stored; \n
          = 'L':  Lower triangle of A is stored. \n
 * @param[in]	N	
          N is INTEGER \n
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0. \n
 * @param[in]	NRHS	
          NRHS is INTEGER \n
          The number of right hand sides, i.e., the number of columns
          of the matrix B.  NRHS >= 0. \n
 * @param[in,out]	A	
          A is COMPLEX*16 array,
          dimension (LDA,N) \n
          On entry, the Hermitian matrix A. If UPLO = 'U', the leading
          N-by-N upper triangular part of A contains the upper
          triangular part of the matrix A, and the strictly lower
          triangular part of A is not referenced.  If UPLO = 'L', the
          leading N-by-N lower triangular part of A contains the lower
          triangular part of the matrix A, and the strictly upper
          triangular part of A is not referenced. \n
 \n
          Note that the imaginary parts of the diagonal
          elements need not be set and are assumed to be zero.
 \n
          On exit, if iterative refinement has been successfully used
          (INFO = 0 and ITER >= 0, see description below), then A is
          unchanged, if double precision factorization has been used
          (INFO = 0 and ITER < 0, see description below), then the
          array A contains the factor U or L from the Cholesky
          factorization A = U**H*U or A = L*L**H. \n
 * @param[in]	LDA	
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,N). \n
 * @param[in]	B	
          B is COMPLEX*16 array, dimension (LDB,NRHS) \n
          The N-by-NRHS right hand side matrix B. \n
 * @param[in]	LDB	
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max(1,N). \n
 * @param[out]	X	
          X is COMPLEX*16 array, dimension (LDX,NRHS) \n
          If INFO = 0, the N-by-NRHS solution matrix X. \n
 * @param[in]	LDX	
          LDX is INTEGER \n
          The leading dimension of the array X.  LDX >= max(1,N). \n
 * @param[out]	WORK	
          WORK is COMPLEX*16 array, dimension (N,NRHS) \n
          This array is used to hold the residual vectors. \n
 * @param[out]	SWORK	
          SWORK is COMPLEX array, dimension (N*(N+NRHS)) \n
          This array is used to use the single precision matrix and the
          right-hand sides or solutions in single precision. \n
 * @param[out]	RWORK	
          RWORK is DOUBLE PRECISION array, dimension (N) \n
 * @param[out]	ITER	
          ITER is INTEGER \n
          < 0: iterative refinement has failed, COMPLEX*16
               factorization has been performed \n
               -1 : the routine fell back to full precision for
                    implementation- or machine-specific reasons \n
               -2 : narrowing the precision induced an overflow,
                    the routine fell back to full precision \n
               -3 : failure of CPOTRF \n
               -31: stop the iterative refinement after the 30th
                    iterations \n
          > 0: iterative refinement has been successfully used.
               Returns the number of iterations \n
 * @param[out]	INFO	
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n
          > 0:  if INFO = i, the leading minor of order i of
                (COMPLEX*16) A is not positive definite, so the
                factorization could not be completed, and the solution
                has not been computed. \n

 * @return INTEGER Return value of the function.
 * */
integer zcposv(char* uplo, integer* n, integer* nrhs, dcomplex* a, integer* lda, dcomplex* b, integer* ldb, dcomplex* x, integer* ldx, dcomplex* work, scomplex* swork, double* rwork, integer* iter, integer* info)
{
  return zcposv_(uplo, n, nrhs, a, lda, b, ldb, x, ldx, work, swork, rwork, iter, info);
}

/*! @brief Computes the LU factorization of a general m-by-n matrix without pivoting.

 * @details
 * \b Purpose:
    \verbatim
    The routine computes the LU factorization of a general m-by-n matrix A as
    A = L*U,
    where L is lower triangular with unit-diagonal elements (lower trapezoidal
    if m > n) and U is upper triangular (upper trapezoidal if m < n).
    The routine does not use pivoting.
    \endverbatim

 * @param[in] m
          M is INTEGER \n
          The number of rows in the matrix A (m 0). \n
 * @param[in] n
          N is INTEGER \n
          The number of columns in A; n 0. \n
 * @param[in, out] a
          A is REAL/DOUBLE/COMPLEX/COMPLEX*16 array \n
          Array, size at least max(1, lda*n) for column-major layout
          or max(1, lda*m) for row-major layout. Contains the matrix A.
          On exit, Overwritten by L and U. The unit diagonal elements
          of L are not stored. \n
 * @param[in] lda
          LDA is INTEGER \n
          The leading dimension of array a, which must be
          at least max(1, m) for column-major layout
          or max(1, n) for row-major layout. \n
 * @param[in] info
          INFO is INTEGER \n
          If info=0, the execution is successful. \n
          If info = -i, parameter i had an illegal value. \n
          If info = i, uii is 0. The factorization has been completed,
          but U is exactly singular. Division by 0 will occur if 
          you use the factor U for solving a system of linear equations. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer getrfnp(integer* m, integer* n, T* a, integer* lda, integer* info)
{
  return getrfnp(m, n, a, lda, info);
}

/*! @brief Computes the partial LDLT factorization of a symmetric matrix using packed storage.

 * @details
 * \b Purpose:
    \verbatim
    The routine computes the partial factorization A = LDLT , where L is a lower
    triangular matrix and D is a diagonal matrix.
    Consider the matrix

    , where a is the element in the first row and first column of A, b is a column
    vector of size n - 1 containing the elements from the second through n-th column
    of A, C is the lower-right square submatrix of A, and I is the identity matrix.
    The spffrt2 routine performs ncolm successive factorizations of the form.
    The spffrtx routine performs ncolm successive factorizations of the form.
    The approximate number of floating point operations performed by real flavors
    of these routines is (1/6)*ncolm*(2*ncolm2 - 6*ncolm*n + 3*ncolm + 6*n2 - 6*n + 7).
    The approximate number of floating point operations performed by complex 
    flavors of these routines is (1/3)*ncolm*(4*ncolm2 - 12*ncolm*n + 9*ncolm + 12*n2 - 18*n + 8).
    \endverbatim

 * @param[in, out] ap
          AP is REAL array. \n
          Array, size at least max(1, n(n+1)/2). The array ap contains
          the lower triangular part of the matrix A in packed 
          storage (see Matrix Storage Schemes for uplo = 'L').
          On exit, Overwritten by the factor L. The first ncolm diagonal
          elements of the input matrix A are replaced with the diagonal
          elements of D. The subdiagonal elements of the first ncolm
          columns are replaced with the corresponding elements of L.
          The rest of the input array is updated as indicated in the
          Description section. \n
 * @param[in] n
          N is INTEGER \n
          The order of matrix A; n 0. \n
 * @param[in] ncolm
          NCOLM is INTEGER \n
          The number of columns to factor, ncolmn. \n
 * @param[in, out] work
          WORK is REAL array. \n
          Workspace arrays, size of each at least n. \n
 * @param[in, out] work2
          WORK2 is REAL array. \n
          Workspace arrays, size of each at least n. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer spffrt2(T *ap, integer *n, integer * ncolm, T *work, T *work2)
{
  return spffrt2(ap, n, ncolm, work, work2);
}
template< typename T >
integer spffrtx(T *ap, integer *n, integer * ncolm, T *work, T *work2)
{
  return spffrtx(ap, n, ncolm, work, work2);
}

/*! @brief Performs LU factorization (complete or incomplete) of a general matrix without pivoting.

 * @details
 * \b Purpose:
    \verbatim
    The routine computes the LU factorization of a general m-by-n matrix A
    without using pivoting. It supports incomplete factorization.
    The factorization has the form:
    A = L*U,
    where L is lower triangular with unit diagonal elements (lower trapezoidal if m > n)
    and U is upper triangular (upper trapezoidal if m < n).
    Incomplete factorization has the form:
    
    where L is lower trapezoidal with unit diagonal elements,
    U is upper trapezoidal, and  is the unfactored part of matrix A. 
    See the application notes section for further details.
    \endverbatim

 * @param[in] m
          M is INTEGER \n
          The number of rows in the matrix A (m 0). \n
 * @param[in] n
          N is INTEGER \n
          The number of columns in A; n 0. \n
 * @param[in] nfact
          NFACT is INTEGER \n
          The number of rows and columns to factor; 0 nfact min(m, n). \n
          Note that if nfact < min(m, n), incomplete factorization is performed. \n
 * @param[in, out] a
          A is REAL/DOUBLE/COMPLEX/COMPLEX*16 array \n
          Array of size at least lda*n for column major layout
          and at least lda*m for row major layout. Contains the matrix A.
          On exit, Overwritten by L and U. The unit diagonal elements of L are not stored.
          When incomplete factorization is specified by setting nfact < min(m, n),
          A also contains the unfactored submatrix. See the application notes section for further details. \n
 * @param[in] lda
          LDA is INTEGER \n
          The leading dimension of array a. lda max(1, m) \n
          for column major layout and lda max(1, n) for row major layout. \n
 * @param[in] info
          INFO is INTEGER \n
          If info=0, the execution is successful. \n
          If info = -i, the i-th parameter had an illegal value. \n
          If info = i, uii is 0. The requested factorization
          has been completed, but U is exactly singular. 
          Division by 0 will occur if factorization is completed
          and factor U is used for solving a system of linear equations. \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer getrfnpi(integer *m, integer *n, integer *nfact, T *a, integer *lda, integer *info)
{
  return getrfnpi(m, n, nfact, a, lda, info);
}

/*! @brief Computes a NB2-sized column blocked QR-factorization.

 * @details
 * \b Purpose:
    \verbatim
    The routine computes a NB2-sized column blocked QR-factorization of a
    complex M-by-N matrix A with M >= N,

    A = Q * R.

    The routine uses internally a NB1-sized column blocked and MB1-sized
    row blocked TSQR-factorization and perfors the reconstruction
    of the Householder vectors from the TSQR output. The routine also
    converts the R_tsqr factor from the TSQR-factorization output into
    the R factor that corresponds to the Householder QR-factorization,

      A = Q_tsqr * R_tsqr = Q * R.

    The output Q and R factors are stored in the same format as in CGEQRT
    (Q is in blocked compact WY-representation). See the documentation
    of CGEQRT for more details on the format.
    \endverbatim

 * @param[in] m
          M is INTEGER \n
          The number of rows of the matrix A.  M >= 0. \n
 * @param[in] n
          N is INTEGER \n
          The number of columns of the matrix A. M >= N >= 0. \n
 * @param[in] mb1
          MB1 is INTEGER \n
          The row block size to be used in the blocked TSQR. \n
          MB1 > N. \n
 * @param[in, out] nb1
          NB1 is INTEGER \n
          The column block size to be used in the blocked TSQR. \n
          N >= NB1 >= 1. \n
 * @param[in, out] nb2
          NB2 is INTEGER \n
          The block size to be used in the blocked QR that is \n
          output. NB2 >= 1. \n
 * @param[in, out] a
          A is REAL/DOUBLE/COMPLEX/COMPLEX*16 array, dimension (LDA,N) \n

          On entry: an M-by-N matrix A.\n

          On exit:\n
           a) the elements on and above the diagonal
              of the array contain the N-by-N upper-triangular
              matrix R corresponding to the Householder QR; \n
           b) the elements below the diagonal represent Q by
              the columns of blocked V (compact WY-representation). \n
 * @param[in] lda
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max(1,M). \n
 * @param[in, out] t
          T is REAL/DOUBLE/COMPLEX/COMPLEX*16 array, dimension (LDT,N)) \n
          The upper triangular block reflectors stored in compact form
          as a sequence of upper triangular blocks. \n
 * @param[in] ldt
          LDT is INTEGER \n
          The leading dimension of the array T.  LDT >= NB2. \n
 * @param[out]	work	
          WORK is REAL/DOUBLE/COMPLEX/COMPLEX*16 array, dimension (N,NRHS) \n
          This array is used to hold the residual vectors. \n
 * @param[out]	lwork	
          The dimension of the array WORK.\n
          LWORK >= MAX( LWT + LW1, MAX( LWT+N*N+LW2, LWT+N*N+N ) ), \n
          where \n
             NUM_ALL_ROW_BLOCKS = CEIL((M-N)/(MB1-N)), \n
             NB1LOCAL = MIN(NB1,N). \n
             LWT = NUM_ALL_ROW_BLOCKS * N * NB1LOCAL, \n
             LW1 = NB1LOCAL * N, \n
             LW2 = NB1LOCAL * MAX( NB1LOCAL, ( N - NB1LOCAL ) ), \n
          If LWORK = -1, then a workspace query is assumed. \n
          The routine only calculates the optimal size of the WORK
          array, returns this value as the first entry of the WORK
          array, and no error message related to LWORK is issued
          by XERBLA. \n
 * @param[in] info
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template< typename T >
integer getsqrhrt(integer *m, integer *n, integer *mb1, integer *nb1, integer *nb2, T *a, integer *lda, T *t, integer *ldt, T *work, integer *lwork, integer *info)
{
  return getsqrhrt(m, n, mb1, nb1, nb2, a, lda, t, ldt, work, lwork, info);
}

/*! @brief  Computes the eigenvalues of a real matrix pair (H,T),
            where H is an upper Hessenberg matrix and T is upper triangular,
            using the double-shift QZ method.

 * @details
 * \b Purpose:
    \verbatim
    LAQZ0 computes the eigenvalues of a real matrix pair (H,T),
    where H is an upper Hessenberg matrix and T is upper triangular,
    using the double-shift QZ method.
    Matrix pairs of this type are produced by the reduction to
    generalized upper Hessenberg form of a real matrix pair (A,B):

      A = Q1*H*Z1**T,  B = Q1*T*Z1**T,

    as computed by SGGHRD.

    If JOB='S', then the Hessenberg-triangular pair (H,T) is
    also reduced to generalized Schur form,

      H = Q*S*Z**T,  T = Q*P*Z**T,

    where Q and Z are orthogonal matrices, P is an upper triangular
    matrix, and S is a quasi-triangular matrix with 1-by-1 and 2-by-2
    diagonal blocks.

    The 1-by-1 blocks correspond to real eigenvalues of the matrix pair
    (H,T) and the 2-by-2 blocks correspond to complex conjugate pairs of
    eigenvalues.

    Additionally, the 2-by-2 upper triangular diagonal blocks of P
    corresponding to 2-by-2 blocks of S are reduced to positive diagonal
    form, i.e., if S(j+1,j) is non-zero, then P(j+1,j) = P(j,j+1) = 0,
    P(j,j) > 0, and P(j+1,j+1) > 0.

    Optionally, the orthogonal matrix Q from the generalized Schur
    factorization may be postmultiplied into an input matrix Q1, and the
    orthogonal matrix Z may be postmultiplied into an input matrix Z1.
    If Q1 and Z1 are the orthogonal matrices from SGGHRD that reduced
    the matrix pair (A,B) to generalized upper Hessenberg form, then the
    output matrices Q1*Q and Z1*Z are the orthogonal factors from the
    generalized Schur factorization of (A,B):

      A = (Q1*Q)*S*(Z1*Z)**T,  B = (Q1*Q)*P*(Z1*Z)**T.

    To avoid overflow, eigenvalues of the matrix pair (H,T) (equivalently,
    of (A,B)) are computed as a pair of values (alpha,beta), where alpha is
    complex and beta real.
    If beta is nonzero, lambda = alpha / beta is an eigenvalue of the
    generalized nonsymmetric eigenvalue problem (GNEP)
      A*x = lambda*B*x
    and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
    alternate form of the GNEP
      mu*A*y = B*y.
    Real eigenvalues can be read directly from the generalized Schur
    form:
     alpha = S(i,i), beta = P(i,i).

    Ref: C.B. Moler & G.W. Stewart, "An Algorithm for Generalized Matrix
        Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
        pp. 241--256.

    Ref: B. Kagstrom, D. Kressner, "Multishift Variants of the QZ
        Algorithm with Aggressive Early Deflation", SIAM J. Numer.
        Anal., 29(2006), pp. 199--227.

    Ref: T. Steel, D. Camps, K. Meerbergen, R. Vandebril "A multishift,
        multipole rational QZ method with agressive early deflation"
    \endverbatim

 * @param[in] WANTS
          WANTS is CHARACTER*1 \n
          = 'E': Compute eigenvalues only; \n
          = 'S': Compute eigenvalues and the Schur form. \n
 * @param[in] WANTQ
          WANTQ is CHARACTER*1 \n
          = 'N': Left Schur vectors (Q) are not computed; \n
          = 'I': Q is initialized to the unit matrix and the matrix Q
                 of left Schur vectors of (A,B) is returned; \n
          = 'V': Q must contain an orthogonal matrix Q1 on entry and
                 the product Q1*Q is returned. \n
 * @param[in] WANTZ
          WANTZ is CHARACTER*1 \n
          = 'N': Right Schur vectors (Z) are not computed; \n
          = 'I': Z is initialized to the unit matrix and the matrix Z
                 of right Schur vectors of (A,B) is returned; \n
          = 'V': Z must contain an orthogonal matrix Z1 on entry and
                 the product Z1*Z is returned. \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrices A, B, Q, and Z.  N >= 0. \n
 * @param[in] ILO
          ILO is INTEGER \n
 * @param[in] IHI
          IHI is INTEGER \n
          ILO and IHI mark the rows and columns of A which are in
          Hessenberg form.  It is assumed that A is already upper
          triangular in rows and columns 1:ILO-1 and IHI+1:N. \n
          If N > 0, 1 <= ILO <= IHI <= N; if N = 0, ILO=1 and IHI=0. \n
 * @param[in, out] A
          A is REAL array, dimension (LDA, N) \n
          On entry, the N-by-N upper Hessenberg matrix A. \n
          On exit, if JOB = 'S', A contains the upper quasi-triangular
          matrix S from the generalized Schur factorization. \n
          If JOB = 'E', the diagonal blocks of A match those of S, but
          the rest of A is unspecified. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max( 1, N ). \n
 * @param[in, out] B
          B is REAL array, dimension (LDB, N) \n
          On entry, the N-by-N upper triangular matrix B. \n
          On exit, if JOB = 'S', B contains the upper triangular
          matrix P from the generalized Schur factorization; \n
          2-by-2 diagonal blocks of P corresponding to 2-by-2 blocks of S
          are reduced to positive diagonal form, i.e., if A(j+1,j) is
          non-zero, then B(j+1,j) = B(j,j+1) = 0, B(j,j) > 0, and
          B(j+1,j+1) > 0. \n
          If JOB = 'E', the diagonal blocks of B match those of P, but
          the rest of B is unspecified. \n
 * @param[in]	LDB	
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max( 1, N ). \n
 * @param[out]	ALPHAR	
          ALPHAR is REAL array, dimension (N) \n
          The real parts of each scalar alpha defining an eigenvalue
          of GNEP. \n
 * @param[out]	ALPHAI
          ALPHAI is REAL array, dimension (N) \n
          The imaginary parts of each scalar alpha defining an
          eigenvalue of GNEP. \n
          If ALPHAI(j) is zero, then the j-th eigenvalue is real; if
          positive, then the j-th and (j+1)-st eigenvalues are a
          complex conjugate pair, with ALPHAI(j+1) = -ALPHAI(j). \n
 * @param[out]	BETA
          BETA is REAL array, dimension (N) \n
          The scalars beta that define the eigenvalues of GNEP. \n
          Together, the quantities alpha = (ALPHAR(j),ALPHAI(j)) and
          beta = BETA(j) represent the j-th eigenvalue of the matrix
          pair (A,B), in one of the forms lambda = alpha/beta or
          mu = beta/alpha.  Since either lambda or mu may overflow,
          they should not, in general, be computed. \n
 * @param[in, out] Q
          Q is REAL array, dimension (LDQ, N) \n
          On entry, if COMPQ = 'V', the orthogonal matrix Q1 used in
          the reduction of (A,B) to generalized Hessenberg form. \n
          On exit, if COMPQ = 'I', the orthogonal matrix of left Schur
          vectors of (A,B), and if COMPQ = 'V', the orthogonal matrix
          of left Schur vectors of (A,B). \n
          Not referenced if COMPQ = 'N'. \n
 * @param[in] LDQ
          LDQ is INTEGER \n
          The leading dimension of the array Q.  LDQ >= 1. \n
          If COMPQ='V' or 'I', then LDQ >= N. \n
 * @param[in, out] Z
          Z is REAL array, dimension (LDZ, N) \n
          On entry, if COMPZ = 'V', the orthogonal matrix Z1 used in
          the reduction of (A,B) to generalized Hessenberg form. \n
          On exit, if COMPZ = 'I', the orthogonal matrix of
          right Schur vectors of (H,T), and if COMPZ = 'V', the
          orthogonal matrix of right Schur vectors of (A,B). \n
          Not referenced if COMPZ = 'N'. \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of the array Z.  LDZ >= 1. \n
          If COMPZ='V' or 'I', then LDZ >= N. \n
 * @param[out]	WORK
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO >= 0, WORK(1) returns the optimal LWORK. \n
 * @param[in] LWORK
          LWORK is INTEGER \n
          The dimension of the array WORK.  LWORK >= max(1,N). \n

          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[in] REC
          REC is INTEGER \n
          REC indicates the current recursion level. Should be set
          to 0 on first call. \n
 * @param[in] INFO
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template < typename T >
integer laqz0(char *wants, char *wantq, char *wantz, integer * n, integer *ilo, integer *ihi, T *a, integer *lda, T *b, integer *ldb, T *alphar, T *alphai, T *beta, T *q, integer *ldq, T *z, integer *ldz, T *work, integer *lwork, integer *rec, integer *info)
{
  return laqz0(wants, wantq, wantz, n, ilo, ihi, a, lda, b, ldb, alphar, alphai, beta, q, ldq, z, ldz, work, lwork, rec, info);
}
template < typename T, typename Ta >
integer laqz0(char *wants, char *wantq, char *wantz, integer * n, integer *ilo, integer *ihi, T *a, integer *lda, T *b, integer *ldb, T *alpha, T *beta, T *q, integer *ldq, T *z, integer *ldz, T *work, integer *lwork, Ta * rwork, integer *rec, integer *info)
{
  return laqz0(wants, wantq, wantz, n, ilo, ihi, a, lda, b, ldb, alpha, beta, q, ldq, z, ldz, work, lwork, rwork, rec, info);
}

/*! @brief Given a 3-by-3 matrix pencil (A,B), LAQZ1 sets v to a
           scalar multiple of the first column of the product.

 * @details
 * \b Purpose:
    \verbatim
    Given a 3-by-3 matrix pencil (A,B), LAQZ1 sets v to a
      scalar multiple of the first column of the product

      (*)  K = (A - (beta2*sr2 - i*si)*B)*B^(-1)*(beta1*A - (sr2 + i*si2)*B)*B^(-1).

      It is assumed that either

              1) sr1 = sr2
          or
              2) si = 0.

      This is useful for starting double implicit shift bulges
      in the QZ algorithm.
    \endverbatim

 * @param[in] A
          A is REAL array, dimension (LDA,N) \n
          The 3-by-3 matrix A in (*). \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of A as declared in
          the calling procedure. \n
 * @param[in] B
          B is REAL array, dimension (LDB,N) \n
          The 3-by-3 matrix B in (*). \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of B as declared in
          the calling procedure. \n
 * @param[in] SR1
          SR1 is REAL \n
 * @param[in] SR2
          SR2 is REAL \n
 * @param[in] SI
          SI is REAL \n
 * @param[in] BETA1
          BETA1 is REAL \n
 * @param[in] BETA2
          BETA2 is REAL \n
 * @param[out] V
          V is REAL array, dimension (N) \n
          A scalar multiple of the first column of the
          matrix K in (*). \n

 * @return INTEGER Return value of the function.
 * */
template < typename T >
integer laqz1(T *a, integer *lda, T *b, integer *ldb, T *sr1, T *sr2, T *si, T *beta1, T *beta2, T *v)
{
  return laqz1(a, lda, b, ldb, sr1, sr2, si, beta1, beta2, v);
}
template < typename T >
integer laqz1(logical *ilq, logical *ilz, integer *k, integer * istartm, integer *istopm, integer *ihi, T *a, integer *lda, T *b, integer *ldb, integer *nq, integer *qstart, T *q, integer *ldq, integer *nz, integer *zstart, T *z, integer * ldz)
{
  return laqz1(ilq, ilz, k, istartm, istopm, ihi, a, lda, b, ldb, nq, qstart, q, ldq, nz, zstart, z, ldz);
}

/*! @brief LAQZ2 chases a 2x2 shift bulge in a matrix pencil down a single position.

 * @details
 * \b Purpose:
    \verbatim
    LAQZ2 chases a 2x2 shift bulge in a matrix pencil down a single position
    \endverbatim

 * @param[in] ILQ
          ILQ is LOGICAL \n
          Determines whether or not to update the matrix Q \n
 * @param[in] ILZ
          ILZ is LOGICAL \n
          Determines whether or not to update the matrix Z \n
 * @param[in] K
          K is INTEGER \n
          Index indicating the position of the bulge. \n
          On entry, the bulge is located in
          (A(k+1:k+2,k:k+1),B(k+1:k+2,k:k+1)). \n
          On exit, the bulge is located in
          (A(k+2:k+3,k+1:k+2),B(k+2:k+3,k+1:k+2)). \n
 * @param[in] ISTARTM
          ISTARTM is INTEGER \n
 * @param[in] ISTOPM
          ISTOPM is INTEGER \n
          Updates to (A,B) are restricted to
          (istartm:k+3,k:istopm). It is assumed
          without checking that istartm <= k+1 and
          k+2 <= istopm \n
 * @param[in] IHI
          IHI is INTEGER \n
 * @param[in, out] A
          A is REAL array, dimension (LDA,N) \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of A as declared in
          the calling procedure. \n
 * @param[in, out] B
          B is REAL array, dimension (LDB,N) \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of B as declared in
          the calling procedure. \n
 * @param[in] NQ
          NQ is INTEGER \n
          The order of the matrix Q \n
 * @param[in] QSTART
          QSTART is INTEGER \n
          Start index of the matrix Q. Rotations are applied
          To columns k+2-qStart:k+4-qStart of Q. \n
 * @param[in, out] Q
          Q is REAL array, dimension (LDQ,NQ) \n
 * @param[in] LDQ
          LDQ is INTEGER \n
          The leading dimension of Q as declared in
          the calling procedure. \n
 * @param[in] NZ
          NZ is INTEGER \n
          The order of the matrix Z \n
 * @param[in] ZSTART
          ZSTART is INTEGER \n
          Start index of the matrix Z. Rotations are applied
          To columns k+1-qStart:k+3-qStart of Z. \n
 * @param[in, out] Z
          Z is REAL array, dimension (LDZ,NZ) \n
 * @param[in] LDZ
          LDZ is INTEGER \n
          The leading dimension of Q as declared in
          the calling procedure. \n

 * @return INTEGER Return value of the function.
 * */
template < typename T >
integer laqz2(logical *ilq, logical *ilz, integer *k, integer * istartm, integer *istopm, integer *ihi, T *a, integer *lda, T *b, integer *ldb, integer *nq, integer *qstart, T *q, integer *ldq, integer *nz, integer *zstart, T *z, integer *ldz)
{
  return laqz2(ilq, ilz, k, istartm, istopm, ihi, a, lda, b, ldb, nq, qstart, q, ldq, nz, zstart, z, ldz);
}
template < typename T, typename Ta >
integer laqz2(logical *ilschur, logical *ilq, logical *ilz, integer *n, integer *ilo, integer *ihi, integer *nw, T *a, integer *lda, T *b, integer *ldb, T *q, integer *ldq, T *z, integer *ldz, integer *ns, integer *nd, T *alpha, T *beta, T *qc, integer *ldqc, T *zc, integer *ldzc, T *work, integer *lwork, float *rwork, integer *rec, integer * info)
{
  return laqz2(ilschur, ilq, ilz, n, ilo, ihi, nw, a, lda, b, ldb, q, ldq, z, ldz, ns, nd, alpha, beta, qc, ldqc, zc, ldzc, work, lwork, rwork, rec, info);
}

/*! @brief LAQZ3 performs AED

 * @details
 * \b Purpose:
    \verbatim
    LAQZ3 performs AED
    \endverbatim

 * @param[in] ILSCHUR
          ILSCHUR is LOGICAL \n
          Determines whether or not to update the full Schur form \n
 * @param[in] ILQ
          ILQ is LOGICAL \n
          Determines whether or not to update the matrix Q \n
 * @param[in] ILZ
          ILZ is LOGICAL \n
          Determines whether or not to update the matrix Z \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrices A, B, Q, and Z.  N >= 0. \n
 * @param[in] ILO
          ILO is INTEGER \n
 * @param[in] IHI
          IHI is INTEGER \n
          ILO and IHI mark the rows and columns of (A,B) which
          are to be normalized \n
 * @param[in] NW
          NW is INTEGER \n
          The desired size of the deflation window. \n
 * @param[in, out] A
          A is REAL array, dimension (LDA, N) \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max( 1, N ). \n
 * @param[in, out] B
          B is REAL array, dimension (LDB,N) \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max( 1, N ). \n
 * @param[in, out] Q
          Q is REAL array, dimension (LDQ,N) \n
 * @param[in] LDQ
          LDQ is INTEGER \n
 * @param[in, out] Z
          Z is REAL array, dimension (LDZ,N) \n
 * @param[in] LDZ
          LDZ is INTEGER \n
 * @param[out] NS
          NS is INTEGER \n
          The number of unconverged eigenvalues available to
          use as shifts. \n
 * @param[out] ND
          ND is INTEGER \n
          The number of converged eigenvalues found. \n
 * @param[out] ALPHAR
          ALPHAR is REAL array, dimension (N) \n
          The real parts of each scalar alpha defining an eigenvalue
          of GNEP. \n
 * @param[out] ALPHAI
          ALPHAI is REAL array, dimension (N) \n
          The imaginary parts of each scalar alpha defining an
          eigenvalue of GNEP. \n
          If ALPHAI(j) is zero, then the j-th eigenvalue is real; if
          positive, then the j-th and (j+1)-st eigenvalues are a
          complex conjugate pair, with ALPHAI(j+1) = -ALPHAI(j). \n
 * @param[out] BETA
          BETA is REAL array, dimension (N) \n
          The scalars beta that define the eigenvalues of GNEP. \n
          Together, the quantities alpha = (ALPHAR(j),ALPHAI(j)) and
          beta = BETA(j) represent the j-th eigenvalue of the matrix
          pair (A,B), in one of the forms lambda = alpha/beta or
          mu = beta/alpha.  Since either lambda or mu may overflow,
          they should not, in general, be computed. \n
 * @param[in, out] QC
          QC is REAL array, dimension (LDQC, NW) \n
 * @param[in] LDQC
          LDQC is INTEGER \n
 * @param[in, out] ZC
          ZC is REAL array, dimension (LDZC, NW) \n
 * @param[in] LDZ
          LDZ is INTEGER \n
 * @param[out] WORK
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO >= 0, WORK(1) returns the optimal LWORK. \n
 * @param[in] LWORK
          LWORK is INTEGER \n
          The dimension of the array WORK.  LWORK >= max(1,N). \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[in] REC
          REC is INTEGER \n
          REC indicates the current recursion level. Should be set
          to 0 on first call. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template < typename T >
integer laqz3(logical *ilschur, logical *ilq, logical *ilz, integer *n, integer *ilo, integer *ihi, integer *nw, T *a, integer *lda, T *b, integer *ldb, T *q, integer * ldq, T *z, integer *ldz, integer *ns, integer *nd, T *alphar, T *alphai, T *beta, T * qc, integer *ldqc, T *zc, integer *ldzc, T *work, integer *lwork, integer *rec, integer *info)
{
  return laqz3(ilschur, ilq, ilz, n, ilo, ihi, nw, a, lda, b, ldb, q, ldq, z, ldz, ns, nd, alphar, alphai, beta, qc, ldqc, zc, ldzc, work, lwork, rec, info);
}
template < typename T >
integer laqz3(logical *ilschur, logical *ilq, logical *ilz, integer *n, integer *ilo, integer *ihi, integer *nshifts, integer * nblock_desired, T *alpha, T *beta, T *a, integer * lda, T *b, integer *ldb, T *q, integer *ldq, T *z, integer *ldz, T *qc, integer *ldqc, T *zc, integer *ldzc, T *work, integer *lwork, integer *info)
{
  return laqz3(ilschur, ilq, ilz, n, ilo, ihi, nshifts, nblock_desired, alpha, beta, a, lda, b, ldb, q, ldq, z, ldz, qc, ldqc, zc, ldzc, work, lwork, info);
}

/*! @brief LAQZ4 Executes a single multishift QZ sweep

 * @details
 * \b Purpose:
    \verbatim
    LAQZ4 Executes a single multishift QZ sweep
    \endverbatim

 * @param[in] ILSCHUR
          ILSCHUR is LOGICAL \n
          Determines whether or not to update the full Schur form \n
 * @param[in] ILQ
          ILQ is LOGICAL \n
          Determines whether or not to update the matrix Q \n
 * @param[in] ILZ
          ILZ is LOGICAL \n
          Determines whether or not to update the matrix Z \n
 * @param[in] N
          N is INTEGER \n
          The order of the matrices A, B, Q, and Z.  N >= 0. \n
 * @param[in] ILO
          ILO is INTEGER \n
 * @param[in] IHI
          IHI is INTEGER \n
 * @param[in] NSHIFTS
          NSHIFTS is INTEGER \n
          The desired number of shifts to use \n
 * @param[in] NBLOCK_DESIRED
          NBLOCK_DESIRED is INTEGER \n
          The desired size of the computational windows \n
 * @param[in] SR
          SR is REAL array. SR contains
          the real parts of the shifts to use. \n
 * @param[in] SI
          SI is REAL array. SI contains
          the imaginary parts of the shifts to use. \n
 * @param[in] SS
          SS is REAL array. SS contains
          the scale of the shifts to use. \n
 * @param[in, out] A
          A is REAL array, dimension (LDA, N) \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A.  LDA >= max( 1, N ). \n
 * @param[in, out] B
          B is REAL array, dimension (LDB,N) \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B.  LDB >= max( 1, N ). \n
 * @param[in, out] Q
          Q is REAL array, dimension (LDQ,N) \n
 * @param[in] LDQ
          LDQ is INTEGER \n
 * @param[in, out] Z
          Z is REAL array, dimension (LDZ,N) \n
 * @param[in] LDZ
          LDZ is INTEGER \n
 * @param[in, out] QC
          QC is REAL array, dimension (LDQC, NBLOCK_DESIRED) \n
 * @param[in] LDQC
          LDQC is INTEGER \n
 * @param[in, out] ZC
          ZC is REAL array, dimension (LDZC, NBLOCK_DESIRED) \n
 * @param[in] LDZC
          LDZC is INTEGER \n
 * @param[out] WORK
          WORK is REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO >= 0, WORK(1) returns the optimal LWORK. \n
 * @param[in] LWORK
          LWORK is INTEGER \n
          The dimension of the array WORK.  LWORK >= max(1,N). \n
 \n
          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0: successful exit \n
          < 0: if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template < typename T >
inline integer laqz4(logical *ilschur, logical *ilq, logical *ilz, integer *n, integer *ilo, integer *ihi, integer *nshifts, integer * nblock_desired, T *sr, T *si, T *ss, T *a, integer *lda, T *b, integer *ldb, T *q, integer *ldq, T *z, integer * ldz, T *qc, integer *ldqc, T *zc, integer *ldzc, T *work, integer *lwork, integer *info)
{
  return laqz4(ilschur, ilq, ilz, n, ilo, ihi, nshifts, nblock_desired, sr, si, ss, a, lda, b, ldb, q, ldq, z, ldz, qc, ldqc, zc, ldzc, work, lwork, info);
}

/*! @brief LARFB_GETT applies a real Householder block reflector H from the
    left to a real (K+M)-by-N  "triangular-pentagonal" matrix.

 * @details
 * \b Purpose:
    \verbatim
    LARFB_GETT applies a real Householder block reflector H from the
    left to a real (K+M)-by-N  "triangular-pentagonal" matrix
    composed of two block matrices: an upper trapezoidal K-by-N matrix A
    stored in the array A, and a rectangular M-by-(N-K) matrix B, stored
    in the array B. The block reflector H is stored in a compact
    WY-representation, where the elementary reflectors are in the
    arrays A, B and T. See Further Details section.
    \endverbatim

 * @param[in] IDENT
          IDENT is CHARACTER*1 \n
          If IDENT = not 'I', or not 'i', then V1 is unit
             lower-triangular and stored in the left K-by-K block of
             the input matrix A, \n
          If IDENT = 'I' or 'i', then  V1 is an identity matrix and
             not stored. \n
          See Further Details section. \n
 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix B.
          M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrices A and B.
          N >= 0. \n
 * @param[in] K
          K is INTEGER \n
          The number or rows of the matrix A. \n
          K is also order of the matrix T, i.e. the number of
          elementary reflectors whose product defines the block
          reflector. 0 <= K <= N. \n
 * @param[in] T
          T is REAL array, dimension (LDT,K) \n
          The upper-triangular K-by-K matrix T in the representation
          of the block reflector. \n
 * @param[in] LDT
          LDT is INTEGER \n
          The leading dimension of the array T. LDT >= K. \n
 * @param[in, out] A
          A is REAL array, dimension (LDA,N) \n
 \n
          On entry: \n
           a) In the K-by-N upper-trapezoidal part A: input matrix A. \n
           b) In the columns below the diagonal: columns of V1
              (ones are not stored on the diagonal). \n
 \n
          On exit: \n
            A is overwritten by rectangular K-by-N product H*A. \n
 \n
          See Further Details section. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A. LDA >= max(1,K). \n
 * @param[in, out] B
          B is REAL array, dimension (LDB,N) \n
 \n
          On entry: \n
            a) In the M-by-(N-K) right block: input matrix B. \n
            b) In the M-by-N left block: columns of V2. \n
 \n
          On exit: \n
            B is overwritten by rectangular M-by-N product H*B. \n
 \n
          See Further Details section. \n
 * @param[in] LDB
          LDB is INTEGER \n
          The leading dimension of the array B. LDB >= max(1,M). \n
 * @param[out] WORK
          WORK is REAL array, \n
          dimension (LDWORK,max(K,N-K)) \n
 * @param[in] LDWORK
          LDWORK is INTEGER \n
          The leading dimension of the array WORK. LDWORK>=max(1,K). \n

 * @return INTEGER Return value of the function.
 * */
template < typename T >
inline integer larfb_gett(char *ident, integer *m, integer *n, integer *k, T *t, integer *ldt, T *a, integer *lda, T *b, integer *ldb, T *work, integer *ldwork)
{
  return larfb_gett(ident, m, n, k, t, ldt, a, lda, b, ldb, work, ldwork);
}

/*! @brief ORGTSQR_ROW generates an M-by-N real matrix Q_out with
           orthonormal columns from the output of LATSQR.

 * @details
 * \b Purpose:
    \verbatim
    ORGTSQR_ROW generates an M-by-N real matrix Q_out with
    orthonormal columns from the output of LATSQR. These N orthonormal
    columns are the first N columns of a product of complex unitary
    matrices Q(k)_in of order M, which are returned by SLATSQR in
    a special format.

        Q_out = first_N_columns_of( Q(1)_in * Q(2)_in * ... * Q(k)_in ).

    The input matrices Q(k)_in are stored in row and column blocks in A.
    See the documentation of SLATSQR for more details on the format of
    Q(k)_in, where each Q(k)_in is represented by block Householder
    transformations. This routine calls an auxiliary routine SLARFB_GETT,
    where the computation is performed on each individual block. The
    algorithm first sweeps NB-sized column blocks from the right to left
    starting in the bottom row block and continues to the top row block
    (hence _ROW in the routine name). This sweep is in reverse order of
    the order in which SLATSQR generates the output blocks.
    \endverbatim

 * @param[in] M
          M is INTEGER \n
          The number of rows of the matrix A.  M >= 0. \n
 * @param[in] N
          N is INTEGER \n
          The number of columns of the matrix A. M >= N >= 0. \n
 * @param[in] MB
          MB is INTEGER \n
          The row block size used by SLATSQR to return
          arrays A and T. MB > N.
          (Note that if MB > M, then M is used instead of MB
          as the row block size). \n
 * @param[in] NB
          NB is INTEGER \n
          The column block size used by SLATSQR to return
          arrays A and T. NB >= 1. \n
          (Note that if NB > N, then N is used instead of NB
          as the column block size). \n
 * @param[in, out] A
          A is REAL array, dimension (LDA,N) \n
 \n
          On entry: \n
 \n
             The elements on and above the diagonal are not used as
             input. The elements below the diagonal represent the unit
             lower-trapezoidal blocked matrix V computed by SLATSQR
             that defines the input matrices Q_in(k) (ones on the
             diagonal are not stored). See SLATSQR for more details.
 \n
          On exit: \n
 \n
             The array A contains an M-by-N orthonormal matrix Q_out,
             i.e the columns of A are orthogonal unit vectors. \n
 * @param[in] LDA
          LDA is INTEGER \n
          The leading dimension of the array A. LDA >= max(1,M). \n
 * @param[in] T
          T is REAL array,
          dimension (LDT, N * NIRB) \n
          where NIRB = Number_of_input_row_blocks
                     = MAX( 1, CEIL((M-N)/(MB-N)) ) \n
          Let NICB = Number_of_input_col_blocks \n
                   = CEIL(N/NB) \n
 \n
          The upper-triangular block reflectors used to define the
          input matrices Q_in(k), k=(1:NIRB*NICB). The block
          reflectors are stored in compact form in NIRB block
          reflector sequences. Each of the NIRB block reflector
          sequences is stored in a larger NB-by-N column block of T
          and consists of NICB smaller NB-by-NB upper-triangular
          column blocks. See SLATSQR for more details on the format
          of T. \n
 * @param[in] LDT
          LDT is INTEGER \n
          The leading dimension of the array T. LDT >= max(1,min(NB,N)). \n
 * @param[out] WORK
          (workspace) REAL array, dimension (MAX(1,LWORK)) \n
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. \n
 * @param[in] LWORK
          The dimension of the array WORK. \n
          LWORK >= NBLOCAL * MAX(NBLOCAL,(N-NBLOCAL)),
          where NBLOCAL=MIN(NB,N). \n
          If LWORK = -1, then a workspace query is assumed. \n
          The routine only calculates the optimal size of the WORK
          array, returns this value as the first entry of the WORK
          array, and no error message related to LWORK is issued
          by XERBLA. \n
 * @param[out] INFO
          INFO is INTEGER \n
          = 0:  successful exit \n
          < 0:  if INFO = -i, the i-th argument had an illegal value \n

 * @return INTEGER Return value of the function.
 * */
template < typename T >
inline integer gtsqr_row(integer *m, integer *n, integer *mb, integer *nb, T *a, integer *lda, T *t, integer *ldt, T *work, integer *lwork, integer *info)
{
  return gtsqr_row(m, n, mb, nb, a, lda, t, ldt, work, lwork, info);
}

}  // namespace libflame
#endif  //  #ifndef LIBFLAME_INTERFACE_HH